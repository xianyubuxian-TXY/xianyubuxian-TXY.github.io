<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>没有重复项数字的全排列问题</title>
    <url>/2026/01/02/%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p><img src="/images/%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98.png" alt="题目描述"></p>
<h1 id="2-问题分析："><a href="#2-问题分析：" class="headerlink" title="2.问题分析："></a>2.问题分析：</h1><pre><code>明显的一种想法：
- 第一个数有n种可能，第二个数有n-1中可能，....,最后一个数
- 从小到达遍历，每次挑选一个还未被挑选的数，被挑选了的则标记为“被访问状态”
- 如果用for循环，则需要n层，而明显写不出——&gt;递归此时似乎是很直观的一种选择
</code></pre>
<h1 id="3-解决方法：递归"><a href="#3-解决方法：递归" class="headerlink" title="3.解决方法：递归"></a>3.解决方法：递归</h1><h2 id="1-普通方法"><a href="#1-普通方法" class="headerlink" title="(1) 普通方法"></a>(1) 普通方法</h2><pre><code>1.每次从小到达遍历，挑选第一个未被挑选的数字，然后设置为“被访问”状态
2.注意点：记得回溯
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//res:存放结果  num:原数组  tmp:存储每次递归的结果  visit:访问数组  floor:递归层数  size:num数组的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res,vector&lt;<span class="type">int</span>&gt;&amp; num,vector&lt;<span class="type">int</span>&gt;tmp,vector&lt;<span class="type">bool</span>&gt;&amp; visit,<span class="type">int</span> floor,<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(floor==size) res.<span class="built_in">push_back</span>(tmp); </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//每次从0开始遍历所有数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]) <span class="keyword">continue</span>; <span class="comment">//被访问，则跳过</span></span><br><span class="line">            <span class="comment">//tmp[floor]表示存储该层被挑选的数字</span></span><br><span class="line">            <span class="comment">//num[i]未被访问，则加入，并将其在visit中的状态设置为true</span></span><br><span class="line">            tmp[floor]=num[i];</span><br><span class="line">            visit[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">find</span>(res,num,tmp,visit,floor<span class="number">+1</span>,size); <span class="comment">//递归进入下一层</span></span><br><span class="line">            visit[i]=<span class="literal">false</span>; <span class="comment">//回溯:因为后面的递归仍可挑选num[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; num) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> size=num.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="built_in">tmp</span>(size,<span class="number">-1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(size,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">find</span>(res,num,tmp,visit,<span class="number">0</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-原地交换的回溯-（常见、高效、空间少）"><a href="#2-原地交换的回溯-（常见、高效、空间少）" class="headerlink" title="(2) 原地交换的回溯 （常见、高效、空间少）"></a>(2) 原地交换的回溯 （常见、高效、空间少）</h2><p>关键解析：<br>	1.floor表示递归层数，也表示挑选了的个数，从0——&gt;size 依次递增，floor&#x3D;&#x3D;size表示全部挑选（结束递归）<br>	2.每一次调用，num[floor]存储当前调用挑选的数字——&gt;通过swap(num[floor],num[i])原地交换实现<br>	3.因为num是‘引用传递’，且floor递增，故当第floor层执行完swap后，num[0,floor]都是被挑选了的,num[floor+1,size]则还未被挑选（因为1,2…,floor-1都执行了swap）——&gt;这也是为什么每一层都从i&#x3D;floor开始循环<br>	4.注意点：因为num是’引用传递’，故递归调用完后，需要’回溯’（交换回来）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res,vector&lt;<span class="type">int</span>&gt;&amp; num,<span class="type">int</span> floor,<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(floor==size) res.<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=floor;i&lt;size;++i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(num[floor],num[i]); <span class="comment">//交换后：num[0,floor]都是被选择的了，num[floor+1,size)则是还未被选择的</span></span><br><span class="line">            <span class="built_in">dfs</span>(res,num,floor<span class="number">+1</span>,size); <span class="comment">//递归：选择下一个</span></span><br><span class="line">            <span class="built_in">swap</span>(num[i],num[floor]); <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; num) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> size=num.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(res,num,<span class="number">0</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程题</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后问题</title>
    <url>/2026/01/05/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h1><p><img src="/images/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.png" alt="题目描述"></p>
<h1 id="2-问题分析："><a href="#2-问题分析：" class="headerlink" title="2.问题分析："></a>2.问题分析：</h1><pre><code>思路很直接：按行放皇后，每放一个就标记该列和两条对角线被占用，放完最后一行时计数＋＋，然后回溯撤销。
</code></pre>
<h1 id="3-解决方法：递归-回溯"><a href="#3-解决方法：递归-回溯" class="headerlink" title="3.解决方法：递归+回溯"></a>3.解决方法：递归+回溯</h1><h2 id="1-利用矩阵的性质"><a href="#1-利用矩阵的性质" class="headerlink" title="(1)利用矩阵的性质"></a>(1)利用矩阵的性质</h2><pre><code>1./ 方向的所有格子满足 i+j == 常量
2.\ 方向的所有格子满足 i−j == 常量，为了下标非负，偏移了 +(n−1) ——&gt;注意：不可以简单的用绝对值，如（1,2），(2,1)
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span>&amp; res,<span class="type">int</span> row,vector&lt;<span class="type">bool</span>&gt;&amp; col,vector&lt;<span class="type">bool</span>&gt;&amp;diag1,vector&lt;<span class="type">bool</span>&gt;&amp;diag2,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历每一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        <span class="comment">//检查所在列、对角线是否还可用</span></span><br><span class="line">        <span class="comment">//关键点1：“/斜线上：row+col=定值”，“\斜线上：row-col=定值——&gt;为保持非负，向右偏移n-1（注意不可以简单的用“绝对值”）”</span></span><br><span class="line">        <span class="keyword">if</span>(col[j] || diag1[row+j] || diag2[row-j+n<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//可用：占用并更新col、diag1、diag2</span></span><br><span class="line">        col[j]=diag1[row+j]=diag2[row-j+n<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归遍历下一行</span></span><br><span class="line">        <span class="built_in">backtrace</span>(res,row<span class="number">+1</span>,col,diag1,diag2,n);</span><br><span class="line">        <span class="comment">//关键点2：回溯</span></span><br><span class="line">        col[j]=diag1[row+j]=diag2[row-j+n<span class="number">-1</span>]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Nqueen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//col：同列是否可用   diag1：/对角线是否可用  diag2：\对角线是否可用  -&gt;false:未占用  true:占用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">col</span><span class="params">(n,<span class="literal">false</span>)</span>,<span class="title">diag1</span><span class="params">(n*<span class="number">2</span>,<span class="literal">false</span>)</span>,<span class="title">diag2</span><span class="params">(n*<span class="number">2</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtrace</span>(res,<span class="number">0</span>,col,diag1,diag2,n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-逐行记录已放皇后的列，并每次遍历已放皇后检查冲突（如果不知道上述矩阵的性质）"><a href="#2-逐行记录已放皇后的列，并每次遍历已放皇后检查冲突（如果不知道上述矩阵的性质）" class="headerlink" title="(2)逐行记录已放皇后的列，并每次遍历已放皇后检查冲突（如果不知道上述矩阵的性质）"></a>(2)逐行记录已放皇后的列，并每次遍历已放皇后检查冲突（如果不知道上述矩阵的性质）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span>&amp; res,<span class="type">int</span> row,vector&lt;<span class="type">int</span>&gt;&amp; pos,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试把第 row 行的皇后放到 col 列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 检查和前面所有行的冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; row; ++r) &#123;</span><br><span class="line">            <span class="comment">// 同列冲突 或 同对角线冲突（|行差|==|列差|）</span></span><br><span class="line">            <span class="keyword">if</span> (pos[r] == col || <span class="built_in">abs</span>(row - r) == <span class="built_in">abs</span>(col - pos[r])) &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 放置皇后</span></span><br><span class="line">        pos[row] = col;</span><br><span class="line">        <span class="built_in">backtrace</span>(res, row + <span class="number">1</span>, pos, n);</span><br><span class="line">        <span class="comment">// 回溯时不需要手动清理 pos[row]，下次覆盖即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Nqueen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">//记录每行放置在哪一列</span></span><br><span class="line">    <span class="built_in">backtrace</span>(res, <span class="number">0</span>, pos, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程题</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
</search>
