<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python入门知识</title>
    <url>/2026/01/09/Python/Python%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><strong>阅读建议</strong>：推荐先阅读《Python编程：从入门到实践》作为基础。<br><strong>声明</strong>：本笔记为个人学习 Python 期间整理，部分内容在 AI 辅助下完成。由于水平有限，可能存在错误或表述不当之处，欢迎指正。</p>
<h1 id="一、简单类型"><a href="#一、简单类型" class="headerlink" title="一、简单类型"></a>一、简单类型</h1><h2 id="1-数字"><a href="#1-数字" class="headerlink" title="1.数字"></a>1.数字</h2><h3 id="（1）数字类型总览"><a href="#（1）数字类型总览" class="headerlink" title="（1）数字类型总览"></a>（1）数字类型总览</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109210235954.png"></p>
<h3 id="（2）运算符"><a href="#（2）运算符" class="headerlink" title="（2）运算符"></a>（2）运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109211802890.png"></p>
<h3 id="（3）关键特性"><a href="#（3）关键特性" class="headerlink" title="（3）关键特性"></a>（3）关键特性</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109210634283.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109210655826.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109210730504.png"></p>
<h4 id="补充：”不可变性”"><a href="#补充：”不可变性”" class="headerlink" title="补充：”不可变性”"></a>补充：”不可变性”</h4><ul>
<li><strong>所有数字类型都是不可变对象（修改会生成新对象）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 地址唯一标识对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 整数示例</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改前 a 的值：<span class="subst">&#123;a&#125;</span>，内存地址：<span class="subst">&#123;<span class="built_in">id</span>(a)&#125;</span>&quot;</span>) <span class="comment"># 修改前 a 的值：10，内存地址：140708467500096  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 看似“修改”a，实际是创建新对象</span></span><br><span class="line">a += <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改后 a 的值：<span class="subst">&#123;a&#125;</span>，内存地址：<span class="subst">&#123;<span class="built_in">id</span>(a)&#125;</span>&quot;</span>)  <span class="comment"># 修改后 a 的值：15，内存地址：140708467500256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 浮点数示例</span></span><br><span class="line">b = <span class="number">3.14</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n修改前 b 的值：<span class="subst">&#123;b&#125;</span>，内存地址：<span class="subst">&#123;<span class="built_in">id</span>(b)&#125;</span>&quot;</span>) <span class="comment"># 修改前 b 的值：3.14，内存地址：2865657515952</span></span><br><span class="line"></span><br><span class="line">b = b * <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改后 b 的值：<span class="subst">&#123;b&#125;</span>，内存地址：<span class="subst">&#123;<span class="built_in">id</span>(b)&#125;</span>&quot;</span>)  <span class="comment"># 修改后 b 的值：6.28，内存地址：2865657516176</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 复数示例</span></span><br><span class="line">c = <span class="number">1</span> + <span class="number">2j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n修改前 c 的值：<span class="subst">&#123;c&#125;</span>，内存地址：<span class="subst">&#123;<span class="built_in">id</span>(c)&#125;</span>&quot;</span>) <span class="comment"># 修改前 c 的值：(1+2j)，内存地址：2865657468880</span></span><br><span class="line"></span><br><span class="line">c = c + (<span class="number">3</span> + <span class="number">4j</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改后 c 的值：<span class="subst">&#123;c&#125;</span>，内存地址：<span class="subst">&#123;<span class="built_in">id</span>(c)&#125;</span>&quot;</span>)  <span class="comment"># 修改后 c 的值：(4+6j)，内存地址：2865657469008</span></span><br></pre></td></tr></table></figure>


<h3 id="（4）类型转换"><a href="#（4）类型转换" class="headerlink" title="（4）类型转换"></a>（4）类型转换</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109211200538.png"></p>
<h3 id="（5）常用内置函数"><a href="#（5）常用内置函数" class="headerlink" title="（5）常用内置函数"></a>（5）常用内置函数</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109211352194.png"></p>
<h2 id="2-bool-布尔-类型"><a href="#2-bool-布尔-类型" class="headerlink" title="2.bool(布尔)类型"></a>2.bool(布尔)类型</h2><h3 id="（1）bool-类型的基础定义与本质"><a href="#（1）bool-类型的基础定义与本质" class="headerlink" title="（1）bool 类型的基础定义与本质"></a>（1）bool 类型的基础定义与本质</h3><ul>
<li><strong>bool类型的定义</strong>： Python 中用于<strong>表示「真&#x2F;假」逻辑判断</strong>的基础类型，核心取值仅两个：<strong>True（真）</strong> 和 <strong>False（假）</strong></li>
<li><strong>bool类型的本质</strong>：特殊的整数，其中 True 等价于整数 1，False 等价于整数 0</li>
</ul>
<h3 id="（2）bool-类型的核心特性"><a href="#（2）bool-类型的核心特性" class="headerlink" title="（2）bool 类型的核心特性"></a>（2）bool 类型的核心特性</h3><ul>
<li><strong>取值唯一</strong>：某个布尔表达式的结果在特定时刻只能是True或False之一<ul>
<li><strong>首字母必须大写</strong>，true、false为无效类型</li>
</ul>
</li>
<li><strong>不可变性</strong>：与数字、字符串类型一致，bool 类型也是不可变对象，一旦创建无法修改值（但因取值唯一，实际无修改场景）</li>
<li><strong>子类特性</strong>：bool 是 int 的子类，因此可继承 int 的部分属性和方法，但自身无额外特有方法；</li>
<li><strong>逻辑运算核心</strong>：支持and（与）、or（或）、not（非）三种核心逻辑运算<ul>
<li><strong>注意</strong>：不是像某些语言用 &amp;&amp; 、 || 、 !</li>
</ul>
</li>
</ul>
<h3 id="（3）其他类型到-bool-类型的转换规则"><a href="#（3）其他类型到-bool-类型的转换规则" class="headerlink" title="（3）其他类型到 bool 类型的转换规则"></a>（3）其他类型到 bool 类型的转换规则</h3><ul>
<li><strong>Python 中，任何类型的对象都可以通过 bool() 函数转为 bool 类型</strong> <ul>
<li><strong>转换规则</strong>：空&#x2F;零为 False，非空&#x2F;非零为 True<br>  <img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109222801836.png"></li>
</ul>
</li>
<li><strong>万物皆bool</strong>：所有类型都可以直接作为bool参与判断（<strong>隐式转换</strong>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 数值类型：0/0.0/0+0j 为 False，其他为 True</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">10</span>:  <span class="comment"># 非零 → True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;10 是 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0.0</span>:  <span class="comment"># 零 → False（不执行）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0.0 是 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 字符串：空字符串 &#x27;&#x27; 为 False，其他（含空白）为 True</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;hello&quot;</span>:  <span class="comment"># 非空 → True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;非空字符串是 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;   &quot;</span>:  <span class="comment"># 空白字符串（非空）→ True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空白字符串也是 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&quot;</span>:  <span class="comment"># 空字符串 → False（不执行）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空字符串是 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 容器类型：空列表/元组/字典为 False，非空为 True</span></span><br><span class="line"><span class="keyword">if</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:  <span class="comment"># 非空列表 → True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;非空列表是 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &#123;&#125;:  <span class="comment"># 空字典 → False（不执行）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空字典是 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. None：直接判断，无需写 == None</span></span><br><span class="line">x = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> x:  <span class="comment"># None → False，not 后为 True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x 是 None&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><h3 id="（1）字符串的定义与基础表示"><a href="#（1）字符串的定义与基础表示" class="headerlink" title="（1）字符串的定义与基础表示"></a>（1）字符串的定义与基础表示</h3><ul>
<li><strong>单引号（’）</strong>：适用于短文本，内部可直接包含双引号（无需转义）</li>
<li><strong>双引号（”）</strong>：与单引号功能基本一致，内部可直接包含单引号</li>
<li><strong>三引号（’’’ 或 “””）</strong>：支持多行文本，可保留换行、空格等格式，也可用于文档字符串（注释）</li>
<li><strong>原始字符串（r&#x2F;R 前缀）</strong>：禁止转义字符（\）生效，适用于路径、正则表达式等场景</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 单引号与双引号</span></span><br><span class="line">str1 = <span class="string">&#x27;Hello Python&#x27;</span></span><br><span class="line">str2 = <span class="string">&quot;Hello &#x27;Python&#x27;&quot;</span>  <span class="comment"># 内部包含单引号，用双引号包裹无需转义</span></span><br><span class="line">str3 = <span class="string">&#x27;Hello &quot;Python&quot;&#x27;</span>  <span class="comment"># 内部包含双引号，用单引号包裹无需转义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 三引号（多行文本）</span></span><br><span class="line">str4 = <span class="string">&#x27;&#x27;&#x27;第一行文本</span></span><br><span class="line"><span class="string">第二行文本</span></span><br><span class="line"><span class="string">第三行文本&#x27;&#x27;&#x27;</span>  <span class="comment"># 保留换行格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 原始字符串（禁止转义）</span></span><br><span class="line">str5 = <span class="string">r&#x27;C:\Users\test\Desktop&#x27;</span>  <span class="comment"># 无需写成 C:\\Users\\test\\Desktop</span></span><br><span class="line">str6 = <span class="string">R&#x27;hello\nworld&#x27;</span>  <span class="comment"># 输出：hello\nworld（\n不被解析为换行）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str2)  <span class="comment"># Hello &#x27;Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str4)  <span class="comment"># 按多行格式输出</span></span><br><span class="line"><span class="built_in">print</span>(str5)  <span class="comment"># C:\Users\test\Desktop</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）字符串的常用操作"><a href="#（2）字符串的常用操作" class="headerlink" title="（2）字符串的常用操作"></a>（2）字符串的常用操作</h3><h4 id="拼接与重复"><a href="#拼接与重复" class="headerlink" title="&lt;1&gt;拼接与重复"></a>&lt;1&gt;拼接与重复</h4><ul>
<li><strong>拼接</strong>：用 + 运算符，将多个字符串合并为一个新字符串</li>
<li><strong>重复</strong>：用 * 运算符，将字符串重复指定次数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拼接</span></span><br><span class="line">s1 = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;World&#x27;</span></span><br><span class="line">s3 = s1 + <span class="string">&#x27;, &#x27;</span> + s2 + <span class="string">&#x27;!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># Hello, World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复</span></span><br><span class="line">s4 = <span class="string">&#x27;ab&#x27;</span> * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(s4)  <span class="comment"># ababab</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：字符串不能与非字符串类型直接拼接，需先转换类型</span></span><br><span class="line">num = <span class="number">123</span></span><br><span class="line"><span class="comment"># s5 = s1 + num  # 报错：TypeError: can only concatenate str (not &quot;int&quot;) to str</span></span><br><span class="line">s5 = s1 + <span class="built_in">str</span>(num)  <span class="comment"># 先将int转为str</span></span><br><span class="line"><span class="built_in">print</span>(s5)  <span class="comment"># Hello123</span></span><br></pre></td></tr></table></figure>

<h4 id="格式化转换"><a href="#格式化转换" class="headerlink" title="&lt;2&gt;格式化转换"></a>&lt;2&gt;格式化转换</h4><p><strong>字符串格式化用于将变量&#x2F;表达式的值插入到字符串中，常用三种方式：</strong></p>
<ul>
<li><strong>% 格式化</strong>：传统方式，类似 C 语言的 printf；</li>
<li><strong>str.format()</strong>：Python 2.6+ 引入，更灵活的格式化方式；</li>
<li><strong>f-string（f&#x2F;F 前缀）</strong>：Python 3.6+ 引入，最简洁高效的格式化方式，支持在字符串中<strong>直接嵌入变量&#x2F;表达式</strong>。（<strong>最推荐！</strong>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">score = <span class="number">95.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. % 格式化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：%s，年龄：%d，成绩：%.1f&#x27;</span> % (name, age, score))  <span class="comment"># 姓名：小明，年龄：20，成绩：95.5</span></span><br><span class="line"><span class="comment"># 说明：%s（字符串）、%d（整数）、%.1f（保留1位小数的浮点数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. str.format() 格式化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#123;&#125;，年龄：&#123;&#125;，成绩：&#123;:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(name, age, score))  <span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#123;0&#125;，年龄：&#123;1&#125;，成绩：&#123;2:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(name, age, score))  <span class="comment"># 按索引指定参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#123;n&#125;，年龄：&#123;a&#125;，成绩：&#123;s:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(n=name, a=age, s=score))  <span class="comment"># 按参数名指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. f-string 格式化（推荐）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>，成绩：<span class="subst">&#123;score:<span class="number">.1</span>f&#125;</span>&#x27;</span>)  <span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;明年年龄：<span class="subst">&#123;age + <span class="number">1</span>&#125;</span>&#x27;</span>)  <span class="comment"># 支持表达式：明年年龄：21</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;成绩的平方：<span class="subst">&#123;score ** <span class="number">2</span>&#125;</span>&#x27;</span>)  <span class="comment"># 支持表达式：成绩的平方：9120.25</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）字符串常用内置函数与方法"><a href="#（3）字符串常用内置函数与方法" class="headerlink" title="（3）字符串常用内置函数与方法"></a>（3）字符串常用内置函数与方法</h3><h4 id="内置函数（全局函数，可直接调用）"><a href="#内置函数（全局函数，可直接调用）" class="headerlink" title="&lt;1&gt;内置函数（全局函数，可直接调用）"></a>&lt;1&gt;内置函数（全局函数，可直接调用）</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260112103648031.png"></p>
<h4 id="字符串对象方法（需通过字符串实例调用，s-方法名-）"><a href="#字符串对象方法（需通过字符串实例调用，s-方法名-）" class="headerlink" title="&lt;2&gt;字符串对象方法（需通过字符串实例调用，s.方法名()）"></a>&lt;2&gt;字符串对象方法（需通过字符串实例调用，s.方法名()）</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109215553043.png"></p>
<h4 id="补充：-join-方法"><a href="#补充：-join-方法" class="headerlink" title="补充： join()方法"></a>补充： join()方法</h4><p>join() 是字符串的内置方法，作用是将一个可迭代对象（列表、元组、字符串、生成器等）中的所有元素拼接成一个新字符串，<strong>拼接的分隔符就是调用 join() 的这个字符串</strong>。</p>
<h5 id="1）基本语法"><a href="#1）基本语法" class="headerlink" title="1）基本语法"></a>1）基本语法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">分隔符字符串.join(可迭代对象)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>要求</strong>：可迭代对象中的元素必须<strong>都是字符串类型</strong>（否则会报错）。</li>
<li><strong>返回值</strong>：拼接后的新字符串。</li>
</ul>
<h5 id="2）基础示例"><a href="#2）基础示例" class="headerlink" title="2）基础示例"></a>2）基础示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：用逗号拼接列表元素</span></span><br><span class="line">lst = [<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;橙子&quot;</span>]</span><br><span class="line">result = <span class="string">&quot;,&quot;</span>.join(lst)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：苹果,香蕉,橙子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：用空格拼接元组元素</span></span><br><span class="line">tup = (<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>)</span><br><span class="line">result = <span class="string">&quot; &quot;</span>.join(tup)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：Python Java C++</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：空字符串拼接（无分隔符）</span></span><br><span class="line">chars = [<span class="string">&quot;H&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>]</span><br><span class="line">result = <span class="string">&quot;&quot;</span>.join(chars)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例4：复杂分隔符</span></span><br><span class="line">words = [<span class="string">&quot;2026&quot;</span>, <span class="string">&quot;01&quot;</span>, <span class="string">&quot;12&quot;</span>]</span><br><span class="line">result = <span class="string">&quot;-&quot;</span>.join(words)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：2026-01-12</span></span><br></pre></td></tr></table></figure>
<h5 id="3）常见坑点-解决方法"><a href="#3）常见坑点-解决方法" class="headerlink" title="3）常见坑点 &amp; 解决方法"></a>3）常见坑点 &amp; 解决方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 坑点 1：可迭代对象含非字符串元素</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误写法（会报错）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="string">&quot;|&quot;</span>.join(nums)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;报错：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：报错：sequence item 0: expected str instance, int found</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line">result = <span class="string">&quot;|&quot;</span>.join(<span class="built_in">str</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：1|2|3 ✅</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 坑点 2：拼接空可迭代对象</span></span><br><span class="line">empty_lst = []</span><br><span class="line">result = <span class="string">&quot;-&quot;</span>.join(empty_lst)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;结果：&#x27;<span class="subst">&#123;result&#125;</span>&#x27;&quot;</span>)  <span class="comment"># 输出：结果：&#x27;&#x27; </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;长度：<span class="subst">&#123;<span class="built_in">len</span>(result)&#125;</span>&quot;</span>)  <span class="comment"># 输出：长度：0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 坑点 3：误以为是 list.join() 而不是 str.join()</span></span><br><span class="line">words = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 错误写法（初学者常犯）</span></span><br><span class="line"><span class="comment"># words.join(&quot;-&quot;)  # 报错：AttributeError: &#x27;list&#x27; object has no attribute &#x27;join&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确写法：是&quot;分隔符&quot;.join(列表)</span></span><br><span class="line">result = <span class="string">&quot;-&quot;</span>.join(words)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：Hello-World</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（4）字符串的核心特性"><a href="#（4）字符串的核心特性" class="headerlink" title="（4）字符串的核心特性"></a>（4）字符串的核心特性</h3><h4 id="不可变性"><a href="#不可变性" class="headerlink" title="&lt;1&gt;不可变性"></a>&lt;1&gt;不可变性</h4><ul>
<li>字符串对象<strong>一旦创建</strong>，其内部的字符序列就<strong>无法被修改</strong>（包括增删、替换单个字符）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># s[0] = &#x27;H&#x27;  # 报错：TypeError: &#x27;str&#x27; object does not support item assignment（字符串不支持元素赋值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若需修改，需通过切片、拼接生成新字符串</span></span><br><span class="line">s_new = <span class="string">&#x27;H&#x27;</span> + s[<span class="number">1</span>:]  <span class="comment"># 拼接：用&#x27;H&#x27;替换第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(s_new)  <span class="comment"># Hello</span></span><br></pre></td></tr></table></figure>
<ul>
<li>任何看似 “修改” 字符串的操作，本质都是<strong>创建一个全新的字符串对象</strong>，原对象保持不变。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始字符串</span></span><br><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;初始值：<span class="subst">&#123;s&#125;</span>，内存地址：<span class="subst">&#123;<span class="built_in">id</span>(s)&#125;</span>&quot;</span>)  <span class="comment"># 比如：初始值：hello，地址：140708467898160</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 拼接操作（看似修改，实际新建）</span></span><br><span class="line">s += <span class="string">&quot; world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;拼接后：<span class="subst">&#123;s&#125;</span>，内存地址：<span class="subst">&#123;<span class="built_in">id</span>(s)&#125;</span>&quot;</span>)  <span class="comment"># 拼接后：hello world，地址：140708467900272（地址变了）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切片替换（看似修改，实际新建）</span></span><br><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s_new = <span class="string">&quot;H&quot;</span> + s[<span class="number">1</span>:]  <span class="comment"># 用切片生成新字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;替换后：<span class="subst">&#123;s_new&#125;</span>，原s地址：<span class="subst">&#123;<span class="built_in">id</span>(s)&#125;</span>，新s_new地址：<span class="subst">&#123;<span class="built_in">id</span>(s_new)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：替换后：Hello，原s地址：140708467898160，新地址：140708467900400（地址不同）</span></span><br></pre></td></tr></table></figure>

<h4 id="序列特性（初学者可以先了解，之后再回头看）"><a href="#序列特性（初学者可以先了解，之后再回头看）" class="headerlink" title="&lt;2&gt;序列特性（初学者可以先了解，之后再回头看）"></a>&lt;2&gt;序列特性（初学者可以先了解，之后再回头看）</h4><p>字符串是字符的序列，支持「索引」和「切片」操作，可按位置访问或截取字符（与列表、元组的序列操作逻辑一致）</p>
<ul>
<li><p><strong>索引</strong>：从 0 开始（正向索引），也可从 -1 开始（反向索引，即从末尾倒数）</p>
</li>
<li><p><strong>切片</strong>：语法为 <strong>str[start:end:step]</strong>，start 为起始位置（默认 0），end 为结束位置（不包含，默认字符串长度），step 为步长（默认 1，负数表示反向切片）。</p>
</li>
</ul>
<h4 id="编码特性（编码安全）"><a href="#编码特性（编码安全）" class="headerlink" title="&lt;3&gt;编码特性（编码安全）"></a>&lt;3&gt;编码特性（编码安全）</h4><ul>
<li><strong>UTF-8 编码</strong>：Python 3 中字符串默认采用 UTF-8 编码，支持全球绝大多数字符（中文、英文、符号等），无需额外处理编码问题</li>
<li><strong>与字节流转换</strong>：若需与字节流（bytes）转换，可使用 <strong>encode()（字符串转字节流）</strong> 和 <strong>decode()（字节流转字符串）</strong></li>
</ul>
<h3 id="（5）字符串的关键注意事项"><a href="#（5）字符串的关键注意事项" class="headerlink" title="（5）字符串的关键注意事项"></a>（5）字符串的关键注意事项</h3><ul>
<li><strong>不可变性避坑</strong>：避免频繁用 + 拼接大量字符串（每次拼接都会生成新对象，效率低），推荐用 str.join() 或列表暂存字符后拼接：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 低效：频繁 + 拼接</span></span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    s += <span class="built_in">str</span>(i)  <span class="comment"># 每次循环生成新字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高效：用列表暂存，最后 join</span></span><br><span class="line">lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    lst.append(<span class="built_in">str</span>(i))</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span>.join(lst)  <span class="comment"># 仅生成1个新字符串</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>转义字符的使用</strong>：当字符串中需要包含引号、换行、制表符等特殊字符时，可使用转义字符 \：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;He said: &quot;I\&#x27;m fine.&quot;&#x27;</span>)  <span class="comment"># He said: &quot;I&#x27;m fine.&quot;（\转义单引号）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一行\n第二行&#x27;</span>)  <span class="comment"># 换行输出（\n转义为换行）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名\t年龄&#x27;</span>)  <span class="comment"># 姓名    年龄（\t转义为制表符，空格对齐）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>空字符串与空白字符串的区别</strong>:空字符串（’’）长度为 0，无任何字符；空白字符串（’   ‘）长度为空格个数，包含空白字符：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="string">&#x27;&#x27;</span>) == <span class="number">0</span>)    <span class="comment"># True（空字符串）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="string">&#x27;   &#x27;</span>) == <span class="number">0</span>) <span class="comment"># False（空白字符串，长度3）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.strip() == <span class="string">&#x27;&#x27;</span>) <span class="comment"># True（空字符串strip后仍为空）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;   &#x27;</span>.strip() == <span class="string">&#x27;&#x27;</span>) <span class="comment"># True（空白字符串strip后为空）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>字符串比较</strong>：<ul>
<li>用 &#x3D;&#x3D; 比较字符串内容是否相同</li>
<li>用 is 比较是否为同一个对象(不可变特性导致相同内容的短字符串可能复用对象，但不推荐用 is 比较内容）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s1 == s2)  <span class="comment"># True（内容相同）</span></span><br><span class="line"><span class="built_in">print</span>(s1 <span class="keyword">is</span> s2)  <span class="comment"># True（短字符串复用对象，地址相同）</span></span><br><span class="line"></span><br><span class="line">s3 = <span class="string">&#x27;hello&#x27;</span> * <span class="number">1000</span></span><br><span class="line">s4 = <span class="string">&#x27;hello&#x27;</span> * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(s3 == s4)  <span class="comment"># True（内容相同）</span></span><br><span class="line"><span class="built_in">print</span>(s3 <span class="keyword">is</span> s4)  <span class="comment"># False（长字符串不复用对象，地址不同）</span></span><br></pre></td></tr></table></figure>

<h2 id="补充：decimal-模块（精确浮点运算）"><a href="#补充：decimal-模块（精确浮点运算）" class="headerlink" title="补充：decimal 模块（精确浮点运算）"></a>补充：decimal 模块（精确浮点运算）</h2><h3 id="（1）为什么需要-decimal？"><a href="#（1）为什么需要-decimal？" class="headerlink" title="（1）为什么需要 decimal？"></a>（1）为什么需要 decimal？</h3><p>Python 的 float 类型使用二进制浮点数表示，会产生精度丢失：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 经典的浮点数精度问题</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0.1</span> + <span class="number">0.2</span>)          <span class="comment"># 输出：0.30000000000000004（不是 0.3！）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>)   <span class="comment"># 输出：False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 累计误差问题</span></span><br><span class="line">total = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    total += <span class="number">0.1</span></span><br><span class="line"><span class="built_in">print</span>(total)              <span class="comment"># 输出：0.9999999999999999（不是 1.0！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 金融计算中的灾难</span></span><br><span class="line">price = <span class="number">19.99</span></span><br><span class="line">quantity = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(price * quantity)   <span class="comment"># 输出：59.97000000000001（多出 0.00000000000001）</span></span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>：0.1 在二进制中是无限循环小数，无法精确表示。</p>
<h3 id="（2）decimal-模块基础用法"><a href="#（2）decimal-模块基础用法" class="headerlink" title="（2）decimal 模块基础用法"></a>（2）decimal 模块基础用法</h3><h4 id="导入与创建-Decimal-对象"><a href="#导入与创建-Decimal-对象" class="headerlink" title="&lt;1&gt;导入与创建 Decimal 对象"></a>&lt;1&gt;导入与创建 Decimal 对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal, getcontext</span><br><span class="line"></span><br><span class="line"><span class="comment"># ⚠️ 关键：用字符串创建，避免 float 的精度问题</span></span><br><span class="line">d1 = Decimal(<span class="string">&quot;0.1&quot;</span>)       <span class="comment"># ✅ 正确：精确的 0.1</span></span><br><span class="line">d2 = Decimal(<span class="string">&quot;0.2&quot;</span>)</span><br><span class="line">d3 = Decimal(<span class="number">0.1</span>)         <span class="comment"># ❌ 错误：已经丢失精度</span></span><br><span class="line"><span class="built_in">print</span>(d3)                 <span class="comment"># 输出：0.1000000000000000055511151231257827021181583404541015625</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证精度</span></span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="string">&quot;0.1&quot;</span>) + Decimal(<span class="string">&quot;0.2&quot;</span>))              <span class="comment"># 输出：0.3 ✅</span></span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="string">&quot;0.1&quot;</span>) + Decimal(<span class="string">&quot;0.2&quot;</span>) == Decimal(<span class="string">&quot;0.3&quot;</span>))  <span class="comment"># 输出：True ✅</span></span><br></pre></td></tr></table></figure>

<h4 id="基本运算"><a href="#基本运算" class="headerlink" title="&lt;2&gt;基本运算"></a>&lt;2&gt;基本运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">a = Decimal(<span class="string">&quot;10.5&quot;</span>)</span><br><span class="line">b = Decimal(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a + b)    <span class="comment"># 输出：13.5</span></span><br><span class="line"><span class="built_in">print</span>(a - b)    <span class="comment"># 输出：7.5</span></span><br><span class="line"><span class="built_in">print</span>(a * b)    <span class="comment"># 输出：31.5</span></span><br><span class="line"><span class="built_in">print</span>(a / b)    <span class="comment"># 输出：3.5</span></span><br><span class="line"><span class="built_in">print</span>(a // b)   <span class="comment"># 输出：3（整除）</span></span><br><span class="line"><span class="built_in">print</span>(a % b)    <span class="comment"># 输出：1.5（取余）</span></span><br><span class="line"><span class="built_in">print</span>(a ** <span class="number">2</span>)   <span class="comment"># 输出：110.25（幂运算）</span></span><br></pre></td></tr></table></figure>

<h4 id="精度控制"><a href="#精度控制" class="headerlink" title="&lt;3&gt;精度控制"></a>&lt;3&gt;精度控制</h4><h5 id="1）全局精度控制"><a href="#1）全局精度控制" class="headerlink" title="1）全局精度控制"></a>1）全局精度控制</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal, getcontext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看默认精度（28位有效数字）</span></span><br><span class="line"><span class="built_in">print</span>(getcontext().prec)  <span class="comment"># 输出：28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局精度为 6 位有效数字</span></span><br><span class="line">getcontext().prec = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">result = Decimal(<span class="string">&quot;1&quot;</span>) / Decimal(<span class="string">&quot;7&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：0.142857（6位有效数字）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认精度</span></span><br><span class="line">getcontext().prec = <span class="number">28</span></span><br></pre></td></tr></table></figure>

<h5 id="2）局部精度控制（推荐）"><a href="#2）局部精度控制（推荐）" class="headerlink" title="2）局部精度控制（推荐）"></a>2）局部精度控制（推荐）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal, localcontext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 localcontext 临时修改精度，不影响全局设置</span></span><br><span class="line"><span class="keyword">with</span> localcontext() <span class="keyword">as</span> ctx:</span><br><span class="line">    ctx.prec = <span class="number">4</span></span><br><span class="line">    result = Decimal(<span class="string">&quot;1&quot;</span>) / Decimal(<span class="string">&quot;7&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)  <span class="comment"># 输出：0.1429</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出 with 块后恢复原精度</span></span><br><span class="line">result = Decimal(<span class="string">&quot;1&quot;</span>) / Decimal(<span class="string">&quot;7&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：0.1428571428571428571428571429（28位）</span></span><br></pre></td></tr></table></figure>

<h4 id="舍入模式"><a href="#舍入模式" class="headerlink" title="&lt;4&gt;舍入模式"></a>&lt;4&gt;舍入模式</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260112103214903.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal, ROUND_HALF_UP, ROUND_DOWN, ROUND_CEILING</span><br><span class="line"></span><br><span class="line">price = Decimal(<span class="string">&quot;19.996&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的 ROUND_HALF_UP 是&quot;四舍五入&quot;，但要注意：</span></span><br><span class="line"><span class="comment"># 0.5 会向远离零的方向舍入（即正数向上，负数向下）</span></span><br><span class="line"><span class="comment"># 四舍五入到 2 位小数（常用于金融）</span></span><br><span class="line"><span class="built_in">print</span>(price.quantize(Decimal(<span class="string">&quot;0.01&quot;</span>), rounding=ROUND_HALF_UP))  <span class="comment"># 输出：20.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接截断（向零取整）</span></span><br><span class="line"><span class="built_in">print</span>(price.quantize(Decimal(<span class="string">&quot;0.01&quot;</span>), rounding=ROUND_DOWN))     <span class="comment"># 输出：19.99</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上取整（正数向正无穷，负数向零）</span></span><br><span class="line"><span class="built_in">print</span>(price.quantize(Decimal(<span class="string">&quot;0.01&quot;</span>), rounding=ROUND_CEILING))  <span class="comment"># 输出：20.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 负数的向上取整</span></span><br><span class="line">neg_price = Decimal(<span class="string">&quot;-19.996&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(neg_price.quantize(Decimal(<span class="string">&quot;0.01&quot;</span>), rounding=ROUND_CEILING))  <span class="comment"># 输出：-19.99</span></span><br></pre></td></tr></table></figure>

<h4 id="Decimal-与其他类型的转换"><a href="#Decimal-与其他类型的转换" class="headerlink" title="&lt;5&gt;Decimal 与其他类型的转换"></a>&lt;5&gt;Decimal 与其他类型的转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decimal → float（可能丢失精度）</span></span><br><span class="line">d = Decimal(<span class="string">&quot;3.14159265358979323846&quot;</span>)</span><br><span class="line">f = <span class="built_in">float</span>(d)</span><br><span class="line"><span class="built_in">print</span>(f)  <span class="comment"># 输出：3.141592653589793（精度丢失）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decimal → int（截断小数部分）</span></span><br><span class="line">d = Decimal(<span class="string">&quot;99.99&quot;</span>)</span><br><span class="line">i = <span class="built_in">int</span>(d)</span><br><span class="line"><span class="built_in">print</span>(i)  <span class="comment"># 输出：99</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decimal → str</span></span><br><span class="line">d = Decimal(<span class="string">&quot;123.45&quot;</span>)</span><br><span class="line">s = <span class="built_in">str</span>(d)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># float → Decimal（⚠️ 不推荐，精度已丢失）</span></span><br><span class="line">d = Decimal(<span class="number">0.1</span>)  <span class="comment"># 不要这样做！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># float → Decimal（正确做法：先转字符串）</span></span><br><span class="line">d = Decimal(<span class="built_in">str</span>(<span class="number">0.1</span>))  <span class="comment"># ✅</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）性能对比与使用建议"><a href="#（3）性能对比与使用建议" class="headerlink" title="（3）性能对比与使用建议"></a>（3）性能对比与使用建议</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能对比</span></span><br><span class="line">float_time = timeit.timeit(<span class="string">&quot;0.1 + 0.2&quot;</span>, number=<span class="number">1000000</span>)</span><br><span class="line">decimal_time = timeit.timeit(</span><br><span class="line">    <span class="string">&quot;Decimal(&#x27;0.1&#x27;) + Decimal(&#x27;0.2&#x27;)&quot;</span>, </span><br><span class="line">    setup=<span class="string">&quot;from decimal import Decimal&quot;</span>,</span><br><span class="line">    number=<span class="number">1000000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;float 运算时间：<span class="subst">&#123;float_time:<span class="number">.4</span>f&#125;</span>s&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decimal 运算时间：<span class="subst">&#123;decimal_time:<span class="number">.4</span>f&#125;</span>s&quot;</span>)</span><br><span class="line"><span class="comment"># Decimal 比 float 慢约 10-100 倍</span></span><br></pre></td></tr></table></figure>
<p><strong>使用建议</strong>：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260112000424733.png"></p>
<h3 id="（4）常见陷阱与避坑"><a href="#（4）常见陷阱与避坑" class="headerlink" title="（4）常见陷阱与避坑"></a>（4）常见陷阱与避坑</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 陷阱1：用 float 创建 Decimal</span></span><br><span class="line">bad = Decimal(<span class="number">0.1</span>)</span><br><span class="line"><span class="built_in">print</span>(bad)  <span class="comment"># 0.1000000000000000055511151231257827...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：用字符串创建</span></span><br><span class="line">good = Decimal(<span class="string">&quot;0.1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(good)  <span class="comment"># 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 陷阱2：Decimal 与 float 混合运算</span></span><br><span class="line">d = Decimal(<span class="string">&quot;10.5&quot;</span>)</span><br><span class="line">f = <span class="number">3.0</span></span><br><span class="line"><span class="comment"># result = d + f  # TypeError: unsupported operand type(s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：统一类型</span></span><br><span class="line">result = d + Decimal(<span class="built_in">str</span>(f))</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 13.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 陷阱3：忘记处理精度</span></span><br><span class="line">price = Decimal(<span class="string">&quot;19.99&quot;</span>) * Decimal(<span class="string">&quot;0.1&quot;</span>)  <span class="comment"># 打9折</span></span><br><span class="line"><span class="built_in">print</span>(price)  <span class="comment"># 1.999（可能需要四舍五入）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：明确精度</span></span><br><span class="line">price = (Decimal(<span class="string">&quot;19.99&quot;</span>) * Decimal(<span class="string">&quot;0.1&quot;</span>)).quantize(Decimal(<span class="string">&quot;0.01&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(price)  <span class="comment"># 2.00</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二、列表（list）"><a href="#二、列表（list）" class="headerlink" title="二、列表（list）"></a>二、列表（list）</h1><h2 id="1-列表的定义与基础表示"><a href="#1-列表的定义与基础表示" class="headerlink" title="1.列表的定义与基础表示"></a>1.列表的定义与基础表示</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><ul>
<li><strong>Python 中定义列表使用方括号 [] 包裹元素，元素之间用逗号 , 分隔</strong></li>
<li><strong>列表支持存储不同类型的元素，也支持嵌套（列表内部包含列表）</strong></li>
<li><strong>list()函数</strong>：将<strong>可迭代对象</strong>转换为列表，如字符串、元组</li>
</ul>
<h3 id="（2）常用创建方法"><a href="#（2）常用创建方法" class="headerlink" title="（2）常用创建方法"></a>（2）常用创建方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1： 基础列表定义（不同类型元素）</span></span><br><span class="line">lst1 = [<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;Python&quot;</span>, <span class="literal">True</span>]  <span class="comment"># 包含 int、float、str、bool 类型</span></span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># [10, 3.14, &#x27;Python&#x27;, True]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：空列表定义</span></span><br><span class="line">lst2 = []  <span class="comment"># 空列表，长度为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(lst2))  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：嵌套列表（列表内部包含列表）</span></span><br><span class="line">lst3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]]  <span class="comment"># 二维、三维嵌套</span></span><br><span class="line"><span class="built_in">print</span>(lst3)  <span class="comment"># [1, 2, [3, 4], [5, [6, 7]]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4：用 list() 函数创建列表（可转换可迭代对象，如字符串、元组）</span></span><br><span class="line">lst4 = <span class="built_in">list</span>(<span class="string">&quot;hello&quot;</span>)  <span class="comment"># 字符串转列表（每个字符为元素）</span></span><br><span class="line">lst5 = <span class="built_in">list</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 元组转列表</span></span><br><span class="line"><span class="built_in">print</span>(lst4)  <span class="comment"># [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(lst5)  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-列表的核心特性"><a href="#2-列表的核心特性" class="headerlink" title="2.列表的核心特性"></a>2.列表的核心特性</h2><h3 id="（1）可变性（最核心特性）"><a href="#（1）可变性（最核心特性）" class="headerlink" title="（1）可变性（最核心特性）"></a>（1）可变性（最核心特性）</h3><ul>
<li><strong>列表创建后，可直接修改元素的值、新增元素、删除元素，无需生成新列表</strong>（与字符串、数字、bool 的不可变性形成对比）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 1. 修改元素（通过索引赋值）</span></span><br><span class="line">lst[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># 将第 0 位元素改为 10</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 新增元素（append() 方法）</span></span><br><span class="line">lst.append(<span class="number">4</span>)  <span class="comment"># 在列表末尾新增元素 4</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除元素（del 语句）</span></span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">1</span>]  <span class="comment"># 删除第 1 位元素（值为 2）</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）有序性"><a href="#（2）有序性" class="headerlink" title="（2）有序性"></a>（2）有序性</h3><ul>
<li><strong>列表中的元素按「插入顺序」排列，支持通过「索引」（正向、反向）访问元素，也支持切片截取子列表</strong><ul>
<li><strong>正向索引</strong>：从 0 开始，依次递增（0 表示第一个元素，1 表示第二个，以此类推）；</li>
<li><strong>反向索引</strong>：从 -1 开始，依次递减（-1 表示最后一个元素，-2 表示倒数第二个，以此类推）；</li>
<li><strong>切片</strong>：语法为lst[start:end:step]，start 起始位置（默认 0），end 结束位置（不包含，默认列表长度），step 步长（默认 1，负数表示反向切片）。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line"><span class="comment"># 1. 正向索引访问</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>])  <span class="comment"># &#x27;a&#x27;（第一个元素）</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">2</span>])  <span class="comment"># &#x27;c&#x27;（第三个元素）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 反向索引访问</span></span><br><span class="line"><span class="built_in">print</span>(lst[-<span class="number">1</span>])  <span class="comment"># &#x27;e&#x27;（最后一个元素）</span></span><br><span class="line"><span class="built_in">print</span>(lst[-<span class="number">3</span>])  <span class="comment"># &#x27;c&#x27;（倒数第三个元素）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 切片操作</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]（从第1位到第3位，不包含第4位）</span></span><br><span class="line"><span class="built_in">print</span>(lst[:<span class="number">3</span>])   <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]（从开头到第2位，不包含第3位）</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">2</span>:])   <span class="comment"># [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]（从第2位到末尾）</span></span><br><span class="line"><span class="built_in">print</span>(lst[::<span class="number">2</span>])  <span class="comment"># [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;]（步长2，每隔1个元素取1个）</span></span><br><span class="line"><span class="built_in">print</span>(lst[::-<span class="number">1</span>]) <span class="comment"># [&#x27;e&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]（反向切片，倒序输出）</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）元素类型无限制"><a href="#（3）元素类型无限制" class="headerlink" title="（3）元素类型无限制"></a>（3）元素类型无限制</h3><ul>
<li><strong>列表可存储任意类型的元素，包括数字、字符串、列表、字典等，甚至可以混合存储不同类型。</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">100</span>, <span class="string">&quot;hello&quot;</span>, [<span class="number">1</span>,<span class="number">2</span>], &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>&#125;, <span class="literal">None</span>]</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [100, &#x27;hello&#x27;, [1, 2], &#123;&#x27;name&#x27;: &#x27;小明&#x27;&#125;, None]</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）不可哈希性"><a href="#（4）不可哈希性" class="headerlink" title="（4）不可哈希性"></a>（4）不可哈希性</h3><p><strong>由于列表是可变对象，因此它是「不可哈希」的，无法作为字典的键（key），也无法放入集合（set）中（集合元素需可哈希）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表作为字典键（报错）</span></span><br><span class="line"><span class="comment"># dict1 = &#123;[1,2]: &quot;error&quot;&#125;  # TypeError: unhashable type: &#x27;list&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表放入集合（报错）</span></span><br><span class="line"><span class="comment"># set1 = &#123;[1,2], [3,4]&#125;  # TypeError: unhashable type: &#x27;list&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-列表的常用操作"><a href="#3-列表的常用操作" class="headerlink" title="3.列表的常用操作"></a>3.列表的常用操作</h2><h3 id="（1）元素的增、删、改、查"><a href="#（1）元素的增、删、改、查" class="headerlink" title="（1）元素的增、删、改、查"></a>（1）元素的增、删、改、查</h3><ul>
<li><strong>查（访问元素）</strong>：通过索引或切片访问，若索引超出范围会报错（IndexError）；</li>
<li><strong>改（修改元素）</strong>：通过索引赋值修改，支持批量修改（切片赋值）；</li>
<li><strong>增（新增元素）</strong>：<ul>
<li><strong>append()</strong>：末尾新增</li>
<li><strong>insert()</strong>：指定位置新增</li>
<li><strong>extend()</strong>：合并另一个可迭代对象</li>
</ul>
</li>
<li><strong>删（删除元素）</strong>：<ul>
<li><strong>del</strong>：按索引删除</li>
<li><strong>remove()</strong>：按值删除，删除第一个匹配项</li>
<li><strong>pop()</strong>：按索引删除并返回元素，默认删除末尾</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注：切片是“左闭右开”</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 1. 查</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">1</span>])  <span class="comment"># 2（索引访问）</span></span><br><span class="line"><span class="built_in">print</span>(lst[<span class="number">0</span>:<span class="number">2</span>])  <span class="comment"># [1, 2]（切片访问）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 改</span></span><br><span class="line">lst[<span class="number">2</span>] = <span class="number">30</span>  <span class="comment"># 单个元素修改</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 30]</span></span><br><span class="line">lst[<span class="number">0</span>:<span class="number">2</span>] = [<span class="number">10</span>, <span class="number">20</span>]  <span class="comment"># 批量修改（切片赋值）</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 增</span></span><br><span class="line">lst.append(<span class="number">40</span>)  <span class="comment"># 末尾新增</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 20, 30, 40]</span></span><br><span class="line">lst.insert(<span class="number">1</span>, <span class="number">15</span>)  <span class="comment"># 在第1位插入 15</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 15, 20, 30, 40]</span></span><br><span class="line">lst.extend([<span class="number">50</span>, <span class="number">60</span>])  <span class="comment"># 合并列表 [50,60]</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 15, 20, 30, 40, 50, 60]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删</span></span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">1</span>]  <span class="comment"># 按索引删除第1位（15）</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 20, 30, 40, 50, 60]</span></span><br><span class="line">lst.remove(<span class="number">30</span>)  <span class="comment"># 按值删除 30（第一个匹配项）</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 20, 40, 50, 60]</span></span><br><span class="line">pop_val = lst.pop()  <span class="comment"># 默认删除末尾元素，返回删除的值</span></span><br><span class="line"><span class="built_in">print</span>(pop_val)  <span class="comment"># 60</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [10, 20, 40, 50]</span></span><br><span class="line">pop_val2 = lst.pop(<span class="number">0</span>)  <span class="comment"># 删除第0位元素，返回值</span></span><br><span class="line"><span class="built_in">print</span>(pop_val2)  <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [20, 40, 50]</span></span><br></pre></td></tr></table></figure>

<p><strong>补充：切片赋值的长度可以不一致</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">lst[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]  <span class="comment"># 用4个元素替换2个元素</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 20, 30, 40, 50, 4, 5]</span></span><br><span class="line"></span><br><span class="line">lst[<span class="number">1</span>:<span class="number">5</span>] = [<span class="number">100</span>]  <span class="comment"># 用1个元素替换4个元素</span></span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 100, 4, 5]</span></span><br></pre></td></tr></table></figure>


<h3 id="（2）列表的拼接与重复"><a href="#（2）列表的拼接与重复" class="headerlink" title="（2）列表的拼接与重复"></a>（2）列表的拼接与重复</h3><ul>
<li><strong>+</strong>：拼接两个列表</li>
<li><strong>*</strong>：将列表元素重复指定次数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 拼接（+）</span></span><br><span class="line">lst3 = lst1 + lst2</span><br><span class="line"><span class="built_in">print</span>(lst3)  <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># [1, 2, 3]（原列表未修改）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重复（*）</span></span><br><span class="line">lst4 = lst1 * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(lst4)  <span class="comment"># [1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）成员判断（in-not-in）"><a href="#（3）成员判断（in-not-in）" class="headerlink" title="（3）成员判断（in &#x2F; not in）"></a>（3）成员判断（in &#x2F; not in）</h3><ul>
<li><strong>用 in 判断元素是否在列表中，not in 判断元素是否不在列表中，返回布尔值</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="string">&quot;hello&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="number">20</span> <span class="keyword">in</span> lst)  <span class="comment"># True（元素存在）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span> <span class="keyword">in</span> lst)  <span class="comment"># False（元素不存在）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> lst)  <span class="comment"># False（元素存在，not in 返回 False）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> lst)  <span class="comment"># True（元素不存在）</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）列表的排序与反转"><a href="#（4）列表的排序与反转" class="headerlink" title="（4）列表的排序与反转"></a>（4）列表的排序与反转</h3><ul>
<li><strong>sort()</strong>：对列表进行排序，默认升序</li>
<li><strong>reverse()</strong>：反转列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 1. sort() 排序（默认升序，修改原列表）</span></span><br><span class="line">lst.sort()</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># 降序排序</span></span><br><span class="line">lst.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [5, 4, 3, 2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. reverse() 反转（修改原列表）</span></span><br><span class="line"><span class="comment"># 当前 lst 为 [5, 4, 3, 2, 1]，反转后变为 [1, 2, 3, 4, 5]</span></span><br><span class="line">lst.reverse()</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-列表常用内置函数与方法"><a href="#4-列表常用内置函数与方法" class="headerlink" title="4.列表常用内置函数与方法"></a>4.列表常用内置函数与方法</h2><h3 id="（1）内置函数（全局函数，直接调用）"><a href="#（1）内置函数（全局函数，直接调用）" class="headerlink" title="（1）内置函数（全局函数，直接调用）"></a>（1）内置函数（全局函数，直接调用）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109232134158.png"></p>
<h3 id="（2）列表对象方法（list-方法名-）"><a href="#（2）列表对象方法（list-方法名-）" class="headerlink" title="（2）列表对象方法（list.方法名()）"></a>（2）列表对象方法（list.方法名()）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109233311166.png"></p>
<h2 id="5-操作列表"><a href="#5-操作列表" class="headerlink" title="5.操作列表"></a>5.操作列表</h2><h3 id="（1）列表的创建"><a href="#（1）列表的创建" class="headerlink" title="（1）列表的创建"></a>（1）列表的创建</h3><h4 id="直接用方括号定义（最基础常用）"><a href="#直接用方括号定义（最基础常用）" class="headerlink" title="&lt;1&gt;直接用方括号定义（最基础常用）"></a>&lt;1&gt;直接用方括号定义（最基础常用）</h4><ul>
<li><strong>用 [] 包裹元素，元素间用逗号分隔，支持混合类型元素和嵌套列表</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 混合类型列表</span></span><br><span class="line">lst1 = [<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;Python&quot;</span>, <span class="literal">True</span>]</span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># 输出：[10, 3.14, &#x27;Python&#x27;, True]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套列表</span></span><br><span class="line">lst_nest = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]]</span><br><span class="line"><span class="built_in">print</span>(lst_nest)  <span class="comment"># 输出：[1, [2, 3], [4, [5, 6]]]</span></span><br></pre></td></tr></table></figure>

<h4 id="创建空列表（动态添加元素场景）"><a href="#创建空列表（动态添加元素场景）" class="headerlink" title="&lt;2&gt;创建空列表（动态添加元素场景）"></a>&lt;2&gt;创建空列表（动态添加元素场景）</h4><ul>
<li><strong>直接写 []，后续通过 append()、extend() 等方法动态添加元素</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建空列表</span></span><br><span class="line">lst2 = []</span><br><span class="line"><span class="comment"># 动态添加单个元素</span></span><br><span class="line">lst2.append(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst2)  <span class="comment"># 输出：[&#x27;test&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续动态添加多个元素</span></span><br><span class="line">lst2.extend([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(lst2)  <span class="comment"># 输出：[&#x27;test&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="创建数值列表（range-）"><a href="#创建数值列表（range-）" class="headerlink" title="&lt;3&gt;创建数值列表（range()）"></a>&lt;3&gt;创建数值列表（range()）</h4><h5 id="1-使用range函数"><a href="#1-使用range函数" class="headerlink" title="1.使用range函数"></a>1.使用range函数</h5><ul>
<li><strong>range(start, stop, step)能够轻松地生成一系列的数字（“左闭右开区间”,step：步长）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"> 1</span></span><br><span class="line"><span class="string"> 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-使用range-创建数字列表"><a href="#2-使用range-创建数字列表" class="headerlink" title="2.使用range()创建数字列表"></a>2.使用range()创建数字列表</h5><ul>
<li><strong>核心语法：list(range(start, stop, step))（start 默认 0，step 默认 1）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法：list(range(stop))</span></span><br><span class="line"><span class="comment"># 生成：0 ~ stop-1 的整数列表</span></span><br><span class="line">num_list1 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(num_list1)  <span class="comment"># 输出：[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法：list(range(start, stop))</span></span><br><span class="line"><span class="comment"># 生成：start ~ stop-1 的整数列表（左闭右开）</span></span><br><span class="line">num_list2 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>, <span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(num_list2)  <span class="comment"># 输出：[3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法：list(range(start, stop, step))</span></span><br><span class="line"><span class="comment"># 生成：从 start 开始，每次加 step，直到不超过 stop（左闭右开）</span></span><br><span class="line"><span class="comment"># 示例1：生成奇数列表（1-9）</span></span><br><span class="line">odd_nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(odd_nums)  <span class="comment"># [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：生成偶数列表（0-10）</span></span><br><span class="line">even_nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">11</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(even_nums)  <span class="comment"># [0, 2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：生成递减数值列表（步长为负）</span></span><br><span class="line">desc_nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(desc_nums)  <span class="comment"># [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<h4 id="list-函数转换（可迭代对象转列表）"><a href="#list-函数转换（可迭代对象转列表）" class="headerlink" title="&lt;4&gt;list()函数转换（可迭代对象转列表）"></a>&lt;4&gt;list()函数转换（可迭代对象转列表）</h4><ul>
<li><strong>将字符串、元组、range对象等可迭代对象转换为列表</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串转列表（每个字符为元素）</span></span><br><span class="line">str_to_lst = <span class="built_in">list</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_to_lst)  <span class="comment"># 输出：[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组转列表</span></span><br><span class="line">tuple_to_lst = <span class="built_in">list</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(tuple_to_lst)  <span class="comment"># 输出：[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="列表推导式（高效生成有规律列表）"><a href="#列表推导式（高效生成有规律列表）" class="headerlink" title="&lt;5&gt;列表推导式（高效生成有规律列表）"></a>&lt;5&gt;列表推导式（高效生成有规律列表）</h4><ul>
<li><strong>核心语法：[表达式 for 变量 in 可迭代对象 if 条件]（条件可选）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成0-9的偶数列表（带条件判断）</span></span><br><span class="line">even_lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(even_lst)  <span class="comment"># 输出：[0, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对已有列表元素加工（无条件判断）</span></span><br><span class="line">processed_lst = [x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="built_in">print</span>(processed_lst)  <span class="comment"># 输出：[3, 6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套列表推导式（生成二维列表）</span></span><br><span class="line">two_dimensional_lst = [[i*j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line"><span class="built_in">print</span>(two_dimensional_lst)  <span class="comment"># 输出：[[0, 0, 0], [0, 1, 2]]</span></span><br></pre></td></tr></table></figure>

<h2 id="6-列表的遍历（for循环）"><a href="#6-列表的遍历（for循环）" class="headerlink" title="6.列表的遍历（for循环）"></a>6.列表的遍历（for循环）</h2><h3 id="（1）基础for循环遍历（直接遍历元素）"><a href="#（1）基础for循环遍历（直接遍历元素）" class="headerlink" title="（1）基础for循环遍历（直接遍历元素）"></a>（1）基础for循环遍历（直接遍历元素）</h3><ul>
<li><strong>最常用的遍历方式，直接迭代列表中的每个元素，无需关心索引，语法简洁高效，适合仅需使用元素值的场景。</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lst = [<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;橙子&quot;</span>]</span><br><span class="line"><span class="comment"># 基础遍历：直接取元素</span></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="built_in">print</span>(fruit)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历混合类型列表</span></span><br><span class="line">mix_lst = [<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;Python&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> mix_lst:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;元素值：<span class="subst">&#123;item&#125;</span>，元素类型：<span class="subst">&#123;<span class="built_in">type</span>(item)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># 元素值：10，元素类型：&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 元素值：3.14，元素类型：&lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 元素值：Python，元素类型：&lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）带索引的for循环遍历（enumerate函数）"><a href="#（2）带索引的for循环遍历（enumerate函数）" class="headerlink" title="（2）带索引的for循环遍历（enumerate函数）"></a>（2）带索引的for循环遍历（enumerate函数）</h3><ul>
<li><strong>当需要同时获取元素的「索引」和「值」时，使用 enumerate() 函数，该函数返回元组 (索引, 元素值)，默认索引从0开始，也可指定起始索引。</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lst = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]</span><br><span class="line"><span class="comment"># 默认索引从0开始</span></span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(lst):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;索引：<span class="subst">&#123;idx&#125;</span>，元素：<span class="subst">&#123;val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引从1开始</span></span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(lst, start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;序号：<span class="subst">&#123;idx&#125;</span>，元素：<span class="subst">&#123;val&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（3）切片遍历（遍历子列表）"><a href="#（3）切片遍历（遍历子列表）" class="headerlink" title="（3）切片遍历（遍历子列表）"></a>（3）切片遍历（遍历子列表）</h3><p><strong>通过切片获取列表的子列表后，再用for循环遍历，适合仅需要遍历列表中部分元素的场景（如前3个元素、间隔元素、倒序元素等）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lst = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># 1. 遍历前5个元素（切片：lst[:5]）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前5个元素：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> lst[:<span class="number">5</span>]:</span><br><span class="line">    <span class="built_in">print</span>(num, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 输出：前5个元素：0 1 2 3 4  (注：应该换行，这里为了节省篇幅就不换了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 遍历索引2到7的元素（不包含7，切片：lst[2:7]）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n索引2-6的元素：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> lst[<span class="number">2</span>:<span class="number">7</span>]:</span><br><span class="line">    <span class="built_in">print</span>(num, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 输出：索引2-6的元素：2 3 4 5 6  (注：应该换行，这里为了节省篇幅就不换了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 遍历间隔2的元素（步长2，切片：lst[::2]）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n间隔2的元素：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> lst[::<span class="number">2</span>]:</span><br><span class="line">    <span class="built_in">print</span>(num, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 输出：间隔2的元素：0 2 4 6 8 (注：应该换行，这里为了节省篇幅就不换了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 倒序遍历（步长-1，切片：lst[::-1]）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n倒序遍历所有元素：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> lst[::-<span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(num, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 输出：倒序遍历所有元素：9 8 7 6 5 4 3 2 1 0 (注：应该换行，这里为了节省篇幅就不换了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 遍历嵌套列表的子列表</span></span><br><span class="line">nest_lst = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n嵌套列表中的子列表元素：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> nest_lst[<span class="number">2</span>]:  <span class="comment"># 先取子列表 lst[2] = [3,4,5]，再遍历</span></span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 输出：嵌套列表中的子列表元素：3 4 5 (注：应该换行，这里为了节省篇幅就不换了)</span></span><br></pre></td></tr></table></figure>

<h2 id="7-列表的关键注意事项"><a href="#7-列表的关键注意事项" class="headerlink" title="7.列表的关键注意事项"></a>7.列表的关键注意事项</h2><h3 id="（1）可变对象的引用问题（“可变性”）"><a href="#（1）可变对象的引用问题（“可变性”）" class="headerlink" title="（1）可变对象的引用问题（“可变性”）"></a>（1）可变对象的引用问题（“可变性”）</h3><ul>
<li><strong>列表是可变对象，赋值时传递的是引用（内存地址），修改新列表会影响原列表（与不可变对象的赋值逻辑不同）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变对象引用传递</span></span><br><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst2 = lst1  <span class="comment"># lst2 指向 lst1 的内存地址</span></span><br><span class="line">lst2[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># 修改 lst2，原列表 lst1 也会被修改</span></span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># [10, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(lst2)  <span class="comment"># [10, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决：创建列表副本（不影响原列表）</span></span><br><span class="line">lst3 = lst1.copy()  <span class="comment"># 方法1：copy() 方法</span></span><br><span class="line">lst4 = lst1[:]      <span class="comment"># 方法2：切片（全切片）</span></span><br><span class="line">lst5 = <span class="built_in">list</span>(lst1)   <span class="comment"># 方法3：list() 函数</span></span><br><span class="line">lst3[<span class="number">0</span>] = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># [10, 2, 3]（原列表未变）</span></span><br><span class="line"><span class="built_in">print</span>(lst3)  <span class="comment"># [20, 2, 3]（副本修改）</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）嵌套列表的副本问题"><a href="#（2）嵌套列表的副本问题" class="headerlink" title="（2）嵌套列表的副本问题"></a>（2）嵌套列表的副本问题</h3><ul>
<li><strong>普通 copy()&#x2F;切片 是「浅拷贝」，仅复制外层列表，内层嵌套列表仍为引用传递，修改内层列表会影响原列表</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">lst2 = lst1.copy()  <span class="comment"># 浅拷贝</span></span><br><span class="line">lst2[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">30</span>  <span class="comment"># 修改内层列表</span></span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># [1, 2, [30, 4]]（原列表内层被修改）</span></span><br><span class="line"><span class="built_in">print</span>(lst2)  <span class="comment"># [1, 2, [30, 4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决：深拷贝（复制所有层级的元素，完全独立）</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">lst3 = copy.deepcopy(lst1)  <span class="comment"># 深拷贝</span></span><br><span class="line">lst3[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">300</span></span><br><span class="line"><span class="built_in">print</span>(lst1)  <span class="comment"># [1, 2, [30, 4]]（原列表未变）</span></span><br><span class="line"><span class="built_in">print</span>(lst3)  <span class="comment"># [1, 2, [300, 4]]</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）避免频繁在列表开头增删元素"><a href="#（3）避免频繁在列表开头增删元素" class="headerlink" title="（3）避免频繁在列表开头增删元素"></a>（3）避免频繁在列表开头增删元素</h3><ul>
<li><strong>列表是动态数组，开头增删元素（如 insert(0, x)、pop(0)）需要移动所有后续元素，效率低</strong></li>
<li><strong>若需频繁在两端操作，推荐用 collections.deque（双端队列）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 低效：列表开头插入</span></span><br><span class="line">lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    lst.insert(<span class="number">0</span>, i)  <span class="comment"># 每次插入都要移动所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高效：双端队列开头插入</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">dq = deque()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    dq.appendleft(i)  <span class="comment"># 双端队列开头插入效率高</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="三、元组"><a href="#三、元组" class="headerlink" title="三、元组"></a>三、元组</h1><h2 id="1-元组的定义与基础表示"><a href="#1-元组的定义与基础表示" class="headerlink" title="1.元组的定义与基础表示"></a>1.元组的定义与基础表示</h2><h3 id="（1）概述-1"><a href="#（1）概述-1" class="headerlink" title="（1）概述"></a>（1）概述</h3><ul>
<li><strong>定义元组使用圆括号 () 包裹元素，元素之间用“逗号 , ”分隔</strong></li>
<li><strong>元组支持存储不同类型的元素，也支持嵌套（元组内部包含元组、列表等）</strong></li>
</ul>
<p><strong>注意：当元组中只有一个元素时，必须在元素后加“逗号 , ”，否则圆括号会被当作运算符处理，无法正确创建元组。</strong></p>
<h3 id="（2）常用创建方法-1"><a href="#（2）常用创建方法-1" class="headerlink" title="（2）常用创建方法"></a>（2）常用创建方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1：直接用圆括号定义（最常用，支持混合类型/嵌套）</span></span><br><span class="line">t1 = (<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;Python&quot;</span>, <span class="literal">True</span>)  <span class="comment"># 包含 int、float、str、bool 类型</span></span><br><span class="line">t_nest = (<span class="number">1</span>, <span class="number">2</span>, (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]))  <span class="comment"># 二维嵌套元组（内部可包含列表）</span></span><br><span class="line"><span class="built_in">print</span>(t1)  <span class="comment"># (10, 3.14, &#x27;Python&#x27;, True)</span></span><br><span class="line"><span class="built_in">print</span>(t_nest)  <span class="comment"># (1, 2, (3, 4), (5, [6, 7]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：创建单元素元组（必须加逗号，否则不是元组）</span></span><br><span class="line">t2 = (<span class="number">5</span>,)  <span class="comment"># 正确：单元素元组，逗号不可省略</span></span><br><span class="line">t3 = (<span class="number">5</span>)   <span class="comment"># 错误：被当作整数 5 处理，类型是 int</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t2))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t3))  <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：省略圆括号创建（元组的特殊语法，简洁）</span></span><br><span class="line">t4 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment"># 无需圆括号，直接用逗号分隔元素</span></span><br><span class="line"><span class="built_in">print</span>(t4)  <span class="comment"># (1, 2, 3)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t4))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4：用 tuple() 函数转换（可迭代对象转元组）</span></span><br><span class="line">t5 = <span class="built_in">tuple</span>(<span class="string">&quot;hello&quot;</span>)  <span class="comment"># 字符串转元组（每个字符为元素）</span></span><br><span class="line">t6 = <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 列表转元组</span></span><br><span class="line">t7 = <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">5</span>))  <span class="comment"># range对象转元组（生成连续整数元组）</span></span><br><span class="line"><span class="built_in">print</span>(t5)  <span class="comment"># (&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(t6)  <span class="comment"># (1, 2, 3)</span></span><br><span class="line"><span class="built_in">print</span>(t7)  <span class="comment"># (0, 1, 2, 3, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法5：创建空元组</span></span><br><span class="line">t8 = ()  <span class="comment"># 空元组，长度为 0</span></span><br><span class="line">t9 = <span class="built_in">tuple</span>()  <span class="comment"># 空元组（tuple() 无参数时返回空元组）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t8))  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(t9)  <span class="comment"># ()</span></span><br></pre></td></tr></table></figure>

<h2 id="2-元组的核心特性"><a href="#2-元组的核心特性" class="headerlink" title="2.元组的核心特性"></a>2.元组的核心特性</h2><h3 id="（1）不可变性（最核心特性，必看！）"><a href="#（1）不可变性（最核心特性，必看！）" class="headerlink" title="（1）不可变性（最核心特性，必看！）"></a>（1）不可变性（最核心特性，必看！）</h3><ul>
<li><strong>元组存储的是对象的引用，而非对象本身</strong></li>
<li><strong>元组的不可变性仅意味着元组的结构（长度和对象引用）不能改变</strong></li>
<li><strong>但引用指向的可变对象的内部状态可以改变</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,[<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="comment"># 1. 尝试修改元素（报错）</span></span><br><span class="line"><span class="comment"># t[0] = 10  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br><span class="line"><span class="comment"># 2. 尝试删除元素（报错）</span></span><br><span class="line"><span class="comment"># del t[1]  # TypeError: &#x27;tuple&#x27; object doesn&#x27;t support item deletion</span></span><br><span class="line"><span class="comment"># 3. 尝试新增元素（报错）</span></span><br><span class="line"><span class="comment"># t.append(4)  # AttributeError: &#x27;tuple&#x27; object has no attribute &#x27;append&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.修改元组中列表的内容（成功）</span></span><br><span class="line">t[<span class="number">3</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改后元组: <span class="subst">&#123;t&#125;</span>&quot;</span>)  <span class="comment"># 修改后元组: (1, 2, 3,[3, 4, 5])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.尝试替换整个列表（报错）</span></span><br><span class="line">t[<span class="number">3</span>] = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  <span class="comment"># 错误：&#x27;tuple&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure>
<p><strong>注意！！：若元组内部包含“可变对象”（如列表），则可变对象的内部元素可以修改，但元组的结构（长度和对象引用）不能改变</strong>。</p>
<ul>
<li><strong>对于「不可变元素」</strong>（如数字、bool值、字符串等）：引用地址和实际值绑定，修改值 &#x3D; 修改引用（<strong>由不可变性知</strong>），因此元组不允许操作修改<strong>不可变元素</strong>的值；<ul>
<li><strong>不可变元素</strong>：整数（int）、布尔值（bool）、浮点数（float）、字符串（str）、元组（tuple）</li>
</ul>
</li>
<li><strong>对于「可变元素」</strong>（如列表、字典等）：引用地址与实际值分开存储，修改值 !&#x3D; 修改引用（<strong>有可变性知</strong>），因此元组允许操作修改<strong>可变元素</strong>内的值；<ul>
<li><strong>可变元素</strong>：列表（list）、字典（dict）、集合（set）、字节数组（bytearray）</li>
</ul>
</li>
</ul>
<h3 id="（2）有序性-1"><a href="#（2）有序性-1" class="headerlink" title="（2）有序性"></a>（2）有序性</h3><p><strong>元组中的元素按「插入顺序」排列，支持通过「索引」（正向、反向）访问元素，也支持切片截取子元组，操作逻辑与列表、字符串完全一致。</strong></p>
<ul>
<li><strong>正向索引</strong>：从 0 开始，依次递增（0 表示第一个元素）</li>
<li><strong>反向索引</strong>：从 -1 开始，依次递减（-1 表示最后一个元素）</li>
<li><strong>切片</strong>：语法为 t[start:end:step]，start 起始位置（默认 0），end 结束位置（不包含，默认元组长度），step 步长（默认 1，负数表示反向切片）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>)</span><br><span class="line"><span class="comment"># 1. 索引访问</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">0</span>])   <span class="comment"># &#x27;a&#x27;（正向索引：第0位）</span></span><br><span class="line"><span class="built_in">print</span>(t[-<span class="number">1</span>])  <span class="comment"># &#x27;e&#x27;（反向索引：最后一位）</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">3</span>])   <span class="comment"># &#x27;d&#x27;（正向索引：第3位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切片操作</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)（从第1位到第3位，不包含第4位）</span></span><br><span class="line"><span class="built_in">print</span>(t[:<span class="number">3</span>])   <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)（从开头到第2位）</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">2</span>:])   <span class="comment"># (&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;)（从第2位到末尾）</span></span><br><span class="line"><span class="built_in">print</span>(t[::<span class="number">2</span>])  <span class="comment"># (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;)（步长2，间隔取元素）</span></span><br><span class="line"><span class="built_in">print</span>(t[::-<span class="number">1</span>]) <span class="comment"># (&#x27;e&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;)（反向切片，倒序输出）</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）元素类型无限制-1"><a href="#（3）元素类型无限制-1" class="headerlink" title="（3）元素类型无限制"></a>（3）元素类型无限制</h3><p><strong>元组可存储任意类型的元素，包括数字、字符串、元组、列表、字典等，支持混合类型存储。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">100</span>, <span class="string">&quot;hello&quot;</span>, (<span class="number">1</span>,<span class="number">2</span>), [<span class="number">3</span>,<span class="number">4</span>], &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>&#125;, <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(t)  <span class="comment"># (100, &#x27;hello&#x27;, (1, 2), [3, 4], &#123;&#x27;name&#x27;: &#x27;小明&#x27;&#125;, None)</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）可哈希性"><a href="#（4）可哈希性" class="headerlink" title="（4）可哈希性"></a>（4）可哈希性</h3><p><strong>由于元组是不可变的，因此它是「可哈希」对象，可以作为字典的键（key），也可以放入集合（set）中；而列表是不可哈希的，无法作为字典键或集合元素。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 元组作为字典键（合法）</span></span><br><span class="line">dict1 = &#123;(<span class="number">1</span>,<span class="number">2</span>): <span class="string">&quot;a&quot;</span>, (<span class="number">3</span>,<span class="number">4</span>): <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;(1, 2): &#x27;a&#x27;, (3, 4): &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表作为字典键（报错）</span></span><br><span class="line"><span class="comment"># dict2 = &#123;[1,2]: &quot;a&quot;&#125;  # TypeError: unhashable type: &#x27;list&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组放入集合（合法）</span></span><br><span class="line">set1 = &#123;(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(set1)  <span class="comment"># &#123;(1, 2), (3, 4)&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-元组的常见操作"><a href="#3-元组的常见操作" class="headerlink" title="3.元组的常见操作"></a>3.元组的常见操作</h2><p><strong>元组的操作主要围绕「读取」和「判断」展开，因“不可变性”，无增删改相关方法。常用操作包括遍历、索引&#x2F;切片访问、拼接&#x2F;重复、成员判断等。</strong></p>
<h3 id="（1）元组遍历"><a href="#（1）元组遍历" class="headerlink" title="（1）元组遍历"></a>（1）元组遍历</h3><ul>
<li><strong>元组的遍历方式与列表完全一致，支持基础 for 循环、带索引的遍历（enumerate 函数）、切片遍历。</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;橙子&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 基础 for 循环（直接遍历元素）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基础遍历：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> t:</span><br><span class="line">    <span class="built_in">print</span>(fruit)  <span class="comment"># 苹果、香蕉、橙子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 带索引的遍历（enumerate 函数）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n带索引遍历：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(t, start=<span class="number">1</span>):  <span class="comment"># start=1 指定索引从1开始</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;序号：<span class="subst">&#123;idx&#125;</span>，元素：<span class="subst">&#123;val&#125;</span>&quot;</span>)  <span class="comment"># 序号1-3，对应元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 切片遍历（遍历子元组）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n切片遍历前2个元素：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> t[:<span class="number">2</span>]:</span><br><span class="line">    <span class="built_in">print</span>(fruit)  <span class="comment"># 苹果、香蕉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 嵌套元组遍历</span></span><br><span class="line">t_nest = (<span class="number">1</span>, <span class="number">2</span>, (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n嵌套元组的子元组遍历：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> t_nest[<span class="number">2</span>]:  <span class="comment"># 遍历子元组 t_nest[2] = (3,4,5)</span></span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 3、4、5</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）拼接与重复"><a href="#（2）拼接与重复" class="headerlink" title="（2）拼接与重复"></a>（2）拼接与重复</h3><p><strong>元组支持用 + 拼接（合并两个元组）、用 *重复（将元组元素重复指定次数），但这两种操作会生成新元组，不修改原元组（符合不可变特性）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">t2 = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 拼接（+）</span></span><br><span class="line">t3 = t1 + t2</span><br><span class="line"><span class="built_in">print</span>(t3)  <span class="comment"># (1, 2, 3, 4, 5, 6)</span></span><br><span class="line"><span class="built_in">print</span>(t1)  <span class="comment"># (1, 2, 3)（原元组未修改）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重复（*）</span></span><br><span class="line">t4 = t1 * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(t4)  <span class="comment"># (1, 2, 3, 1, 2, 3, 1, 2, 3)</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）成员判断（in-not-in）-1"><a href="#（3）成员判断（in-not-in）-1" class="headerlink" title="（3）成员判断（in &#x2F; not in）"></a>（3）成员判断（in &#x2F; not in）</h3><p><strong>用 in 判断元素是否在元组中，not in 判断元素是否不在元组中，返回布尔值。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">20</span> <span class="keyword">in</span> t)  <span class="comment"># True（元素存在）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span> <span class="keyword">in</span> t)  <span class="comment"># False（元素不存在）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> t)  <span class="comment"># False（元素存在，not in 返回 False）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> t)  <span class="comment"># True（元素不存在）</span></span><br></pre></td></tr></table></figure>

<h2 id="4-元组的常用内置函数与方法"><a href="#4-元组的常用内置函数与方法" class="headerlink" title="4.元组的常用内置函数与方法"></a>4.元组的常用内置函数与方法</h2><p><strong>元组的方法较少（因不可变性），核心方法为 index()（查找元素索引）和 count()（统计元素出现次数）；常用内置函数与列表通用。</strong></p>
<h3 id="（1）内置函数（全局函数，直接调用）-1"><a href="#（1）内置函数（全局函数，直接调用）-1" class="headerlink" title="（1）内置函数（全局函数，直接调用）"></a>（1）内置函数（全局函数，直接调用）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110090007457.png"></p>
<h3 id="（2）元组对象方法（t-方法名-）"><a href="#（2）元组对象方法（t-方法名-）" class="headerlink" title="（2）元组对象方法（t.方法名()）"></a>（2）元组对象方法（t.方法名()）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110090252610.png"></p>
<h2 id="5-元组与列表的核心区别"><a href="#5-元组与列表的核心区别" class="headerlink" title="5.元组与列表的核心区别"></a>5.元组与列表的核心区别</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110090555054.png"></p>
<h2 id="6-元组的关键注意事项"><a href="#6-元组的关键注意事项" class="headerlink" title="6.元组的关键注意事项"></a>6.元组的关键注意事项</h2><ul>
<li><strong>单元素元组必须加逗号</strong>：这是常见的坑！若省略逗号，圆括号会被当作运算符，创建的是对应类型的单个元素，而非元组。</li>
<li><strong>元组的不可变是「浅层不可变」</strong>：元组的不可变指的是「元素的引用不可变」，即不能修改元组中元素的指向，但如果元素本身是可变对象（如列表），其内部状态可以改变。</li>
<li><strong>元组的「不可变」不代表元素不可变</strong>：元组的不可变指的是「元素的引用不可变」，即不能修改元组中元素的指向，但如果元素本身是可变对象（如列表），其内部状态可以改变。</li>
<li><strong>避免不必要的元组转列表</strong>：若仅需读取数据，直接使用元组更高效；若必须修改数据，再转为列表（用 list(tuple)），修改后可再转回元组（用 tuple(list)）。</li>
<li><strong>函数返回多个值的本质是元组</strong>：Python 中函数返回多个值时，默认会将这些值封装为元组返回，即使没有显式用圆括号包裹。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数返回多个值（默认元组）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>():</span><br><span class="line">    name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    age = <span class="number">20</span></span><br><span class="line">    score = <span class="number">95.5</span></span><br><span class="line">    <span class="keyword">return</span> name, age, score  <span class="comment"># 等价于 return (name, age, score)</span></span><br><span class="line"></span><br><span class="line">result = get_info()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># (&#x27;小明&#x27;, 20, 95.5)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解构赋值（直接提取元组元素）</span></span><br><span class="line">name, age, score = get_info()</span><br><span class="line"><span class="built_in">print</span>(name)  <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(age)   <span class="comment"># 20</span></span><br><span class="line"><span class="built_in">print</span>(score) <span class="comment"># 95.5</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四、字典"><a href="#四、字典" class="headerlink" title="四、字典"></a>四、字典</h1><h2 id="1-字典的定义与基础表示"><a href="#1-字典的定义与基础表示" class="headerlink" title="1.字典的定义与基础表示"></a>1.字典的定义与基础表示</h2><h3 id="（1）概述-2"><a href="#（1）概述-2" class="headerlink" title="（1）概述"></a>（1）概述</h3><ul>
<li><strong>定义字典使用花括号 {} 包裹键值对，键与值之间用冒号 : 分隔，不同键值对之间用逗号 , 分隔</strong><ul>
<li><strong>键（key）</strong>：必须是<strong>不可变对象</strong>（如整数、字符串、元组），且在同一个字典中<strong>唯一</strong>，<strong>不可重复</strong>；</li>
<li><strong>值（value）</strong>：可以是任意类型的对象（如整数、字符串、列表、字典等），<strong>支持重复</strong>；</li>
<li><strong>无序性</strong>：Python 3.7 之前字典是无序的，Python 3.7 及以后保证插入顺序，但仍不支持索引访问（需通过键访问）</li>
</ul>
</li>
</ul>
<h3 id="（2）常用创建方法-2"><a href="#（2）常用创建方法-2" class="headerlink" title="（2）常用创建方法"></a>（2）常用创建方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1：直接用花括号定义（最常用，支持混合类型值）</span></span><br><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;score&quot;</span>: <span class="number">95.5</span>, <span class="string">&quot;is_pass&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line"><span class="comment"># 键：字符串类型；值：字符串、整数、浮点数、布尔值</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 20, &#x27;score&#x27;: 95.5, &#x27;is_pass&#x27;: True&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：创建空字典（动态添加键值对场景）</span></span><br><span class="line">dict2 = &#123;&#125;  <span class="comment"># 空字典，长度为 0</span></span><br><span class="line">dict3 = <span class="built_in">dict</span>()  <span class="comment"># 空字典（dict() 无参数时返回空字典）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(dict2))  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(dict3)  <span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：用 dict() 函数转换（多种可迭代对象转字典）</span></span><br><span class="line"><span class="comment"># 3.1 列表/元组嵌套键值对</span></span><br><span class="line">dict4 = <span class="built_in">dict</span>([(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小红&quot;</span>), (<span class="string">&quot;age&quot;</span>, <span class="number">19</span>)])</span><br><span class="line">dict5 = <span class="built_in">dict</span>(((<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小刚&quot;</span>), (<span class="string">&quot;age&quot;</span>, <span class="number">21</span>)))</span><br><span class="line"><span class="built_in">print</span>(dict4)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小红&#x27;, &#x27;age&#x27;: 19&#125;</span></span><br><span class="line"><span class="built_in">print</span>(dict5)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小刚&#x27;, &#x27;age&#x27;: 21&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 关键字参数（键为字符串时可用）</span></span><br><span class="line">dict6 = <span class="built_in">dict</span>(name=<span class="string">&quot;小李&quot;</span>, age=<span class="number">22</span>, score=<span class="number">88.0</span>)</span><br><span class="line"><span class="built_in">print</span>(dict6)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小李&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 88.0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3 两个可迭代对象（键列表+值列表，用 zip 打包）</span></span><br><span class="line">keys = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line">values = [<span class="string">&quot;小王&quot;</span>, <span class="number">23</span>]</span><br><span class="line">dict7 = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values))</span><br><span class="line"><span class="built_in">print</span>(dict7)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小王&#x27;, &#x27;age&#x27;: 23&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4：字典推导式（简洁生成有规律的字典，高效）</span></span><br><span class="line">dict8 = &#123;i: i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)&#125;  <span class="comment"># 键为 0-4，值为键的 2 倍</span></span><br><span class="line">dict9 = &#123;k: v.upper() <span class="keyword">for</span> k, v <span class="keyword">in</span> &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;.items()&#125;</span><br><span class="line"><span class="built_in">print</span>(dict8)  <span class="comment"># &#123;0: 0, 1: 2, 2: 4, 3: 6, 4: 8&#125;</span></span><br><span class="line"><span class="built_in">print</span>(dict9)  <span class="comment"># &#123;&#x27;a&#x27;: &#x27;APPLE&#x27;, &#x27;b&#x27;: &#x27;BANANA&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>zip(*iterables)</strong>：将多个可迭代对象（如列表、元组等）对应位置的元素打包成一个个元组，返回一个可迭代的 zip 对象。</li>
<li><strong>字典推导式语法</strong>：{key_expr: value_expr for item in iterable if condition}</li>
</ul>
<h2 id="2-字典的核心特性"><a href="#2-字典的核心特性" class="headerlink" title="2.字典的核心特性"></a>2.字典的核心特性</h2><h3 id="（1）键值对映射（核心特性）"><a href="#（1）键值对映射（核心特性）" class="headerlink" title="（1）键值对映射（核心特性）"></a>（1）键值对映射（核心特性）</h3><ul>
<li><strong>字典的核心作用是通过「键」快速定位「值」，无需像列表&#x2F;元组那样遍历查找，访问效率极高（时间复杂度 O(1)）</strong></li>
<li><strong>键是查找的唯一标识，必须满足「不可变」和「唯一」两个条件。</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># 通过键访问值（核心用法）</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&quot;age&quot;</span>])   <span class="comment"># 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键必须唯一，重复键会覆盖前面的值</span></span><br><span class="line">dict2 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;a&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict2)  <span class="comment"># &#123;&#x27;a&#x27;: 2&#125;（后面的键值对覆盖前面的）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键必须是不可变对象，用可变对象作键会报错</span></span><br><span class="line"><span class="comment"># dict3 = &#123;[1,2]: &quot;error&quot;&#125;  # TypeError: unhashable type: &#x27;list&#x27;</span></span><br><span class="line"><span class="comment"># 合法的键类型：整数、字符串、元组</span></span><br><span class="line">dict4 = &#123;<span class="number">1</span>: <span class="string">&quot;int&quot;</span>, <span class="string">&quot;str&quot;</span>: <span class="number">2</span>, (<span class="number">3</span>,<span class="number">4</span>): <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict4)  <span class="comment"># &#123;1: &#x27;int&#x27;, &#x27;str&#x27;: 2, (3, 4): 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）可变性（支持动态增删改）"><a href="#（2）可变性（支持动态增删改）" class="headerlink" title="（2）可变性（支持动态增删改）"></a>（2）可变性（支持动态增删改）</h3><p><strong>字典创建后，可自由添加新的键值对、修改已有键对应的值、删除不需要的键值对，且修改后字典对象的内存地址不变（直接修改原对象）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改前地址：<span class="subst">&#123;<span class="built_in">id</span>(dict1)&#125;</span>&quot;</span>)  <span class="comment"># 如：140692251235840</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 修改已有键的值</span></span><br><span class="line">dict1[<span class="string">&quot;age&quot;</span>] = <span class="number">21</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 21&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加新键值对（键不存在则新增）</span></span><br><span class="line">dict1[<span class="string">&quot;score&quot;</span>] = <span class="number">95.5</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 21, &#x27;score&#x27;: 95.5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除键值对</span></span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&quot;score&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 21&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改后地址：<span class="subst">&#123;<span class="built_in">id</span>(dict1)&#125;</span>&quot;</span>)  <span class="comment"># 如：140692251235840（地址不变）</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）无序性（Python-3-7-有条件有序）"><a href="#（3）无序性（Python-3-7-有条件有序）" class="headerlink" title="（3）无序性（Python 3.7+ 有条件有序）"></a>（3）无序性（Python 3.7+ 有条件有序）</h3><ul>
<li><strong>python 3.6 之前</strong>：字典完全无序，每次迭代可能顺序不同</li>
<li><strong>Python 3.7+</strong>：正式将保留插入顺序作为语言特性</li>
<li><strong>无论是否有序，字典的核心访问方式都是通过键，而非位置。</strong></li>
<li><strong>保留插入顺序不等于排序</strong>：字典不会自动对键进行排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># Python 3.7+ 输出：&#123;&#x27;b&#x27;: 2, &#x27;a&#x27;: 1, &#x27;c&#x27;: 3&#125;（保留插入顺序）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不支持索引访问，报错</span></span><br><span class="line"><span class="comment"># print(dict1[0])  # TypeError: &#x27;dict&#x27; object is not subscriptable</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）值可任意性与可重复性"><a href="#（4）值可任意性与可重复性" class="headerlink" title="（4）值可任意性与可重复性"></a>（4）值可任意性与可重复性</h3><p><strong>字典的值可以是任意类型的对象（包括可变对象如列表、字典），且多个键可以对应相同的值（值不唯一）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;</span><br><span class="line">    <span class="string">&quot;list&quot;</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],  <span class="comment"># 值为列表（可变）</span></span><br><span class="line">    <span class="string">&quot;dict&quot;</span>: &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;,  <span class="comment"># 值为字典（可变）</span></span><br><span class="line">    <span class="string">&quot;tuple&quot;</span>: (<span class="number">4</span>,<span class="number">5</span>),   <span class="comment"># 值为元组（不可变）</span></span><br><span class="line">    <span class="string">&quot;repeat_val&quot;</span>: <span class="number">10</span>  <span class="comment"># 重复值</span></span><br><span class="line">&#125;</span><br><span class="line">dict1[<span class="string">&quot;another_repeat&quot;</span>] = <span class="number">10</span>  <span class="comment"># 新增键，值与上面重复</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;list&#x27;: [1, 2, 3], &#x27;dict&#x27;: &#123;&#x27;a&#x27;: 1&#125;, &#x27;tuple&#x27;: (4, 5), &#x27;repeat_val&#x27;: 10, &#x27;another_repeat&#x27;: 10&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="（5）不可哈希性"><a href="#（5）不可哈希性" class="headerlink" title="（5）不可哈希性"></a>（5）不可哈希性</h3><p><strong>由于字典是可变对象，因此它是「不可哈希」的，无法作为字典的键（key），也无法放入集合（set）中（集合元素需可哈希）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典作为字典键（报错）</span></span><br><span class="line"><span class="comment"># dict1 = &#123;&#123;&quot;a&quot;:1&#125;: &quot;error&quot;&#125;  # TypeError: unhashable type: &#x27;dict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典放入集合（报错）</span></span><br><span class="line"><span class="comment"># set1 = &#123;&#123;&quot;a&quot;:1&#125;, &#123;&quot;b&quot;:2&#125;&#125;  # TypeError: unhashable type: &#x27;dict&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-字典的常用操作"><a href="#3-字典的常用操作" class="headerlink" title="3.字典的常用操作"></a>3.字典的常用操作</h2><p><strong>字典的操作围绕「键值对的增、删、改、查」展开，提供了丰富的内置方法，核心操作包括访问值、添加&#x2F;修改键值对、删除键值对、遍历字典等。</strong></p>
<h3 id="（1）键值对“增加操作”（含“更新操作”）"><a href="#（1）键值对“增加操作”（含“更新操作”）" class="headerlink" title="（1）键值对“增加操作”（含“更新操作”）"></a>（1）键值对“增加操作”（含“更新操作”）</h3><p><strong>字典的增加操作核心是向字典中添加新的键值对，常用方式有3种，根据场景灵活选择：</strong></p>
<ul>
<li><strong>直接赋值（最常用）</strong>：通过 字典[新键] &#x3D; 新值 的形式添加，<strong>若键不存在则新增，若键已存在则覆盖原有值</strong>；</li>
<li><strong>setdefault() 方法</strong>：添加键值对，<strong>若键已存在则返回原有值（不覆盖），若键不存在则添加并返回默认值（如果不设置默认值，则返回None）</strong>；</li>
<li><strong>update() 方法</strong>：批量添加键值对，支持<strong>传入字典</strong>或<strong>键值对参数</strong>,<strong>若键不存在则新增，若键已存在则覆盖原有值</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 直接赋值（新增键值对）</span></span><br><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;</span><br><span class="line">dict1[<span class="string">&quot;score&quot;</span>] = <span class="number">95.5</span>  <span class="comment"># 键&quot;score&quot;不存在，新增</span></span><br><span class="line">dict1[<span class="string">&quot;gender&quot;</span>] = <span class="string">&quot;男&quot;</span>  <span class="comment"># 键&quot;gender&quot;不存在，新增</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 20, &#x27;score&#x27;: 95.5, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：键已存在时会覆盖</span></span><br><span class="line">dict1[<span class="string">&quot;age&quot;</span>] = <span class="number">21</span>  <span class="comment"># 键&quot;age&quot;已存在，覆盖原有值</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 21, &#x27;score&#x27;: 95.5, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. setdefault() 方法（新增不覆盖）</span></span><br><span class="line">dict2 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>&#125;</span><br><span class="line"><span class="comment"># 键不存在，新增并返回默认值</span></span><br><span class="line">hobby = dict2.setdefault(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;画画&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(hobby)  <span class="comment"># 画画</span></span><br><span class="line"><span class="built_in">print</span>(dict2)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小红&#x27;, &#x27;age&#x27;: 19, &#x27;hobby&#x27;: &#x27;画画&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键不存在，且不设置默认值，返回None</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line">result = d.setdefault(<span class="string">&quot;key&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(d)       <span class="comment"># &#123;&#x27;key&#x27;: None&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键已存在，返回原有值，不覆盖</span></span><br><span class="line">age = dict2.setdefault(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(age)  <span class="comment"># 19</span></span><br><span class="line"><span class="built_in">print</span>(dict2)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小红&#x27;, &#x27;age&#x27;: 19, &#x27;hobby&#x27;: &#x27;画画&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. update() 方法（批量新增）</span></span><br><span class="line">dict3 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小刚&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">22</span>&#125;</span><br><span class="line"><span class="comment"># 传入字典批量新增</span></span><br><span class="line">dict3.update(&#123;<span class="string">&quot;score&quot;</span>: <span class="number">88.0</span>, <span class="string">&quot;address&quot;</span>: <span class="string">&quot;北京&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(dict3)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小刚&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 88.0, &#x27;address&#x27;: &#x27;北京&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入键值对参数批量新增</span></span><br><span class="line">dict3.update(gender=<span class="string">&quot;男&quot;</span>, hobby=<span class="string">&quot;篮球&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dict3)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小刚&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 88.0, &#x27;address&#x27;: &#x27;北京&#x27;, &#x27;gender&#x27;: &#x27;男&#x27;, &#x27;hobby&#x27;: &#x27;篮球&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）访问字典的值（3种常用方式）"><a href="#（2）访问字典的值（3种常用方式）" class="headerlink" title="（2）访问字典的值（3种常用方式）"></a>（2）访问字典的值（3种常用方式）</h3><ul>
<li><strong>方括号 [] 访问</strong>：直接通过键访问，键不存在则报错（KeyError）</li>
<li><strong>get() 方法访问</strong>：键不存在时返回默认值（默认 None，可手动指定），不会报错（<strong>推荐使用</strong>）</li>
<li><strong>values() 方法</strong>：获取所有值组成的可迭代对象（视图对象），可用于转为列表等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;score&quot;</span>: <span class="number">95.5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 方括号 [] 访问</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 小明</span></span><br><span class="line"><span class="comment"># print(dict1[&quot;gender&quot;])  # KeyError: &#x27;gender&#x27;（键不存在报错）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. get() 方法访问（推荐）</span></span><br><span class="line"><span class="built_in">print</span>(dict1.get(<span class="string">&quot;age&quot;</span>))  <span class="comment"># 20</span></span><br><span class="line"><span class="built_in">print</span>(dict1.get(<span class="string">&quot;gender&quot;</span>))  <span class="comment"># None（键不存在，返回默认值）</span></span><br><span class="line"><span class="built_in">print</span>(dict1.get(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;未知&quot;</span>))  <span class="comment"># 未知（指定默认值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. values() 方法（获取所有值）</span></span><br><span class="line">values = dict1.values()</span><br><span class="line"><span class="built_in">print</span>(values)  <span class="comment"># dict_values([&#x27;小明&#x27;, 20, 95.5])（视图对象）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(values))  <span class="comment"># [&#x27;小明&#x27;, 20, 95.5]（转为列表）</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）“获取、判断”字典的键"><a href="#（3）“获取、判断”字典的键" class="headerlink" title="（3）“获取、判断”字典的键"></a>（3）“获取、判断”字典的键</h3><ul>
<li><strong>keys() 方法</strong>：获取所有键组成的可迭代对象（视图对象）,可用于转为列表等</li>
<li><strong>items() 方法</strong>：获取所有键值对组成的可迭代对象（<strong>每个元素是 (key, value) 元组</strong>）</li>
<li><strong>in &#x2F; not in</strong>：判断键是否存在于字典中（<strong>判断的是键，不是值</strong>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;score&quot;</span>: <span class="number">95.5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. keys() 方法（获取所有键）</span></span><br><span class="line">keys = dict1.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)  <span class="comment"># dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;score&#x27;])（视图对象）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(keys))  <span class="comment"># [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;score&#x27;]（转为列表）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. items() 方法（获取所有键值对）</span></span><br><span class="line">items = dict1.items()</span><br><span class="line"><span class="built_in">print</span>(items)  <span class="comment"># dict_items([(&#x27;name&#x27;, &#x27;小明&#x27;), (&#x27;age&#x27;, 20)])（视图对象）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(items))  <span class="comment"># [(&#x27;name&#x27;, &#x27;小明&#x27;), (&#x27;age&#x27;, 20)]（转为列表）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 成员判断（in / not in）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> dict1)  <span class="comment"># True（键存在）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gender&quot;</span> <span class="keyword">in</span> dict1)  <span class="comment"># False（键不存在）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小明&quot;</span> <span class="keyword">in</span> dict1)  <span class="comment"># False（判断的是键，不是值）</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）删除键值对（4种常用方式）"><a href="#（4）删除键值对（4种常用方式）" class="headerlink" title="（4）删除键值对（4种常用方式）"></a>（4）删除键值对（4种常用方式）</h3><ul>
<li><strong>del 语句</strong>：通过键删除指定键值对，键不存在则报错</li>
<li><strong>pop() 方法</strong>：删除指定键的键值对，并返回对应的值，键不存在可指定默认值</li>
<li><strong>popitem() 方法</strong>：删除并返回最后插入的键值对（元组形式），空字典调用报错</li>
<li><strong>clear() 方法</strong>：清空字典中所有键值对，返回空字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;score&quot;</span>: <span class="number">95.5</span>, <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. del 语句</span></span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&quot;gender&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 20, &#x27;score&#x27;: 95.5&#125;</span></span><br><span class="line"><span class="comment"># del dict1[&quot;address&quot;]  # KeyError: &#x27;address&#x27;（键不存在报错）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. pop() 方法</span></span><br><span class="line">score = dict1.pop(<span class="string">&quot;score&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(score)  <span class="comment"># 95.5（返回删除的值）</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br><span class="line"><span class="comment"># 键不存在时指定默认值</span></span><br><span class="line">address = dict1.pop(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;未知&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(address)  <span class="comment"># 未知</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. popitem() 方法（删除最后插入的键值对）</span></span><br><span class="line">item = dict1.popitem()</span><br><span class="line"><span class="built_in">print</span>(item)  <span class="comment"># (&#x27;age&#x27;, 20)（返回删除的键值对元组）</span></span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;小明&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. clear() 方法（清空字典）</span></span><br><span class="line">dict1.clear()</span><br><span class="line"><span class="built_in">print</span>(dict1)  <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）字典的遍历（3种核心场景）"><a href="#（5）字典的遍历（3种核心场景）" class="headerlink" title="（5）字典的遍历（3种核心场景）"></a>（5）字典的遍历（3种核心场景）</h3><p><strong>核心逻辑：字典默认遍历的是键，通过 keys()、values()、items() 方法可分别获取“键”、“值”、“键值对”的可迭代对象（视图对象），进而实现针对性遍历。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;score&quot;</span>: <span class="number">95.5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 遍历键（最常用，默认遍历键）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;遍历键：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1:</span><br><span class="line">    <span class="built_in">print</span>(key)  <span class="comment"># name、age、score</span></span><br><span class="line"><span class="comment"># 等价于：for key in dict1.keys():</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 遍历值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n遍历值：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 小明、20、95.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 遍历键值对（最实用，通过 items() 方法）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n遍历键值对：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># name: 小明</span></span><br><span class="line"><span class="comment"># age: 20</span></span><br><span class="line"><span class="comment"># score: 95.5</span></span><br></pre></td></tr></table></figure>

<h3 id="补充：视图对象"><a href="#补充：视图对象" class="headerlink" title="补充：视图对象"></a>补充：视图对象</h3><h4 id="视图对象的核心定义"><a href="#视图对象的核心定义" class="headerlink" title="&lt;1&gt;视图对象的核心定义"></a>&lt;1&gt;视图对象的核心定义</h4><p><strong>视图对象是通过字典的 keys()、values()、items() 方法返回的对象（分别对应「键视图」「值视图」「键值对视图」），特点是：</strong></p>
<ul>
<li><strong>动态关联</strong>：视图对象<strong>不存储数据</strong>，而是实时映射原字典的内容 —— <strong>原字典修改后，视图对象会立即反映出变化</strong>；</li>
<li><strong>不可修改</strong>：视图对象本身不能直接增删改（比如不能给 dict.keys() 返回的对象加元素），但可通过原字典修改，视图会同步；</li>
<li><strong>可迭代</strong>：可以用 for 循环遍历，也支持部分集合操作（如判断元素是否存在）。</li>
</ul>
<h4 id="三类视图对象及基础用法"><a href="#三类视图对象及基础用法" class="headerlink" title="&lt;2&gt;三类视图对象及基础用法"></a>&lt;2&gt;三类视图对象及基础用法</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110102612554.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化字典</span></span><br><span class="line">student = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;北京&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 键视图（dict_keys）</span></span><br><span class="line">key_view = student.keys()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;键视图对象：&quot;</span>, key_view)  <span class="comment"># 键视图对象： dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;遍历键视图：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> key_view:</span><br><span class="line">    <span class="built_in">print</span>(k, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 遍历键视图： name age city</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 值视图（dict_values）</span></span><br><span class="line">value_view = student.values()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;值视图对象：&quot;</span>, value_view)  <span class="comment"># 值视图对象： dict_values([&#x27;张三&#x27;, 25, &#x27;北京&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 键值对视图（dict_items）</span></span><br><span class="line">item_view = student.items()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;键值对视图对象：&quot;</span>, item_view)  <span class="comment"># 键值对视图对象： dict_items([(&#x27;name&#x27;, &#x27;张三&#x27;), (&#x27;age&#x27;, 25), (&#x27;city&#x27;, &#x27;北京&#x27;)])</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> item_view:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;v&#125;</span>&quot;</span>)  <span class="comment"># 逐行输出 name: 张三 / age:25 / city:北京</span></span><br></pre></td></tr></table></figure>

<h4 id="视图对象的核心特性（重点）"><a href="#视图对象的核心特性（重点）" class="headerlink" title="&lt;3&gt;视图对象的核心特性（重点）"></a>&lt;3&gt;视图对象的核心特性（重点）</h4><h5 id="特性1：动态关联原字典（最核心）"><a href="#特性1：动态关联原字典（最核心）" class="headerlink" title="特性1：动态关联原字典（最核心）"></a>特性1：动态关联原字典（最核心）</h5><p><strong>视图对象不复制数据，原字典修改后，视图会实时更新，这是和列表最大的区别</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化字典</span></span><br><span class="line">student = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;北京&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键视图（dict_keys）</span></span><br><span class="line">key_view = student.keys()</span><br><span class="line"><span class="comment"># 值视图（dict_values）</span></span><br><span class="line">value_view = student.values()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改前值视图：&quot;</span>, value_view)  <span class="comment"># 修改前值视图： dict_values([&#x27;张三&#x27;, 25, &#x27;北京&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改原字典的内容</span></span><br><span class="line">student[<span class="string">&quot;age&quot;</span>] = <span class="number">26</span>  <span class="comment"># 覆盖已有值</span></span><br><span class="line">student[<span class="string">&quot;gender&quot;</span>] = <span class="string">&quot;男&quot;</span>  <span class="comment"># 新增键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图对象自动同步变化（无需重新获取）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后值视图：&quot;</span>, value_view)  <span class="comment"># 修改后值视图： dict_values([&#x27;张三&#x27;, 26, &#x27;北京&#x27;, &#x27;男&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后键视图：&quot;</span>, key_view)    <span class="comment"># 修改后键视图： dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;, &#x27;gender&#x27;])</span></span><br></pre></td></tr></table></figure>
<h5 id="特性2：不可直接修改，但可判断元素是否存在"><a href="#特性2：不可直接修改，但可判断元素是否存在" class="headerlink" title="特性2：不可直接修改，但可判断元素是否存在"></a>特性2：不可直接修改，但可判断元素是否存在</h5><p><strong>图对象本身不能增删改，但若想修改内容，需操作原字典；同时支持 in 操作判断元素是否存在</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化字典</span></span><br><span class="line">student = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;北京&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键视图（dict_keys）</span></span><br><span class="line">key_view = student.keys()</span><br><span class="line"><span class="comment"># 值视图（dict_values）</span></span><br><span class="line">value_view = student.values()</span><br><span class="line"><span class="comment"># 键值对视图（dict_items）</span></span><br><span class="line">item_view = student.items()</span><br><span class="line"><span class="comment"># 1. 判断元素是否存在（支持）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> key_view)  <span class="comment"># True（键视图判断键是否存在）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">25</span> <span class="keyword">in</span> value_view)    <span class="comment"># True（值视图判断值是否存在）</span></span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;age&#x27;</span>, <span class="number">25</span>) <span class="keyword">in</span> item_view)  <span class="comment"># True（键值对视图判断键值对是否存在）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 尝试直接修改视图（报错）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    key_view.append(<span class="string">&quot;hobby&quot;</span>)  <span class="comment"># 视图对象无append方法</span></span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;报错：&quot;</span>, e)  <span class="comment"># 报错： &#x27;dict_keys&#x27; object has no attribute &#x27;append&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 正确修改方式：操作原字典，视图自动同步</span></span><br><span class="line">student[<span class="string">&quot;hobby&quot;</span>] = <span class="string">&quot;篮球&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;新增hobby后键视图：&quot;</span>, key_view)  <span class="comment"># 修改后键视图： dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;, &#x27;gender&#x27;,&#x27;hobby&#x27;])</span></span><br></pre></td></tr></table></figure>

<h5 id="特性3：可转为列表-集合（按需复制数据）"><a href="#特性3：可转为列表-集合（按需复制数据）" class="headerlink" title="特性3：可转为列表&#x2F;集合（按需复制数据）"></a>特性3：可转为列表&#x2F;集合（按需复制数据）</h5><p><strong>若需要对“键&#x2F;值&#x2F;键值对”做增删改、切片等操作，可将视图对象转为列表&#x2F;集合（此时会复制数据，不再关联原字典）：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 视图转列表（复制数据，后续修改列表不影响原字典）</span></span><br><span class="line">key_list = <span class="built_in">list</span>(key_view)</span><br><span class="line">key_list.append(<span class="string">&quot;score&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表新增元素：&quot;</span>, key_list)  <span class="comment"># [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;, &#x27;gender&#x27;, &#x27;hobby&#x27;, &#x27;score&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原字典键视图：&quot;</span>, key_view)  <span class="comment"># 仍为 [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;, &#x27;gender&#x27;, &#x27;hobby&#x27;]（无score）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图转集合（支持集合运算）</span></span><br><span class="line">value_set = <span class="built_in">set</span>(value_view)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;值集合：&quot;</span>, value_set)  <span class="comment"># &#123;&#x27;张三&#x27;, 26, &#x27;北京&#x27;, &#x27;男&#x27;, &#x27;篮球&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-字典的常用内置函数与方法"><a href="#4-字典的常用内置函数与方法" class="headerlink" title="4.字典的常用内置函数与方法"></a>4.字典的常用内置函数与方法</h2><h3 id="（1）内置函数（全局函数，直接调用）-2"><a href="#（1）内置函数（全局函数，直接调用）-2" class="headerlink" title="（1）内置函数（全局函数，直接调用）"></a>（1）内置函数（全局函数，直接调用）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110103442591.png"></p>
<h3 id="（2）字典对象方法（d-方法名-）"><a href="#（2）字典对象方法（d-方法名-）" class="headerlink" title="（2）字典对象方法（d.方法名()）"></a>（2）字典对象方法（d.方法名()）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110103756223.png"></p>
<h2 id="5-字典与元组、列表的核心区别"><a href="#5-字典与元组、列表的核心区别" class="headerlink" title="5.字典与元组、列表的核心区别"></a>5.字典与元组、列表的核心区别</h2><p><strong>字典、元组、列表是 Python 中最常用的三种容器类型，核心差异在于「数据组织方式」和「可变性」，适用场景完全不同。以下是详细对比：</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110104027376.png"></p>
<h2 id="6-字典的关键注意事项"><a href="#6-字典的关键注意事项" class="headerlink" title="6.字典的关键注意事项"></a>6.字典的关键注意事项</h2><ul>
<li><strong>键的选择原则</strong><ul>
<li>优先使用字符串作为键（语义清晰，通用性强）</li>
<li>避免使用复杂不可变对象（如嵌套元组）</li>
<li><strong>键必须唯一，重复键会覆盖前面的值</strong></li>
</ul>
</li>
<li><strong>访问值的推荐方式</strong><ul>
<li>优先使用 get() 方法访问值，而非方括号 []，可避免键不存在时的 KeyError 报错，提升代码稳定性。</li>
</ul>
</li>
<li><strong>字典的浅拷贝与深拷贝</strong><ul>
<li><strong>浅拷贝</strong>（d.copy()、dict(d)）：仅复制字典本身，值为引用（若值是可变对象，修改原字典的值会影响拷贝后的字典）；</li>
<li><strong>深拷贝</strong>（需导入 copy 模块，copy.deepcopy(d)）：完全复制字典及所有值对象，原字典与拷贝字典相互独立。</li>
</ul>
</li>
<li><strong>避免在遍历字典时修改结构</strong><ul>
<li>遍历字典（如 for key in d）时，<strong>禁止直接添加&#x2F;删除键值对（会导致遍历异常）</strong></li>
<li>若需修改，可先遍历字典的键列表（for key in list(d.keys())）</li>
</ul>
</li>
<li><strong>空字典的判断</strong><ul>
<li>判断字典是否为空，<strong>优先使用 if not d:（简洁高效）</strong>，而非 if len(d) &#x3D;&#x3D; 0:</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 浅拷贝 vs 深拷贝示例</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">d1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;hobbies&quot;</span>: [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;游戏&quot;</span>]&#125;</span><br><span class="line">d2 = d1.copy()  <span class="comment"># 浅拷贝</span></span><br><span class="line">d3 = copy.deepcopy(d1)  <span class="comment"># 深拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改原字典的可变值（hobbies列表）</span></span><br><span class="line">d1[<span class="string">&quot;hobbies&quot;</span>].append(<span class="string">&quot;读书&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d2[<span class="string">&quot;hobbies&quot;</span>])  <span class="comment"># [&#x27;篮球&#x27;, &#x27;游戏&#x27;, &#x27;读书&#x27;]（浅拷贝受影响）</span></span><br><span class="line"><span class="built_in">print</span>(d3[<span class="string">&quot;hobbies&quot;</span>])  <span class="comment"># [&#x27;篮球&#x27;, &#x27;游戏&#x27;]（深拷贝不受影响）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 遍历字典时修改结构（正确做法）</span></span><br><span class="line">d4 = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>, <span class="string">&quot;c&quot;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 错误：直接遍历字典时删除键</span></span><br><span class="line"><span class="comment"># for key in d4:</span></span><br><span class="line"><span class="comment">#     del d4[key]  # RuntimeError: dictionary changed size during iteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：遍历键列表</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">list</span>(d4.keys()):</span><br><span class="line">    <span class="keyword">del</span> d4[key]</span><br><span class="line"><span class="built_in">print</span>(d4)  <span class="comment"># &#123;&#125;（正常清空）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 空字典判断</span></span><br><span class="line">d5 = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> d5:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字典为空&quot;</span>)  <span class="comment"># 输出：字典为空</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="五、分支结构（if、match-case）"><a href="#五、分支结构（if、match-case）" class="headerlink" title="五、分支结构（if、match-case）"></a>五、分支结构（if、match-case）</h1><h2 id="1-if-语句：灵活适配复杂条件的基础分支"><a href="#1-if-语句：灵活适配复杂条件的基础分支" class="headerlink" title="1.if 语句：灵活适配复杂条件的基础分支"></a>1.if 语句：灵活适配复杂条件的基础分支</h2><ul>
<li><strong>if 语句是 Python 中最基础、最常用的分支结构，核心逻辑是「判断条件表达式的布尔值（True&#x2F;False），执行对应代码块」。</strong></li>
<li><strong>支持单分支、双分支、多分支三种形式，可灵活应对从简单到复杂的各类条件判断场景。</strong></li>
</ul>
<h3 id="（1）核心语法与结构（有基础的可跳过这节）"><a href="#（1）核心语法与结构（有基础的可跳过这节）" class="headerlink" title="（1）核心语法与结构（有基础的可跳过这节）"></a>（1）核心语法与结构（有基础的可跳过这节）</h3><p><strong>Python 中 if 语句的语法核心是「条件表达式 + 缩进代码块」，缩进（通常 4 个空格）是区分代码块归属的关键（无大括号 {} 包裹）。</strong></p>
<h4 id="单分支：满足条件才执行"><a href="#单分支：满足条件才执行" class="headerlink" title="&lt;1&gt;单分支：满足条件才执行"></a>&lt;1&gt;单分支：满足条件才执行</h4><p><strong>适用场景：仅需在某个条件成立时执行一段代码，不成立则跳过</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法结构</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式:</span><br><span class="line">    缩进的代码块  <span class="comment"># 条件为 True 时执行，False 则跳过</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实战示例：判断数值是否为正数</span></span><br><span class="line">num = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> 是正数&quot;</span>)  <span class="comment"># 输出：15 是正数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件不成立时的情况</span></span><br><span class="line">num = -<span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> 是正数&quot;</span>)  <span class="comment"># 无输出（条件为 False，代码块跳过）</span></span><br></pre></td></tr></table></figure>

<h4 id="双分支：非此即彼的二选一"><a href="#双分支：非此即彼的二选一" class="headerlink" title="&lt;2&gt;双分支：非此即彼的二选一"></a>&lt;2&gt;双分支：非此即彼的二选一</h4><p><strong>适用场景：存在两种互斥条件，无论哪种情况都需执行对应代码（必走一个分支）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法结构</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式:</span><br><span class="line">    代码块<span class="number">1</span>  <span class="comment"># 条件为 True 时执行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码块<span class="number">2</span>  <span class="comment"># 条件为 False 时执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实战示例：判断成绩是否合格</span></span><br><span class="line">score = <span class="number">75</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成绩合格，顺利通过&quot;</span>)  <span class="comment"># 输出：成绩合格，顺利通过</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成绩不合格，需补考&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="三元表达式：双分支的简洁写法"><a href="#三元表达式：双分支的简洁写法" class="headerlink" title="&lt;3&gt;三元表达式：双分支的简洁写法"></a>&lt;3&gt;三元表达式：双分支的简洁写法</h4><ul>
<li><strong>三元表达式是 if-else 双分支的简化形式，适用于两个分支均只有单条语句、且目的是返回一个值的场景</strong></li>
<li><strong>它能让代码更简洁紧凑，但复杂逻辑下不建议使用（会降低可读性）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 核心语法</span></span><br><span class="line">结果变量 = 表达式<span class="number">1</span> <span class="keyword">if</span> 条件表达式 <span class="keyword">else</span> 表达式<span class="number">2</span></span><br><span class="line"><span class="comment"># 逻辑：条件表达式为 True 时，结果变量 = 表达式1；否则 = 表达式2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础示例：判断成绩合格与否</span></span><br><span class="line">score = <span class="number">75</span></span><br><span class="line">result = <span class="string">&quot;合格&quot;</span> <span class="keyword">if</span> score &gt;= <span class="number">60</span> <span class="keyword">else</span> <span class="string">&quot;不合格&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成绩等级：<span class="subst">&#123;result&#125;</span>&quot;</span>)  <span class="comment"># 输出：成绩等级：合格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比普通 if-else（功能等价，三元表达式更简洁）</span></span><br><span class="line">score = <span class="number">75</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    result = <span class="string">&quot;合格&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = <span class="string">&quot;不合格&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成绩等级：<span class="subst">&#123;result&#125;</span>&quot;</span>)  <span class="comment"># 输出：成绩等级：合格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶示例：用于简单计算</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">max_num = a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;较大值：<span class="subst">&#123;max_num&#125;</span>&quot;</span>)  <span class="comment"># 输出：较大值：20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：三元表达式支持嵌套，但不推荐（可读性差）</span></span><br><span class="line"><span class="comment"># 嵌套示例：判断分数等级（及格/良好/优秀简化版）</span></span><br><span class="line">score = <span class="number">88</span></span><br><span class="line">level = <span class="string">&quot;优秀&quot;</span> <span class="keyword">if</span> score &gt;= <span class="number">90</span> <span class="keyword">else</span> (<span class="string">&quot;良好&quot;</span> <span class="keyword">if</span> score &gt;= <span class="number">80</span> <span class="keyword">else</span> <span class="string">&quot;及格&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成绩等级：<span class="subst">&#123;level&#125;</span>&quot;</span>)  <span class="comment"># 输出：成绩等级：良好</span></span><br></pre></td></tr></table></figure>

<h4 id="多分支：按顺序匹配多个条件"><a href="#多分支：按顺序匹配多个条件" class="headerlink" title="&lt;4&gt;多分支：按顺序匹配多个条件"></a>&lt;4&gt;多分支：按顺序匹配多个条件</h4><p><strong>适用场景：存在多个递进条件，按顺序判断，匹配到第一个成立的条件后执行对应代码，后续条件不再判断（避免重复执行）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法结构</span></span><br><span class="line"><span class="keyword">if</span> 条件表达式<span class="number">1</span>:</span><br><span class="line">    代码块<span class="number">1</span>  <span class="comment"># 条件1为 True 时执行</span></span><br><span class="line"><span class="keyword">elif</span> 条件表达式<span class="number">2</span>:  <span class="comment"># 可添加多个 elif（else if 的缩写）</span></span><br><span class="line">    代码块<span class="number">2</span>  <span class="comment"># 条件2为 True 时执行</span></span><br><span class="line"><span class="keyword">elif</span> 条件表达式<span class="number">3</span>:</span><br><span class="line">    代码块<span class="number">3</span>  <span class="comment"># 条件3为 True 时执行</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 可选，所有条件都不成立时执行</span></span><br><span class="line">    代码块n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实战示例：根据分数划分等级</span></span><br><span class="line">score = <span class="number">88</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：优秀&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：良好&quot;</span>)  <span class="comment"># 输出：等级：良好（第一个匹配的条件）</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：及格&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：不及格&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：多分支的条件顺序不可随意调换</span></span><br><span class="line"><span class="comment"># 错误示例：若先判断 score &gt;=60，会导致 88 直接匹配到及格，后续条件失效</span></span><br><span class="line">score = <span class="number">88</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：及格&quot;</span>)  <span class="comment"># 错误输出：等级：及格</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：良好&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：优秀&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）条件表达式的合法形式"><a href="#（2）条件表达式的合法形式" class="headerlink" title="（2）条件表达式的合法形式"></a>（2）条件表达式的合法形式</h3><p><strong>if 语句的条件表达式最终需返回布尔值（True&#x2F;False），常见合法形式包括：</strong></p>
<ul>
<li><strong>直接布尔值</strong>：True&#x2F;False 直接作为条件</li>
<li><strong>比较运算</strong>：&#x3D;&#x3D;（等于）、!&#x3D;（不等于）、&gt;（大于）、&lt;（小于）、&gt;&#x3D;（大于等于）、&lt;&#x3D;（小于等于）</li>
<li><strong>逻辑运算</strong><ul>
<li><strong>and（与）</strong>：所有条件都成立才为 True</li>
<li><strong>or （或）</strong>：任意一个条件成立即为 True</li>
<li><strong>not（非）</strong>：取反）</li>
</ul>
</li>
<li><strong>成员判断</strong><ul>
<li><strong>in</strong>：元素在容器中</li>
<li><strong>not in</strong>：元素不在容器中</li>
</ul>
</li>
<li><strong>身份判断</strong><ul>
<li><strong>is</strong>：两个对象是同一内存地址</li>
<li><strong>is not</strong>：两个对象不是同一内存地址</li>
</ul>
</li>
<li><strong>对象（自动转为bool值）</strong><ul>
<li><strong>数字</strong>：0 为 False，非 0 为 True</li>
<li><strong>字符串</strong>：空字符串为 False，非空为 True</li>
<li><strong>容器</strong>：空列表&#x2F;字典&#x2F;元组为 False，非空为 True</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 比较运算 + 逻辑运算</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> <span class="keyword">and</span> age &lt;= <span class="number">30</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;青年&quot;</span>)  <span class="comment"># 输出：青年</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 成员判断</span></span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;banana&quot;</span> <span class="keyword">in</span> fruits:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;包含香蕉&quot;</span>)  <span class="comment"># 输出：包含香蕉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 身份判断（判断是否为 None）</span></span><br><span class="line">obj = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对象为空&quot;</span>)  <span class="comment"># 输出：对象为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 自动转换为布尔值的对象</span></span><br><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">if</span> s:  <span class="comment"># 非空字符串 → True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字符串非空&quot;</span>)  <span class="comment"># 输出：字符串非空</span></span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> lst:  <span class="comment"># 空列表 → False，not 取反为 True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;列表为空&quot;</span>)  <span class="comment"># 输出：列表为空</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）if-语句的避坑要点"><a href="#（3）if-语句的避坑要点" class="headerlink" title="（3）if 语句的避坑要点"></a>（3）if 语句的避坑要点</h3><ul>
<li><strong>缩进错误是致命问题</strong><ul>
<li>代码块必须缩进（4 个空格），且同一级代码块缩进一致；</li>
<li>若忘记缩进或缩进混乱，会报 IndentationError 错误；</li>
</ul>
</li>
<li><strong>不要混淆 &#x3D;&#x3D; 和 is</strong><ul>
<li><strong>&#x3D;&#x3D;</strong>： 判断值是否相等</li>
<li><strong>is</strong>：判断内存地址是否相同</li>
<li>通常判断值用 &#x3D;&#x3D;，判断是否为 None 用 is</li>
</ul>
</li>
<li><strong>多分支条件需按「从严格到宽松」排序</strong><ul>
<li>如划分成绩等级时，需先判断高分段（90+），再判断低分段（80+），否则会出现逻辑错误</li>
</ul>
</li>
<li><strong>避免冗余条件</strong>：<ul>
<li>多分支中，后续条件默认是「前面条件不成立」的前提下判断，无需重复添加前面的条件（如无需写 if score &gt;&#x3D;80 and score &lt;90）</li>
</ul>
</li>
</ul>
<h2 id="2-case分支（Python-3-10-新增的模式匹配）"><a href="#2-case分支（Python-3-10-新增的模式匹配）" class="headerlink" title="2.case分支（Python 3.10+ 新增的模式匹配）"></a>2.case分支（Python 3.10+ 新增的模式匹配）</h2><h3 id="（1）核心语法与结构"><a href="#（1）核心语法与结构" class="headerlink" title="（1）核心语法与结构"></a>（1）核心语法与结构</h3><p><strong>match-case 的语法核心是「匹配表达式 + 多个 case 模式 + 代码块」，每个 case 对应一种匹配规则，最后可通过通配符 _ 匹配所有未命中的情况。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础语法结构</span></span><br><span class="line"><span class="keyword">match</span> 匹配表达式:  <span class="comment"># 需匹配的值/表达式（如变量、函数返回值）</span></span><br><span class="line">    <span class="keyword">case</span> 模式<span class="number">1</span>:  <span class="comment"># 第一个匹配模式</span></span><br><span class="line">        代码块<span class="number">1</span>  <span class="comment"># 匹配成功则执行，执行后自动终止（无需 break）</span></span><br><span class="line">    <span class="keyword">case</span> 模式<span class="number">2</span>:  <span class="comment"># 第二个匹配模式</span></span><br><span class="line">        代码块<span class="number">2</span>  <span class="comment"># 模式1不匹配时，判断模式2</span></span><br><span class="line">    <span class="keyword">case</span> 模式<span class="number">3</span> | 模式<span class="number">4</span>:  <span class="comment"># 多模式匹配（用 | 分隔，满足一个即可）</span></span><br><span class="line">        代码块<span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> _:  <span class="comment"># 通配符，匹配所有未匹配的情况（类似 else，可选）</span></span><br><span class="line">        代码块n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最简单示例：精准匹配值</span></span><br><span class="line">day = <span class="number">3</span></span><br><span class="line"><span class="keyword">match</span> day:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;星期一&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;星期二&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;星期三&quot;</span>)  <span class="comment"># 输出：星期三</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> | <span class="number">5</span>:  <span class="comment"># 多模式匹配：4 或 5</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工作日&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> | <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;周末&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无效的日期&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）常用匹配模式（核心重点）"><a href="#（2）常用匹配模式（核心重点）" class="headerlink" title="（2）常用匹配模式（核心重点）"></a>（2）常用匹配模式（核心重点）</h3><p><strong>match-case 的强大之处在于支持多种灵活的模式，而非仅能匹配固定值，以下是最常用的 6 种模式：</strong></p>
<h4 id="字面量模式：精准匹配固定值"><a href="#字面量模式：精准匹配固定值" class="headerlink" title="&lt;1&gt;字面量模式：精准匹配固定值"></a>&lt;1&gt;字面量模式：精准匹配固定值</h4><p><strong>匹配表达式的值与 case 后的字面量（字符串、整数、布尔值等）完全相等时命中，是最基础的模式。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配字符串</span></span><br><span class="line">fruit = <span class="string">&quot;apple&quot;</span></span><br><span class="line"><span class="keyword">match</span> fruit:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;苹果，单价 5 元/斤&quot;</span>)  <span class="comment"># 输出：苹果，单价 5 元/斤</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;banana&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;香蕉，单价 3 元/斤&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;orange&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;橙子，单价 4 元/斤&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;未知水果&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配布尔值（注意：True/False 是字面量，0/1 不匹配）</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">match</span> flag:</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;条件成立&quot;</span>)  <span class="comment"># 输出：条件成立</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;条件不成立&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="变量模式：匹配任意值并绑定到变量"><a href="#变量模式：匹配任意值并绑定到变量" class="headerlink" title="&lt;2&gt;变量模式：匹配任意值并绑定到变量"></a>&lt;2&gt;变量模式：匹配任意值并绑定到变量</h4><p><strong>case 后跟变量名时，会匹配任意值，并将匹配表达式的值绑定到该变量（类似赋值），常用于接收不确定的值。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量模式匹配任意值</span></span><br><span class="line">user_input = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">match</span> user_input:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;退出程序&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> msg:  <span class="comment"># 匹配任意值，绑定到 msg 变量</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;你输入的内容：<span class="subst">&#123;msg&#125;</span>&quot;</span>)  <span class="comment"># 输出：你输入的内容：hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合多模式使用</span></span><br><span class="line">num = <span class="number">7</span></span><br><span class="line"><span class="keyword">match</span> num:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> | <span class="number">3</span> | <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;奇数（1/3/5）&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> x:  <span class="comment"># 匹配其他所有值，绑定到 x</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;其他数字：<span class="subst">&#123;x&#125;</span>&quot;</span>)  <span class="comment"># 输出：其他数字：7</span></span><br></pre></td></tr></table></figure>

<h4 id="通配符模式：-匹配任意值但不绑定"><a href="#通配符模式：-匹配任意值但不绑定" class="headerlink" title="&lt;3&gt;通配符模式： _  匹配任意值但不绑定"></a>&lt;3&gt;通配符模式： _  匹配任意值但不绑定</h4><p><strong>_ 是特殊的通配符模式，可匹配任意值，但不会将值绑定到变量（即无法在代码块中使用该值），常用于「忽略无关值」或「兜底匹配」（类似 else）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 兜底匹配（类似 else）</span></span><br><span class="line">color = <span class="string">&quot;purple&quot;</span></span><br><span class="line"><span class="keyword">match</span> color:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;红色&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;green&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;绿色&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;蓝色&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:  <span class="comment"># 匹配所有未命中的情况</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;其他颜色&quot;</span>)  <span class="comment"># 输出：其他颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略无关值（仅关心特定位置的值）</span></span><br><span class="line">person = (<span class="string">&quot;小明&quot;</span>, <span class="number">22</span>, <span class="string">&quot;男&quot;</span>)  <span class="comment"># 元组：(姓名, 年龄, 性别)</span></span><br><span class="line"><span class="keyword">match</span> person:</span><br><span class="line">    <span class="keyword">case</span> (name, _, gender):  <span class="comment"># 忽略年龄（用 _ 匹配）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，性别：<span class="subst">&#123;gender&#125;</span>&quot;</span>)  <span class="comment"># 输出：姓名：小明，性别：男</span></span><br></pre></td></tr></table></figure>

<h4 id="结构模式：匹配容器（列表-元组-字典）的结构"><a href="#结构模式：匹配容器（列表-元组-字典）的结构" class="headerlink" title="&lt;4&gt;结构模式：匹配容器（列表&#x2F;元组&#x2F;字典）的结构"></a>&lt;4&gt;结构模式：匹配容器（列表&#x2F;元组&#x2F;字典）的结构</h4><p><strong>可精准匹配列表、元组、字典的「结构」（长度、元素位置、键名），并提取其中的元素，是 match-case 最强大的功能之一。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 匹配元组结构（固定长度、提取元素）</span></span><br><span class="line">point = (<span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 二维坐标：(x, y)</span></span><br><span class="line"><span class="keyword">match</span> point:</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;原点&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (x, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;在 x 轴上，x = <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;在 y 轴上，y = <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;在平面内，坐标 (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)  <span class="comment"># 输出：在平面内，坐标 (3, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 匹配列表结构（支持可变长度，用 * 表示剩余元素）</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">match</span> nums:</span><br><span class="line">    <span class="keyword">case</span> [<span class="number">1</span>, *rest]:  <span class="comment"># 以 1 开头，剩余元素绑定到 rest</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;以 1 开头，剩余元素：<span class="subst">&#123;rest&#125;</span>&quot;</span>)  <span class="comment"># 输出：以 1 开头，剩余元素：[2, 3, 4]</span></span><br><span class="line">    <span class="keyword">case</span> [a, b]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;两个元素：<span class="subst">&#123;a&#125;</span>, <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 匹配字典结构（匹配指定键，提取值,不需要完全匹配，可以是超集）</span></span><br><span class="line">user = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;score&quot;</span>: <span class="number">92</span>&#125;</span><br><span class="line"><span class="keyword">match</span> user:</span><br><span class="line">    <span class="keyword">case</span> &#123;<span class="string">&quot;name&quot;</span>: name, <span class="string">&quot;age&quot;</span>: age&#125;:  <span class="comment"># 匹配包含 name 和 age 键的字典，提取值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>)  <span class="comment"># 输出：姓名：小红，年龄：19</span></span><br><span class="line">    <span class="keyword">case</span> &#123;<span class="string">&quot;name&quot;</span>: name, <span class="string">&quot;score&quot;</span>: score&#125;:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，成绩：<span class="subst">&#123;score&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="类型模式：匹配指定数据类型"><a href="#类型模式：匹配指定数据类型" class="headerlink" title="&lt;5&gt;类型模式：匹配指定数据类型"></a>&lt;5&gt;类型模式：匹配指定数据类型</h4><p><strong>通过 “类型名()” 的形式匹配值的类型，可同时将值绑定到变量，适合「根据数据类型执行不同逻辑」的场景。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类型模式匹配</span></span><br><span class="line">data = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">match</span> data:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">int</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;整数类型：<span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">float</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;浮点数类型：<span class="subst">&#123;data&#125;</span>&quot;</span>)  <span class="comment"># 输出：浮点数类型：3.14</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">str</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;字符串类型：<span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">list</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;列表类型：<span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;未知类型&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型模式 + 绑定变量（更常用）</span></span><br><span class="line">data = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">match</span> data:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">int</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;整数：<span class="subst">&#123;n * <span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">str</span>(s):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;字符串：<span class="subst">&#123;s.upper()&#125;</span>&quot;</span>)  <span class="comment"># 输出：字符串：HELLO</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">float</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;浮点数：<span class="subst">&#123;num + <span class="number">1</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="守卫模式：在模式匹配的基础上添加额外条件"><a href="#守卫模式：在模式匹配的基础上添加额外条件" class="headerlink" title="&lt;6&gt;守卫模式：在模式匹配的基础上添加额外条件"></a>&lt;6&gt;守卫模式：在模式匹配的基础上添加额外条件</h4><p><strong>通过 “if 条件” 给模式添加额外限制，仅当「模式匹配成功」且「条件成立」时才执行代码块，弥补了纯模式匹配的灵活性不足。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 守卫模式（模式 + 额外条件）</span></span><br><span class="line">num = <span class="number">18</span></span><br><span class="line"><span class="keyword">match</span> num:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">int</span>(n) <span class="keyword">if</span> n &gt; <span class="number">18</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;大于 18 的整数：<span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">int</span>(n) <span class="keyword">if</span> n == <span class="number">18</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;等于 18 的整数：<span class="subst">&#123;n&#125;</span>&quot;</span>)  <span class="comment"># 输出：等于 18 的整数：18</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">int</span>(n) <span class="keyword">if</span> n &lt; <span class="number">18</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;小于 18 的整数：<span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合结构模式使用</span></span><br><span class="line">point = (<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">match</span> point:</span><br><span class="line">    <span class="keyword">case</span> (x, y) <span class="keyword">if</span> x == y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;在 y = x 直线上，坐标 (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)  <span class="comment"># 输出：在 y = x 直线上，坐标 (5, 5)</span></span><br><span class="line">    <span class="keyword">case</span> (x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;坐标 (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（3）case-分支的避坑要点"><a href="#（3）case-分支的避坑要点" class="headerlink" title="（3）case 分支的避坑要点"></a>（3）case 分支的避坑要点</h3><ul>
<li><p><strong>版本限制</strong></p>
<ul>
<li>match-case 仅支持 Python 3.10 及以上版本，低版本使用会报语法错误；</li>
</ul>
</li>
<li><p><strong>自动终止</strong></p>
<ul>
<li><strong>无需 break</strong>：与其他语言（如 Java）的 switch-case 不同，Python 的 match-case 匹配成功后会自动终止，无需添加 break</li>
<li><strong>需继续匹配后续模式</strong>：可使用 case … if False 等特殊技巧，<strong>但不推荐</strong>；</li>
</ul>
</li>
<li><p><strong>通配符 _ 的位置</strong></p>
<ul>
<li><strong>_</strong> ：是“兜底匹配”，需<strong>放在所有 case 的最后</strong>，否则会覆盖前面的模式（导致前面的模式无法命中）；</li>
</ul>
</li>
<li><p><strong>模式匹配的优先级</strong></p>
<ul>
<li>更<strong>具体的模式</strong>（如字面量模式、固定结构模式）应<strong>放在前面</strong>，更<strong>通用的模式</strong>（如变量模式、通配符）应<strong>放在后面</strong>；</li>
</ul>
</li>
<li><p><strong>字典模式的匹配规则</strong></p>
<ul>
<li>匹配字典时，仅要求字典包含 case 中指定的键即可（<strong>不要求键完全一致</strong>），会提取指定键的值；</li>
</ul>
</li>
<li><p><strong>避免过度使用</strong></p>
<ul>
<li>简单的条件判断（如单一比较）用 if 语句更直观</li>
<li>match-case 更适合多值精准匹配、结构匹配、类型匹配场景。</li>
</ul>
</li>
</ul>
<h3 id="（4）与其他语言switch的区别"><a href="#（4）与其他语言switch的区别" class="headerlink" title="（4）与其他语言switch的区别"></a>（4）与其他语言switch的区别</h3><ul>
<li>Python的match-case<strong>不需要break语句</strong>阻止继续执行（自动终止）</li>
<li>支持复杂的模式匹配而非仅支持常量值比较</li>
<li>可以直接从匹配中提取和绑定变量</li>
<li>支持结构解构和类型匹配</li>
</ul>
<hr>
<h1 id="六、while循环"><a href="#六、while循环" class="headerlink" title="六、while循环"></a>六、while循环</h1><h2 id="1-核心语法与基础机制"><a href="#1-核心语法与基础机制" class="headerlink" title="1.核心语法与基础机制"></a>1.核心语法与基础机制</h2><p><strong>while 循环的语法简洁，核心由「条件表达式」和「循环体」组成，通过条件的布尔值控制循环的启动与终止。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础语法</span></span><br><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">    缩进的循环体代码  <span class="comment"># 条件为 True 时执行</span></span><br><span class="line">    （可选但推荐）条件更新语句  <span class="comment"># 用于修改条件，避免无限循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空循环（仅占位/延迟，无实际逻辑）</span></span><br><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># pass 是占位符，代表“无操作”（用与暂时不需要实现，后续补充/扩展）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：基本循环（输出 1-5）</span></span><br><span class="line">num = <span class="number">1</span>  <span class="comment"># 初始化条件变量</span></span><br><span class="line"><span class="keyword">while</span> num &lt;= <span class="number">5</span>:  <span class="comment"># 条件：num 小于等于 5</span></span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># 循环体：输出 num，依次为 1、2、3、4、5</span></span><br><span class="line">    num += <span class="number">1</span>  <span class="comment"># 条件更新：num 自增 1（关键！避免无限循环）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：条件更新（延迟 3 秒，仅作演示）</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 暂停 1 秒</span></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;延迟 <span class="subst">&#123;count&#125;</span> 秒...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：纯占位空循环（代码框架搭建阶段）</span></span><br><span class="line"><span class="comment"># 作用：先定义循环结构，后续补充业务逻辑，避免语法错误</span></span><br><span class="line">empty_flag = <span class="literal">False</span>  <span class="comment"># 初始为False，循环不执行（仅占位）</span></span><br><span class="line"><span class="keyword">while</span> empty_flag:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># while 必须有循环体，若没有任何实现又不用 pass 占位，则会报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例4：无限循环占位（需配合break，否则会卡死）</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 循环体逻辑后续补充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例5：嵌套 while 循环（多层循环）</span></span><br><span class="line">row = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> row &lt;= <span class="number">3</span>:  <span class="comment"># 外层循环：控制行数</span></span><br><span class="line">    col = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> col &lt;= <span class="number">4</span>:  <span class="comment"># 内层循环：控制每行的列数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># end=&quot; &quot; 使打印不换行</span></span><br><span class="line">        col += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 一行打印完毕，换行</span></span><br><span class="line">    row += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># * * * * </span></span><br><span class="line"><span class="comment"># * * * * </span></span><br><span class="line"><span class="comment"># * * * * </span></span><br></pre></td></tr></table></figure>
<p><strong>pass：「语法占位符」</strong></p>
<ul>
<li><strong>核心作用</strong>：避免 “缺少语句导致的语法错误”</li>
</ul>
<h2 id="2-循环控制关键字：break-与-continue"><a href="#2-循环控制关键字：break-与-continue" class="headerlink" title="2.循环控制关键字：break 与 continue"></a>2.循环控制关键字：break 与 continue</h2><p><strong>默认情况下，while 循环按「条件判断→循环体执行」的流程重复，但实际开发中常需灵活控制循环（如提前终止、跳过某次循环），此时需用到 break 和 continue 两个核心关键字。</strong></p>
<h3 id="（1）break（立即终止循环）"><a href="#（1）break（立即终止循环）" class="headerlink" title="（1）break（立即终止循环）"></a>（1）break（立即终止循环）</h3><p><strong>作用</strong>：当执行到 break 时，直接终止当前所在的循环，跳出循环体，程序执行循环之后的代码（无论条件是否仍成立）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：找到目标值后立即终止循环</span></span><br><span class="line">target = <span class="number">3</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> num &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> num == target:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;找到目标值：<span class="subst">&#123;num&#125;</span>，终止循环&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 找到目标，立即终止循环</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前值：<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出：当前值：1 → 当前值：2 → 找到目标值：3，终止循环</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）continue（跳过当前循环，进入下一轮）"><a href="#（2）continue（跳过当前循环，进入下一轮）" class="headerlink" title="（2）continue（跳过当前循环，进入下一轮）"></a>（2）continue（跳过当前循环，进入下一轮）</h3><p><strong>作用</strong>：当执行到 continue 时，跳过当前循环体中剩余的代码，直接回到「条件判断」环节，准备执行下一轮循环（不会终止循环）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：跳过偶数，只输出奇数（1-5）</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">5</span>:</span><br><span class="line">    num += <span class="number">1</span>    <span class="comment"># 注：必须在 continue 之前更新循环变量！</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 判断是否为偶数</span></span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 是偶数则跳过后续打印代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;奇数：<span class="subst">&#123;num&#125;</span>&quot;</span>)  <span class="comment"># 仅输出奇数：1、3、5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 错误示例：会导致死循环</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 当 num=0 时，跳过了 num+=1，永远卡在 0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;奇数：<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h1 id="七、用户输入（input）"><a href="#七、用户输入（input）" class="headerlink" title="七、用户输入（input）"></a>七、用户输入（input）</h1><h2 id="1-核心语法与基础用法"><a href="#1-核心语法与基础用法" class="headerlink" title="1.核心语法与基础用法"></a>1.核心语法与基础用法</h2><p><strong>input() 函数的语法简洁，核心功能是“阻塞程序等待用户输入，获取输入内容并返回”。根据是否需要提示用户，可分为带提示&#x2F;不带提示两种用法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础语法</span></span><br><span class="line"><span class="comment"># 用法1：无提示信息（仅等待用户输入）</span></span><br><span class="line">输入变量 = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法2：带自定义提示信息（推荐，提升用户体验）</span></span><br><span class="line">输入变量 = <span class="built_in">input</span>(<span class="string">&quot;请输入xxx：&quot;</span>)  <span class="comment"># 提示信息会直接显示在控制台，引导用户输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="comment"># 示例1：无提示信息的输入</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入任意内容，按回车结束：&quot;</span>)</span><br><span class="line">content = <span class="built_in">input</span>()  <span class="comment"># 程序阻塞，等待用户输入</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;你输入的内容是：<span class="subst">&#123;content&#125;</span>&quot;</span>)  <span class="comment"># 输出用户输入的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：带提示信息的输入（日常开发首选）</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的姓名：&quot;</span>)</span><br><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;欢迎你，<span class="subst">&#123;name&#125;</span>！你的年龄是 <span class="subst">&#123;age&#125;</span> 岁。&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-input-函数的核心特性（必记）"><a href="#2-input-函数的核心特性（必记）" class="headerlink" title="2.input() 函数的核心特性（必记）"></a>2.input() 函数的核心特性（必记）</h2><p><strong>理解 input() 的核心特性是正确处理用户输入的关键，尤其是“返回值类型”和“阻塞特性”，直接影响后续代码逻辑</strong></p>
<h3 id="（1）返回值永远是字符串类型"><a href="#（1）返回值永远是字符串类型" class="headerlink" title="（1）返回值永远是字符串类型"></a>（1）返回值永远是字符串类型</h3><ul>
<li><strong>无论用户输入的是数字（如 18）、布尔值（如 True）还是符号（如 @），input() 的返回值都默认是 字符串（str）</strong></li>
<li><strong>若需要用输入内容进行数学运算，必须“手动进行类型转换”，否则会报错</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 典型错误示例：直接用输入的“数字字符串”做运算</span></span><br><span class="line">score = <span class="built_in">input</span>(<span class="string">&quot;请输入你的成绩：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(score + <span class="number">10</span>)  <span class="comment"># 报错：TypeError: can only concatenate str (not &quot;int&quot;) to str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确示例：先转换为对应数字类型</span></span><br><span class="line">score = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的成绩：&quot;</span>))  <span class="comment"># 转换为整数（适用于整数输入）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成绩+10后的分数：<span class="subst">&#123;score + <span class="number">10</span>&#125;</span>&quot;</span>)  <span class="comment"># 正常执行</span></span><br><span class="line"></span><br><span class="line">height = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（m）：&quot;</span>))  <span class="comment"># 转换为浮点数（适用于小数输入）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;身高的2倍：<span class="subst">&#123;height * <span class="number">2</span>&#125;</span>&quot;</span>)  <span class="comment"># 正常执行</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）程序阻塞特性"><a href="#（2）程序阻塞特性" class="headerlink" title="（2）程序阻塞特性"></a>（2）程序阻塞特性</h3><ul>
<li><strong>当程序执行到 input() 时，会立即暂停（阻塞），直到用户完成输入并按下「回车键」，程序才会继续执行后续代码</strong></li>
<li><strong>注意：用户未输入时，程序会一直等待，不会自动继续。</strong></li>
</ul>
<h3 id="（3）空输入的处理"><a href="#（3）空输入的处理" class="headerlink" title="（3）空输入的处理"></a>（3）空输入的处理</h3><ul>
<li><strong>若用户未输入任何内容，直接按下回车键，input() 会返回一个 空字符串（””）。</strong></li>
<li><strong>空输入是常见场景，需根据业务需求判断是否允许，避免程序因空值出现逻辑错误。</strong></li>
<li><strong>此外，input() 在遇到 EOF（如 Ctrl+D &#x2F; Ctrl+Z 或重定向空文件）时会抛 EOFError，在某些自动化&#x2F;测试场景下需要注意。</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：处理空输入</span></span><br><span class="line">user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入内容（不能为空）：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> user_input == <span class="string">&quot;&quot;</span>:  <span class="comment"># 判断是否为空输入</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误：输入不能为空，请重新输入！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你输入的内容是：<span class="subst">&#123;user_input&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-输入内容的类型转换（关键操作）"><a href="#3-输入内容的类型转换（关键操作）" class="headerlink" title="3.输入内容的类型转换（关键操作）"></a>3.输入内容的类型转换（关键操作）</h2><p><strong>日常开发中，用户输入常需作为数字（int&#x2F;float）、布尔值（bool）等类型使用，因此“类型转换”是input() 用法的核心延伸。需根据输入场景选择合适的转换方式，并处理转换失败的情况。</strong></p>
<h3 id="（1）常见类型转换场景与示例"><a href="#（1）常见类型转换场景与示例" class="headerlink" title="（1）常见类型转换场景与示例"></a>（1）常见类型转换场景与示例</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110115257300.png"></p>
<h3 id="（2）多值输入的处理技巧"><a href="#（2）多值输入的处理技巧" class="headerlink" title="（2）多值输入的处理技巧"></a>（2）多值输入的处理技巧</h3><p><strong>若需要用户一次性输入多个值（如“姓名 年龄 成绩”“多个数字”），可结合 split() 方法拆分输入字符串，再批量转换类型：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：用空格分隔多个值（如“小明 20 95”）</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    info = <span class="built_in">input</span>(<span class="string">&quot;请输入姓名 年龄 成绩（用空格分隔）：&quot;</span>).split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(info) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：请输入恰好 3 个值！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        name = info[<span class="number">0</span>]</span><br><span class="line">        age = <span class="built_in">int</span>(info[<span class="number">1</span>])</span><br><span class="line">        score = <span class="built_in">int</span>(info[<span class="number">2</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>，成绩：<span class="subst">&#123;score&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：用逗号分隔多个值（如“90,85,92”）</span></span><br><span class="line">scores_input = <span class="built_in">input</span>(<span class="string">&quot;请输入多个成绩，用逗号分隔：&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">scores = [<span class="built_in">int</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> scores_input]  <span class="comment"># 列表推导式批量转换为整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成绩列表：<span class="subst">&#123;scores&#125;</span>，平均成绩：<span class="subst">&#123;<span class="built_in">sum</span>(scores)/<span class="built_in">len</span>(scores):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-核心难点：输入验证与异常处理"><a href="#4-核心难点：输入验证与异常处理" class="headerlink" title="4.核心难点：输入验证与异常处理"></a>4.核心难点：输入验证与异常处理</h2><p><strong>用户输入具有不可控性（如要求输入数字却输入文字、输入超出范围的值），直接使用输入内容会导致程序崩溃。因此，“输入验证”和“异常处理”是保障程序稳定性的关键，常用 try-except 语句捕获转换异常。</strong></p>
<h3 id="（1）基础异常处理：确保输入可转换为目标类型"><a href="#（1）基础异常处理：确保输入可转换为目标类型" class="headerlink" title="（1）基础异常处理：确保输入可转换为目标类型"></a>（1）基础异常处理：确保输入可转换为目标类型</h3><p><strong>当用户输入无法转换为目标类型（如输入“abc”却要转换为 int）时，会触发 ValueError 异常，用 try-except 捕获并提示用户重新输入</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：确保用户输入的是整数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 循环直到输入正确</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数：&quot;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;你输入的整数是：<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 输入正确，退出循环</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：输入的不是有效整数，请重新输入！&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）进阶验证：同时验证类型与值的范围"><a href="#（2）进阶验证：同时验证类型与值的范围" class="headerlink" title="（2）进阶验证：同时验证类型与值的范围"></a>（2）进阶验证：同时验证类型与值的范围</h3><p><strong>除了类型验证，还需验证输入值是否符合业务范围（如年龄 0-120、成绩 0-100），结合 if-else 实现完整验证逻辑</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：验证输入的是 0-100 之间的成绩</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        score = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入成绩（0-100）：&quot;</span>))</span><br><span class="line">        <span class="comment"># 验证值的范围</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;成绩录入成功：<span class="subst">&#123;score&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;错误：成绩必须在 0-100 之间，请重新输入！&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：输入的不是有效数字，请重新输入！&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="（3）复杂验证：多条件组合验证"><a href="#（3）复杂验证：多条件组合验证" class="headerlink" title="（3）复杂验证：多条件组合验证"></a>（3）复杂验证：多条件组合验证</h3><p><strong>针对更复杂的输入需求（如密码长度、格式验证），可组合多个条件实现精准验证</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：验证密码格式（长度≥6，包含字母和数字）</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请设置密码（长度≥6，包含字母和数字）：&quot;</span>)</span><br><span class="line">    <span class="comment"># 验证条件：长度≥6、包含字母、包含数字</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(password) &lt; <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：密码长度必须≥6，请重新设置！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">any</span>(c.isalpha() <span class="keyword">for</span> c <span class="keyword">in</span> password):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：密码必须包含字母，请重新设置！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">any</span>(c.isdigit() <span class="keyword">for</span> c <span class="keyword">in</span> password):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：密码必须包含数字，请重新设置！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码设置成功！&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="5-高级技巧：提升输入交互体验"><a href="#5-高级技巧：提升输入交互体验" class="headerlink" title="5.高级技巧：提升输入交互体验"></a>5.高级技巧：提升输入交互体验</h2><p><strong>在基础用法之上，可通过一些技巧优化用户输入体验，适配更多特殊场景</strong></p>
<h3 id="（1）隐藏敏感输入（如密码）"><a href="#（1）隐藏敏感输入（如密码）" class="headerlink" title="（1）隐藏敏感输入（如密码）"></a>（1）隐藏敏感输入（如密码）</h3><p><strong>默认情况下，用户输入的内容会明文显示在控制台，对于密码等敏感信息，可使用 getpass 模块的 getpass() 函数隐藏输入（输入内容不显示）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> getpass  <span class="comment"># 导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐藏密码输入（输入内容不显示）</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">password = getpass.getpass(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单验证（实际开发中需对接数据库）</span></span><br><span class="line"><span class="keyword">if</span> username == <span class="string">&quot;admin&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登录成功！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户名或密码错误！&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）预设默认值（用户可直接回车使用默认值）"><a href="#（2）预设默认值（用户可直接回车使用默认值）" class="headerlink" title="（2）预设默认值（用户可直接回车使用默认值）"></a>（2）预设默认值（用户可直接回车使用默认值）</h3><p><strong>对于可选输入项，可设置默认值，用户直接按下回车键时，使用预设值，提升交互效率</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：设置默认年龄为 18</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄（默认 18）：&quot;</span>)</span><br><span class="line">        age = <span class="built_in">int</span>(user_input) <span class="keyword">if</span> user_input != <span class="string">&quot;&quot;</span> <span class="keyword">else</span> <span class="number">18</span> <span class="comment"># 空输入则使用默认值 18</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：输入的不是有效数字，请重新输入！&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;你的年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-避坑要点与注意事项"><a href="#6-避坑要点与注意事项" class="headerlink" title="6.避坑要点与注意事项"></a>6.避坑要点与注意事项</h2><ul>
<li><strong>永远不要信任用户输入</strong>：用户输入具有不可控性，必须进行验证（类型、范围、格式），否则会导致程序崩溃或逻辑错误</li>
<li><strong>牢记返回值是字符串</strong>：无论用户输入什么，先按字符串处理，再根据需求转换类型，避免直接用输入内容做运算</li>
<li><strong>循环验证时注意退出条件</strong>：用 while True 做循环验证时，必须确保有 break语句退出循环，避免无限循环</li>
<li><strong>区分 split() 与 split(‘分隔符’)</strong><ul>
<li><strong>split()</strong>： 默认按任意空白字符（空格、制表符、换行）拆分</li>
<li><strong>split(‘分隔符’)</strong>：按指定分隔符拆分，需根据用户输入格式选择</li>
</ul>
</li>
<li><strong>敏感输入用 getpass 而非 input</strong>：密码、验证码等敏感信息，不要用 input() 明文显示，优先使用 getpass.getpass()</li>
<li><strong>兼容空输入场景</strong>：用户可能直接回车，需提前判断空字符串并处理（如设置默认值、提示重新输入）</li>
</ul>
<h1 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h1><h2 id="1-函数的核心定义"><a href="#1-函数的核心定义" class="headerlink" title="1.函数的核心定义"></a>1.函数的核心定义</h2><p><strong>函数是 Python 中「封装可复用逻辑的基本单元」，本质是“输入→处理→输出”的黑盒</strong></p>
<ul>
<li><strong>输入</strong>：通过参数接收外部数据</li>
<li><strong>处理</strong>：执行封装的代码逻辑</li>
<li><strong>输出</strong>：通过返回值向外部反馈结果（无返回值则默认返回 None）</li>
</ul>
<p><strong>注！！</strong>：函数体必须<strong>通过缩进来标识</strong>（默认 4 个空格），这是 Python 区分代码块归属的核心规则。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110153245076.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完整结构：关键字 + 函数名 + 参数 + 冒号 + 缩进体 + 返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数列表</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;文档字符串（可选，用于说明函数功能）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 函数体（要执行的逻辑）</span></span><br><span class="line">    处理逻辑</span><br><span class="line">    <span class="keyword">return</span> 返回值  <span class="comment"># 可选，无return则返回None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最简示例：计算两数之和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算两个数的和&quot;&quot;&quot;</span></span><br><span class="line">    result = a + b</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数（执行函数逻辑，获取返回值）</span></span><br><span class="line">sum_result = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(sum_result)  <span class="comment"># 输出：30</span></span><br></pre></td></tr></table></figure>

<h2 id="2-函数的参数体系（核心重点）"><a href="#2-函数的参数体系（核心重点）" class="headerlink" title="2.函数的参数体系（核心重点）"></a>2.函数的参数体系（核心重点）</h2><p><strong>参数组合顺序</strong>:位置参数 → 默认参数 → *args → 仅限关键字参数 → **kwargs</p>
<h3 id="（1）位置参数"><a href="#（1）位置参数" class="headerlink" title="（1）位置参数"></a>（1）位置参数</h3><ul>
<li><strong>定义</strong>：最基础的参数，调用时<strong>必须按「定义顺序」传入</strong>，<strong>数量必须匹配</strong></li>
<li><strong>特点</strong>：无默认值，不传则报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">name, age</span>):  <span class="comment"># name、age是位置参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确调用（按位置传参）</span></span><br><span class="line">print_info(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>)  <span class="comment"># 输出：姓名：张三，年龄：25</span></span><br><span class="line"><span class="comment"># 错误调用（少传参数）</span></span><br><span class="line"><span class="comment"># print_info(&quot;李四&quot;)  # 报错：missing 1 required positional argument: &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）默认参数"><a href="#（2）默认参数" class="headerlink" title="（2）默认参数"></a>（2）默认参数</h3><ul>
<li><strong>定义</strong>：给参数指定默认值，调用时<strong>可省略不传</strong>（使用默认值）</li>
<li><strong>特点</strong><ul>
<li>默认参数<strong>必须放在「位置参数之后」</strong></li>
<li>默认参数<strong>建议用「不可变对象」</strong>（如数字、字符串、元组），避免用列表&#x2F;字典（可变对象会导致多次调用共享数据）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># city是默认参数（默认值&quot;北京&quot;），必须放在位置参数后</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">name, age, city=<span class="string">&quot;北京&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>，城市：<span class="subst">&#123;city&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略默认参数（使用&quot;北京&quot;）</span></span><br><span class="line">print_info(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>)  <span class="comment"># 输出：姓名：张三，年龄：25，城市：北京</span></span><br><span class="line"><span class="comment"># 覆盖默认参数（传&quot;上海&quot;）</span></span><br><span class="line">print_info(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>, <span class="string">&quot;上海&quot;</span>)  <span class="comment"># 输出：姓名：李四，年龄：30，城市：上海</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 坑点：默认参数用可变对象（列表）的问题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_item</span>(<span class="params">item, lst=[]</span>):  <span class="comment"># 不推荐！lst是可变对象</span></span><br><span class="line">    lst.append(item)</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add_item(<span class="number">1</span>))  <span class="comment"># [1]（第一次调用，lst初始化为空列表）</span></span><br><span class="line"><span class="built_in">print</span>(add_item(<span class="number">2</span>))  <span class="comment"># [1,2]（第二次调用，lst复用了上次的列表）</span></span><br><span class="line"><span class="comment"># 正确写法：默认参数用None，内部初始化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_item</span>(<span class="params">item, lst=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> lst <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        lst = []</span><br><span class="line">    lst.append(item)</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"><span class="built_in">print</span>(add_item(<span class="number">1</span>))  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span>(add_item(<span class="number">2</span>))  <span class="comment"># [2]</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）关键字参数"><a href="#（3）关键字参数" class="headerlink" title="（3）关键字参数"></a>（3）关键字参数</h3><ul>
<li><strong>定义</strong>：调用函数时，通过 <strong>「参数名&#x3D;值」</strong> 的方式传参，<strong>无需按位置顺序传入</strong></li>
<li><strong>特点</strong>：提高代码可读性，适合参数多的场景</li>
<li><strong>注意</strong>：调用时，关键字参数不能在位置参数前</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">name, age, city</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>，城市：<span class="subst">&#123;city&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字参数（顺序可打乱）</span></span><br><span class="line">print_info(age=<span class="number">25</span>, name=<span class="string">&quot;张三&quot;</span>, city=<span class="string">&quot;北京&quot;</span>)  <span class="comment"># 输出正常</span></span><br><span class="line"><span class="comment"># 混合位置参数+关键字参数（位置参数必须在前）</span></span><br><span class="line">print_info(<span class="string">&quot;张三&quot;</span>, city=<span class="string">&quot;上海&quot;</span>, age=<span class="number">30</span>)  <span class="comment"># 正确</span></span><br><span class="line"><span class="comment"># print_info(city=&quot;广州&quot;, &quot;李四&quot;, 28)  # 错误：关键字参数不能在位置参数前</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）仅限关键字参数（-）（Python-3-）"><a href="#（4）仅限关键字参数（-）（Python-3-）" class="headerlink" title="（4）仅限关键字参数（ * ）（Python 3+）"></a>（4）仅限关键字参数（ * ）（Python 3+）</h3><ul>
<li><strong>定义</strong>：必须通过关键字参数传入的参数，放在 *args 之后、**kwargs 之前；</li>
<li><strong>作用</strong>：强制调用者明确参数名，避免歧义</li>
<li><strong>定义仅限关键字</strong>：<ul>
<li>1.使用 <strong>*</strong> 作为分隔符：<br>  * 之后的参数都被标记为仅限关键字参数，调用时必须用 关键字&#x3D;值 的形式传递。</li>
<li>2.*args 之后的参数自动成为仅限关键字参数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.使用 * 作为分隔符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, *, b, c</span>):  <span class="comment"># * 之后的b、c是仅限关键字参数</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)  <span class="comment"># 正确（必须用关键字传b、c）</span></span><br><span class="line"><span class="comment"># func(1, 2, 3)  # 错误：b,c must be keyword arguments</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.\*args 之后</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">*args, sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟Python内置的print函数：*args接收任意位置参数，sep/end/file是仅限关键字参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    output = sep.join(<span class="built_in">map</span>(<span class="built_in">str</span>, args))</span><br><span class="line">    <span class="built_in">print</span>(output, end=end, file=file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确调用</span></span><br><span class="line">print_info(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, sep=<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;!\n&#x27;</span>)  <span class="comment"># 输出: Hello-Python!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 错误调用</span></span><br><span class="line"><span class="comment"># print_info(&#x27;Hello&#x27;, &#x27;Python&#x27;, &#x27;-&#x27;, &#x27;!\n&#x27;)  # sep/end被当作args传递，达不到预期效果</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）万能参数（-args-和-kwargs）"><a href="#（5）万能参数（-args-和-kwargs）" class="headerlink" title="（5）万能参数（*args 和 **kwargs）"></a>（5）万能参数（*args 和 **kwargs）</h3><ul>
<li><strong>用于接收「不确定数量」的参数，是实现通用函数的核心</strong></li>
<li><strong>注意</strong>：*args 和 **kwargs 均<strong>支持不传入任何对应参数</strong>，程序不会报错，会自动以空容器接收</li>
</ul>
<h4 id="args：接收任意数量的位置参数，打包为“元组”"><a href="#args：接收任意数量的位置参数，打包为“元组”" class="headerlink" title="&lt;1&gt;*args：接收任意数量的位置参数，打包为“元组”"></a>&lt;1&gt;*args：接收任意数量的位置参数，打包为“元组”</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_all</span>(<span class="params">*args</span>):  <span class="comment"># args是元组，接收所有位置参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args类型：&quot;</span>, <span class="built_in">type</span>(args))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> args:</span><br><span class="line">        total += num</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入任意数量参数</span></span><br><span class="line"><span class="built_in">print</span>(sum_all(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 6</span></span><br><span class="line"><span class="built_in">print</span>(sum_all(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>))  <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">print</span>(sum_all())  <span class="comment"># 0（无参数时args是空元组）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包列表/元组传入args</span></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(sum_all(*nums))  <span class="comment"># 6（*表示解包）</span></span><br></pre></td></tr></table></figure>

<h4 id="kwargs：接收任意数量的关键字参数，打包为“字典”"><a href="#kwargs：接收任意数量的关键字参数，打包为“字典”" class="headerlink" title="&lt;2&gt;**kwargs：接收任意数量的关键字参数，打包为“字典”"></a>&lt;2&gt;**kwargs：接收任意数量的关键字参数，打包为“字典”</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_kwargs</span>(<span class="params">**kwargs</span>):  <span class="comment"># kwargs是字典，接收所有关键字参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs类型：&quot;</span>, <span class="built_in">type</span>(kwargs))  <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;v&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入任意数量关键字参数</span></span><br><span class="line">print_kwargs(name=<span class="string">&quot;张三&quot;</span>, age=<span class="number">25</span>, city=<span class="string">&quot;北京&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># name: 张三</span></span><br><span class="line"><span class="comment"># age: 25</span></span><br><span class="line"><span class="comment"># city: 北京</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包字典传入kwargs</span></span><br><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">print_kwargs(**info)  <span class="comment"># **表示解包字典</span></span><br></pre></td></tr></table></figure>

<h4 id="args-与-kwargs-四种传参场景演示"><a href="#args-与-kwargs-四种传参场景演示" class="headerlink" title="&lt;3&gt;*args 与 **kwargs 四种传参场景演示"></a>&lt;3&gt;*args 与 **kwargs 四种传参场景演示</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义支持任意位置参数和关键字参数的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;1. 位置参数 args：<span class="subst">&#123;args&#125;</span>&quot;</span>)  <span class="comment"># args打包为元组</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;2. 关键字参数 kwargs：<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)  <span class="comment"># kwargs打包为字典</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)  <span class="comment"># 分隔线，清晰区分不同场景</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景1：不传参</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;场景1：不传参&quot;</span>)</span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景2：仅*args传参（位置参数）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;场景2：仅*args传参（2个位置参数）&quot;</span>)</span><br><span class="line">func(<span class="number">10</span>, <span class="number">20</span>)  <span class="comment"># 直接传位置参数，自动打包到args</span></span><br><span class="line"><span class="comment"># 也可通过解包可迭代对象传参（呼应前文*解包知识）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;场景2扩展：解包列表传参给*args&quot;</span>)</span><br><span class="line">func(*[<span class="number">30</span>, <span class="number">40</span>])  <span class="comment"># 解包列表为位置参数，等价于func(30,40)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景3：仅**kwargs传参（关键字参数）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;场景3：仅**kwargs传参（2个关键字参数）&quot;</span>)</span><br><span class="line">func(name=<span class="string">&quot;Python&quot;</span>, version=<span class="number">3.10</span>)  <span class="comment"># 直接传关键字参数，自动打包到kwargs</span></span><br><span class="line"><span class="comment"># 也可通过解包字典传参（呼应前文**解包知识）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;场景3扩展：解包字典传参给**kwargs&quot;</span>)</span><br><span class="line">func(**&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;version&quot;</span>: <span class="number">17</span>&#125;)  <span class="comment"># 解包字典为关键字参数，等价于func(name=&quot;Java&quot;, version=17)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景4：*args + **kwargs 混合传参</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;场景4：混合传参（2个位置参数 + 2个关键字参数）&quot;</span>)</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, x=<span class="number">3</span>, y=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 混合解包传参（实用场景）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;场景4扩展：混合解包传参&quot;</span>)</span><br><span class="line">func(*(<span class="number">5</span>, <span class="number">6</span>), **&#123;<span class="string">&quot;x&quot;</span>:<span class="number">7</span>, <span class="string">&quot;y&quot;</span>:<span class="number">8</span>&#125;)  <span class="comment"># 解包元组+字典，等价于func(5,6,x=7,y=8)</span></span><br></pre></td></tr></table></figure>

<h4 id="参数组合顺序（必须遵守）"><a href="#参数组合顺序（必须遵守）" class="headerlink" title="&lt;4&gt;参数组合顺序（必须遵守）"></a>&lt;4&gt;参数组合顺序（必须遵守）</h4><p><strong>位置参数 → 默认参数 → *args → 仅限关键字参数 → **kwargs</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正确顺序示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">10</span>, *args, c, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, args, c, kwargs)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, c=<span class="number">5</span>, d=<span class="number">6</span>, e=<span class="number">7</span>)  <span class="comment"># 输出：1 2 (3, 4) 5 &#123;&#x27;d&#x27;: 6, &#x27;e&#x27;: 7&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3.函数的返回值"></a>3.函数的返回值</h2><h3 id="（1）基本规则"><a href="#（1）基本规则" class="headerlink" title="（1）基本规则"></a>（1）基本规则</h3><ul>
<li><strong>无 return 语句</strong>：函数执行完默认返回 None</li>
<li><strong>有 return 语句</strong>：执行到 return 立即终止函数，返回指定值</li>
<li><strong>可返回任意类型</strong>：数字、字符串、列表、字典、函数、对象等</li>
</ul>
<h3 id="（2）多返回值（Python-特色）"><a href="#（2）多返回值（Python-特色）" class="headerlink" title="（2）多返回值（Python 特色）"></a>（2）多返回值（Python 特色）</h3><p><strong>Python 没有真正的“多返回值”，本质是返回「元组」，只是省略了括号</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>():</span><br><span class="line">    name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    age = <span class="number">25</span></span><br><span class="line">    <span class="keyword">return</span> name, age  <span class="comment"># 等价于 return (name, age)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收多返回值（自动解包）</span></span><br><span class="line">name, age = get_info()</span><br><span class="line"><span class="built_in">print</span>(name, age)  <span class="comment"># 张三 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以接收为元组</span></span><br><span class="line">result = get_info()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># (&#x27;张三&#x27;, 25)</span></span><br></pre></td></tr></table></figure>

<h2 id="4-函数的作用域（变量可见性）"><a href="#4-函数的作用域（变量可见性）" class="headerlink" title="4.函数的作用域（变量可见性）"></a>4.函数的作用域（变量可见性）</h2><h3 id="（1）四种作用域介绍"><a href="#（1）四种作用域介绍" class="headerlink" title="（1）四种作用域介绍"></a>（1）四种作用域介绍</h3><p>Python 遵循「LEGB 规则」，变量查找优先级：</p>
<ul>
<li><strong>全局作用域（Global）</strong><ul>
<li>模块（.py文件）级别的变量，可被当前模块内的所有函数、类访问，除非被局部变量遮蔽；</li>
</ul>
</li>
<li><strong>局部作用域（Local）</strong><ul>
<li>函数内部定义的变量，仅在当前函数体内有效，函数执行结束后变量被销毁</li>
</ul>
</li>
<li><strong>嵌套作用域（Enclosing）</strong><ul>
<li>外部函数（嵌套函数的外层）定义的变量，仅对外部函数自身及内部嵌套函数可见</li>
</ul>
</li>
<li><strong>内置作用域（Built-in）</strong><ul>
<li>Python 内置的函数、关键字等（如 print、len、int），无需定义即可在任意位置直接使用。</li>
</ul>
</li>
</ul>
<h3 id="（2）四种作用域示例"><a href="#（2）四种作用域示例" class="headerlink" title="（2）四种作用域示例"></a>（2）四种作用域示例</h3><h4 id="全局作用域示例"><a href="#全局作用域示例" class="headerlink" title="&lt;1&gt;全局作用域示例"></a>&lt;1&gt;全局作用域示例</h4><p>全局变量定义在模块级别，可被模块内所有函数访问，<strong>修改需用 global 声明</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局变量：定义在模块最外层，模块内所有函数可访问</span></span><br><span class="line">global_app_name = <span class="string">&quot;Python学习工具&quot;</span></span><br><span class="line">global_user_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register_user</span>(<span class="params">username</span>):</span><br><span class="line">    <span class="comment"># 访问全局变量global_app_name（无需声明，直接访问）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;【<span class="subst">&#123;global_app_name&#125;</span>】用户注册：<span class="subst">&#123;username&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 修改全局变量需用global声明</span></span><br><span class="line">    <span class="keyword">global</span> global_user_count</span><br><span class="line">    global_user_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_count</span>():</span><br><span class="line">    <span class="comment"># 不同函数可共享全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;【<span class="subst">&#123;global_app_name&#125;</span>】当前注册用户数：<span class="subst">&#123;global_user_count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，共享并修改全局变量</span></span><br><span class="line">register_user(<span class="string">&quot;张三&quot;</span>)  <span class="comment"># 输出：【Python学习工具】用户注册：张三</span></span><br><span class="line">register_user(<span class="string">&quot;李四&quot;</span>)  <span class="comment"># 输出：【Python学习工具】用户注册：李四</span></span><br><span class="line">get_user_count()       <span class="comment"># 输出：【Python学习工具】当前注册用户数：2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块外部（当前脚本内）可直接访问全局变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;全局应用名：<span class="subst">&#123;global_app_name&#125;</span>&quot;</span>)  <span class="comment"># 输出：全局应用名：Python学习工具</span></span><br></pre></td></tr></table></figure>

<h4 id="局部作用域示例"><a href="#局部作用域示例" class="headerlink" title="&lt;2&gt;局部作用域示例"></a>&lt;2&gt;局部作用域示例</h4><p>局部变量仅在定义它的函数内部有效，外部无法访问，函数执行完毕后变量释放</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数，内部包含局部变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">radius</span>):</span><br><span class="line">    <span class="comment"># 局部变量：仅在calculate_area内部有效</span></span><br><span class="line">    pi = <span class="number">3.14159</span>  </span><br><span class="line">    area = pi * radius ** <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;圆的面积：<span class="subst">&#123;area&#125;</span>&quot;</span>)  <span class="comment"># 函数内部可正常访问局部变量pi、area</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">calculate_area(<span class="number">5</span>)  <span class="comment"># 输出：圆的面积：78.53975</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：外部无法访问函数内的局部变量</span></span><br><span class="line"><span class="comment"># print(pi)  # 报错：name &#x27;pi&#x27; is not defined</span></span><br><span class="line"><span class="comment"># print(area)  # 报错：name &#x27;area&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套作用域示例"><a href="#嵌套作用域示例" class="headerlink" title="&lt;3&gt;嵌套作用域示例"></a>&lt;3&gt;嵌套作用域示例</h4><p>嵌套作用域变量由外部函数定义，内部函数可直接访问，外部函数外无法访问</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 外部函数（定义嵌套作用域变量）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_func</span>(<span class="params">company</span>):</span><br><span class="line">    <span class="comment"># 嵌套作用域变量：对outer_func和inner_func可见</span></span><br><span class="line">    department = <span class="string">&quot;技术部&quot;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 内部函数（嵌套在outer_func内部）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_func</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="comment"># 可直接访问嵌套作用域变量department和外部函数参数company</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，公司：<span class="subst">&#123;company&#125;</span>，部门：<span class="subst">&#123;department&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    inner_func(<span class="string">&quot;张三&quot;</span>)  <span class="comment"># 内部函数调用，正常访问嵌套变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用外部函数</span></span><br><span class="line">outer_func(<span class="string">&quot;字节跳动&quot;</span>)  <span class="comment"># 输出：姓名：张三，公司：字节跳动，部门：技术部</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：外部无法访问嵌套作用域变量</span></span><br><span class="line"><span class="comment"># print(department)  # 报错：name &#x27;department&#x27; is not defined</span></span><br><span class="line"><span class="comment"># 错误：外部无法直接调用内部函数（间接体现嵌套作用域隔离）</span></span><br><span class="line"><span class="comment"># inner_func(&quot;李四&quot;)  # 报错：name &#x27;inner_func&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="内置作用域示例"><a href="#内置作用域示例" class="headerlink" title="&lt;4&gt;内置作用域示例"></a>&lt;4&gt;内置作用域示例</h4><p>内置作用域包含 Python 自带的函数&#x2F;关键字，无需定义即可直接使用，<strong>优先级最低（当其他作用域有同名变量时会被遮蔽）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用内置函数print（无需定义，属于内置作用域）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;使用内置函数print输出&quot;</span>)  <span class="comment"># 输出：使用内置函数print输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用内置函数len（计算字符串长度）</span></span><br><span class="line">str_data = <span class="string">&quot;Python作用域&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串长度：<span class="subst">&#123;<span class="built_in">len</span>(str_data)&#125;</span>&quot;</span>)  <span class="comment"># 输出：字符串长度：8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：同名局部变量会遮蔽内置函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_builtin</span>():</span><br><span class="line">    <span class="comment"># 定义与内置函数同名的局部变量，遮蔽内置len</span></span><br><span class="line">    <span class="built_in">len</span> = <span class="number">10</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;局部变量len：<span class="subst">&#123;<span class="built_in">len</span>&#125;</span>&quot;</span>)  <span class="comment"># 输出：局部变量len：10</span></span><br><span class="line">    <span class="comment"># 此时无法直接使用内置len函数，需通过__builtins__访问</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;内置len计算长度：<span class="subst">&#123;__builtins__.<span class="built_in">len</span>(<span class="string">&#x27;test&#x27;</span>)&#125;</span>&quot;</span>)  <span class="comment"># 输出：内置len计算长度：4</span></span><br><span class="line"></span><br><span class="line">test_builtin()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外部仍可正常使用内置len（局部变量不影响全局/内置作用域）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;外部使用内置len：<span class="subst">&#123;<span class="built_in">len</span>(<span class="string">&#x27;hello&#x27;</span>)&#125;</span>&quot;</span>)  <span class="comment"># 输出：外部使用内置len：5</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）global-与-nonlocal-关键字"><a href="#（3）global-与-nonlocal-关键字" class="headerlink" title="（3）global 与 nonlocal 关键字"></a>（3）global 与 nonlocal 关键字</h3><ul>
<li>在 Python 作用域规则中，默认**“内部作用域不能直接修改外部作用域变量”**。</li>
<li>global 和 nonlocal 关键字的<strong>核心作用</strong>：「打破这一限制」，明确声明变量的作用域归属，实现对外部变量的修改。</li>
<li>两者适用场景不同，需严格区分使用。</li>
</ul>
<h4 id="global-关键字"><a href="#global-关键字" class="headerlink" title="&lt;1&gt;global 关键字"></a>&lt;1&gt;global 关键字</h4><ul>
<li><strong>作用</strong>:<ul>
<li>声明变量是「全局作用域」的变量，允许<strong>在局部作用域（函数内部）中修改全局变量</strong></li>
</ul>
</li>
<li><strong>核心规则</strong>：<ul>
<li><strong>仅读取全局变量</strong>：无需用 global 声明，直接访问即可</li>
<li><strong>在函数内部修改全局变量</strong>：<strong>必须先通过 global 声明</strong>，否则会被解析为局部变量</li>
<li>可同时声明多个全局变量，用逗号分隔（如 global a, b, c）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局变量（模块级别）</span></span><br><span class="line">global_count = <span class="number">0</span></span><br><span class="line">global_name = <span class="string">&quot;全局默认名&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1：仅读取全局变量（无需global声明）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_global</span>():</span><br><span class="line">    <span class="comment"># 仅访问全局变量，不修改，无需声明global</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;仅读取全局变量：count=<span class="subst">&#123;global_count&#125;</span>, name=<span class="subst">&#123;global_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_global()  <span class="comment"># 输出：仅读取全局变量：count=0, name=全局默认名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：修改全局变量（必须用global声明）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify_global</span>():</span><br><span class="line">    <span class="comment"># 声明要修改的是全局变量（必须在赋值前声明）</span></span><br><span class="line">    <span class="keyword">global</span> global_count, global_name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 修改全局变量</span></span><br><span class="line">    global_count += <span class="number">10</span></span><br><span class="line">    global_name = <span class="string">&quot;修改后的全局名&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取全局变量（声明后可直接使用）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;函数内访问全局变量：count=<span class="subst">&#123;global_count&#125;</span>, name=<span class="subst">&#123;global_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，触发全局变量修改</span></span><br><span class="line">modify_global()  <span class="comment"># 输出：函数内访问全局变量：count=10, name=修改后的全局名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数外部验证全局变量已被修改</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;函数外访问全局变量：count=<span class="subst">&#123;global_count&#125;</span>, name=<span class="subst">&#123;global_name&#125;</span>&quot;</span>)  <span class="comment"># 输出：count=10, name=修改后的全局名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反面案例：未声明global直接赋值（被解析为局部变量）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrong_modify</span>():</span><br><span class="line">    global_count = <span class="number">100</span>  <span class="comment"># 此处是新的局部变量，与全局变量无关</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;函数内局部变量：<span class="subst">&#123;global_count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">wrong_modify()  <span class="comment"># 输出：函数内局部变量：100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;全局变量未变：<span class="subst">&#123;global_count&#125;</span>&quot;</span>)  <span class="comment"># 输出：全局变量未变：10</span></span><br></pre></td></tr></table></figure>

<h4 id="nonlocal-关键字"><a href="#nonlocal-关键字" class="headerlink" title="&lt;2&gt;nonlocal 关键字"></a>&lt;2&gt;nonlocal 关键字</h4><ul>
<li><strong>作用</strong>：<ul>
<li>声明变量是「嵌套作用域」的变量（外部函数的变量），允许<strong>在内部函数中修改外部函数的变量</strong></li>
</ul>
</li>
<li><strong>核心规则</strong>：<ul>
<li>nonlocal 仅适用于嵌套结构，<strong>不能用于修改全局变量</strong></li>
<li>声明的变量<strong>必须在外部函数中已定义</strong>，不能是未定义的新变量</li>
<li>多层嵌套 nonlocal逐层向上查找变量</li>
<li>可同时声明多个嵌套变量，用逗号分隔（如 nonlocal x, y）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：仅读取外部函数变量（无需nonlocal声明）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_func_read</span>():</span><br><span class="line">    <span class="comment"># 外部函数变量（嵌套作用域）</span></span><br><span class="line">    outer_var = <span class="string">&quot;外部函数的变量&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_func_read</span>():</span><br><span class="line">        <span class="comment"># 仅读取外部变量，不修改，无需声明nonlocal</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;内部函数仅读取外部变量：<span class="subst">&#123;outer_var&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    inner_func_read()  <span class="comment"># 调用内部函数</span></span><br><span class="line"></span><br><span class="line">outer_func_read()  <span class="comment"># 输出：内部函数仅读取外部变量：外部函数的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：修改外部函数变量（必须用nonlocal声明）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_func</span>():</span><br><span class="line">    <span class="comment"># 外部函数变量（嵌套作用域）</span></span><br><span class="line">    outer_num = <span class="number">10</span></span><br><span class="line">    outer_str = <span class="string">&quot;外部默认字符串&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_func</span>():</span><br><span class="line">        <span class="comment"># 声明要修改的是嵌套作用域变量</span></span><br><span class="line">        <span class="keyword">nonlocal</span> outer_num, outer_str</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 修改嵌套作用域变量</span></span><br><span class="line">        outer_num *= <span class="number">2</span></span><br><span class="line">        outer_str = <span class="string">&quot;修改后的嵌套字符串&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;内部函数访问：num=<span class="subst">&#123;outer_num&#125;</span>, str=<span class="subst">&#123;outer_str&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    inner_func()  <span class="comment"># 调用内部函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;外部函数验证：num=<span class="subst">&#123;outer_num&#125;</span>, str=<span class="subst">&#123;outer_str&#125;</span>&quot;</span>)  <span class="comment"># 变量已被内部函数修改</span></span><br><span class="line"></span><br><span class="line">outer_func()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 内部函数访问：num=20, str=修改后的嵌套字符串</span></span><br><span class="line"><span class="comment"># 外部函数验证：num=20, str=修改后的嵌套字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反面案例：nonlocal修饰未定义的变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrong_outer</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrong_inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> undefined_var  <span class="comment"># 语法错误：nonlocal声明的变量必须在外层函数作用域中存在</span></span><br><span class="line">        undefined_var = <span class="number">5</span></span><br><span class="line">    wrong_inner()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这段代码在**定义阶段**就会触发 SyntaxError（语法错误），而非运行时错误</span></span><br><span class="line"><span class="comment"># wrong_outer()  # 实际执行前就会报错：SyntaxError: no binding for nonlocal &#x27;undefined_var&#x27; found</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：多层嵌套场景（nonlocal逐层向上查找变量）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_layer1</span>():</span><br><span class="line">    var = <span class="string">&quot;最外层变量&quot;</span>  <span class="comment"># 层级1：最外层外部函数变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">outer_layer2</span>():  <span class="comment"># 层级2：中间嵌套函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner_layer</span>():  <span class="comment"># 层级3：最内层内部函数</span></span><br><span class="line">            <span class="keyword">nonlocal</span> var  <span class="comment"># 查找规则：从外层2开始向上找，最终找到outer_layer1的var</span></span><br><span class="line">            var = <span class="string">&quot;被最内层函数修改&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;最内层函数修改后：<span class="subst">&#123;var&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        inner_layer()  <span class="comment"># 调用最内层函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;中间层函数访问：<span class="subst">&#123;var&#125;</span>&quot;</span>)  <span class="comment"># 能访问到被修改后的var</span></span><br><span class="line">    </span><br><span class="line">    outer_layer2()  <span class="comment"># 调用中间层函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最外层函数验证：<span class="subst">&#123;var&#125;</span>&quot;</span>)  <span class="comment"># 最终变量被修改</span></span><br><span class="line"></span><br><span class="line">outer_layer1()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 最内层函数修改后：被最内层函数修改</span></span><br><span class="line"><span class="comment"># 中间层函数访问：被最内层函数修改</span></span><br><span class="line"><span class="comment"># 最外层函数验证：被最内层函数修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例4：多层嵌套中存在同名变量（nonlocal优先找最近的外层变量）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer1</span>():</span><br><span class="line">    var = <span class="string">&quot;outer1的变量&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">outer2</span>():</span><br><span class="line">        var = <span class="string">&quot;outer2的变量&quot;</span>  <span class="comment"># 与外层同名的中间层变量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">            <span class="keyword">nonlocal</span> var  <span class="comment"># 优先找最近的外层（outer2）的var，而非outer1的var</span></span><br><span class="line">            var = <span class="string">&quot;修改outer2的变量&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;内层函数：<span class="subst">&#123;var&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        inner()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;outer2函数：<span class="subst">&#123;var&#125;</span>&quot;</span>)  <span class="comment"># 被修改的是outer2的var</span></span><br><span class="line">    </span><br><span class="line">    outer2()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;outer1函数：<span class="subst">&#123;var&#125;</span>&quot;</span>)  <span class="comment"># outer1的var未被修改</span></span><br><span class="line"></span><br><span class="line">outer1()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 内层函数：修改outer2的变量</span></span><br><span class="line"><span class="comment"># outer2函数：修改outer2的变量</span></span><br><span class="line"><span class="comment"># outer1函数：outer1的变量</span></span><br></pre></td></tr></table></figure>

<h4 id="global-与-nonlocal-核心差异对比"><a href="#global-与-nonlocal-核心差异对比" class="headerlink" title="&lt;3&gt;global 与 nonlocal 核心差异对比"></a>&lt;3&gt;global 与 nonlocal 核心差异对比</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110210400109.png"></p>
<h2 id="5-内部函数（嵌套函数）"><a href="#5-内部函数（嵌套函数）" class="headerlink" title="5.内部函数（嵌套函数）"></a>5.内部函数（嵌套函数）</h2><p>内部函数指「在另一个函数（外部函数）内部定义的函数」，也叫嵌套函数。它是实现闭包、装饰器等进阶特性的基础，核心价值是<strong>封装内部逻辑、隔离作用域</strong>。</p>
<h3 id="核心定义与特征"><a href="#核心定义与特征" class="headerlink" title="核心定义与特征"></a>核心定义与特征</h3><ul>
<li><strong>定义位置</strong>：必须在外部函数的函数体内部</li>
<li><strong>作用域隔离</strong>：内部函数默认只能在外部函数内部被调用，外部无法直接访问</li>
<li><strong>变量访问</strong>：内部函数可直接访问外部函数的变量（嵌套作用域变量），若需修改需用 nonlocal 声明</li>
<li><strong>独立性</strong>：<strong>内部函数可作为外部函数的返回值传出，或作为参数传递给其他函数</strong>（依托函数是一等对象的特性）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：作用域隔离（内部函数变量外部不可访问）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer1</span>():</span><br><span class="line">    inner_var = <span class="string">&quot;内部函数变量&quot;</span>  <span class="comment"># 内部函数局部变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner1</span>():</span><br><span class="line">        <span class="built_in">print</span>(inner_var)  <span class="comment"># 内部可访问自身变量</span></span><br><span class="line">    </span><br><span class="line">    inner1()</span><br><span class="line"></span><br><span class="line">outer1()</span><br><span class="line"><span class="comment"># print(inner_var)  # 报错：name &#x27;inner_var&#x27; is not defined（外部无法访问，体现隔离）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：变量访问与修改（内部函数访问/修改外层变量）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer2</span>():</span><br><span class="line">    outer_var = <span class="string">&quot;外层变量&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 子示例2-1：仅访问外层变量（无需nonlocal）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner2_read</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;仅访问外层变量：<span class="subst">&#123;outer_var&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 子示例2-2：未用nonlocal修改（实际创建局部变量，修改失败）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner2_wrong_modify</span>():</span><br><span class="line">        outer_var = <span class="string">&quot;内部创建的局部变量&quot;</span>  <span class="comment"># 与外层变量同名，不影响外层</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;未用nonlocal修改后（局部变量）：<span class="subst">&#123;outer_var&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 子示例2-3：用nonlocal修改（成功修改外层变量）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner2_correct_modify</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> outer_var  <span class="comment"># 声明变量来自嵌套作用域</span></span><br><span class="line">        outer_var = <span class="string">&quot;修改后的外层变量&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;使用nonlocal修改后（外层变量）：<span class="subst">&#123;outer_var&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    inner2_read()</span><br><span class="line">    inner2_wrong_modify()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;未用nonlocal后，外层变量仍为：<span class="subst">&#123;outer_var&#125;</span>&quot;</span>)</span><br><span class="line">    inner2_correct_modify()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;使用nonlocal后，外层变量变为：<span class="subst">&#123;outer_var&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">outer2()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 仅访问外层变量：外层变量</span></span><br><span class="line"><span class="comment"># 未用nonlocal修改后（局部变量）：内部创建的局部变量</span></span><br><span class="line"><span class="comment"># 未用nonlocal后，外层变量仍为：外层变量</span></span><br><span class="line"><span class="comment"># 使用nonlocal修改后（外层变量）：修改后的外层变量</span></span><br><span class="line"><span class="comment"># 使用nonlocal后，外层变量变为：修改后的外层变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：独立性（内部函数可作为返回值独立传递）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer3</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner3</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;内部函数执行结果&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inner3  <span class="comment"># 返回内部函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 独立调用返回的内部函数（与原外部函数脱离仍可执行）</span></span><br><span class="line">inner_obj = outer3()</span><br><span class="line"><span class="built_in">print</span>(inner_obj())  <span class="comment"># 输出：内部函数执行结果</span></span><br></pre></td></tr></table></figure>

<h2 id="6-解包（序列解包）"><a href="#6-解包（序列解包）" class="headerlink" title="6.* 解包（序列解包）"></a>6.* 解包（序列解包）</h2><ul>
<li><strong>在函数参数相关操作中，* 除了用于定义可变长度参数（*args），还常用于「序列解包」</strong><ul>
<li>将<strong>可迭代对象</strong>（列表、元组、字符串等）的<strong>元素逐个拆解</strong>，作为<strong>独立参数</strong>传入函数</li>
<li>这是 Python 中简化参数传递的实用技巧，与<strong>可变长度参数</strong>相辅相成</li>
</ul>
</li>
</ul>
<h3 id="（1）核心作用"><a href="#（1）核心作用" class="headerlink" title="（1）核心作用"></a>（1）核心作用</h3><ul>
<li>将<strong>可迭代对象</strong>“打散”为<strong>单个元素</strong>，避免手动逐个提取元素传参</li>
<li>可与普通参数、关键字参数混合使用，灵活适配不同函数的参数要求<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110162021473.png"></li>
</ul>
<h3 id="（2）适用场景与示例"><a href="#（2）适用场景与示例" class="headerlink" title="（2）适用场景与示例"></a>（2）适用场景与示例</h3><h4 id="场景1：解包列表-元组传入普通函数（需匹配参数数量）"><a href="#场景1：解包列表-元组传入普通函数（需匹配参数数量）" class="headerlink" title="场景1：解包列表&#x2F;元组传入普通函数（需匹配参数数量）"></a>场景1：解包列表&#x2F;元组传入普通函数（需匹配参数数量）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通函数（2个位置参数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表解包</span></span><br><span class="line">nums_list = [<span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(add(*nums_list))  <span class="comment"># 等价于 add(3, 5)，输出：8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组解包</span></span><br><span class="line">nums_tuple = (<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(add(*nums_tuple))  <span class="comment"># 等价于 add(4, 6)，输出：10</span></span><br></pre></td></tr></table></figure>

<h4 id="场景2：解包序列传入-args（补充可变长度参数）"><a href="#场景2：解包序列传入-args（补充可变长度参数）" class="headerlink" title="场景2：解包序列传入*args（补充可变长度参数）"></a>场景2：解包序列传入*args（补充可变长度参数）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变长度参数函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_all</span>(<span class="params">*args</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> args:</span><br><span class="line">        total += num</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1：解包列表补充参数</span></span><br><span class="line">base_nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(sum_all(*base_nums, <span class="number">4</span>, <span class="number">5</span>))  <span class="comment"># 等价于 sum_all(1,2,3,4,5)，输出：15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：解包字符串（字符串是可迭代对象，拆解为单个字符）</span></span><br><span class="line">str_chars = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sum_all(*str_chars))  <span class="comment"># 等价于 sum_all(&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)？注意：此处会报错，需确保元素类型匹配</span></span><br><span class="line"><span class="comment"># 正确用法：先转换元素类型</span></span><br><span class="line">str_nums = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sum_all(*<span class="built_in">map</span>(<span class="built_in">int</span>, str_nums)))  <span class="comment"># 等价于 sum_all(1,2,3)，输出：6</span></span><br></pre></td></tr></table></figure>

<h4 id="场景3：与关键字参数混合使用（解包需在关键字参数前）"><a href="#场景3：与关键字参数混合使用（解包需在关键字参数前）" class="headerlink" title="场景3：与关键字参数混合使用（解包需在关键字参数前）"></a>场景3：与关键字参数混合使用（解包需在关键字参数前）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">name, age, city</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>，城市：<span class="subst">&#123;city&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包列表传入前两个位置参数，第三个参数用关键字传</span></span><br><span class="line">info_list = [<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>]</span><br><span class="line">print_info(*info_list, city=<span class="string">&quot;北京&quot;</span>)  <span class="comment"># 等价于 print_info(&quot;张三&quot;,25,city=&quot;北京&quot;)，输出正常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误用法：解包不能在关键字参数后</span></span><br><span class="line"><span class="comment"># print_info(name=&quot;李四&quot;, *[30, &quot;上海&quot;])  # 报错：positional argument follows keyword argument</span></span><br></pre></td></tr></table></figure>
<p><strong>位置参数 → 默认参数 → *args → 仅限关键字参数 → **kwargs</strong></p>
<h2 id="7-解包（字典解包）"><a href="#7-解包（字典解包）" class="headerlink" title="7.** 解包（字典解包）"></a>7.** 解包（字典解包）</h2><p><strong>与 * 解包序列对应，** 专门用于「字典解包」</strong> </p>
<ul>
<li>将字典的键值对拆解为“<strong>参数名&#x3D;参数值</strong>”的关键字参数形式传入函数或“合并多个字典”</li>
<li>这一技巧常用于灵活<strong>传递多个关键字参数</strong>，尤其适合参数数量不确定或需要批量传入配置信息的场景。</li>
<li><strong>注</strong>：<strong>仅字典可使用 ** 解包</strong></li>
</ul>
<h3 id="（1）核心作用-1"><a href="#（1）核心作用-1" class="headerlink" title="（1）核心作用"></a>（1）核心作用</h3><ul>
<li>将字典“打散”为多个关键字参数，避免手动逐个写 参数名&#x3D;值，简化多关键字参数的传递</li>
<li>可与普通位置参数、关键字参数混合使用，精准匹配函数的参数要求</li>
<li>与 **kwargs （接收可变关键字参数）相辅相成，实现“批量传参+动态接收”的组合。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110201433413.png"></li>
</ul>
<h3 id="（2）适用场景与示例-1"><a href="#（2）适用场景与示例-1" class="headerlink" title="（2）适用场景与示例"></a>（2）适用场景与示例</h3><h4 id="场景1：解包字典传入普通函数（需字典键与函数参数名完全匹配）"><a href="#场景1：解包字典传入普通函数（需字典键与函数参数名完全匹配）" class="headerlink" title="场景1：解包字典传入普通函数（需字典键与函数参数名完全匹配）"></a>场景1：解包字典传入普通函数（需字典键与函数参数名完全匹配）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通函数（3个位置/关键字参数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">name, age, city</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>，城市：<span class="subst">&#123;city&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典解包（键必须与参数名一致）</span></span><br><span class="line">info_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;北京&quot;</span>&#125;</span><br><span class="line">print_info(**info_dict)  <span class="comment"># 等价于 print_info(name=&quot;张三&quot;, age=25, city=&quot;北京&quot;)，输出正常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误用法：字典键与参数名不匹配</span></span><br><span class="line">wrong_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;address&quot;</span>: <span class="string">&quot;上海&quot;</span>&#125;</span><br><span class="line"><span class="comment"># print_info(**wrong_dict)  # 报错：got an unexpected keyword argument &#x27;address&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="场景2：解包字典传入-kwargs（补充可变关键字参数）"><a href="#场景2：解包字典传入-kwargs（补充可变关键字参数）" class="headerlink" title="场景2：解包字典传入**kwargs（补充可变关键字参数）"></a>场景2：解包字典传入**kwargs（补充可变关键字参数）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变关键字参数函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_details</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>：<span class="subst">&#123;v&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包字典补充参数</span></span><br><span class="line">base_info = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">28</span>&#125;</span><br><span class="line">print_details(**base_info, city=<span class="string">&quot;广州&quot;</span>, gender=<span class="string">&quot;男&quot;</span>)  <span class="comment"># 等价于 print_details(name=&quot;王五&quot;, age=28, city=&quot;广州&quot;, gender=&quot;男&quot;)</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># name：王五</span></span><br><span class="line"><span class="comment"># age：28</span></span><br><span class="line"><span class="comment"># city：广州</span></span><br><span class="line"><span class="comment"># gender：男</span></span><br></pre></td></tr></table></figure>

<h4 id="场景3：混合-解包与-解包（序列-字典联合传参）"><a href="#场景3：混合-解包与-解包（序列-字典联合传参）" class="headerlink" title="场景3：混合*解包与**解包（序列+字典联合传参）"></a>场景3：混合*解包与**解包（序列+字典联合传参）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 混合参数的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c, d</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c + d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># *解包列表（位置参数） + **解包字典（关键字参数）</span></span><br><span class="line">list_data = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">dict_data = &#123;<span class="string">&quot;c&quot;</span>: <span class="number">3</span>, <span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">func(*list_data, **dict_data)  <span class="comment"># 等价于 func(1, 2, c=3, d=4)，输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意顺序：*解包（位置参数）必须在**解包（关键字参数）之前</span></span><br><span class="line"><span class="comment"># func(**dict_data, *list_data)  # 报错：positional argument follows keyword argument</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）注意事项"><a href="#（3）注意事项" class="headerlink" title="（3）注意事项"></a>（3）注意事项</h3><ul>
<li><p><strong>字典的键必须是「字符串类型」</strong>，且<strong>与函数的参数名完全一致</strong>，否则会报“意外的关键字参数”错误</p>
</li>
<li><p>单个函数调用中可多次解包字典，但需确保不重复传递同名参数（否则报错 duplicate keyword argument）；</p>
</li>
<li><p><strong>** 仅用于解包「字典类型」</strong>：dict、OrderedDict 等）</p>
<ul>
<li>不能用于列表、元组等序列（会报错 TypeError: <strong>dict</strong> must be a mapping）；</li>
</ul>
</li>
<li><p><strong>** 解包只能用于函数参数传递场景，不能单独用于赋值</strong></p>
<ul>
<li>如 a, b, c &#x3D; **dict_data 是错误的）；</li>
</ul>
</li>
<li><p>混合传参时，必须遵循“位置参数→*解包（位置参数）→关键字参数→**解包（关键字参数）”的顺序。</p>
</li>
</ul>
<h2 id="8-函数的进阶特性"><a href="#8-函数的进阶特性" class="headerlink" title="8.函数的进阶特性"></a>8.函数的进阶特性</h2><h3 id="（1）函数是一等对象（Python-核心特性）"><a href="#（1）函数是一等对象（Python-核心特性）" class="headerlink" title="（1）函数是一等对象（Python 核心特性）"></a>（1）函数是一等对象（Python 核心特性）</h3><p><strong>函数可以作为：参数、返回值、赋值给变量、存储在容器中（列表&#x2F;字典），这是高阶函数的基础</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 函数赋值给变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">f = add  <span class="comment"># 变量f指向add函数</span></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">10</span>, <span class="number">20</span>))  <span class="comment"># 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 函数作为参数传入另一个函数（高阶函数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">func, x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> func(x, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calculate(add, <span class="number">5</span>, <span class="number">6</span>))  <span class="comment"># 11（add作为参数传入）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 函数作为返回值（高阶函数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_operation</span>(<span class="params">op</span>):</span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> add</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a, b</span>):  <span class="comment"># 内部函数</span></span><br><span class="line">            <span class="keyword">return</span> a - b</span><br><span class="line">        <span class="keyword">return</span> sub</span><br><span class="line"></span><br><span class="line">f = get_operation(<span class="string">&quot;+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>, <span class="number">2</span>))  <span class="comment"># 5</span></span><br><span class="line">f = get_operation(<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>, <span class="number">2</span>))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 函数存储在列表中</span></span><br><span class="line">funcs = [add, <span class="keyword">lambda</span> x,y: x*y]</span><br><span class="line"><span class="built_in">print</span>(funcs[<span class="number">0</span>](<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(funcs[<span class="number">1</span>](<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）匿名函数（lambda）"><a href="#（2）匿名函数（lambda）" class="headerlink" title="（2）匿名函数（lambda）"></a>（2）匿名函数（lambda）</h3><ul>
<li><strong>定义</strong>：<ul>
<li>用 <strong>lambda 关键字</strong>创建的极简函数，<strong>无函数名（匿名）</strong>，仅适用于简单逻辑</li>
</ul>
</li>
<li><strong>语法</strong>：<ul>
<li>lambda 参数列表: 表达式（表达式结果就是返回值，无 return）</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li>lambda 匿名函数<strong>一定有返回值</strong>，「表达式」的计算结果会自动作为返回值</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li>临时使用的简单函数（如配合 map&#x2F;filter&#x2F;sorted）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础用法</span></span><br><span class="line">add = <span class="keyword">lambda</span> a, b: a + b</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配合map使用（批量计算）</span></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">result = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x*<span class="number">2</span>, nums))</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># [2,4,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配合sorted使用（自定义排序）</span></span><br><span class="line">students = [(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>), (<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>), (<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>)]</span><br><span class="line"><span class="comment"># 按年龄升序排序（取元组第二个元素）</span></span><br><span class="line">sorted_students = <span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_students)  <span class="comment"># [(&#x27;李四&#x27;,20), (&#x27;张三&#x27;,25), (&#x27;王五&#x27;,30)]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一定有返回值</span></span><br><span class="line"><span class="comment"># 1. 常规表达式，返回计算结果</span></span><br><span class="line">add = <span class="keyword">lambda</span> a, b: a + b</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment"># 输出 3（返回 a+b 的结果）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 无参数，返回固定值</span></span><br><span class="line">hello = <span class="keyword">lambda</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hello())  <span class="comment"># 输出 &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 表达式结果为 None（仍有返回值）</span></span><br><span class="line">empty = <span class="keyword">lambda</span> x: x <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(empty(-<span class="number">5</span>))  <span class="comment"># 输出 None（并非没有返回值）</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）闭包"><a href="#（3）闭包" class="headerlink" title="（3）闭包"></a>（3）闭包</h3><ul>
<li><strong>定义</strong>：<ul>
<li>内部函数引用外部函数的变量，且外部函数返回内部函数（形成“封闭环境”）；</li>
</ul>
</li>
<li><strong>核心</strong>：<ul>
<li><strong>保存外部函数的变量状态</strong>，即使外部函数执行完毕，变量仍可被内部函数访问；</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">num1</span>):</span><br><span class="line">    <span class="comment"># 外部函数变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">num2</span>):</span><br><span class="line">        <span class="comment"># 内部函数引用外部变量num1（闭包）</span></span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br><span class="line">    <span class="comment"># 返回内部函数</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建闭包实例（绑定num1=10）</span></span><br><span class="line">f = outer(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 调用内部函数（仍能访问num1=10）</span></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">5</span>))  <span class="comment"># 15</span></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">6</span>))  <span class="comment"># 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：“状态保持”</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> increment</span><br><span class="line"></span><br><span class="line">c = counter()</span><br><span class="line"><span class="built_in">print</span>(c())  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(c())  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(c())  <span class="comment"># 3（count 状态被保持）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 忘记使用 nonlocal 会报错</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counter_wrong</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">        count += <span class="number">1</span>  <span class="comment"># UnboundLocalError: &#x27;count&#x27; referenced before assignment</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> increment</span><br></pre></td></tr></table></figure>

<h3 id="（4）装饰器（闭包的核心应用）"><a href="#（4）装饰器（闭包的核心应用）" class="headerlink" title="（4）装饰器（闭包的核心应用）"></a>（4）装饰器（闭包的核心应用）</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="&lt;1&gt;介绍"></a>&lt;1&gt;介绍</h4><ul>
<li><strong>定义</strong>：<ul>
<li>在不修改原函数代码的前提下，为函数添加额外功能（如日志、计时、权限校验）</li>
</ul>
</li>
<li><strong>核心原理</strong>：<ul>
<li>装饰器本质是「高阶函数」（接收函数作为参数、返回函数作为结果），利用函数是一等对象的特性，通过“包装”原函数实现功能扩展，最终替换原函数的引用。</li>
</ul>
</li>
<li>可使用 <strong>@语法糖</strong>简化包装过程</li>
<li>**注！：**装饰器会导致原函数的 <strong>name</strong>、<strong>doc</strong> 丢失，实际开发中通常会加 <strong>@wraps</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 定义装饰器函数（logger_decorator是装饰器，接收原函数作为参数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger_decorator</span>(<span class="params">func</span>):  <span class="comment"># func：接收被装饰的原函数（如后续的add函数）</span></span><br><span class="line">    <span class="comment"># 2. 定义内部包装函数（wrapper是核心，负责添加额外功能+执行原函数）</span></span><br><span class="line">    <span class="comment"># *args, **kwargs：万能参数，确保能接收原函数的任意参数，保证装饰器通用性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 3. 前置额外功能：在原函数执行前执行（此处是打印调用日志）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;调用函数：<span class="subst">&#123;func.__name__&#125;</span>，参数：<span class="subst">&#123;args&#125;</span>, <span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 4. 执行原函数：调用传入的原函数func，传入接收的参数，获取返回值</span></span><br><span class="line">        result = func(*args, **kwargs)  <span class="comment"># 若原函数无返回值，result为None</span></span><br><span class="line">        <span class="comment"># 5. 后置额外功能：在原函数执行后执行（此处是打印返回值）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数返回值：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 6. 返回原函数的返回值：确保装饰后的函数与原函数返回值一致，不破坏原逻辑</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment"># 7. 装饰器返回包装函数：用wrapper替换原函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动包装（不推荐，推荐用 @语法糖）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_original</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="comment"># 手动完成装饰器的绑定：传入原函数→获取包装函数→重新赋值</span></span><br><span class="line">add_original = logger_decorator(add_original)</span><br><span class="line">add_original(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># 调用函数：add_original，参数：(10, 20), &#123;&#125;</span></span><br><span class="line"><span class="comment"># 函数返回值：30</span></span><br></pre></td></tr></table></figure>

<h4 id="语法糖"><a href="#语法糖" class="headerlink" title="&lt;2&gt;@语法糖"></a>&lt;2&gt;@语法糖</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义装饰器函数（logger_decorator是装饰器，接收原函数作为参数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger_decorator</span>(<span class="params">func</span>):  <span class="comment"># func：接收被装饰的原函数（如后续的add函数）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;调用函数：<span class="subst">&#123;func.__name__&#125;</span>，参数：<span class="subst">&#123;args&#125;</span>, <span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数返回值：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用@语法糖（简洁，推荐）</span></span><br><span class="line"><span class="meta">@logger_decorator  </span><span class="comment"># 等价于：add = logger_decorator(add)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):  <span class="comment"># 原函数：核心逻辑是计算两数之和，无额外功能</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<ul>
<li>当程序执行到 <strong>@装饰器名</strong> 时，会自动完成 3 步操作：<ul>
<li>1.先定义下方的原函数（如 add）</li>
<li>2.将原函数作为参数传入 @ 后面的装饰器函数（如 logger_decorator(add)）</li>
<li>3.把装饰器函数返回的「包装函数」（如 wrapper）重新赋值给原函数名（如 add &#x3D; wrapper）</li>
<li>最终效果：后续调用原函数名（如 add(10,20)），实际调用的是装饰器返回的包装函数。</li>
</ul>
</li>
<li><strong>@语法的核心优势</strong>：<ul>
<li><strong>简洁性</strong>：无需手动写“原函数 &#x3D; 装饰器(原函数)”的赋值语句，一行 @装饰器名 即可完成装饰器绑定；</li>
<li><strong>可读性</strong>：装饰器与原函数的关联关系直观，一眼就能看出“该函数被哪个装饰器增强”；</li>
<li><strong>可叠加性</strong>：支持多个装饰器叠加使用（按从上到下的顺序依次装饰）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">等价于：func = decorator1(decorator2(func))</span><br></pre></td></tr></table></figure>

<h4 id="wraps的使用"><a href="#wraps的使用" class="headerlink" title="&lt;3&gt;@wraps的使用"></a>&lt;3&gt;@wraps的使用</h4><ul>
<li>在上述基础装饰器中，存在一个隐藏问题：<ul>
<li>装饰后的函数（如被装饰的add），其原始信息（如函数名__name__、文档字符串__doc__）会被包装函数wrapper覆盖，这会影响依赖函数原始信息的场景（如查看文档、反射等）</li>
</ul>
</li>
<li><strong>@wraps 的核心作用</strong>：<ul>
<li>将原函数的元信息（函数名、文档字符串等）复制到包装函数中，保留原函数的身份信息。</li>
</ul>
</li>
</ul>
<h5 id="1）问题演示（未使用-wraps）"><a href="#1）问题演示（未使用-wraps）" class="headerlink" title="1）问题演示（未使用@wraps）"></a>1）问题演示（未使用@wraps）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logger_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;调用函数：<span class="subst">&#123;func.__name__&#125;</span>&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算两个数的和&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看装饰后函数的信息（被wrapper覆盖）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;函数名：<span class="subst">&#123;add.__name__&#125;</span>&quot;</span>)  <span class="comment"># 输出：wrapper（期望是add）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文档字符串：<span class="subst">&#123;add.__doc__&#125;</span>&quot;</span>)  <span class="comment"># 输出：None（期望是“计算两个数的和”）</span></span><br></pre></td></tr></table></figure>

<h5 id="2）-wraps的使用方法（解决问题）"><a href="#2）-wraps的使用方法（解决问题）" class="headerlink" title="2）@wraps的使用方法（解决问题）"></a>2）@wraps的使用方法（解决问题）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  <span class="comment"># 必须导入wraps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)  </span><span class="comment"># 关键：将func的元信息复制到wrapper</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;调用函数：<span class="subst">&#123;func.__name__&#125;</span>&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算两个数的和&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看函数信息（已保留原函数信息）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;函数名：<span class="subst">&#123;add.__name__&#125;</span>&quot;</span>)  <span class="comment"># 输出：add（正确）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文档字符串：<span class="subst">&#123;add.__doc__&#125;</span>&quot;</span>)  <span class="comment"># 输出：计算两个数的和（正确）</span></span><br></pre></td></tr></table></figure>

<h2 id="9-函数的实战技巧"><a href="#9-函数的实战技巧" class="headerlink" title="9.函数的实战技巧"></a>9.函数的实战技巧</h2><h3 id="（1）文档字符串（规范写法）"><a href="#（1）文档字符串（规范写法）" class="headerlink" title="（1）文档字符串（规范写法）"></a>（1）文档字符串（规范写法）</h3><p>技巧意义：提升代码可维护性与可读性，方便使用者快速了解函数信息，适配团队协作与规范化开发。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算两个数的和</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        a (int/float)：第一个数</span></span><br><span class="line"><span class="string">        b (int/float)：第二个数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">        int/float：两个数的和</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文档字符串</span></span><br><span class="line"><span class="built_in">print</span>(add.__doc__)</span><br><span class="line"><span class="built_in">help</span>(add)  <span class="comment"># 更清晰的格式</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）函数注解"><a href="#（2）函数注解" class="headerlink" title="（2）函数注解"></a>（2）函数注解</h3><ul>
<li><strong>定义</strong>：为参数&#x2F;返回值添加类型提示（<strong>仅提示，不强制校验</strong>）</li>
<li><strong>作用</strong>：提高代码可读性，配合IDE自动提示，明确参数与返回值类型，降低传参错误，提升开发效率，支持静态类型校验。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注解格式：参数: 类型，返回值 -&gt; 类型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注解不影响执行（传入字符串也能运行）</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>))  <span class="comment"># helloworld</span></span><br><span class="line"><span class="comment"># 查看注解</span></span><br><span class="line"><span class="built_in">print</span>(add.__annotations__)  <span class="comment"># &#123;&#x27;a&#x27;: int, &#x27;b&#x27;: int, &#x27;return&#x27;: int&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）偏函数（functools-partial）"><a href="#（3）偏函数（functools-partial）" class="headerlink" title="（3）偏函数（functools.partial）"></a>（3）偏函数（functools.partial）</h3><ul>
<li><strong>定义</strong>：<ul>
<li>偏函数是 Python functools 模块提供的工具，用于固定原函数的部分参数（位置参数或关键字参数），生成一个参数更少的新函数</li>
<li>新函数调用时只需传入剩余未固定的参数，即可完成原函数的逻辑执行，核心价值是简化重复场景下的函数调用</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 导入偏函数工具（必须）</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 偏函数核心语法格式</span></span><br><span class="line">新函数名 = partial(原函数名, 固定参数<span class="number">1</span>=值<span class="number">1</span>, 固定参数<span class="number">2</span>=值<span class="number">2</span>, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法说明：</span></span><br><span class="line"><span class="comment"># - 原函数名：需要被固定参数的原始函数</span></span><br><span class="line"><span class="comment"># - 固定参数：可指定原函数的任意位置参数（按顺序固定）或关键字参数（按参数名固定）</span></span><br><span class="line"><span class="comment"># - 新函数名：生成的简化版函数，调用时传入剩余参数即可</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1：固定关键字参数c=10，生成新函数add_10</span></span><br><span class="line">add_10 = partial(add, c=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(add_10(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 13（1+2+10）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：固定位置参数a=5，生成新函数add_5</span></span><br><span class="line">add_5 = partial(add, <span class="number">5</span>)  <span class="comment"># 按位置固定第一个参数a</span></span><br><span class="line"><span class="built_in">print</span>(add_5(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 10（5+2+3）</span></span><br></pre></td></tr></table></figure>

<h2 id="10-常用高阶辅助函数"><a href="#10-常用高阶辅助函数" class="headerlink" title="10.常用高阶辅助函数"></a>10.常用高阶辅助函数</h2><p>高阶函数是指“接收函数作为参数”或“返回函数作为结果”的函数，是 Python 函数式编程的核心，常<strong>与匿名函数（lambda）配合</strong>，提升代码简洁性和可读性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260110231245247.png"></p>
<h3 id="（1）enumerate-：索引-元素对-迭代"><a href="#（1）enumerate-：索引-元素对-迭代" class="headerlink" title="（1）enumerate()：索引-元素对 迭代"></a>（1）enumerate()：索引-元素对 迭代</h3><ul>
<li><p><strong>定义</strong>：</p>
<ul>
<li>遍历可迭代对象时，<strong>同时返回元素的“索引”和“对应值”</strong>，将两者打包为元组序列，返回迭代器（需用 list&#x2F;tuple 转换查看）</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<ul>
<li>enumerate(可迭代对象, start&#x3D;0)；</li>
</ul>
</li>
<li><p><strong>核心特点</strong>：</p>
<ul>
<li>索引起始值默认 0，可通过 start 参数自定义（如 start&#x3D;1 实现序号从 1 开始）；</li>
<li>返回枚举迭代器，节省内存，遍历效率高于手动维护索引（如 i&#x3D;0; for x in lst: …; i+&#x3D;1）；</li>
<li>适用于需要同时获取“位置”和“元素值”的场景（如列表遍历标序号）。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础用法：默认索引从0开始</span></span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, fruit <span class="keyword">in</span> <span class="built_in">enumerate</span>(fruits):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;索引<span class="subst">&#123;idx&#125;</span>：<span class="subst">&#123;fruit&#125;</span>&quot;</span>)  <span class="comment"># 输出：索引0：apple；索引1：banana；索引2：pear；索引3：orange</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法：自定义索引起始值（适合生成序号）</span></span><br><span class="line"><span class="keyword">for</span> seq, fruit <span class="keyword">in</span> <span class="built_in">enumerate</span>(fruits, start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;序号<span class="subst">&#123;seq&#125;</span>：<span class="subst">&#123;fruit&#125;</span>&quot;</span>)  <span class="comment"># 输出：序号1：apple；序号2：banana；序号3：pear；序号4：orange</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为列表查看完整结果</span></span><br><span class="line">enum_result = <span class="built_in">list</span>(<span class="built_in">enumerate</span>(fruits))</span><br><span class="line"><span class="built_in">print</span>(enum_result)  <span class="comment"># 输出：[(0, &#x27;apple&#x27;), (1, &#x27;banana&#x27;), (2, &#x27;pear&#x27;), (3, &#x27;orange&#x27;)]</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）zip-：多序列元素打包"><a href="#（2）zip-：多序列元素打包" class="headerlink" title="（2）zip()：多序列元素打包"></a>（2）zip()：多序列元素打包</h3><ul>
<li><strong>定义</strong>：<ul>
<li>将多个可迭代对象（列表、元组等）的**“对应位置”<strong>元素打包为</strong>元组**，返回迭代器</li>
<li>当多个序列长度不一致时，以最短的序列为准停止打包</li>
</ul>
</li>
<li><strong>语法</strong>：<ul>
<li>zip(可迭代对象1, 可迭代对象2, …)</li>
</ul>
</li>
<li><strong>核心特点</strong>：<ul>
<li>支持任意数量的可迭代对象（如 2 个、3 个甚至更多）</li>
<li>返回 zip 迭代器，需用 list&#x2F;tuple 转换查看具体元素</li>
<li>可通过 * 运算符解包 zip 结果，<strong>内容</strong>上能还原原始序列的元素，但<strong>类型</strong>上得到的是<strong>元组</strong><ul>
<li><strong>注意：返回的是“元组”！</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础用法1：打包两个序列（长度一致）并循环处理结果</span></span><br><span class="line">names = [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>]</span><br><span class="line">ages = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">28</span>]</span><br><span class="line">user_info = <span class="built_in">zip</span>(names, ages)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景1：循环遍历打包结果，批量处理用户信息</span></span><br><span class="line"><span class="keyword">for</span> name, age <span class="keyword">in</span> user_info:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;用户：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>，是否成年：<span class="subst">&#123;age &gt;= <span class="number">18</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 用户：张三，年龄：25，是否成年：True</span></span><br><span class="line"><span class="comment"># 用户：李四，年龄：30，是否成年：True</span></span><br><span class="line"><span class="comment"># 用户：王五，年龄：28，是否成年：True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法1：打包多个序列（以最短为准）并转换为列表用于后续操作</span></span><br><span class="line">scores = [<span class="number">85</span>, <span class="number">92</span>]  <span class="comment"># 长度比 names/ages 短</span></span><br><span class="line">user_detail = <span class="built_in">zip</span>(names, ages, scores)</span><br><span class="line">detail_list = <span class="built_in">list</span>(user_detail)  <span class="comment"># 转换为列表便于多次使用（迭代器只能遍历一次）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景2：根据打包数据生成用户成绩字典</span></span><br><span class="line">score_dict = &#123;name: (age, score) <span class="keyword">for</span> name, age, score <span class="keyword">in</span> detail_list&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户成绩字典：&quot;</span>, score_dict)</span><br><span class="line"><span class="comment"># 输出：用户成绩字典： &#123;&#x27;张三&#x27;: (25, 85), &#x27;李四&#x27;: (30, 92)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法2：解包zip结果（核心修改：元组转列表，支持修改）</span></span><br><span class="line">packed = <span class="built_in">zip</span>(names, ages)</span><br><span class="line">unpacked_names, unpacked_ages = <span class="built_in">zip</span>(*packed)  <span class="comment"># 解包得到元组</span></span><br><span class="line"><span class="comment"># 关键步骤：将不可变的元组转为可变的列表</span></span><br><span class="line">unpacked_names_list = <span class="built_in">list</span>(unpacked_names)</span><br><span class="line">unpacked_ages_list = <span class="built_in">list</span>(unpacked_ages)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景3：解包后批量更新序列数据（列表可直接修改）</span></span><br><span class="line"><span class="comment"># 方式1：列表推导式生成新列表（推荐）</span></span><br><span class="line">updated_ages = [age + <span class="number">1</span> <span class="keyword">for</span> age <span class="keyword">in</span> unpacked_ages_list]  <span class="comment"># 所有人年龄+1</span></span><br><span class="line"><span class="comment"># 方式2：直接修改原列表（按需选择）</span></span><br><span class="line"><span class="comment"># unpacked_ages_list[0] = 100  # 直接修改张三的年龄为100</span></span><br><span class="line"></span><br><span class="line">updated_user_info = <span class="built_in">zip</span>(unpacked_names_list, updated_ages)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;年龄更新后的数据：&quot;</span>, <span class="built_in">list</span>(updated_user_info))</span><br><span class="line"><span class="comment"># 输出：年龄更新后的数据： [(&#x27;张三&#x27;, 26), (&#x27;李四&#x27;, 31), (&#x27;王五&#x27;, 29)]</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）sorted-：通用排序"><a href="#（3）sorted-：通用排序" class="headerlink" title="（3）sorted()：通用排序"></a>（3）sorted()：通用排序</h3><ul>
<li><strong>定义</strong>：<ul>
<li>对任意可迭代对象（列表、元组、字符串等）<strong>按指定规则排序</strong>，返回“新的排序列表”，不会修改原可迭代对象</li>
</ul>
</li>
<li><strong>语法</strong>：<ul>
<li>sorted(可迭代对象, key&#x3D;None, reverse&#x3D;False)</li>
</ul>
</li>
<li><strong>核心特点</strong>：<ul>
<li><strong>key 参数</strong>：<ul>
<li>接收函数作为参数，用于自定义排序规则（如按字符串长度、字典某字段排序）</li>
</ul>
</li>
<li><strong>reverse 参数</strong>：<ul>
<li>控制排序方向，默认 False（升序），True 为降序</li>
</ul>
</li>
<li><strong>通用性强</strong>：可用于所有可迭代对象（区别于列表的 sort() 方法，sort() 仅适用于列表且修改原列表）。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 基础用法：默认升序排序，后续用于计算排序后列表的总和</span></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">sorted_nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line"><span class="built_in">print</span>(sorted_nums)  <span class="comment"># 输出：[1, 1, 2, 3, 4, 5, 9]</span></span><br><span class="line"><span class="built_in">print</span>(nums)         <span class="comment"># 输出：[3, 1, 4, 1, 5, 9, 2]（原列表未修改）</span></span><br><span class="line"><span class="comment"># 实际使用：计算排序后列表的总和</span></span><br><span class="line">sorted_sum = <span class="built_in">sum</span>(sorted_nums)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;排序后列表的总和：<span class="subst">&#123;sorted_sum&#125;</span>&quot;</span>)  <span class="comment"># 输出：排序后列表的总和：25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法1：降序排序，后续用于筛选前3个最大值</span></span><br><span class="line">desc_nums = <span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(desc_nums)    <span class="comment"># 输出：[9, 5, 4, 3, 2, 1, 1]</span></span><br><span class="line"><span class="comment"># 实际使用：筛选前3个最大值并组成新列表</span></span><br><span class="line">top3_nums = desc_nums[:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表中的前3个最大值：<span class="subst">&#123;top3_nums&#125;</span>&quot;</span>)  <span class="comment"># 输出：列表中的前3个最大值：[9, 5, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法2：自定义排序规则（按字符串长度排序），后续用于构建长度映射字典</span></span><br><span class="line">strs = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;grape&quot;</span>]</span><br><span class="line">sorted_strs = <span class="built_in">sorted</span>(strs, key=<span class="built_in">len</span>)  <span class="comment"># key=len 表示按字符串长度排序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_strs)  <span class="comment"># 输出：[&#x27;pear&#x27;, &#x27;apple&#x27;, &#x27;grape&#x27;, &#x27;banana&#x27;]（长度：4→5→5→6）</span></span><br><span class="line"><span class="comment"># 实际使用：构建字符串与对应长度的映射字典</span></span><br><span class="line">str_len_dict = &#123;s: <span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> sorted_strs&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串-长度映射字典：<span class="subst">&#123;str_len_dict&#125;</span>&quot;</span>)  <span class="comment"># 输出：字符串-长度映射字典：&#123;&#x27;pear&#x27;:4, &#x27;apple&#x27;:5, &#x27;grape&#x27;:5, &#x27;banana&#x27;:6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法3：按字典字段排序，后续用于提取排序后的姓名列表</span></span><br><span class="line">users = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;]</span><br><span class="line">sorted_users = <span class="built_in">sorted</span>(users, key=<span class="keyword">lambda</span> x: x[<span class="string">&quot;age&quot;</span>])  <span class="comment"># 按 age 字段升序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_users)  <span class="comment"># 输出：[&#123;&#x27;name&#x27;: &#x27;李四&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 25&#125;, &#123;&#x27;name&#x27;: &#x27;王五&#x27;, &#x27;age&#x27;: 30&#125;]</span></span><br><span class="line"><span class="comment"># 实际使用：提取排序后的姓名，生成有序姓名列表</span></span><br><span class="line">sorted_names = [user[<span class="string">&quot;name&quot;</span>] <span class="keyword">for</span> user <span class="keyword">in</span> sorted_users]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;按年龄升序的姓名列表：<span class="subst">&#123;sorted_names&#125;</span>&quot;</span>)  <span class="comment"># 输出：按年龄升序的姓名列表：[&#x27;李四&#x27;, &#x27;张三&#x27;, &#x27;王五&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）max-min-：最值获取"><a href="#（4）max-min-：最值获取" class="headerlink" title="（4）max() &#x2F; min()：最值获取"></a>（4）max() &#x2F; min()：最值获取</h3><ul>
<li><strong>定义</strong>：<ul>
<li>max() 用于获取可迭代对象或多个零散参数的“最大值”</li>
<li>min() 用于获取“最小值”</li>
</ul>
</li>
<li><strong>语法</strong>：<ul>
<li>max(可迭代对象&#x2F;参数组, key&#x3D;None)</li>
<li>min(可迭代对象&#x2F;参数组, key&#x3D;None)</li>
</ul>
</li>
<li><strong>核心特点</strong>：<ul>
<li>支持两种传参方式：<ul>
<li>直接传多个零散参数： 如max(2,5,1)</li>
<li>传一个可迭代对象：如max([2,5,1])</li>
</ul>
</li>
<li><strong>key 参数</strong>：<ul>
<li>接收函数作为参数，自定义比较规则（如按字符串长度找最长&#x2F;最短字符串）</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li>单个最值（非迭代器），若可迭代对象为空则报错（需注意边界处理）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础用法1：对可迭代对象取最值</span></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(nums))  <span class="comment"># 输出：5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(nums))  <span class="comment"># 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础用法2：对多个零散参数取最值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>))  <span class="comment"># 输出：7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>))  <span class="comment"># 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法：自定义比较规则（按字符串长度找最值）</span></span><br><span class="line">strs = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>]</span><br><span class="line">longest_str = <span class="built_in">max</span>(strs, key=<span class="built_in">len</span>)  <span class="comment"># 最长字符串</span></span><br><span class="line">shortest_str = <span class="built_in">min</span>(strs, key=<span class="built_in">len</span>)  <span class="comment"># 最短字符串</span></span><br><span class="line"><span class="built_in">print</span>(longest_str)  <span class="comment"># 输出：banana</span></span><br><span class="line"><span class="built_in">print</span>(shortest_str) <span class="comment"># 输出：pear</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法2：按字典字段找最值</span></span><br><span class="line">users = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">85</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">92</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">78</span>&#125;]</span><br><span class="line">max_score_user = <span class="built_in">max</span>(users, key=<span class="keyword">lambda</span> x: x[<span class="string">&quot;score&quot;</span>])</span><br><span class="line">min_score_user = <span class="built_in">min</span>(users, key=<span class="keyword">lambda</span> x: x[<span class="string">&quot;score&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(max_score_user)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;李四&#x27;, &#x27;score&#x27;: 92&#125;</span></span><br><span class="line"><span class="built_in">print</span>(min_score_user)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;王五&#x27;, &#x27;score&#x27;: 78&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）any-all-：布尔值判断"><a href="#（5）any-all-：布尔值判断" class="headerlink" title="（5）any() &#x2F; all()：布尔值判断"></a>（5）any() &#x2F; all()：布尔值判断</h3><ul>
<li><p><strong>定义</strong>：</p>
<ul>
<li>any() 和 all() 用于判断可迭代对象中元素的布尔值状态，返回单个布尔值；</li>
<li><strong>any()</strong>：<ul>
<li>可迭代对象中**“任一元素为 True”则返回 True**，否则返回 False；</li>
</ul>
</li>
<li><strong>all()</strong>：<ul>
<li>可迭代对象中**“所有元素为 True”才返回 True**，否则返回 False。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<ul>
<li>any(可迭代对象)；</li>
<li>all(可迭代对象)；</li>
</ul>
</li>
<li><p><strong>核心特点</strong>：</p>
<ul>
<li>短路求值：<ul>
<li>any() 找到第一个 True 就停止遍历，all() 找到第一个 False 就停止遍历，效率高；</li>
</ul>
</li>
<li>空可迭代对象<strong>特殊处理</strong>：<ul>
<li>any(空序列) 返回 False，<strong>all(空序列) 返回 True</strong>（逻辑上理解为”不存在 False 的元素”，即”没有反例”）</li>
</ul>
</li>
<li>仅关注布尔值：<ul>
<li>不处理元素本身，仅判断元素的“真值”（0、空字符串、空列表等为 False，非空&#x2F;非0为 True）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础用法：any() 判断“任一为真”</span></span><br><span class="line">list1 = [<span class="literal">False</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>]  <span class="comment"># 存在 &quot;hello&quot;（True）</span></span><br><span class="line">list2 = [<span class="literal">False</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>]           <span class="comment"># 所有元素均为 False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(list1))  <span class="comment"># 输出：True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(list2))  <span class="comment"># 输出：False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础用法：all() 判断“所有为真”</span></span><br><span class="line">list3 = [<span class="literal">True</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>]  <span class="comment"># 所有元素均为 True</span></span><br><span class="line">list4 = [<span class="literal">True</span>, <span class="number">1</span>, <span class="string">&quot;&quot;</span>]       <span class="comment"># 存在 &quot;&quot;（False）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(list3))  <span class="comment"># 输出：True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(list4))  <span class="comment"># 输出：False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法：空序列处理</span></span><br><span class="line">empty_list = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(empty_list))  <span class="comment"># 输出：False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(empty_list))  <span class="comment"># 输出：True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实战场景：判断列表是否存在负数</span></span><br><span class="line">nums = [<span class="number">3</span>, -<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">has_negative = <span class="built_in">any</span>(num &lt; <span class="number">0</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line"><span class="built_in">print</span>(has_negative)  <span class="comment"># 输出：True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实战场景：判断列表所有元素均为正数</span></span><br><span class="line">all_positive = <span class="built_in">all</span>(num &gt; <span class="number">0</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line"><span class="built_in">print</span>(all_positive)  <span class="comment"># 输出：False</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）filter-：元素筛选"><a href="#（6）filter-：元素筛选" class="headerlink" title="（6）filter()：元素筛选"></a>（6）filter()：元素筛选</h3><ul>
<li><strong>定义</strong>：<ul>
<li>接收一个“筛选函数”和一个可迭代对象，遍历可迭代对象的每个元素，<strong>保留“筛选函数返回 True”的元素</strong>，返回迭代器（需用 list&#x2F;tuple 转换查看结果）；</li>
</ul>
</li>
<li><strong>语法</strong>：<ul>
<li>filter(筛选函数, 可迭代对象)；</li>
</ul>
</li>
<li><strong>核心特点</strong>：<ul>
<li>筛选函数可为 None：此时直接判断元素自身的布尔值（保留 True 的元素）；</li>
<li>返回 filter 迭代器，节省内存，仅在遍历&#x2F;转换时才执行筛选；</li>
<li>仅保留符合条件的“原始元素”，不修改元素本身。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础用法1：自定义筛选函数（筛选偶数）</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>  <span class="comment"># 偶数返回 True，奇数返回 False</span></span><br><span class="line"></span><br><span class="line">even_nums = <span class="built_in">filter</span>(is_even, nums)</span><br><span class="line">even_list = <span class="built_in">list</span>(even_nums)  <span class="comment"># 转换为列表便于后续使用</span></span><br><span class="line"><span class="comment"># 使用筛选结果进行后续计算（求偶数和）</span></span><br><span class="line">even_sum = <span class="built_in">sum</span>(even_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;筛选出的偶数列表：<span class="subst">&#123;even_list&#125;</span>&quot;</span>)  <span class="comment"># 输出：[2, 4, 6, 8]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;偶数列表的和：<span class="subst">&#123;even_sum&#125;</span>&quot;</span>)  <span class="comment"># 输出：20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础用法2：筛选函数为 None（保留非空元素）</span></span><br><span class="line">strs = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;&quot;</span>]</span><br><span class="line">non_empty_strs = <span class="built_in">filter</span>(<span class="literal">None</span>, strs)</span><br><span class="line">non_empty_list = <span class="built_in">list</span>(non_empty_strs)</span><br><span class="line"><span class="comment"># 使用筛选结果构建字典（姓名-序号映射）</span></span><br><span class="line">name_dict = &#123;name: idx+<span class="number">1</span> <span class="keyword">for</span> idx, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(non_empty_list)&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;非空姓名列表：<span class="subst">&#123;non_empty_list&#125;</span>&quot;</span>)  <span class="comment"># 输出：[&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;姓名序号字典：<span class="subst">&#123;name_dict&#125;</span>&quot;</span>)  <span class="comment"># 输出：&#123;&#x27;张三&#x27;: 1, &#x27;李四&#x27;: 2, &#x27;王五&#x27;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法：结合 lambda 简化筛选（筛选年龄大于25的用户）</span></span><br><span class="line">users = [(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>), (<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>), (<span class="string">&quot;王五&quot;</span>, <span class="number">28</span>), (<span class="string">&quot;赵六&quot;</span>, <span class="number">22</span>)]</span><br><span class="line">adult_users = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x[<span class="number">1</span>] &gt; <span class="number">25</span>, users)</span><br><span class="line">adult_list = <span class="built_in">list</span>(adult_users)</span><br><span class="line"><span class="comment"># 使用筛选结果提取姓名，生成成年用户名单</span></span><br><span class="line">adult_names = [user[<span class="number">0</span>] <span class="keyword">for</span> user <span class="keyword">in</span> adult_list]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成年用户列表：<span class="subst">&#123;adult_list&#125;</span>&quot;</span>)  <span class="comment"># 输出：[(&#x27;李四&#x27;, 30), (&#x27;王五&#x27;, 28)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成年用户名单：<span class="subst">&#123;adult_names&#125;</span>&quot;</span>)  <span class="comment"># 输出：[&#x27;李四&#x27;, &#x27;王五&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="（7）map-：元素映射转换"><a href="#（7）map-：元素映射转换" class="headerlink" title="（7）map()：元素映射转换"></a>（7）map()：元素映射转换</h3><ul>
<li><strong>定义</strong>：<ul>
<li>接收一个“映射函数”和一个&#x2F;多个可迭代对象，对可迭代对象的<strong>每个元素“应用”映射函数</strong>，将函数执行结果作为新元素，返回迭代器（需用 list&#x2F;tuple 转换查看）</li>
</ul>
</li>
<li><strong>语法</strong>：<ul>
<li>map(映射函数, 可迭代对象1, 可迭代对象2, …)</li>
</ul>
</li>
<li><strong>核心特点</strong>：<ul>
<li>映射函数可为普通函数、匿名函数（lambda），也可为内置函数（如 int、str）</li>
<li>支持多个可迭代对象：映射函数需接收对应数量的参数，以最短的可迭代对象为准停止；</li>
<li>返回 map 迭代器，元素为映射函数的执行结果（实现元素的批量转换）。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 基础用法1：单个可迭代对象（元素批量乘2，后续用于求和计算）</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">double_nums = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, nums)</span><br><span class="line">double_list = <span class="built_in">list</span>(double_nums)  <span class="comment"># 转换为列表便于后续使用</span></span><br><span class="line"><span class="comment"># 实际使用：计算翻倍后的总和</span></span><br><span class="line">double_sum = <span class="built_in">sum</span>(double_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元素翻倍列表：<span class="subst">&#123;double_list&#125;</span>&quot;</span>)  <span class="comment"># 输出：[2, 4, 6, 8, 10]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;翻倍后总和：<span class="subst">&#123;double_sum&#125;</span>&quot;</span>)  <span class="comment"># 输出：30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础用法2：多个可迭代对象（两列表元素对应相加，后续用于筛选大于30的结果）</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">list2 = [<span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>]  <span class="comment"># 长度较短，以该列表为准停止</span></span><br><span class="line">sum_list = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y, list1, list2)</span><br><span class="line">sum_result = <span class="built_in">list</span>(sum_list)</span><br><span class="line"><span class="comment"># 实际使用：筛选相加结果大于30的数据</span></span><br><span class="line">filtered_sum = [num <span class="keyword">for</span> num <span class="keyword">in</span> sum_result <span class="keyword">if</span> num &gt; <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;两列表对应相加结果：<span class="subst">&#123;sum_result&#125;</span>&quot;</span>)  <span class="comment"># 输出：[15, 35, 55]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;相加结果中大于30的数：<span class="subst">&#123;filtered_sum&#125;</span>&quot;</span>)  <span class="comment"># 输出：[35, 55]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法：内置函数作为映射函数（字符串转整数，后续用于求平均值）</span></span><br><span class="line">str_nums = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>]</span><br><span class="line">int_nums = <span class="built_in">map</span>(<span class="built_in">int</span>, str_nums)</span><br><span class="line">int_list = <span class="built_in">list</span>(int_nums)</span><br><span class="line"><span class="comment"># 实际使用：计算转换后的整数平均值</span></span><br><span class="line">average = <span class="built_in">sum</span>(int_list) / <span class="built_in">len</span>(int_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串转整数列表：<span class="subst">&#123;int_list&#125;</span>&quot;</span>)  <span class="comment"># 输出：[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;整数列表的平均值：<span class="subst">&#123;average&#125;</span>&quot;</span>)  <span class="comment"># 输出：3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法：自定义函数实现多元素转换（格式化用户信息，后续用于生成用户列表）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_user</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">names = [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>]</span><br><span class="line">ages = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">28</span>]</span><br><span class="line">formatted_users = <span class="built_in">map</span>(format_user, names, ages)</span><br><span class="line">formatted_list = <span class="built_in">list</span>(formatted_users)</span><br><span class="line"><span class="comment"># 实际使用：将格式化后的用户信息写入模拟文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;user_info.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> formatted_list:</span><br><span class="line">        f.write(user + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;格式化用户信息列表：<span class="subst">&#123;formatted_list&#125;</span>&quot;</span>)  <span class="comment"># 输出：[&#x27;姓名：张三，年龄：25&#x27;, &#x27;姓名：李四，年龄：30&#x27;, &#x27;姓名：王五，年龄：28&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户信息已写入 user_info.txt 文件&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（8）reduce-：累积计算"><a href="#（8）reduce-：累积计算" class="headerlink" title="（8）reduce()：累积计算"></a>（8）reduce()：累积计算</h3><ul>
<li><strong>定义</strong>：<ul>
<li>接收一个“累积函数”和一个可迭代对象，从左到右遍历可迭代对象，将前两个元素的计算结果与下一个元素继续累积，最终返回“单个累积结果”（非迭代器）；</li>
</ul>
</li>
<li><strong>语法</strong>：<ul>
<li>reduce(func, iterable[, initial])</li>
<li>需从 functools 模块导入</li>
</ul>
</li>
<li><strong>核心特点</strong>：<ul>
<li>必须导入：<ul>
<li>reduce() 不在 Python 内置函数中，需通过 <strong>from functools import reduce</strong> 导入；</li>
</ul>
</li>
<li>initial 参数（可选）：<ul>
<li>为累积计算设置初始值（初始值将参与第一次计算，如 initial&#x3D;10 时，先计算 10+第一个元素）；</li>
</ul>
</li>
<li>累积函数要求：<ul>
<li>必须接收两个参数（前一次累积结果和当前元素），返回新的累积结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础用法1：累积求和</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">sum_result = reduce(<span class="keyword">lambda</span> x, y: x + y, nums)</span><br><span class="line"><span class="built_in">print</span>(sum_result)  <span class="comment"># 输出：15（计算过程：((((1+2)+3)+4)+5)）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础用法2：累积求积</span></span><br><span class="line">product_result = reduce(<span class="keyword">lambda</span> x, y: x * y, nums)</span><br><span class="line"><span class="built_in">print</span>(product_result)  <span class="comment"># 输出：120（计算过程：((((1*2)*3)*4)*5)）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法：设置初始值（初始值参与第一次计算）</span></span><br><span class="line">sum_with_init = reduce(<span class="keyword">lambda</span> x, y: x + y, nums, <span class="number">10</span>)  <span class="comment"># 初始值10</span></span><br><span class="line"><span class="built_in">print</span>(sum_with_init)  <span class="comment"># 输出：25（计算过程：(((((10+1)+2)+3)+4)+5)）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶用法：自定义累积函数（拼接字符串）</span></span><br><span class="line">strs = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;World&quot;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">concat_str</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">final_str = reduce(concat_str, strs)</span><br><span class="line"><span class="built_in">print</span>(final_str)  <span class="comment"># 输出：Hello Python World</span></span><br></pre></td></tr></table></figure>

<h1 id="九、类"><a href="#九、类" class="headerlink" title="九、类"></a>九、类</h1><h2 id="1-类的基础概念和定义"><a href="#1-类的基础概念和定义" class="headerlink" title="1.类的基础概念和定义"></a>1.类的基础概念和定义</h2><h3 id="（1）核心概念"><a href="#（1）核心概念" class="headerlink" title="（1）核心概念"></a>（1）核心概念</h3><ul>
<li><strong>类（class）</strong>：是对一类具有相同属性和方法的对象的抽象描述，相当于一个“模板”。<ul>
<li>例如，“动物”类可以抽象出所有动物共有的属性（如名字、年龄）和方法（如进食、移动）。</li>
</ul>
</li>
<li><strong>对象（object）</strong>：是类的实例化结果，是具体的实体。<ul>
<li>例如，“一只名叫旺财的狗”是“动物”类的一个对象，具备具体的名字（旺财）和年龄（3岁）。</li>
</ul>
</li>
<li><strong>面向对象三大特征</strong>：封装、继承、多态，是类设计的核心思想。</li>
</ul>
<h3 id="（2）类的定义语法"><a href="#（2）类的定义语法" class="headerlink" title="（2）类的定义语法"></a>（2）类的定义语法</h3><p>使用 <strong>class</strong> 关键字定义类，基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">父类列表</span>):  <span class="comment"># 父类列表可选，默认继承object（Python3中所有类的基类）</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;类的文档字符串（用于说明类的功能）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 类属性（属于类本身，所有实例共享）</span></span><br><span class="line">    类属性名 = 属性值</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构造方法（初始化实例属性）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, 参数列表</span>):</span><br><span class="line">        <span class="comment"># 实例属性（属于单个实例，每个实例独立）</span></span><br><span class="line">        <span class="variable language_">self</span>.实例属性名 = 参数值</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类的方法（用于操作属性、实现功能）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self, 参数列表</span>):</span><br><span class="line">        方法体</span><br><span class="line">        <span class="keyword">return</span> 返回值</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化对象（创建类的具体实体）</span></span><br><span class="line">对象名 = 类名(参数列表)  <span class="comment"># 参数列表对应__init__方法的参数（除self外）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义Animal类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;动物类，封装动物的基本属性和行为&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 类属性：所有动物共有的属性（如所属界别）</span></span><br><span class="line">    kingdom = <span class="string">&quot;动物界&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构造方法：初始化实例属性（名字、年龄）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="comment"># self：必须作为第一个参数，指代当前实例本身</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 实例属性：名字</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age    <span class="comment"># 实例属性：年龄</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例方法：动物的行为（进食）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, food</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>（<span class="subst">&#123;self.age&#125;</span>岁）正在吃<span class="subst">&#123;food&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例方法：动物的行为（移动）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>正在移动&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 实例化对象（创建具体的动物）</span></span><br><span class="line">dog = Animal(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>)  <span class="comment"># dog是Animal类的一个实例</span></span><br><span class="line">cat = Animal(<span class="string">&quot;咪宝&quot;</span>, <span class="number">2</span>)  <span class="comment"># cat是另一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 访问类属性（所有实例共享）</span></span><br><span class="line"><span class="built_in">print</span>(Animal.kingdom)  <span class="comment"># 输出：动物界</span></span><br><span class="line"><span class="built_in">print</span>(dog.kingdom)     <span class="comment"># 输出：动物界（实例可访问类属性）</span></span><br><span class="line"><span class="built_in">print</span>(cat.kingdom)     <span class="comment"># 输出：动物界</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 访问实例属性（每个实例独立）</span></span><br><span class="line"><span class="built_in">print</span>(dog.name)  <span class="comment"># 输出：旺财</span></span><br><span class="line"><span class="built_in">print</span>(cat.name)  <span class="comment"># 输出：咪宝</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 调用实例方法</span></span><br><span class="line">dog.eat(<span class="string">&quot;骨头&quot;</span>)  <span class="comment"># 输出：旺财（3岁）正在吃骨头</span></span><br><span class="line">cat.move()       <span class="comment"># 输出：咪宝正在移动</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）-init-：核心构造方法"><a href="#（3）-init-：核心构造方法" class="headerlink" title="（3）__init__：核心构造方法"></a>（3）__init__：核心构造方法</h3><p>__init__是Python类中最核心的魔术方法（特殊方法）之一，专门用于<strong>在实例化对象时完成实例属性的初始化</strong>，相当于对象的“出生初始化器”。它是连接类模板与具体对象的关键桥梁，决定了对象创建时必须具备的初始状态。</p>
<h4 id="核心特征"><a href="#核心特征" class="headerlink" title="&lt;1&gt;核心特征"></a>&lt;1&gt;核心特征</h4><ul>
<li><strong>自动触发执行</strong>：<ul>
<li>仅在通过 <strong>类名()</strong> 进行实例化时<strong>自动调用</strong>，无需手动调用。</li>
<li>例如：执行dog &#x3D; Animal(“旺财”, 3)时，Python会自动触发Animal.<strong>init</strong>(dog, “旺财”, 3)的执行。</li>
</ul>
</li>
<li><strong>强制首个参数为self</strong><ul>
<li><strong>self</strong>是Python的内置约定，用于<strong>指代</strong>当前正在创建的<strong>实例对象本身</strong>。</li>
<li>Python会自动将新创建的实例作为参数传递给self，开发者无需手动传入。</li>
</ul>
</li>
<li><strong>无默认返回值</strong>：<ul>
<li>__init__方法的<strong>返回值必须是None</strong>，不能返回任何其他数据类型（否则会直接抛出TypeError异常）。</li>
</ul>
</li>
<li><strong>实例属性的载体</strong>：<ul>
<li><strong>通过self.属性名 &#x3D; 值的语法，将数据绑定到当前实例上</strong>，这些属性会成为实例的<strong>专属数据</strong>，实现不同实例间的<strong>数据隔离</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, 参数<span class="number">1</span>, 参数<span class="number">2</span>, ...</span>):</span><br><span class="line">        <span class="comment"># 初始化实例属性</span></span><br><span class="line">        <span class="variable language_">self</span>.属性<span class="number">1</span> = 参数<span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.属性<span class="number">2</span> = 参数<span class="number">2</span></span><br><span class="line">        <span class="comment"># 可定义默认属性（无需外部传入）</span></span><br><span class="line">        <span class="variable language_">self</span>.属性<span class="number">3</span> = 默认值</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化时传入参数（匹配__init__除self外的参数）</span></span><br><span class="line">对象 = 类名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义Person类，通过__init__初始化姓名和年龄属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="comment"># 将外部传入的name绑定为实例属性self.name</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="comment"># 将外部传入的age绑定为实例属性self.age</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="comment"># 定义默认实例属性（无需外部传入）</span></span><br><span class="line">        <span class="variable language_">self</span>.gender = <span class="string">&quot;未知&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化对象：传入name和age参数，__init__自动执行</span></span><br><span class="line">p1 = Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line">p2 = Person(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问实例属性（每个实例的属性独立）</span></span><br><span class="line"><span class="built_in">print</span>(p1.name, p1.age, p1.gender)  <span class="comment"># 输出：张三 18 未知</span></span><br><span class="line"><span class="built_in">print</span>(p2.name, p2.age, p2.gender)  <span class="comment"># 输出：李四 20 未知</span></span><br></pre></td></tr></table></figure>

<h4 id="init-方法的高级用法"><a href="#init-方法的高级用法" class="headerlink" title="&lt;2&gt;__init__方法的高级用法"></a>&lt;2&gt;__init__方法的高级用法</h4><h5 id="1）参数默认值：提升初始化灵活性"><a href="#1）参数默认值：提升初始化灵活性" class="headerlink" title="1）参数默认值：提升初始化灵活性"></a>1）参数默认值：提升初始化灵活性</h5><p>可以为__init__的参数设置默认值，实例化时可省略这些参数，使用默认值初始化属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age=<span class="number">18</span>, score=<span class="number">60</span></span>):</span><br><span class="line">        <span class="comment"># age默认值18，score默认值60</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="variable language_">self</span>.score = score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化时传入不同数量的参数</span></span><br><span class="line">s1 = Student(<span class="string">&quot;王五&quot;</span>)  <span class="comment"># 仅传name，age和score用默认值</span></span><br><span class="line">s2 = Student(<span class="string">&quot;赵六&quot;</span>, <span class="number">19</span>)  <span class="comment"># 传name和age，score用默认值</span></span><br><span class="line">s3 = Student(<span class="string">&quot;孙七&quot;</span>, <span class="number">20</span>, <span class="number">95</span>)  <span class="comment"># 传所有参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1.age, s1.score)  <span class="comment"># 输出：18 60</span></span><br><span class="line"><span class="built_in">print</span>(s2.age, s2.score)  <span class="comment"># 输出：19 60</span></span><br><span class="line"><span class="built_in">print</span>(s3.age, s3.score)  <span class="comment"># 输出：20 95</span></span><br></pre></td></tr></table></figure>

<h5 id="2）可变参数：支持动态传入多个属性"><a href="#2）可变参数：支持动态传入多个属性" class="headerlink" title="2）可变参数：支持动态传入多个属性"></a>2）可变参数：支持动态传入多个属性</h5><p>通过*args（可变位置参数）和**kwargs（可变关键字参数），让__init__支持动态传入任意数量的参数，适配更复杂的初始化场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, price, *args, **kwargs</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.price = price</span><br><span class="line">        <span class="comment"># 处理可变位置参数（如商品标签）</span></span><br><span class="line">        <span class="variable language_">self</span>.tags = args</span><br><span class="line">        <span class="comment"># 处理可变关键字参数（如产地、保质期等额外属性）</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="built_in">setattr</span>(<span class="variable language_">self</span>, key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化时传入固定参数、可变位置参数、可变关键字参数</span></span><br><span class="line">p = Product(<span class="string">&quot;手机&quot;</span>, <span class="number">2999</span>, <span class="string">&quot;电子产品&quot;</span>, <span class="string">&quot;智能&quot;</span>, origin=<span class="string">&quot;中国&quot;</span>, shelf_life=<span class="string">&quot;2年&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.name, p.price)  <span class="comment"># 输出：手机 2999</span></span><br><span class="line"><span class="built_in">print</span>(p.tags)  <span class="comment"># 输出：(&#x27;电子产品&#x27;, &#x27;智能&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(p.origin, p.shelf_life)  <span class="comment"># 输出：中国 2年</span></span><br></pre></td></tr></table></figure>
<p><strong>补充</strong>：</p>
<ul>
<li>setattr() 是 Python 内置函数，作用是<strong>动态</strong>给对象（类实例 &#x2F; 类本身）设置属性</li>
<li>语法： setattr(对象, 属性名, 属性值)<ul>
<li>等价于 <strong>对象.属性名 &#x3D; 属性值</strong>，但支持动态传入属性名字符串（灵活度更高）</li>
<li><strong>属性不存在则创建，存在则覆盖原有值</strong></li>
</ul>
</li>
</ul>
<h2 id="2-类的属性"><a href="#2-类的属性" class="headerlink" title="2.类的属性"></a>2.类的属性</h2><p>属性分为 <strong>「类属性」</strong> 和 <strong>「实例属性」</strong> ，核心区别在于<strong>作用域（是否共享）</strong>。</p>
<h3 id="（1）类属性"><a href="#（1）类属性" class="headerlink" title="（1）类属性"></a>（1）类属性</h3><ul>
<li><strong>定义位置</strong>：在类体中、所有方法之外。</li>
<li><strong>作用域</strong>：属于类本身，所有实例<strong>共享</strong>该属性，修改类属性会影响所有实例。</li>
<li><strong>访问方式</strong>：<ul>
<li><strong>类名.类属性名（推荐）</strong></li>
<li>实例名.类属性名（不推荐，易混淆实例属性）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># 类属性：所有学生共享的学校名称</span></span><br><span class="line">    school = <span class="string">&quot;北京大学&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 实例属性：学生姓名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问类属性</span></span><br><span class="line"><span class="built_in">print</span>(Student.school)  <span class="comment"># 输出：北京大学</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个实例共享类属性</span></span><br><span class="line">stu1 = Student(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">stu2 = Student(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(stu1.school)  <span class="comment"># 输出：北京大学</span></span><br><span class="line"><span class="built_in">print</span>(stu2.school)  <span class="comment"># 输出：北京大学</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改类属性（影响所有实例）</span></span><br><span class="line">Student.school = <span class="string">&quot;清华大学&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stu1.school)  <span class="comment"># 输出：清华大学</span></span><br><span class="line"><span class="built_in">print</span>(stu2.school)  <span class="comment"># 输出：清华大学</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：实例不能直接修改类属性（会创建同名实例属性覆盖类属性）</span></span><br><span class="line">stu1.school = <span class="string">&quot;复旦大学&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stu1.school)  <span class="comment"># 输出：复旦大学（实例属性覆盖）</span></span><br><span class="line"><span class="built_in">print</span>(stu2.school)  <span class="comment"># 输出：清华大学（类属性未变）</span></span><br><span class="line"><span class="built_in">print</span>(Student.school)  <span class="comment"># 输出：清华大学（类属性未变）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="补充：类属性必须在类体中定义时就赋值（哪怕赋-None）"><a href="#补充：类属性必须在类体中定义时就赋值（哪怕赋-None）" class="headerlink" title="补充：类属性必须在类体中定义时就赋值（哪怕赋 None）"></a>补充：类属性必须在类体中定义时就赋值（哪怕赋 None）</h4><ul>
<li><strong>原因</strong>：类属性的核心是 “赋值”，仅写属性名没有赋值，Python 不会将其注册为类的属性，自然无法访问。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.错误示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    school  <span class="comment"># ❌ 空声明，不是有效类属性（无赋值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.正确示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    school=<span class="string">&quot;北京大学&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.类属性的 “延迟赋值”（特殊场景）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># 先声明类属性（无初始值），后续赋值</span></span><br><span class="line">    school = <span class="literal">None</span>  <span class="comment"># 先赋空值，避免空声明</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 后续给类属性赋值（仍无需__init__）</span></span><br><span class="line">Student.school = <span class="string">&quot;复旦大学&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Student.school)  <span class="comment"># 输出：复旦大学</span></span><br></pre></td></tr></table></figure>


<h3 id="（2）实例属性"><a href="#（2）实例属性" class="headerlink" title="（2）实例属性"></a>（2）实例属性</h3><ul>
<li><strong>定义位置</strong>：<ul>
<li>通常<strong>在 <strong>init</strong> 方法中</strong></li>
<li>通过 <strong>self.属性名</strong> 定义。</li>
</ul>
</li>
<li><strong>作用域</strong>：<ul>
<li>属于单个实例，<strong>每个实例的属性独立</strong></li>
<li>修改一个实例的属性不影响其他实例。</li>
</ul>
</li>
<li><strong>访问方式</strong>：<ul>
<li><strong>实例名.实例属性名</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, height</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name      <span class="comment"># 实例属性：姓名</span></span><br><span class="line">        <span class="variable language_">self</span>.height = height  <span class="comment"># 实例属性：身高</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法中访问实例属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;self.name&#125;</span>，身高：<span class="subst">&#123;self.height&#125;</span>cm&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例1</span></span><br><span class="line">p1 = Person(<span class="string">&quot;张三&quot;</span>, <span class="number">180</span>)</span><br><span class="line"><span class="comment"># 实例2</span></span><br><span class="line">p2 = Person(<span class="string">&quot;李四&quot;</span>, <span class="number">175</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问实例属性</span></span><br><span class="line">p1.show_info()  <span class="comment"># 输出：姓名：张三，身高：180cm</span></span><br><span class="line">p2.show_info()  <span class="comment"># 输出：姓名：李四，身高：175cm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改实例属性（仅影响当前实例）</span></span><br><span class="line">p1.height = <span class="number">182</span></span><br><span class="line">p1.show_info()  <span class="comment"># 输出：姓名：张三，身高：182cm</span></span><br><span class="line">p2.show_info()  <span class="comment"># 输出：姓名：李四，身高：175cm（无变化）</span></span><br></pre></td></tr></table></figure>

<p><strong>补充</strong></p>
<ul>
<li>实例属性<strong>推荐</strong>在 <strong>init</strong> 中通过 self.属性 &#x3D; 值 初始化（确保所有实例具有一致的属性结构）</li>
<li>实例属性也可以在其他方法中动态添加，但<strong>不推荐</strong>（会导致不同实例属性不一致）</li>
<li>实例属性也可以是类，即<strong>组合</strong>，详情见<a href="#class-composition">类的组合</a></li>
</ul>
<h3 id="（3）私有属性（隐藏属性）"><a href="#（3）私有属性（隐藏属性）" class="headerlink" title="（3）私有属性（隐藏属性）"></a>（3）私有属性（隐藏属性）</h3><p>Python中没有严格的“私有”关键字，通过属性名前缀的下划线区分不同访问权限的属性，主要分为**单下划线 _<strong>属性和</strong>双下划线 __**属性两类，核心作用是控制属性的访问范围，体现封装特性。</p>
<h4 id="单下划线属性（-attr）"><a href="#单下划线属性（-attr）" class="headerlink" title="&lt;1&gt;单下划线属性（_attr）"></a>&lt;1&gt;单下划线属性（_attr）</h4><p>单下划线属性是Python社区的<strong>约定俗成规范</strong>，并非语法级别的限制，用于标识“不建议外部直接访问”的属性，但<strong>外部仍可直接访问和修改</strong>，仅作为开发者之间的沟通信号（类似“内部使用，谨慎操作”的提醒）。</p>
<ul>
<li>定义：self._保护属性名 &#x3D; 属性值。</li>
<li>访问：外部可直接访问（实例名._保护属性名），无语法限制。</li>
<li>用途：标记类的内部属性，提示外部尽量通过类提供的公开方法操作，而非直接修改。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单下划线保护属性示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name          <span class="comment"># 公开属性</span></span><br><span class="line">        <span class="variable language_">self</span>._age = age           <span class="comment"># 保护属性（约定不建议外部直接访问）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 公开方法操作保护属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, new_age</span>):</span><br><span class="line">        <span class="keyword">if</span> new_age &gt; <span class="number">0</span> <span class="keyword">and</span> new_age &lt; <span class="number">150</span>:</span><br><span class="line">            <span class="variable language_">self</span>._age = new_age</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;年龄输入无效！&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># 外部可直接访问保护属性（不推荐）</span></span><br><span class="line"><span class="built_in">print</span>(p._age)  <span class="comment"># 输出：18</span></span><br><span class="line"><span class="comment"># 外部可直接修改保护属性（不推荐）</span></span><br><span class="line">p._age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(p._age)  <span class="comment"># 输出：20</span></span><br><span class="line"><span class="comment"># 推荐：通过公开方法操作</span></span><br><span class="line">p.set_age(<span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(p.get_age())  <span class="comment"># 输出：25</span></span><br></pre></td></tr></table></figure>

<h4 id="双下划线属性（-attr）"><a href="#双下划线属性（-attr）" class="headerlink" title="&lt;2&gt;双下划线属性（__attr）"></a>&lt;2&gt;双下划线属性（__attr）</h4><p>双下划线属性是Python的语法特性，通过<strong>名称修饰（Name Mangling）机制</strong>实现真正的访问限制，外部无法直接通过原属性名访问，只能通过类内部的方法操作。</p>
<h5 id="1）核心原理：名称修饰（Name-Mangling）"><a href="#1）核心原理：名称修饰（Name-Mangling）" class="headerlink" title="1）核心原理：名称修饰（Name Mangling）"></a>1）核心原理：名称修饰（Name Mangling）</h5><ul>
<li>当类中定义双下划线属性时，Python解释器会自动将属性名修改为 <strong>_类名__属性名</strong> 的格式（即 _ClassName__attr），从而隐藏原属性名，避免外部直接访问。</li>
<li>这种修改是语法层面的，并非加密，<strong>外部仍可通过修改后的名称访问</strong>（不推荐，违反封装设计）。</li>
</ul>
<h5 id="2）定义与访问规则："><a href="#2）定义与访问规则：" class="headerlink" title="2）定义与访问规则："></a>2）定义与访问规则：</h5><ul>
<li>定义：self.__私有属性名 &#x3D; 属性值。</li>
<li>访问限制：外部直接通过 实例名.__私有属性名 会报错（AttributeError）。</li>
<li>合法访问：只能通过类内部的“getter&#x2F;setter”等公开方法访问和修改。</li>
<li>特殊访问（不推荐）：外部可通过 <strong>实例名._类名__私有属性名</strong> 访问修饰后的属性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 双下划线属性原理解析</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, username, password</span>):</span><br><span class="line">        <span class="variable language_">self</span>.username = username          <span class="comment"># 公开属性</span></span><br><span class="line">        <span class="variable language_">self</span>.__password = password        <span class="comment"># 双下划线私有属性（会被名称修饰）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># getter方法：类内部访问私有属性（正常）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_password</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 类内部可直接使用原属性名访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__password</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># setter方法：类内部修改私有属性（正常）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_password</span>(<span class="params">self, new_password</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(new_password) &gt;= <span class="number">6</span>:</span><br><span class="line">            <span class="variable language_">self</span>.__password = new_password</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;密码长度不能小于6位！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">user = User(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 访问公开属性（正常）</span></span><br><span class="line"><span class="built_in">print</span>(user.username)  <span class="comment"># 输出：zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 直接访问原私有属性名（报错：名称已被修饰）</span></span><br><span class="line"><span class="comment"># print(user.__password)  # AttributeError: &#x27;User&#x27; object has no attribute &#x27;__password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看实例的属性列表（可看到修饰后的属性名）</span></span><br><span class="line"><span class="built_in">print</span>(user.__dict__)  <span class="comment"># 输出：&#123;&#x27;username&#x27;: &#x27;zhangsan&#x27;, &#x27;_User__password&#x27;: &#x27;123456&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 外部通过修饰后的名称访问（不推荐，破坏封装）</span></span><br><span class="line"><span class="built_in">print</span>(user._User__password)  <span class="comment"># 输出：123456</span></span><br><span class="line"><span class="comment"># 外部通过修饰后的名称修改（不推荐）</span></span><br><span class="line">user._User__password = <span class="string">&quot;abc123456&quot;</span></span><br><span class="line"><span class="built_in">print</span>(user.get_password())  <span class="comment"># 输出：abc123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 通过合法的getter/setter方法操作（推荐）</span></span><br><span class="line"><span class="built_in">print</span>(user.get_password())  <span class="comment"># 输出：abc123456</span></span><br><span class="line">user.set_password(<span class="string">&quot;654321&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(user.get_password())  <span class="comment"># 输出：654321</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）补充：-实例属性名写错会-“静默创建新属性”-的问题"><a href="#（4）补充：-实例属性名写错会-“静默创建新属性”-的问题" class="headerlink" title="（4）补充： 实例属性名写错会 “静默创建新属性” 的问题"></a>（4）补充： 实例属性名写错会 “静默创建新属性” 的问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="&lt;1&gt;问题描述"></a>&lt;1&gt;问题描述</h4><p><strong>问题本质</strong>：Python 是动态类型语言，属性 &#x2F; 变量无需提前声明，不会在运行前检查属性 &#x2F; 变量是否存在</p>
<ul>
<li>若你手滑写成 stu1.scholl &#x3D; “复旦大学”（多写一个 l），Python 不会报错，而是默默创建一个全新的 scholl 实例属性，原 school 类属性 &#x2F; 实例属性完全不受影响。</li>
<li>这种错误在运行前（静态检查）很难发现，只有运行时用到该属性时才会暴露。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    school = <span class="string">&quot;北京大学&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"><span class="comment"># 手滑把 school 写成 scholl（拼写错误）</span></span><br><span class="line">stu1.scholl = <span class="string">&quot;复旦大学&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时访问正确属性名，还是原来的类属性值，你可能误以为修改成功</span></span><br><span class="line"><span class="built_in">print</span>(stu1.school)  <span class="comment"># 输出：北京大学（完全没达到修改预期）</span></span><br><span class="line"><span class="comment"># 而错误的属性名被悄悄创建，你可能完全没意识到</span></span><br><span class="line"><span class="built_in">print</span>(stu1.scholl)  <span class="comment"># 输出：复旦大学（这个属性本不该存在）</span></span><br></pre></td></tr></table></figure>

<h4 id="常用应对方法"><a href="#常用应对方法" class="headerlink" title="&lt;2&gt;常用应对方法"></a>&lt;2&gt;常用应对方法</h4><h5 id="1）使用-slots-（最直接）"><a href="#1）使用-slots-（最直接）" class="headerlink" title="1）使用 __slots__（最直接）"></a>1）使用 __slots__（最直接）</h5><p>通过在类中定义 __slots__，可以指定实例<strong>只能拥有“实例属性”</strong>，一旦尝试创建未声明的“实例属性”，会直接抛出 AttributeError，从根源上阻止拼写错误导致的 “静默创建新实例属性”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># 限制实例只能有 name/school 两个属性，其他实例属性创建会报错</span></span><br><span class="line">    __slots__ = [<span class="string">&quot;name&quot;</span>]  </span><br><span class="line">    school = <span class="string">&quot;北京大学&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"><span class="comment"># 拼写错误：scholl 不在 __slots__ 中，直接报错</span></span><br><span class="line">stu1.scholl = <span class="string">&quot;复旦大学&quot;</span>  </span><br><span class="line"><span class="comment"># 报错：AttributeError: &#x27;Student&#x27; object has no attribute &#x27;scholl&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="补充：-slots-的原理-与-继承规则"><a href="#补充：-slots-的原理-与-继承规则" class="headerlink" title="补充：__slots__ 的原理 与 继承规则"></a>补充：__slots__ 的原理 与 继承规则</h5><ol>
<li><p><strong>动态添加实例属性的本质</strong>：</p>
<ul>
<li>默认情况下，实例通过 __dict__ 字典存储属性，因此可以动态添加任意属性</li>
</ul>
</li>
<li><p><strong>slots的原理</strong>：</p>
</li>
</ol>
<ul>
<li>为实例指定<strong>固定的属性名列表</strong>，用固定内存位置替代 __dict__</li>
<li>实例只能拥有 __slots__ 中声明的属性</li>
</ul>
<ol start="3">
<li><strong>slots 的继承规则</strong></li>
</ol>
<ul>
<li><strong>规则 1</strong>：子类不自动继承父类的 __slots__<ul>
<li>父类有 __slots__、子类无 → 子类实例有 __dict__，可自由添加属性</li>
</ul>
</li>
<li><strong>规则 2</strong>：子类会继承父类的 __dict__（如果有）<ul>
<li>父类无 __slots__、子类有 → 子类的 __slots__ 被绕过</li>
</ul>
</li>
<li><strong>规则 3</strong>：父子都有 __slots__ → 实例可用属性为两者叠加</li>
</ul>
<ol start="4">
<li><strong>判断关键</strong>：<ul>
<li>看实例最终是否有 __dict__ → 有则可自由添加，无则受限于 __slots__</li>
<li>__slots__ 中包含 ‘__dict__‘ 时，相当于恢复动态能力</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则 1：子类不自动继承父类的 __slots__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 子类未定义 __slots__</span></span><br><span class="line"></span><br><span class="line">c = Child()</span><br><span class="line">c.name = <span class="string">&quot;张三&quot;</span>      <span class="comment"># ✅ 继承自父类 slots</span></span><br><span class="line">c.age = <span class="number">18</span>           <span class="comment"># ✅ 子类有 __dict__，可自由添加</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(c, <span class="string">&#x27;__dict__&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类继承父类的 __dict__，导致子类 __slots__ 无效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 无 __slots__，有 __dict__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">c = Child()</span><br><span class="line">c.name = <span class="string">&quot;张三&quot;</span>      <span class="comment"># ✅</span></span><br><span class="line">c.age = <span class="number">18</span>           <span class="comment"># ✅ 不报错！因为继承了 __dict__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(c, <span class="string">&#x27;__dict__&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(c.__dict__)    <span class="comment"># &#123;&#x27;age&#x27;: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则 3：父子都有 __slots__，叠加生效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"></span><br><span class="line">c = Child()</span><br><span class="line">c.name = <span class="string">&quot;张三&quot;</span>      <span class="comment"># ✅ 来自父类 slots</span></span><br><span class="line">c.age = <span class="number">18</span>           <span class="comment"># ✅ 来自子类 slots</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(c, <span class="string">&#x27;__dict__&#x27;</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试添加 slots 外的属性</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    c.gender = <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;Child&#x27; object has no attribute &#x27;gender&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充1：__slots__ 中包含 &#x27;__dict__&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">c = Child()</span><br><span class="line">c.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">c.age = <span class="number">18</span></span><br><span class="line">c.gender = <span class="string">&quot;男&quot;</span>      <span class="comment"># ✅ 可以，因为有 __dict__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(c, <span class="string">&#x27;__dict__&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(c.__dict__)    <span class="comment"># &#123;&#x27;gender&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充2：空 __slots__ 禁用一切动态属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>:</span><br><span class="line">    __slots__ = []</span><br><span class="line"></span><br><span class="line">e = Empty()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    e.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;Empty&#x27; object has no attribute &#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="3）封装修改属性的方法（而非直接赋值）"><a href="#3）封装修改属性的方法（而非直接赋值）" class="headerlink" title="3）封装修改属性的方法（而非直接赋值）"></a>3）封装修改属性的方法（而非直接赋值）</h5><p>通过自定义方法修改属性，在方法内校验属性名 &#x2F; 值的合法性，避免直接赋值的随意性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    school = <span class="string">&quot;北京大学&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_school</span>(<span class="params">self, new_school</span>):</span><br><span class="line">        <span class="comment"># 方法内只处理正确的属性名，避免拼写错误</span></span><br><span class="line">        <span class="variable language_">self</span>.school = new_school</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"><span class="comment"># 只能通过方法修改，无法写错属性名（方法名错会直接报错，更容易发现）</span></span><br><span class="line">stu1.set_school(<span class="string">&quot;复旦大学&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(stu1.school)  <span class="comment"># 输出：复旦大学（正确修改）</span></span><br><span class="line"><span class="comment"># 若手滑写 stu1.set_scholl(&quot;复旦大学&quot;)，会直接报 AttributeError，立刻发现错误</span></span><br></pre></td></tr></table></figure>

<h5 id="3）IDE-提示"><a href="#3）IDE-提示" class="headerlink" title="3）IDE 提示"></a>3）IDE 提示</h5><p>PyCharm&#x2F;VSCode 等DIE中会给出**“警告提示”**，看见时需注意</p>
<h2 id="3-类的方法"><a href="#3-类的方法" class="headerlink" title="3.类的方法"></a>3.类的方法</h2><p>方法是类中定义的函数，根据参数和作用域可分为 <strong>「实例方法」</strong> 、 <strong>「类方法」</strong>、 <strong>「静态方法」</strong> 三类。</p>
<h3 id="（1）实例方法"><a href="#（1）实例方法" class="headerlink" title="（1）实例方法"></a>（1）实例方法</h3><ul>
<li><strong>定义</strong>：<ul>
<li><strong>第一个参数必须是 self</strong>（指代当前实例）</li>
<li>通过 self 访问实例属性和其他实例方法。</li>
</ul>
</li>
<li><strong>调用</strong>：<ul>
<li>只能通过「实例」调用（<strong>实例名.方法名()</strong>），self 由Python自动传递，无需手动传入。</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>操作实例属性，实现与具体实例相关的功能。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义包含实例方法的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment"># 构造方法初始化实例属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 实例属性：姓名</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age    <span class="comment"># 实例属性：年龄</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例方法1：访问实例属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 通过self访问当前实例的属性</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;self.name&#125;</span>，年龄：<span class="subst">&#123;self.age&#125;</span>岁&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例方法2：修改实例属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grow_up</span>(<span class="params">self, years=<span class="number">1</span></span>):</span><br><span class="line">        <span class="comment"># 通过self修改实例属性</span></span><br><span class="line">        <span class="variable language_">self</span>.age += years</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>长大了<span class="subst">&#123;years&#125;</span>岁，现在<span class="subst">&#123;self.age&#125;</span>岁&quot;</span>)</span><br><span class="line">        <span class="comment"># 通过self调用其他实例方法</span></span><br><span class="line">        <span class="variable language_">self</span>.show_info()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 实例化对象（触发__init__初始化属性）</span></span><br><span class="line">p = Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 调用实例方法（无需传递self，Python自动绑定）</span></span><br><span class="line">p.show_info()  <span class="comment"># 输出：姓名：张三，年龄：18岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 调用带参数的实例方法</span></span><br><span class="line">p.grow_up(<span class="number">2</span>)  <span class="comment"># 输出：张三长大了2岁，现在20岁；姓名：张三，年龄：20岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 再次调用实例方法，验证属性已修改</span></span><br><span class="line">p.show_info()  <span class="comment"># 输出：姓名：张三，年龄：20岁</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）类方法"><a href="#（2）类方法" class="headerlink" title="（2）类方法"></a>（2）类方法</h3><p>使用 <strong>@classmethod 装饰器定义</strong>，<strong>用于操作类属性</strong>，不依赖实例。</p>
<ul>
<li><strong>定义</strong>：<ul>
<li>第一个参数必须是 cls（<strong>指代当前类</strong>）</li>
<li>通过 cls 访问类属性和其他类方法。</li>
</ul>
</li>
<li><strong>调用</strong>：<ul>
<li><strong>可通过「类」或「实例」调用</strong>（推荐用类调用：类名.方法名()），cls 由Python自动传递。</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>修改类属性、创建实例（替代构造方法）等与类相关的操作。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="comment"># 类属性：汽车总数</span></span><br><span class="line">    total_cars = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, brand</span>):</span><br><span class="line">        <span class="variable language_">self</span>.brand = brand  <span class="comment"># 实例属性：品牌</span></span><br><span class="line">        Car.total_cars += <span class="number">1</span>  <span class="comment"># 每创建一个实例，汽车总数+1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类方法：获取汽车总数（操作类属性）</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_total_cars</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;当前汽车总数：<span class="subst">&#123;cls.total_cars&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> cls.total_cars</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类方法：创建默认品牌的汽车（替代构造方法）</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_default_car</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls(brand=<span class="string">&quot;丰田&quot;</span>)  <span class="comment"># 等价于 Car(&quot;丰田&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 实例化汽车</span></span><br><span class="line">car1 = Car(<span class="string">&quot;宝马&quot;</span>)</span><br><span class="line">car2 = Car(<span class="string">&quot;奔驰&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 调用类方法（类调用）</span></span><br><span class="line">Car.get_total_cars()  <span class="comment"># 输出：当前汽车总数：2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 实例调用类方法（也可，但不推荐）</span></span><br><span class="line">car1.get_total_cars()  <span class="comment"># 输出：当前汽车总数：2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 通过类方法创建实例</span></span><br><span class="line">default_car = Car.create_default_car()</span><br><span class="line"><span class="built_in">print</span>(default_car.brand)  <span class="comment"># 输出：丰田</span></span><br><span class="line">Car.get_total_cars()  <span class="comment"># 输出：当前汽车总数：3</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）静态方法"><a href="#（3）静态方法" class="headerlink" title="（3）静态方法"></a>（3）静态方法</h3><p>使用 <strong>@staticmethod 装饰器</strong>定义，既不依赖实例（无 self），也不依赖类（无 cls），相当于类中的“普通函数”。</p>
<ul>
<li><strong>定义</strong>：<ul>
<li>无强制第一个参数self，参数自由定义。</li>
</ul>
</li>
<li><strong>调用</strong>：<ul>
<li>可通过「类」或「实例」调用（推荐用类调用）。</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>实现与类和实例都无关的辅助功能（如工具函数）。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathTools</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数学工具类，包含静态方法实现辅助计算&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 静态方法：计算两个数的平方和</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum_of_squares</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a**<span class="number">2</span> + b**<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 静态方法：判断一个数是否为偶数</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">num</span>):</span><br><span class="line">        <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 类调用静态方法（推荐）</span></span><br><span class="line"><span class="built_in">print</span>(MathTools.sum_of_squares(<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 输出：25（3²+4²=25）</span></span><br><span class="line"><span class="built_in">print</span>(MathTools.is_even(<span class="number">6</span>))            <span class="comment"># 输出：True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 实例调用静态方法（也可）</span></span><br><span class="line">tools = MathTools()</span><br><span class="line"><span class="built_in">print</span>(tools.sum_of_squares(<span class="number">5</span>, <span class="number">12</span>))  <span class="comment"># 输出：169（5²+12²=169）</span></span><br><span class="line"><span class="built_in">print</span>(tools.is_even(<span class="number">7</span>))             <span class="comment"># 输出：False</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）方法对比总结"><a href="#（4）方法对比总结" class="headerlink" title="（4）方法对比总结"></a>（4）方法对比总结</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260111104147036.png"></p>
<h2 id="4-面向对象三大特性：封装、继承、多态"><a href="#4-面向对象三大特性：封装、继承、多态" class="headerlink" title="4.面向对象三大特性：封装、继承、多态"></a>4.面向对象三大特性：封装、继承、多态</h2><h3 id="（1）封装"><a href="#（1）封装" class="headerlink" title="（1）封装"></a>（1）封装</h3><ul>
<li><strong>核心思想</strong>：<ul>
<li>将类的属性和方法“包裹”起来，<strong>隐藏内部实现细节，只对外提供有限的访问接口（如getter&#x2F;setter方法），防止外部随意修改内部数据</strong>，保证数据的安全性和代码的可维护性。</li>
</ul>
</li>
<li><strong>实现方式</strong>：<ul>
<li>使用 __ 定义私有属性&#x2F;私有方法（外部无法直接访问）。</li>
<li>提供公开的getter（获取）、setter（修改）方法，控制对私有属性的访问逻辑。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;银行账户类，封装账户余额的访问和修改&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_id, balance=<span class="number">0</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.account_id = account_id      <span class="comment"># 公开属性：账号</span></span><br><span class="line">        <span class="variable language_">self</span>.__balance = balance          <span class="comment"># 私有属性：余额（隐藏）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 私有方法：日志记录（内部使用，外部无法调用）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__log</span>(<span class="params">self, action, amount</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;账号<span class="subst">&#123;self.account_id&#125;</span>：<span class="subst">&#123;action&#125;</span> <span class="subst">&#123;amount&#125;</span>元，当前余额：<span class="subst">&#123;self.__balance&#125;</span>元&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># getter方法：查询余额</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_balance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__log(<span class="string">&quot;查询余额&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__balance</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># setter方法：存款（控制存款逻辑）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.__balance += amount</span><br><span class="line">            <span class="variable language_">self</span>.__log(<span class="string">&quot;存款&quot;</span>, amount)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;存款金额必须大于0！&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># setter方法：取款（控制取款逻辑）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount &gt; <span class="number">0</span> <span class="keyword">and</span> amount &lt;= <span class="variable language_">self</span>.__balance:</span><br><span class="line">            <span class="variable language_">self</span>.__balance -= amount</span><br><span class="line">            <span class="variable language_">self</span>.__log(<span class="string">&quot;取款&quot;</span>, amount)</span><br><span class="line">            <span class="keyword">return</span> amount</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;取款金额无效或余额不足！&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化账户</span></span><br><span class="line">account = BankAccount(<span class="string">&quot;6222081234567890&quot;</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问公开属性</span></span><br><span class="line"><span class="built_in">print</span>(account.account_id)  <span class="comment"># 输出：6222081234567890</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过公开方法操作私有属性</span></span><br><span class="line">account.deposit(<span class="number">500</span>)        <span class="comment"># 输出：账号6222081234567890：存款 500元，当前余额：1500元</span></span><br><span class="line">account.withdraw(<span class="number">300</span>)       <span class="comment"># 输出：账号6222081234567890：取款 300元，当前余额：1200元</span></span><br><span class="line"><span class="built_in">print</span>(account.get_balance())<span class="comment"># 输出：账号6222081234567890：查询余额 0元，当前余额：1200元</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试直接访问私有属性/方法（报错）</span></span><br><span class="line"><span class="comment"># print(account.__balance)  # AttributeError</span></span><br><span class="line"><span class="comment"># account.__log(&quot;测试&quot;, 0)  # AttributeError</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）继承（Inheritance）"><a href="#（2）继承（Inheritance）" class="headerlink" title="（2）继承（Inheritance）"></a>（2）继承（Inheritance）</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="&lt;1&gt;介绍"></a>&lt;1&gt;介绍</h4><ul>
<li><strong>核心思想</strong>：<ul>
<li><strong>子类（派生类）继承父类（基类）的属性和方法</strong>，无需重复编写代码，同时子类可扩展新的属性和方法，或重写父类的方法（覆盖父类逻辑），实现代码复用和扩展。</li>
<li>Python支持「单继承」和「多继承」（一个子类继承多个父类），但多继承易导致逻辑复杂，通常推荐单继承。</li>
</ul>
</li>
<li><strong>基本语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类（基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">父类名</span>:</span><br><span class="line">    父类属性和方法</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类（派生类）继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">子类名</span>(<span class="title class_ inherited__">父类名</span>):</span><br><span class="line">    <span class="comment"># 子类可扩展新的属性和方法</span></span><br><span class="line">    子类属性和方法</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># （可选）重写父类方法（覆盖父类逻辑）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">父类方法名</span>(<span class="params">self, 参数列表</span>):</span><br><span class="line">        子类的方法体</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>关键概念</strong><ul>
<li><strong>继承传递性</strong>：<ul>
<li>如果B继承A，C继承B，则C同时拥有A和B的属性和方法。</li>
</ul>
</li>
<li><strong>重写（Override）</strong>：<ul>
<li>子类定义与父类同名的方法，覆盖父类的实现逻辑（当调用该方法时，优先执行子类逻辑）。</li>
</ul>
</li>
<li><strong>super()</strong>：<ul>
<li>在子类中调用父类的方法（如 <strong>super().__init__()</strong> 调用父类的构造方法）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意！！</strong>：如果要继承父类的属性，<strong>子类__init__必须显式调用父类__init__</strong></p>
<ul>
<li>子类自定义了__init__方法，会覆盖父类的__init__方法。</li>
<li>若子类需要继承父类的实例属性，必须通过 super().__init__(参数) 显式调用父类的构造方法，否则父类的实例属性无法被初始化，子类实例将缺少父类的相关属性。</li>
</ul>
<h4 id="示例：单继承与重写"><a href="#示例：单继承与重写" class="headerlink" title="&lt;2&gt;示例：单继承与重写"></a>&lt;2&gt;示例：单继承与重写</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类：Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, food</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>正在吃<span class="subst">&#123;food&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>正在缓慢移动&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类：Dog 继承 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="comment"># 扩展子类特有的属性（品种）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, breed</span>):</span><br><span class="line">        <span class="comment"># 关键：必须显式调用父类__init__，才能继承name和age属性</span></span><br><span class="line">        <span class="comment"># 若省略此句，Dog实例将缺少name和age属性，调用父类方法时会报错</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        <span class="variable language_">self</span>.breed = breed  <span class="comment"># 子类新增属性：品种</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重写父类的move方法（覆盖父类逻辑）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>（<span class="subst">&#123;self.breed&#125;</span>）正在快速奔跑&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 扩展子类特有的方法（叫）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>汪汪叫！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化子类Dog</span></span><br><span class="line">dog = Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>, <span class="string">&quot;金毛&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问父类的属性（因显式调用父类__init__，才可正常访问）</span></span><br><span class="line"><span class="built_in">print</span>(dog.name)  <span class="comment"># 输出：旺财</span></span><br><span class="line"><span class="built_in">print</span>(dog.age)   <span class="comment"># 输出：3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问子类的属性</span></span><br><span class="line"><span class="built_in">print</span>(dog.breed)  <span class="comment"># 输出：金毛</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用父类的方法（未被重写）</span></span><br><span class="line">dog.eat(<span class="string">&quot;骨头&quot;</span>)  <span class="comment"># 输出：旺财正在吃骨头</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用重写后的方法（执行子类逻辑）</span></span><br><span class="line">dog.move()  <span class="comment"># 输出：旺财（金毛）正在快速奔跑</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用子类特有的方法</span></span><br><span class="line">dog.bark()  <span class="comment"># 输出：旺财汪汪叫！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反面示例：子类未调用父类__init__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, color</span>):</span><br><span class="line">        <span class="variable language_">self</span>.color = color  <span class="comment"># 仅定义子类属性，未调用父类__init__</span></span><br><span class="line"></span><br><span class="line">cat = Cat(<span class="string">&quot;橘色&quot;</span>)</span><br><span class="line"><span class="comment"># print(cat.name)  # 报错：AttributeError: &#x27;Cat&#x27; object has no attribute &#x27;name&#x27;</span></span><br><span class="line"><span class="comment"># cat.eat(&quot;鱼&quot;)    # 报错：AttributeError: &#x27;Cat&#x27; object has no attribute &#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="示例：多继承（了解）"><a href="#示例：多继承（了解）" class="headerlink" title="&lt;3&gt;示例：多继承（了解）"></a>&lt;3&gt;示例：多继承（了解）</h4><ul>
<li>子类继承多个父类，语法为 <strong>class 子类名(父类1, 父类2, …)</strong></li>
<li>注意「方法解析顺序（MRO）」：<ul>
<li>当多个父类有同名方法时，子类按继承列表的顺序优先调用前面父类的方法。</li>
<li>若要调用后面父类的方法，可通过类名直接调用并传递实例</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类1</span></span><br><span class="line"><span class="comment"># 父类1：拥有自身属性和方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="comment"># 父类1的属性</span></span><br><span class="line">    feature_a = <span class="string">&quot;来自A类的特征&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A类的show方法&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 父类1的独有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_a</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;调用A类独有方法，<span class="subst">&#123;self.feature_a&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父类2：拥有自身属性和方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="comment"># 父类2的属性</span></span><br><span class="line">    feature_b = <span class="string">&quot;来自B类的特征&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B类的show方法&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 父类2的独有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_b</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;调用B类独有方法，<span class="subst">&#123;self.feature_b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类C继承A和B（顺序：A在前，B在后）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="comment"># 子类可新增自身属性</span></span><br><span class="line">    own_feature = <span class="string">&quot;C类自身的特征&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 子类可新增自身方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_own</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;调用C类自身方法，<span class="subst">&#123;self.own_feature&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化C</span></span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 访问继承自A类的属性和独有方法</span></span><br><span class="line"><span class="built_in">print</span>(c.feature_a)  <span class="comment"># 输出：来自A类的特征</span></span><br><span class="line">c.func_a()          <span class="comment"># 输出：调用A类独有方法，来自A类的特征</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 访问继承自B类的属性和独有方法</span></span><br><span class="line"><span class="built_in">print</span>(c.feature_b)  <span class="comment"># 输出：来自B类的特征</span></span><br><span class="line">c.func_b()          <span class="comment"># 输出：调用B类独有方法，来自B类的特征</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 访问子类自身的属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(c.own_feature)<span class="comment"># 输出：C类自身的特征</span></span><br><span class="line">c.func_own()        <span class="comment"># 输出：调用C类自身方法，C类自身的特征</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 调用同名方法show()，遵循MRO优先调用A类方法（A在继承列表前）</span></span><br><span class="line">c.show()            <span class="comment"># 输出：A类的show方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 查看MRO（方法解析顺序）：C -&gt; A -&gt; B -&gt; object</span></span><br><span class="line"><span class="built_in">print</span>(C.mro())  <span class="comment"># 输出：[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 若需调用B类的同名show方法，可通过类名直接调用并传递实例</span></span><br><span class="line">B.show(c)  <span class="comment"># 输出：B类的show方法</span></span><br></pre></td></tr></table></figure>

<h4 id="补充1：父类各属性的继承情况"><a href="#补充1：父类各属性的继承情况" class="headerlink" title="补充1：父类各属性的继承情况"></a>补充1：父类各属性的继承情况</h4><h5 id="1）类属性：完全继承"><a href="#1）类属性：完全继承" class="headerlink" title="1）类属性：完全继承"></a>1）类属性：完全继承</h5><ul>
<li>子类会直接继承父类的所有类属性（公开、单下划线保护的类属性）</li>
<li>通过 <strong>「子类名.类属性名」</strong> 或 <strong>「子类实例.类属性名」</strong> 直接 <strong>访问</strong><ul>
<li>如果通过「子类名.类属性名」或「子类实例.类属性名」 <strong>修改</strong> ——&gt;其实是<strong>子类重写该属性</strong></li>
</ul>
</li>
<li><strong>修改父类的类属性会影响所有子类实例（子类未重写该类属性时）</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment"># 类属性：公开属性+单下划线保护属性，均可被子类继承</span></span><br><span class="line">    species = <span class="string">&quot;人类&quot;</span></span><br><span class="line">    _feature = <span class="string">&quot;语言能力&quot;</span>  <span class="comment"># 保护类属性，子类仍可继承/访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类（继承父类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 无自定义属性，完全继承父类所有类属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 子类/实例访问继承的类属性（含保护属性）</span></span><br><span class="line"><span class="built_in">print</span>(Student.species)       <span class="comment"># 子类名访问公开类属性 → 人类</span></span><br><span class="line">stu1 = Student()</span><br><span class="line"><span class="built_in">print</span>(stu1._feature)         <span class="comment"># 实例访问继承的保护类属性 → 语言能力</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 修改父类类属性，影响子类实例</span></span><br><span class="line">Person.species = <span class="string">&quot;智人&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stu1.species)          <span class="comment"># 子类实例同步变化 → 智人</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 子类创建了自己的同名类属性，遮蔽了父类的类属性</span></span><br><span class="line">Student.species = <span class="string">&quot;学生&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stu1.species)          <span class="comment"># 子类实例用重写值 → 学生</span></span><br><span class="line"><span class="built_in">print</span>(Person.species)        <span class="comment"># 父类属性不变 → 智人</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 子类实例直接修改保护类属性（_feature），实际创建同名实例属性</span></span><br><span class="line">stu1._feature = <span class="string">&quot;逻辑思维能力&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stu1._feature)         <span class="comment"># 实例属性覆盖 → 逻辑思维能力</span></span><br><span class="line"><span class="built_in">print</span>(Student._feature)      <span class="comment"># 子类类属性仍为 → 语言能力</span></span><br><span class="line"><span class="built_in">print</span>(Person._feature)       <span class="comment"># 父类类属性仍为 → 语言能力</span></span><br></pre></td></tr></table></figure>

<h5 id="2）实例属性：需显式调用父类-init-才继承"><a href="#2）实例属性：需显式调用父类-init-才继承" class="headerlink" title="2）实例属性：需显式调用父类__init__才继承"></a>2）实例属性：需显式调用父类__init__才继承</h5><ul>
<li>父类的实例属性定义在__init__中</li>
<li><strong>若子类自定义了__init__</strong>：<ul>
<li>必须通过super().__init__(参数)<strong>显式调用父类构造方法</strong>，才能继承父类的实例属性</li>
</ul>
</li>
<li><strong>若子类未自定义__init__</strong>：<ul>
<li>会自动继承父类的__init__，实例化时直接传入父类所需参数即可继承。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类：__init__中定义实例属性name、age</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 父类实例属性1</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age    <span class="comment"># 父类实例属性2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类1：未自定义__init__ → 自动继承父类__init__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student1</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化子类1：直接传入父类所需参数，继承所有实例属性</span></span><br><span class="line">stu1 = Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Student1：<span class="subst">&#123;stu1.name&#125;</span>，<span class="subst">&#123;stu1.age&#125;</span>&quot;</span>)  <span class="comment"># 输出：张三，18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类2：自定义__init__但未调用父类构造方法 → 不继承父类实例属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, school</span>):</span><br><span class="line">        <span class="variable language_">self</span>.school = school  <span class="comment"># 仅子类自身实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化子类2：仅传子类参数，无法访问父类属性</span></span><br><span class="line">stu2 = Student2(<span class="string">&quot;北京大学&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Student2：<span class="subst">&#123;stu2.school&#125;</span>&quot;</span>)  <span class="comment"># 输出：北京大学</span></span><br><span class="line"><span class="comment"># print(stu2.name)  # 报错：&#x27;Student2&#x27; object has no attribute &#x27;name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类3：自定义__init__且显式调用父类构造方法 → 继承父类实例属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student3</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, school</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 显式调用父类__init__</span></span><br><span class="line">        <span class="variable language_">self</span>.school = school        <span class="comment"># 子类扩展实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化子类3：传入父类+子类参数，可访问所有属性</span></span><br><span class="line">stu3 = Student3(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>, <span class="string">&quot;清华大学&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Student3：<span class="subst">&#123;stu3.name&#125;</span>，<span class="subst">&#123;stu3.age&#125;</span>，<span class="subst">&#123;stu3.school&#125;</span>&quot;</span>)  <span class="comment"># 输出：李四，20，清华大学</span></span><br></pre></td></tr></table></figure>

<h5 id="3）私有属性（双下划线-attr）：不直接继承，可通过父类公开方法间接访问"><a href="#3）私有属性（双下划线-attr）：不直接继承，可通过父类公开方法间接访问" class="headerlink" title="3）私有属性（双下划线__attr）：不直接继承，可通过父类公开方法间接访问"></a>3）私有属性（双下划线__attr）：不直接继承，可通过父类公开方法间接访问</h5><ul>
<li>父类的双下划线私有属性会被 Python 通过**「名称修饰」机制**隐藏（修饰为_父类名__私有属性名）</li>
<li>子类无法直接通过原属性名访问，也不视为 “继承” 了该属性（<strong>语法层面隔离</strong>）。</li>
<li>但子类可通过父类提供的公开 getter&#x2F;setter 方法间接操作父类的私有属性（<strong>本质是父类内部允许访问，子类调用父类方法实现</strong>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name        <span class="comment"># 公开属性</span></span><br><span class="line">        <span class="variable language_">self</span>.__age = age        <span class="comment"># 私有属性（名称修饰）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 公开方法：操作私有属性（函数体缩进4空格，核心规则）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, new_age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__age = new_age</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, school</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        <span class="variable language_">self</span>.school = school</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 子类无法直接访问父类私有属性</span></span><br><span class="line">stu = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;北大&quot;</span>)</span><br><span class="line"><span class="comment"># print(stu.__age)  # 报错：无__age属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 子类通过父类公开方法间接操作</span></span><br><span class="line"><span class="built_in">print</span>(stu.get_age())  <span class="comment"># 输出：18</span></span><br><span class="line">stu.set_age(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(stu.get_age())  <span class="comment"># 输出：20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 验证名称修饰（仅理解，禁止使用）</span></span><br><span class="line"><span class="built_in">print</span>(stu._Person__age)  <span class="comment"># 输出：20</span></span><br></pre></td></tr></table></figure>

<h4 id="补充2：父类各类方法的继承情况"><a href="#补充2：父类各类方法的继承情况" class="headerlink" title="补充2：父类各类方法的继承情况"></a>补充2：父类各类方法的继承情况</h4><h5 id="1）实例方法（公开、单下划线保护）：完全继承"><a href="#1）实例方法（公开、单下划线保护）：完全继承" class="headerlink" title="1）实例方法（公开、单下划线保护）：完全继承"></a>1）实例方法（公开、单下划线保护）：完全继承</h5><ul>
<li>子类会继承父类的所有公开实例方法（无下划线）、单下划线保护实例方法，可通过子类实例直接调用</li>
<li>若子类定义了与父类同名的方法，会重写父类方法（调用时优先执行子类逻辑）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment"># 公开实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类：你好！&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 单下划线保护实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_show_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类：基础信息&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类继承父类方法，并重写公开方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="comment"># 重写父类公开方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子类：同学你好！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 子类实例调用继承的保护方法</span></span><br><span class="line">stu = Student()</span><br><span class="line">stu._show_info()  <span class="comment"># 输出：父类：基础信息（继承保护方法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 子类实例调用重写后的公开方法</span></span><br><span class="line">stu.say_hello()   <span class="comment"># 输出：子类：同学你好！（优先执行子类逻辑）</span></span><br></pre></td></tr></table></figure>

<h5 id="2）类方法、静态方法：完全继承"><a href="#2）类方法、静态方法：完全继承" class="headerlink" title="2）类方法、静态方法：完全继承"></a>2）类方法、静态方法：完全继承</h5><ul>
<li>子类会直接继承父类的公开 &#x2F; 保护类方法（<strong>@classmethod修饰</strong>）、静态方法（<strong>@staticmethod修饰</strong>）</li>
<li>通过「<strong>子类名.方法名</strong>」或「<strong>子类实例.方法名</strong>」调用</li>
<li>子类可重写父类的类方法、静态方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_func</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类类方法&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_func</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类静态方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="comment"># 重写父类类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_func</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子类类方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 子类名调用继承的静态方法</span></span><br><span class="line">Student.static_func()  <span class="comment"># 输出：父类静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 子类实例调用继承的静态方法</span></span><br><span class="line">stu = Student()</span><br><span class="line">stu.static_func()      <span class="comment"># 输出：父类静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 子类名调用重写后的类方法</span></span><br><span class="line">Student.class_func()   <span class="comment"># 输出：子类类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 子类实例调用重写后的类方法</span></span><br><span class="line">stu.class_func()       <span class="comment"># 输出：子类类方法</span></span><br></pre></td></tr></table></figure>

<h5 id="3）私有方法（双下划线-method）：不直接继承，可通过父类公开方法间接调用"><a href="#3）私有方法（双下划线-method）：不直接继承，可通过父类公开方法间接调用" class="headerlink" title="3）私有方法（双下划线__method）：不直接继承，可通过父类公开方法间接调用"></a>3）私有方法（双下划线__method）：不直接继承，可通过父类公开方法间接调用</h5><ul>
<li>与私有属性类似，父类的双下划线私有方法会被名称修饰（修饰为 <strong>_父类名__私有方法名</strong>）</li>
<li>子类无法直接调用，只能<strong>通过父类的公开方法间接触发</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 双下划线私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类私有方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 公开方法：间接触发私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_private</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__private_func()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">try_call_private</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 直接调用父类私有方法会报错</span></span><br><span class="line">        <span class="comment"># self.__private_func()</span></span><br><span class="line">        <span class="comment"># 调用父类公开方法间接触发私有方法</span></span><br><span class="line">        <span class="variable language_">self</span>.call_private()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 子类实例无法直接调用私有方法</span></span><br><span class="line">stu = Student()</span><br><span class="line"><span class="comment"># stu.__private_func()  # 报错：无该属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 子类通过父类公开方法间接触发私有方法</span></span><br><span class="line">stu.try_call_private()  <span class="comment"># 输出：父类私有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 验证名称修饰（仅理解，禁止使用）</span></span><br><span class="line">stu._Person__private_func()  <span class="comment"># 输出：父类私有方法</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260111114413251.png"></p>
<h3 id="（3）多态"><a href="#（3）多态" class="headerlink" title="（3）多态"></a>（3）多态</h3><ul>
<li><strong>核心思想</strong>：<ul>
<li>同一方法名在不同类中有不同的实现逻辑，当调用该方法时，根据对象的实际类型执行对应的逻辑（即“一个接口，多种实现”）。</li>
<li>多态依赖于继承和重写，核心作用是提高代码的灵活性和可扩展性。</li>
</ul>
</li>
<li><strong>实现条件</strong>：<ul>
<li>存在继承关系（子类继承父类）</li>
<li>子类重写父类的方法</li>
<li>使用<strong>父类类型的变量引用子类对象</strong>，<strong>调用重写方法</strong>时自动匹配子类逻辑。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类：Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 父类方法（被子类重写）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>发出声音&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类1：Dog（重写make_sound）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>汪汪叫！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类2：Cat（重写make_sound）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>喵喵叫！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类3：Duck（重写make_sound）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>嘎嘎叫！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多态核心：统一接口（调用make_sound），不同对象执行不同逻辑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    <span class="comment"># 接收Animal类型的参数（实际可传入任意子类对象）</span></span><br><span class="line">    animal.make_sound()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化不同子类</span></span><br><span class="line">dog = Dog(<span class="string">&quot;旺财&quot;</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;咪宝&quot;</span>)</span><br><span class="line">duck = Duck(<span class="string">&quot;小黄&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用统一接口，自动匹配子类逻辑</span></span><br><span class="line">animal_sound(dog)  <span class="comment"># 输出：旺财汪汪叫！</span></span><br><span class="line">animal_sound(cat)  <span class="comment"># 输出：咪宝喵喵叫！</span></span><br><span class="line">animal_sound(duck) <span class="comment"># 输出：小黄嘎嘎叫！</span></span><br></pre></td></tr></table></figure>

<h2 id="5-类的高级用法"><a href="#5-类的高级用法" class="headerlink" title="5.类的高级用法"></a>5.类的高级用法</h2><h3 id="（1）魔术方法（特殊方法）"><a href="#（1）魔术方法（特殊方法）" class="headerlink" title="（1）魔术方法（特殊方法）"></a>（1）魔术方法（特殊方法）</h3><p>Python类中<strong>以 __ 开头和结尾</strong>的方法称为“魔术方法”（如__init__），它们在<strong>特定场景下自动调用，无需手动调用</strong></p>
<h4 id="构造与析构相关"><a href="#构造与析构相关" class="headerlink" title="&lt;1&gt;构造与析构相关"></a>&lt;1&gt;构造与析构相关</h4><ul>
<li><strong>__init__(self, …)</strong>：构造方法，实例化对象时自动调用（初始化属性）。</li>
<li><strong>__del__(self)</strong>：：析构方法，对象被垃圾回收时自动调用（释放资源，如关闭文件）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="variable language_">self</span>.filename = filename</span><br><span class="line">        <span class="variable language_">self</span>.file = <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;打开文件：<span class="subst">&#123;self.filename&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_content</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.file.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.file.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;关闭文件：<span class="subst">&#123;self.filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">fh = FileHandler(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fh.read_content())</span><br><span class="line"><span class="comment"># 输出：（文件内容）</span></span><br><span class="line"><span class="comment"># 程序结束时自动输出：关闭文件：test.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="运算符重载相关"><a href="#运算符重载相关" class="headerlink" title="&lt;2&gt;运算符重载相关"></a>&lt;2&gt;运算符重载相关</h4><p>通过重写魔术方法，让自定义类的对象支持Python内置运算符（如 +、-、&#x3D;&#x3D;、&lt; 等）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重载 + 运算符（实现两个Point对象相加）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Point(<span class="variable language_">self</span>.x + other.x, <span class="variable language_">self</span>.y + other.y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重载 == 运算符（判断两个Point对象是否相等）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.x == other.x <span class="keyword">and</span> <span class="variable language_">self</span>.y == other.y</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重载字符串输出（print对象时显示自定义格式）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用__add__（+运算符）</span></span><br><span class="line">p3 = p1 + p2</span><br><span class="line"><span class="built_in">print</span>(p3)  <span class="comment"># 输出：Point(4, 6)（调用__str__）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用__eq__（==运算符）</span></span><br><span class="line"><span class="built_in">print</span>(p1 == p2)  <span class="comment"># 输出：False</span></span><br><span class="line"><span class="built_in">print</span>(p1 == Point(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 输出：True</span></span><br></pre></td></tr></table></figure>
<p><strong>想进一步了解，请参考:</strong><a href="/2026/01/09/Python/%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84python%E3%80%8B/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9APython%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/">Python数据模型</a></p>
<h3 id="（2）类的组合"><a href="#（2）类的组合" class="headerlink" title="（2）类的组合 "></a>（2）类的组合 <a id="class-composition"></a></h3><ul>
<li>组合是另一种代码复用方式，指<strong>一个类的属性是另一个类的对象</strong>（即“一个类包含另一个类”）</li>
<li>适用于“整体-部分”关系（如“汽车”包含“发动机”、“轮胎”）。组合比继承更灵活，避免了继承的耦合性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分类1：发动机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发动机启动&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发动机关闭&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部分类2：轮胎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tire</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, brand</span>):</span><br><span class="line">        <span class="variable language_">self</span>.brand = brand</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.brand&#125;</span>轮胎旋转&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体类：汽车（组合Engine和Tire）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tire_brand</span>):</span><br><span class="line">        <span class="comment"># 组合：Car类包含Engine对象和Tire对象</span></span><br><span class="line">        <span class="variable language_">self</span>.engine = Engine()</span><br><span class="line">        <span class="variable language_">self</span>.tire1 = Tire(tire_brand)</span><br><span class="line">        <span class="variable language_">self</span>.tire2 = Tire(tire_brand)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.engine.start()</span><br><span class="line">        <span class="variable language_">self</span>.tire1.rotate()</span><br><span class="line">        <span class="variable language_">self</span>.tire2.rotate()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汽车行驶中...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化汽车</span></span><br><span class="line">car = Car(<span class="string">&quot;米其林&quot;</span>)</span><br><span class="line">car.run()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 发动机启动</span></span><br><span class="line"><span class="comment"># 米其林轮胎旋转</span></span><br><span class="line"><span class="comment"># 米其林轮胎旋转</span></span><br><span class="line"><span class="comment"># 汽车行驶中...</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）抽象类（ABC模块）"><a href="#（3）抽象类（ABC模块）" class="headerlink" title="（3）抽象类（ABC模块）"></a>（3）抽象类（ABC模块）</h3><ul>
<li>抽象类是一种“<strong>不能实例化</strong>”的类，用于定义子类必须实现的方法（规范子类接口）。</li>
<li>Python通过 abc 模块实现抽象类</li>
<li>核心作用：是强制子类遵循统一的接口规范。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># ABC 是 Abstract Base Class 的缩写，且 Python 3.4+ 推荐直接继承 ABC，而非使用 metaclass=ABCMeta</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象类（继承ABC）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="comment"># 抽象方法（子类必须重写）</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 抽象方法（子类必须重写）</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类1：圆形（实现抽象方法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        <span class="variable language_">self</span>.radius = radius</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * <span class="variable language_">self</span>.radius ** <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14</span> * <span class="variable language_">self</span>.radius</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类2：正方形（实现抽象方法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, side</span>):</span><br><span class="line">        <span class="variable language_">self</span>.side = side</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.side ** <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * <span class="variable language_">self</span>.side</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象类不能实例化（报错）</span></span><br><span class="line"><span class="comment"># shape = Shape()  # TypeError: Can&#x27;t instantiate abstract class Shape with abstract method area, perimeter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类可实例化（已实现所有抽象方法）</span></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;圆形面积：<span class="subst">&#123;circle.area()&#125;</span>, 周长：<span class="subst">&#123;circle.perimeter()&#125;</span>&quot;</span>)  <span class="comment"># 输出：圆形面积：78.5, 周长：31.4</span></span><br><span class="line"></span><br><span class="line">square = Square(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正方形面积：<span class="subst">&#123;square.area()&#125;</span>, 周长：<span class="subst">&#123;square.perimeter()&#125;</span>&quot;</span>)  <span class="comment"># 输出：正方形面积：16, 周长：16</span></span><br></pre></td></tr></table></figure>

<h2 id="6-导入类"><a href="#6-导入类" class="headerlink" title="6.导入类"></a>6.导入类</h2><p>在 Python 中，“导入类”是实现代码模块化复用的核心手段，通过将不同功能的类拆分到不同“<strong>模块</strong>”（<strong>.py 文件</strong>），可大幅提升代码的可维护性、可读性和复用性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260111154058716.png"></p>
<h3 id="（1）核心概念-1"><a href="#（1）核心概念-1" class="headerlink" title="（1）核心概念"></a>（1）核心概念</h3><ul>
<li><strong>模块（module）</strong>：<ul>
<li>本质是一个 <strong>.py 后缀</strong>的 Python 文件，可包含类、函数、变量等代码片段，是代码组织的基本单位。<ul>
<li>例如：animal.py 就是一个模块</li>
</ul>
</li>
</ul>
</li>
<li><strong>包（package）</strong>：<ul>
<li><strong>包含多个模块的目录</strong>，需包含 <strong>__init__.py</strong> 文件（Python 3.3+ 可省略，但推荐保留），用于管理多模块层级结构。<ul>
<li>例如 my_package&#x2F; 目录下包含 animal.py、person.py，则 my_package 是包</li>
</ul>
</li>
</ul>
</li>
<li><strong>导入核心目的</strong>：<ul>
<li>在当前模块中复用其他模块已定义的类，避免重复编码；</li>
<li>实现代码功能拆分，让不同模块负责不同业务逻辑。</li>
</ul>
</li>
</ul>
<h3 id="（2）导入单个类"><a href="#（2）导入单个类" class="headerlink" title="（2）导入单个类"></a>（2）导入单个类</h3><p>适用于只需使用目标模块中某一个特定类的场景，语法简洁，导入后可直接使用类名调用。</p>
<h4 id="语法格式"><a href="#语法格式" class="headerlink" title="&lt;1&gt;语法格式"></a>&lt;1&gt;语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 类名</span><br></pre></td></tr></table></figure>

<h4 id="实战示例"><a href="#实战示例" class="headerlink" title="&lt;2&gt;实战示例"></a>&lt;2&gt;实战示例</h4><ul>
<li>步骤1：定义模块（被导入方）—— 新建animal.py文件，定义单个类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># animal.py（模块）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, food</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>（<span class="subst">&#123;self.age&#125;</span>岁）正在吃<span class="subst">&#123;food&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>步骤2：导入并使用（导入方）—— 新建 main.py，从 animal.py 中导入 Animal 类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py（当前模块）</span></span><br><span class="line"><span class="keyword">from</span> animal <span class="keyword">import</span> Animal  <span class="comment"># 从 animal 模块导入 Animal 类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用导入的类实例化</span></span><br><span class="line">dog = Animal(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>)</span><br><span class="line">dog.eat(<span class="string">&quot;骨头&quot;</span>)  <span class="comment"># 输出：旺财（3岁）正在吃骨头</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）在一个模块中存储多个类"><a href="#（3）在一个模块中存储多个类" class="headerlink" title="（3）在一个模块中存储多个类"></a>（3）在一个模块中存储多个类</h3><p>适用于多个类功能关联紧密（如同一业务领域的不同实体）的场景，将相关类集中存储在一个模块中，便于管理和维护。</p>
<h4 id="核心原则"><a href="#核心原则" class="headerlink" title="&lt;1&gt;核心原则"></a>&lt;1&gt;核心原则</h4><p>模块内的类需功能相关，避免将无关联的类随意放在同一模块（如将“动物类”和“数据库操作类”放在同一模块会导致混乱）。</p>
<h4 id="实战示例-1"><a href="#实战示例-1" class="headerlink" title="&lt;2&gt;实战示例"></a>&lt;2&gt;实战示例</h4><ul>
<li>步骤1：模块中定义多个关联类—— 修改 animal.py，新增 Dog、Cat 类（均继承 Animal）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># animal.py（存储多个关联类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:  <span class="comment"># 父类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, food</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>（<span class="subst">&#123;self.age&#125;</span>岁）正在吃<span class="subst">&#123;food&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># 子类1：狗</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>汪汪叫！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># 子类2：猫</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meow</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>喵喵叫！&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>步骤2：导入使用模块中的多个类 —— 在 main.py 中可按需导入其中一个或多个类。（见下文）</li>
</ul>
<h3 id="（4）从一个模块中导入多个类"><a href="#（4）从一个模块中导入多个类" class="headerlink" title="（4）从一个模块中导入多个类"></a>（4）从一个模块中导入多个类</h3><p>适用于需要使用目标模块中多个类的场景，通过逗号分隔类名，一次性导入多个所需类。</p>
<h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="&lt;1&gt;语法格式"></a>&lt;1&gt;语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 类名<span class="number">1</span>, 类名<span class="number">2</span>, 类名<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="实战演示"><a href="#实战演示" class="headerlink" title="&lt;2&gt;实战演示"></a>&lt;2&gt;实战演示</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> animal <span class="keyword">import</span> Dog, Cat  <span class="comment"># 从 animal 模块导入 Dog 和 Cat 两个类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用导入的多个类</span></span><br><span class="line">dog = Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>)</span><br><span class="line">dog.eat(<span class="string">&quot;骨头&quot;</span>)  <span class="comment"># 输出：旺财（3岁）正在吃骨头</span></span><br><span class="line">dog.bark()       <span class="comment"># 输出：旺财汪汪叫！</span></span><br><span class="line"></span><br><span class="line">cat = Cat(<span class="string">&quot;咪宝&quot;</span>, <span class="number">2</span>)</span><br><span class="line">cat.eat(<span class="string">&quot;鱼&quot;</span>)    <span class="comment"># 输出：咪宝（2岁）正在吃鱼</span></span><br><span class="line">cat.meow()       <span class="comment"># 输出：咪宝喵喵叫！</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）导入整个模块"><a href="#（5）导入整个模块" class="headerlink" title="（5）导入整个模块"></a>（5）导入整个模块</h3><ul>
<li>适用于需要使用目标模块中多个类，且希望区分“类所属模块”的场景（避免类名冲突）。</li>
<li>导入后需通过“<strong>模块名.类名</strong>”的方式访问类。</li>
<li><strong>核心优势</strong>：明确类的来源，避免不同模块中同名类的冲突（如同时导入两个模块的 Person 类，可通过 module1.Person 和 module2.Person 区分）</li>
</ul>
<h4 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="&lt;1&gt;语法格式"></a>&lt;1&gt;语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名</span><br></pre></td></tr></table></figure>

<h4 id="实战演示-1"><a href="#实战演示-1" class="headerlink" title="&lt;2&gt;实战演示"></a>&lt;2&gt;实战演示</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> animal  <span class="comment"># 导入整个 animal 模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过“模块名.类名”访问模块中的类</span></span><br><span class="line">animal_obj = animal.Animal(<span class="string">&quot;通用动物&quot;</span>, <span class="number">1</span>)</span><br><span class="line">animal_obj.eat(<span class="string">&quot;食物&quot;</span>)  <span class="comment"># 输出：通用动物（1岁）正在吃食物</span></span><br><span class="line"></span><br><span class="line">dog = animal.Dog(<span class="string">&quot;小黑&quot;</span>, <span class="number">2</span>)</span><br><span class="line">dog.bark()  <span class="comment"># 输出：小黑汪汪叫！</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）导入模块中的所有类（不推荐）"><a href="#（6）导入模块中的所有类（不推荐）" class="headerlink" title="（6）导入模块中的所有类（不推荐）"></a>（6）导入模块中的所有类（不推荐）</h3><ul>
<li>适用于需要使用目标模块中绝大多数或全部类的场景，但<strong>因易导致“命名污染”（导入冗余类）和“类名冲突”</strong></li>
<li>仅推荐在小型脚本中使用，<strong>强烈不推荐在正式项目</strong>中使用<ul>
<li>不清楚导入了哪些名称</li>
<li>可能覆盖当前模块已有的同名变量&#x2F;函数&#x2F;类</li>
</ul>
</li>
</ul>
<h4 id="语法格式-3"><a href="#语法格式-3" class="headerlink" title="&lt;1&gt;语法格式"></a>&lt;1&gt;语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<h4 id="实战示例-2"><a href="#实战示例-2" class="headerlink" title="&lt;2&gt;实战示例"></a>&lt;2&gt;实战示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> animal <span class="keyword">import</span> *  <span class="comment"># 导入 animal 模块中的所有类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用模块中的所有类（无需加模块名前缀）</span></span><br><span class="line">animal_obj = Animal(<span class="string">&quot;通用动物&quot;</span>, <span class="number">1</span>)</span><br><span class="line">dog = Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>)</span><br><span class="line">cat = Cat(<span class="string">&quot;咪宝&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">animal_obj.eat(<span class="string">&quot;食物&quot;</span>)  <span class="comment"># 输出：通用动物（1岁）正在吃食物</span></span><br><span class="line">dog.bark()              <span class="comment"># 输出：旺财汪汪叫！</span></span><br><span class="line">cat.meow()              <span class="comment"># 输出：咪宝喵喵叫！</span></span><br></pre></td></tr></table></figure>

<h3 id="（7）自定义导入（别名、包层级导入、路径配置）"><a href="#（7）自定义导入（别名、包层级导入、路径配置）" class="headerlink" title="（7）自定义导入（别名、包层级导入、路径配置）"></a>（7）自定义导入（别名、包层级导入、路径配置）</h3><p>针对特殊需求（如<strong>类名&#x2F;模块名过长</strong>、<strong>同名冲突</strong>、<strong>跨目录导入</strong>）的自定义导入方式，是实际开发中高频使用的进阶技巧。</p>
<h4 id="给类-模块指定别名（解决命名冲突-简化名称）"><a href="#给类-模块指定别名（解决命名冲突-简化名称）" class="headerlink" title="&lt;1&gt;给类&#x2F;模块指定别名（解决命名冲突&#x2F;简化名称）"></a>&lt;1&gt;给类&#x2F;模块指定别名（解决命名冲突&#x2F;简化名称）</h4><p>当类名&#x2F;模块名过长，或不同模块存在同名类时，通过 as 关键字指定别名，提升代码简洁性并避免冲突。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="comment"># 1.给类指定别名</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 类名 <span class="keyword">as</span> 别名</span><br><span class="line"><span class="comment"># 2.给模块指定别名</span></span><br><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 模块别名</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ----------------- 给类指定别名 ----------------</span></span><br><span class="line"><span class="comment"># 模块1：person1.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;来自person1的<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块2：person2.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;来自person2的<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入时指定别名</span></span><br><span class="line"><span class="keyword">from</span> person1 <span class="keyword">import</span> Person <span class="keyword">as</span> P1</span><br><span class="line"><span class="keyword">from</span> person2 <span class="keyword">import</span> Person <span class="keyword">as</span> P2</span><br><span class="line"></span><br><span class="line">p1 = P1(<span class="string">&quot;张三&quot;</span>)  <span class="comment"># 输出：来自person1的张三</span></span><br><span class="line">p2 = P2(<span class="string">&quot;李四&quot;</span>)  <span class="comment"># 输出：来自person2的李四</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------- 给模块指定别名 ---------------</span></span><br><span class="line"><span class="keyword">import</span> very_long_module_name <span class="keyword">as</span> vlmn  <span class="comment"># 给长模块名指定短别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过模块别名访问类，不直接通过别名变量导入</span></span><br><span class="line">obj = vlmn.VeryLongClassName()</span><br><span class="line">obj.show()  <span class="comment"># 简洁调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注！！</strong>：不能通过模块别名变量导入类（Python无法识别）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误写法：试图通过模块别名变量导入类（Python无法识别）</span></span><br><span class="line"><span class="comment"># from vlmn import VeryLongClassName  # 报错：ModuleNotFoundError: No module named &#x27;vlmn&#x27;</span></span><br></pre></td></tr></table></figure>


<h4 id="包层级导入（跨目录导入）"><a href="#包层级导入（跨目录导入）" class="headerlink" title="&lt;2&gt;包层级导入（跨目录导入）"></a>&lt;2&gt;包层级导入（跨目录导入）</h4><p>当类所在的模块位于包（目录）中时，需通过“包名.模块名”的层级路径导入，适用于大型项目的多目录结构管理。</p>
<p><strong>目录示例</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">my_project/          # 项目根目录</span><br><span class="line">├── main.py          # 当前模块（导入方）</span><br><span class="line">└── my_package/      # 包目录</span><br><span class="line">    ├── __init__.py  # 包初始化文件（可为空）</span><br><span class="line">    ├── animal.py    # 模块1（含 Animal、Dog、Cat 类）</span><br><span class="line">    └── person.py    # 模块2（含 Person 类）</span><br></pre></td></tr></table></figure>

<p><strong>导入语法</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1：从包的模块中导入单个类</span></span><br><span class="line"><span class="keyword">from</span> my_package.animal <span class="keyword">import</span> Dog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：导入包的模块，再通过模块访问类</span></span><br><span class="line"><span class="keyword">import</span> my_package.person <span class="keyword">as</span> mp_person</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式3：从包中导入整个模块</span></span><br><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> animal</span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_package/animal.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self, food</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>（<span class="subst">&#123;self.age&#125;</span>岁）正在吃<span class="subst">&#123;food&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>汪汪叫！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meow</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>喵喵叫！&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_package/person.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pet</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.pet = pet</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_with_pet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 和 <span class="subst">&#123;self.pet.name&#125;</span> 一起玩耍&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> my_package.animal <span class="keyword">import</span> Dog</span><br><span class="line"><span class="keyword">import</span> my_package.person <span class="keyword">as</span> mp_person</span><br><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> animal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方式1导入的 Dog 类</span></span><br><span class="line">dog = Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>)</span><br><span class="line">dog.bark()  <span class="comment"># 输出：旺财汪汪叫！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方式2导入的模块访问 Person 类</span></span><br><span class="line">person = mp_person.Person(<span class="string">&quot;张三&quot;</span>, dog)</span><br><span class="line">person.play_with_pet()  <span class="comment"># 输出：张三 和 旺财 一起玩耍</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方式3导入的模块访问类</span></span><br><span class="line">cat = animal.Animal(<span class="string">&quot;咪咪&quot;</span>, <span class="number">2</span>)</span><br><span class="line">cat.eat(<span class="string">&quot;鱼&quot;</span>)  <span class="comment"># 输出：咪咪（2岁）正在吃鱼</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义模块路径（导入非项目根目录的模块）"><a href="#自定义模块路径（导入非项目根目录的模块）" class="headerlink" title="&lt;3&gt;自定义模块路径（导入非项目根目录的模块）"></a>&lt;3&gt;自定义模块路径（导入非项目根目录的模块）</h4><p>需要导入的模块不在 Python 默认搜索路径（sys.path）中时，需手动将模块所在目录添加到搜索路径，再进行导入。</p>
<p><strong>目录示例</strong>：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span>home<span class="operator">/</span>user<span class="symbol">/</span></span><br><span class="line">├── my_project<span class="symbol">/</span>         <span class="comment"># 项目根目录</span></span><br><span class="line">│   └── main.py          <span class="comment"># 你的主程序</span></span><br><span class="line">│</span><br><span class="line">└── shared_libs<span class="symbol">/</span>         <span class="comment"># 项目外部的公共库（不在 my_project 下）</span></span><br><span class="line">    └── utils.py         <span class="comment"># 想导入的模块</span></span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：</p>
<ul>
<li>直接在 main.py 中 import utils 会报错,因为 shared_libs&#x2F; 不在 Python 的搜索路径中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> utils  <span class="comment"># ❌ ModuleNotFoundError: No module named &#x27;utils&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动添加外部模块所在目录</span></span><br><span class="line">sys.path.append(<span class="string">&quot;/home/user/shared_libs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在可以导入了</span></span><br><span class="line"><span class="keyword">import</span> utils</span><br><span class="line">utils.helper()  <span class="comment"># ✅ 正常调用</span></span><br></pre></td></tr></table></figure>

<h3 id="（8）注意事项"><a href="#（8）注意事项" class="headerlink" title="（8）注意事项"></a>（8）注意事项</h3><h4 id="概述"><a href="#概述" class="headerlink" title="&lt;1&gt;概述"></a>&lt;1&gt;概述</h4><ul>
<li><strong>避免循环导入</strong>：<ul>
<li>禁止出现“模块 A 导入模块 B 的类，模块 B 又导入模块 A 的类”的循环依赖，会直接导致导入失败（ImportError）。</li>
<li><strong>解决方案</strong>：<ul>
<li>将共同依赖的类提取到第三方模块，或延迟导入（在函数内部导入）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>优先明确导入</strong>：<ul>
<li>推荐使用“from 模块名 import 类名”（导入单个&#x2F;多个类）或“import 模块名”（导入整个模块）</li>
<li>避免使用“from 模块名 import *”，减少命名污染和冲突风险。</li>
</ul>
</li>
<li><strong>模块路径规范</strong>：<ul>
<li>同目录导入：直接使用模块名（如 from animal import Animal）。</li>
</ul>
</li>
<li><strong>子目录导入</strong>：<ul>
<li>通过包名+模块名（如 from my_package.animal import Animal）。</li>
</ul>
</li>
<li><strong>上级目录导入</strong>：<ul>
<li>需手动添加路径到 sys.path（如 sys.path.append(“..&#x2F;“)）。</li>
</ul>
</li>
<li><strong>类名冲突处理</strong>：<ul>
<li>当导入的类与当前模块的类同名时，“后导入&#x2F;定义的类”会覆盖“先导入&#x2F;定义的类“。</li>
<li><strong>解决方案</strong>：<ul>
<li>使用<strong>别名（as）</strong> 或通过 **“模块名.类名”**访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="循环导入问题与解决方案"><a href="#循环导入问题与解决方案" class="headerlink" title="&lt;2&gt; 循环导入问题与解决方案"></a>&lt;2&gt; 循环导入问题与解决方案</h4><ul>
<li><strong>错误示例</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------- 错误示例：循环导入导致模块加载失败 ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块 A：a.py</span></span><br><span class="line"><span class="keyword">from</span> b <span class="keyword">import</span> B  <span class="comment"># 模块加载时立即导入 B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.b = B()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;A 持有 B: <span class="subst">&#123;self.b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块 B：b.py</span></span><br><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> A  <span class="comment"># 模块加载时立即导入 A（形成循环）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = A()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;B 持有 A: <span class="subst">&#123;self.a&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> A  <span class="comment"># ❌ 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ImportError: cannot import name &#x27;B&#x27; from partially initialized module &#x27;b&#x27;</span></span><br><span class="line"><span class="comment"># (most likely due to a circular import)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>正确解决方案1</strong>：合并到同一模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块：entities.py（将相互依赖的类放在同一模块）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.b = <span class="literal">None</span>  <span class="comment"># 先不初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_b</span>(<span class="params">self, b</span>):</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_a</span>(<span class="params">self, a</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方：main.py</span></span><br><span class="line"><span class="keyword">from</span> entities <span class="keyword">import</span> A, B</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line">a.set_b(b)  <span class="comment"># 手动关联</span></span><br><span class="line">b.set_a(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.b)  <span class="comment"># &lt;entities.B object ...&gt;</span></span><br><span class="line"><span class="built_in">print</span>(b.a)  <span class="comment"># &lt;entities.A object ...&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>正确解决方案1（变体）</strong>：通过工厂&#x2F;协调模块解耦</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块 A：a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.b = <span class="literal">None</span>  <span class="comment"># 不在构造函数中创建 B</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">link</span>(<span class="params">self, b</span>):</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块 B：b.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">link</span>(<span class="params">self, a</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 协调模块：factory.py（负责创建和关联）</span></span><br><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> A</span><br><span class="line"><span class="keyword">from</span> b <span class="keyword">import</span> B</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_linked_pair</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建互相关联的 A 和 B 实例&quot;&quot;&quot;</span></span><br><span class="line">    a = A()</span><br><span class="line">    b = B()</span><br><span class="line">    a.link(b)</span><br><span class="line">    b.link(a)</span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方：main.py</span></span><br><span class="line"><span class="keyword">from</span> factory <span class="keyword">import</span> create_linked_pair</span><br><span class="line"></span><br><span class="line">a, b = create_linked_pair()</span><br><span class="line"><span class="built_in">print</span>(a.b)  <span class="comment"># &lt;b.B object ...&gt;</span></span><br><span class="line"><span class="built_in">print</span>(b.a)  <span class="comment"># &lt;a.A object ...&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li><strong>正确解决方案2</strong>：延迟导入（函数内部导入）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------- 正确解决方案2：延迟导入（函数内部导入） ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块 A：a.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.b = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_b</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">from</span> b <span class="keyword">import</span> B</span><br><span class="line">        <span class="variable language_">self</span>.b = B()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.b</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):  <span class="comment"># 补充 show 方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;A 持有 B: <span class="subst">&#123;self.b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块 B：b.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_a</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">from</span> a <span class="keyword">import</span> A</span><br><span class="line">        <span class="variable language_">self</span>.a = A()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):  <span class="comment"># 补充 show 方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;B 持有 A: <span class="subst">&#123;self.a&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方：main.py</span></span><br><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> A  <span class="comment"># 补充导入</span></span><br><span class="line">a = A()</span><br><span class="line">b = a.create_b()</span><br><span class="line">b.a = a  <span class="comment"># 手动反向关联</span></span><br><span class="line"></span><br><span class="line">a.show()  <span class="comment"># 输出：A 持有 B: &lt;b.B object at 0x...&gt;</span></span><br><span class="line">b.show()  <span class="comment"># 输出：B 持有 A: &lt;a.A object at 0x...&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>正确解决方案2（变体）</strong>：用于类型注解的延迟导入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块 A：a.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations  <span class="comment"># 启用延迟注解求值</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TYPE_CHECKING</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> TYPE_CHECKING:  <span class="comment"># 仅在类型检查时导入，运行时不执行</span></span><br><span class="line">    <span class="keyword">from</span> b <span class="keyword">import</span> B</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.b: B | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 类型注解可用，但运行时不导入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_b</span>(<span class="params">self, b: B</span>):</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块 B：b.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TYPE_CHECKING</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> TYPE_CHECKING:</span><br><span class="line">    <span class="keyword">from</span> a <span class="keyword">import</span> A</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a: A | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_a</span>(<span class="params">self, a: A</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方：main.py</span></span><br><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> A</span><br><span class="line"><span class="keyword">from</span> b <span class="keyword">import</span> B</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line">a.set_b(b)</span><br><span class="line">b.set_a(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a.b = <span class="subst">&#123;a.b&#125;</span>&quot;</span>)  <span class="comment"># 输出正常</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b.a = <span class="subst">&#123;b.a&#125;</span>&quot;</span>)  <span class="comment"># 输出正常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="补充：-init-py-文件-的使用"><a href="#补充：-init-py-文件-的使用" class="headerlink" title="补充：__init__.py 文件 的使用"></a>补充：__init__.py 文件 的使用</h3><p>在包目录中，__init__.py 是标识目录为 Python 包的核心文件（Python 3.3+ 支持隐式命名空间包，可省略，但工程化开发中推荐保留），核心作用是简化导入和控制包的暴露内容，具体用法分为3类。</p>
<h4 id="基础用法：空文件（仅标识包"><a href="#基础用法：空文件（仅标识包" class="headerlink" title="&lt;1&gt;基础用法：空文件（仅标识包)"></a>&lt;1&gt;基础用法：空文件（仅标识包)</h4><p>只需在包目录下创建一个空的 __init__.py 文件，即可让 Python 将该目录识别为包，支持基础的包层级导入。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目结构（空 __init__.py 示例）</span></span><br><span class="line">my_package<span class="symbol">/</span>          <span class="comment"># 包目录</span></span><br><span class="line">├── __init__.py      <span class="comment"># 空文件（核心：标识为Python包）</span></span><br><span class="line">├── animal.py        <span class="comment"># 含 Animal、Dog 类</span></span><br><span class="line">└── person.py        <span class="comment"># 含 Person 类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入使用（空 __init__.py 支持的基础导入）</span></span><br><span class="line"><span class="keyword">from</span> my_package.animal <span class="keyword">import</span> Dog</span><br><span class="line">dog = Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>)</span><br><span class="line">dog.bark()  <span class="comment"># 正常运行</span></span><br></pre></td></tr></table></figure>

<h4 id="进阶用法1：简化导入路径（常用）"><a href="#进阶用法1：简化导入路径（常用）" class="headerlink" title="&lt;2&gt;进阶用法1：简化导入路径（常用）"></a>&lt;2&gt;进阶用法1：简化导入路径（常用）</h4><p>通过在 __init__.py 中提前导入包内模块的类&#x2F;函数，可让外部导入时跳过中间模块，直接从包名导入目标类，大幅简化导入语法。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目结构（空 __init__.py 示例）</span></span><br><span class="line">my_package<span class="symbol">/</span>          <span class="comment"># 包目录</span></span><br><span class="line">├── __init__.py      <span class="comment"># 空文件（核心：标识为Python包）</span></span><br><span class="line">├── animal.py        <span class="comment"># 含 Animal、Dog 类</span></span><br><span class="line">└── person.py        <span class="comment"># 含 Person 类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步：编写 my_package/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> .animal <span class="keyword">import</span> Animal, Dog  <span class="comment"># 从当前包的 animal 模块导入指定类</span></span><br><span class="line"><span class="keyword">from</span> .person <span class="keyword">import</span> Person       <span class="comment"># 从当前包的 person 模块导入指定类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二步：外部导入（简化前 vs 简化后）</span></span><br><span class="line"><span class="comment"># 简化前（需写全模块路径）</span></span><br><span class="line"><span class="keyword">from</span> my_package.animal <span class="keyword">import</span> Dog</span><br><span class="line"><span class="keyword">from</span> my_package.person <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化后（直接从包名导入，跳过模块名）</span></span><br><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> Dog, Person</span><br><span class="line">dog = Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>)</span><br><span class="line">person = Person(<span class="string">&quot;张三&quot;</span>, dog)</span><br><span class="line">person.play_with_pet()  <span class="comment"># 正常运行</span></span><br></pre></td></tr></table></figure>

<h4 id="进阶用法2：控制“from-包名-import-”的导入内容"><a href="#进阶用法2：控制“from-包名-import-”的导入内容" class="headerlink" title="&lt;3&gt;进阶用法2：控制“from 包名 import *”的导入内容"></a>&lt;3&gt;进阶用法2：控制“from 包名 import *”的导入内容</h4><p>通过 __all__ 变量（列表类型），可明确指定当外部使用 from 包名 import * 时，能导入的类&#x2F;模块列表，避免导入冗余内容，减少命名污染。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目结构（空 __init__.py 示例）</span></span><br><span class="line">my_package<span class="symbol">/</span>          <span class="comment"># 包目录</span></span><br><span class="line">├── __init__.py      <span class="comment"># 空文件（核心：标识为Python包）</span></span><br><span class="line">├── animal.py        <span class="comment"># 含 Animal、Dog 类</span></span><br><span class="line">└── person.py        <span class="comment"># 含 Person 类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步：编写 my_package/__init__.py</span></span><br><span class="line">__all__ = [<span class="string">&quot;Animal&quot;</span>, <span class="string">&quot;Person&quot;</span>]  <span class="comment"># 仅允许外部通配导入这两个类</span></span><br><span class="line"><span class="keyword">from</span> .animal <span class="keyword">import</span> Animal, Dog  <span class="comment"># 包内导入了 Dog，但未加入 __all__</span></span><br><span class="line"><span class="keyword">from</span> .person <span class="keyword">import</span> Person</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二步：外部通配导入测试</span></span><br><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> *  <span class="comment"># 仅能导入 __all__ 中的 Animal 和 Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可正常使用</span></span><br><span class="line">animal = Animal(<span class="string">&quot;通用动物&quot;</span>, <span class="number">1</span>)</span><br><span class="line">person = Person(<span class="string">&quot;张三&quot;</span>, animal)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无法使用（Dog 未在 __all__ 中，通配导入未包含）</span></span><br><span class="line"><span class="comment"># dog = Dog(&quot;旺财&quot;, 3)  # 报错：NameError: name &#x27;Dog&#x27; is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若需使用 Dog，需明确导入</span></span><br><span class="line"><span class="keyword">from</span> my_package.animal <span class="keyword">import</span> Dog</span><br><span class="line">dog = Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>)  <span class="comment"># 正常运行</span></span><br></pre></td></tr></table></figure>

<h3 id="补充：-name-“-main-“"><a href="#补充：-name-“-main-“" class="headerlink" title="补充：__name__ &#x3D;&#x3D; “__main__“"></a>补充：__name__ &#x3D;&#x3D; “__main__“</h3><p>Python 中 __name__ &#x3D;&#x3D; “__main__“ 的核心作用，是通过 __name__ 变量的动态取值，区分模块的两种核心使用状态——<strong>「直接使用」<strong>和</strong>「被导入」</strong>，进而<strong>实现代码的“按需执行”</strong>。</p>
<h4 id="1）-name-是什么？"><a href="#1）-name-是什么？" class="headerlink" title="1）__name__ 是什么？"></a>1）__name__ 是什么？</h4><p>__name__ 是 Python 为每个 .py 文件（模块）内置的 <strong>「模块级特殊变量」</strong>，无需手动定义，其值由模块的“使用方式”决定：</p>
<ul>
<li>当模块 <strong>直接使用</strong> 时：<ul>
<li><strong>__name__ &#x3D; “__main__“</strong>（__main__ 是 Python 规定的“主模块”标识）</li>
</ul>
</li>
<li>当模块 <strong>被导入</strong> 时：<ul>
<li>__name__ &#x3D; 模块名（即<strong>模块的文件名</strong>，不含 .py 后缀）</li>
</ul>
</li>
</ul>
<p>__name__ &#x3D;&#x3D; “__main__“ 本质是一个“状态判断语句”，用于检测当前模块是否处于「直接使用」状态。</p>
<h4 id="2）模块被直接使用（作为主程序入口）"><a href="#2）模块被直接使用（作为主程序入口）" class="headerlink" title="2）模块被直接使用（作为主程序入口）"></a>2）模块被直接使用（作为主程序入口）</h4><p>当我们通过命令行执行 <strong>python 模块名.py</strong> ，或在 IDE 中<strong>直接运行某个 .py 文件</strong>时，该模块就是“直接使用”的主模块，此时：</p>
<ul>
<li>模块的 __name__ 自动赋值为 “__main__“；</li>
<li>__name__ &#x3D;&#x3D; “__main__“ 条件成立，会执行该判断语句下的代码块。</li>
</ul>
<p><strong>注！！</strong>：</p>
<ul>
<li><strong>这里的“主程序入口”，是指”判断当前模块是否是用户直接运行的主模块”，而不是“执行入口”</strong></li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculator.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;加法函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;乘法函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前模块的 __name__ 值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前模块的 __name__ = <span class="subst">&#123;__name__&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为直接运行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 只有直接运行 calculator.py 时，这里的代码才会执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">40</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模块被直接运行，执行测试代码：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;add(10, 20) = <span class="subst">&#123;add(<span class="number">10</span>, <span class="number">20</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;multiply(5, 6) = <span class="subst">&#123;multiply(<span class="number">5</span>, <span class="number">6</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">40</span>)</span><br></pre></td></tr></table></figure>

<p><strong>直接运行</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">python calculator.py</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">当前模块的 __name__ = __main__</span><br><span class="line">========================================</span><br><span class="line">模块被直接运行，执行测试代码：</span><br><span class="line">add(10, 20) = 30</span><br><span class="line">multiply(5, 6) = 30</span><br><span class="line">========================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3）模块被导入使用"><a href="#3）模块被导入使用" class="headerlink" title="3）模块被导入使用"></a>3）模块被导入使用</h4><p>当我们在 A 模块中通过import B 导入 B 模块时，B 模块是“被导入”的工具库模块，此时：</p>
<ul>
<li>B 模块的 __name__ 自动赋值为其模块名（如 “direct_use_demo”）；</li>
<li>B 模块中 __name__ &#x3D;&#x3D; “__main__“ 条件不成立，不会执行该判断下的代码块。</li>
</ul>
<p><strong>文件结构</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">├── utils.py      # 被导入的工具模块（B模块）</span><br><span class="line">└── main.py       # 主程序（A模块）</span><br></pre></td></tr></table></figure>

<p><strong>utils.py（被导入的模块）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;问候函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">radius</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算圆的面积&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">return</span> math.pi * radius ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前模块的 __name__ 值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[utils.py] 当前 __name__ = <span class="subst">&#123;__name__&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这段代码只有直接运行 utils.py 时才执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">40</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;utils.py 被直接运行，执行测试代码：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(greet(<span class="string">&quot;World&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;半径为 5 的圆面积：<span class="subst">&#123;calculate_area(<span class="number">5</span>):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">40</span>)</span><br></pre></td></tr></table></figure>

<p><strong>运行 main.py（utils 被导入）</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[main.py] 程序开始</span><br><span class="line">[main.py] 当前 __name__ = __main__</span><br><span class="line">----------------------------------------</span><br><span class="line">[utils.py] 当前 __name__ = utils</span><br><span class="line">----------------------------------------</span><br><span class="line">[main.py] 导入完成，开始调用函数</span><br><span class="line">Hello, Python!</span><br><span class="line">半径为 <span class="number">10</span> 的圆面积：<span class="number">314.16</span></span><br></pre></td></tr></table></figure>



<h1 id="十、文件"><a href="#十、文件" class="headerlink" title="十、文件"></a>十、文件</h1><ul>
<li>Python 文件操作的核心是通过内置函数（如 <strong>open()</strong>）和标准库（如 <strong>json</strong>、pickle）实现数据的读取、写入与结构化存储。</li>
</ul>
<h2 id="1-open-函数"><a href="#1-open-函数" class="headerlink" title="1.open()函数"></a>1.open()函数</h2><ul>
<li>Python 操作文件的<strong>基础入口</strong>是 open() 函数，该函数返回文件对象，通过文件对象的方法实现读写</li>
<li><strong>核心语法</strong>：<ul>
<li><strong>open(file, mode, encoding, …)</strong><ul>
<li><strong>mode</strong>（打开模式）：决定操作类型</li>
<li><strong>encoding</strong>（编码）：仅针对文本文件</li>
<li><strong>返回值</strong>：文件对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260111171120316.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260112011135864.png"></p>
<h2 id="2-with语句"><a href="#2-with语句" class="headerlink" title="2.with语句"></a>2.with语句</h2><h3 id="（1）基本语法与执行流程"><a href="#（1）基本语法与执行流程" class="headerlink" title="（1）基本语法与执行流程"></a>（1）基本语法与执行流程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, mode, encoding=<span class="string">&quot;编码&quot;</span>) <span class="keyword">as</span> 文件对象:</span><br><span class="line">    <span class="comment"># 文件操作代码</span></span><br><span class="line">    内容 = 文件对象.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># with 块结束后，文件自动关闭</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">     │                                             │</span><br><span class="line">     │ ① 调用 <span class="built_in">open</span>() 返回文件对象                  │</span><br><span class="line">     │ ② 调用文件对象的 __enter__() 方法           │</span><br><span class="line">     │ ③ 将返回值赋给 f                            │</span><br><span class="line">     ▼                                             │</span><br><span class="line">    content = f.read()  ◄─── ④ 执行 <span class="keyword">with</span> 块内代码</span><br><span class="line">     │</span><br><span class="line">     │ ⑤ <span class="keyword">with</span> 块结束（正常/异常）</span><br><span class="line">     ▼</span><br><span class="line">    自动调用 f.__exit__() ──► 内部执行 f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）同时打开多个文件"><a href="#（2）同时打开多个文件" class="headerlink" title="（2）同时打开多个文件"></a>（2）同时打开多个文件</h3><h4 id="括号换行（Python-3-10-推荐！！）"><a href="#括号换行（Python-3-10-推荐！！）" class="headerlink" title="&lt;1&gt;括号换行（Python 3.10+ 推荐！！）"></a>&lt;1&gt;括号换行（Python 3.10+ 推荐！！）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;file1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f1,</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f2,</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_out,</span><br><span class="line">):</span><br><span class="line">    content1 = f1.read()</span><br><span class="line">    content2 = f2.read()</span><br><span class="line">    f_out.write(content1 + <span class="string">&quot;\n&quot;</span> + content2)</span><br></pre></td></tr></table></figure>

<h4 id="单行写法（逗号分隔）"><a href="#单行写法（逗号分隔）" class="headerlink" title="&lt;2&gt;单行写法（逗号分隔）"></a>&lt;2&gt;单行写法（逗号分隔）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_in, <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">    content = f_in.read()</span><br><span class="line">    f_out.write(content.upper())</span><br><span class="line"><span class="comment"># 两个文件都会自动关闭</span></span><br></pre></td></tr></table></figure>
<h4 id="反斜杠换行（提高可读性）"><a href="#反斜杠换行（提高可读性）" class="headerlink" title="&lt;3&gt;反斜杠换行（提高可读性）"></a>&lt;3&gt;反斜杠换行（提高可读性）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_in, \</span><br><span class="line">     <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f_in:</span><br><span class="line">        f_out.write(line.upper())</span><br></pre></td></tr></table></figure>

<h4 id="嵌套写法（兼容所有版本）"><a href="#嵌套写法（兼容所有版本）" class="headerlink" title="&lt;4&gt;嵌套写法（兼容所有版本）"></a>&lt;4&gt;嵌套写法（兼容所有版本）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_in:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">        f_out.write(f_in.read())</span><br></pre></td></tr></table></figure>


<h3 id="（3）使用-vs-不使用-with"><a href="#（3）使用-vs-不使用-with" class="headerlink" title="（3）使用 vs 不使用 with"></a>（3）使用 vs 不使用 with</h3><ul>
<li><strong>使用with</strong>：<ul>
<li>能自动、安全地管理资源生命周期（无需手动关闭，即使代码抛出异常也会保证资源释放）</li>
</ul>
</li>
<li><strong>不使用with</strong>：<ul>
<li>要么容易因忘记关闭导致资源泄漏，要么需手动写 try-finally 保证安全（代码繁琐），或仅简单手动关闭（异常场景下资源无法释放），既增加开发成本，又存在资源管理漏洞。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1：忘记关闭（资源泄漏）</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">content = f.read()</span><br><span class="line"><span class="comment"># 忘记 f.close()，文件句柄未释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：手动关闭（异常不安全）</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">content = f.read()</span><br><span class="line">f.close()  <span class="comment"># 如果 read() 抛异常，close() 不会执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式3：try-finally（繁琐但安全）</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    content = f.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()  <span class="comment"># 无论是否异常都会执行</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）with-语句不会创建新的作用域"><a href="#（4）with-语句不会创建新的作用域" class="headerlink" title="（4）with 语句不会创建新的作用域"></a>（4）with 语句不会创建新的作用域</h3><p>with 不创建新作用域，变量属于外层作用域，只是文件被关闭了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">    lines = f.readlines()  <span class="comment"># 注意：此时已读完，lines 为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with 块外</span></span><br><span class="line"><span class="built_in">print</span>(content)      <span class="comment"># ✅ 可用，content 仍存在</span></span><br><span class="line"><span class="built_in">print</span>(f)            <span class="comment"># ✅ f 仍存在</span></span><br><span class="line"><span class="built_in">print</span>(f.closed)     <span class="comment"># ✅ 输出 True（文件已关闭）</span></span><br><span class="line"><span class="comment"># f.read()          # ❌ 报错：I/O operation on closed file</span></span><br></pre></td></tr></table></figure>


<h2 id="3-读取文件"><a href="#3-读取文件" class="headerlink" title="3.读取文件"></a>3.读取文件</h2><ul>
<li>读取文件的核心逻辑：用 open() 以“读模式”打开文件，通过文件对象的读取方法获取数据，最后关闭文件</li>
<li><strong>推荐用 with 上下文管理器自动关闭！</strong></li>
</ul>
<h3 id="（1）read-size-：读取指定长度-全部内容"><a href="#（1）read-size-：读取指定长度-全部内容" class="headerlink" title="（1）read(size) ：读取指定长度&#x2F;全部内容"></a>（1）read(size) ：读取指定长度&#x2F;全部内容</h3><ul>
<li><strong>读取指定长度&#x2F;全部内容</strong></li>
<li><strong>参数 size</strong>（可选）： <ul>
<li>指定读取的字节数</li>
<li>不指定时读取文件全部内容</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法示例1：读取全部文本内容（应用：内容筛选与保存）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()  <span class="comment"># 读取全部内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际应用：筛选包含&quot;Python&quot;的句子，写入新文件</span></span><br><span class="line">filtered_content = [sentence <span class="keyword">for</span> sentence <span class="keyword">in</span> content.split(<span class="string">&quot;\n&quot;</span>) <span class="keyword">if</span> <span class="string">&quot;Python&quot;</span> <span class="keyword">in</span> sentence]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;python_related.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>.join(filtered_content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法示例2：读取前 10 个字符（应用：获取文件头部信息）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    header = f.read(<span class="number">10</span>)  <span class="comment"># 仅读取前10个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际应用：判断文件是否为指定类型（如判断日志文件头部标识）</span></span><br><span class="line"><span class="keyword">if</span> header.startswith(<span class="string">&quot;LOG-2024&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是2024年的日志文件&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;非目标日志文件&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）readline-：按行读取（一次一行）"><a href="#（2）readline-：按行读取（一次一行）" class="headerlink" title="（2）readline()：按行读取（一次一行）"></a>（2）readline()：按行读取（一次一行）</h3><ul>
<li><strong>按行读取（一次一行）</strong></li>
<li>适用于大文件（避免一次性加载全部内容占用内存），每次调用读取一行，直到文件末尾返回空字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法示例1：逐行读取文本（仅演示）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = f.readline()  <span class="comment"># 一次读一行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:  <span class="comment"># 读到末尾，返回空字符串，退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(line.strip())  <span class="comment"># strip() 去除换行符和空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：直接迭代文件对象（更推荐）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line.strip())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法示例2：逐行读取文本（应用：统计特定行数量）（仅演示）</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">target_keyword = <span class="string">&quot;错误&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;large_log.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f, \</span><br><span class="line">     <span class="built_in">open</span>(<span class="string">&quot;error_log.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> err_f:</span><br><span class="line">    line_num = <span class="number">1</span>  <span class="comment"># 手动维护行号（enumerate的替代方案）</span></span><br><span class="line">    <span class="comment"># 用readline()循环读取，直到返回空字符串（文件末尾）</span></span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">while</span> line:  <span class="comment"># 非空字符串为True，空字符串（EOF）为False</span></span><br><span class="line">        <span class="keyword">if</span> target_keyword <span class="keyword">in</span> line:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 写入带行号的错误行，保持和原代码一致的格式</span></span><br><span class="line">            err_f.write(<span class="string">f&quot;行<span class="subst">&#123;line_num&#125;</span>：<span class="subst">&#123;line.strip()&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="comment"># 读取下一行，并更新行号</span></span><br><span class="line">        line = f.readline()</span><br><span class="line">        line_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;日志中包含&#x27;错误&#x27;的行数：<span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  方式2：直接迭代文件对象（更推荐）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;large_log.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f, \</span><br><span class="line">     <span class="built_in">open</span>(<span class="string">&quot;error_log.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> err_f:  <span class="comment"># 同时打开两个文件</span></span><br><span class="line">    <span class="keyword">for</span> line_num, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> target_keyword <span class="keyword">in</span> line:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            err_f.write(<span class="string">f&quot;行<span class="subst">&#123;line_num&#125;</span>：<span class="subst">&#123;line.strip()&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;日志中包含&#x27;错误&#x27;的行数：<span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（3）readlines-：读取所有行-返回列表"><a href="#（3）readlines-：读取所有行-返回列表" class="headerlink" title="（3）readlines()：读取所有行,返回列表"></a>（3）readlines()：读取所有行,返回列表</h3><p>一次性读取文件所有行，每一行作为列表的一个元素，适用于中小文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法示例1：读取所有行并遍历</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()  <span class="comment"># 返回列表，元素为每一行内容</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="built_in">print</span>(line.strip())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法示例2：读取所有行并遍历（应用：数据清洗与格式转换）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()  <span class="comment"># 返回列表，元素为每一行内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤1：清洗空行和空格</span></span><br><span class="line">cleaned_lines = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> lines <span class="keyword">if</span> line.strip()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2：格式转换（将&quot;姓名:年龄&quot;格式转为&quot;姓名,年龄&quot;的CSV格式）</span></span><br><span class="line">csv_lines = [line.replace(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;,&quot;</span>) <span class="keyword">for</span> line <span class="keyword">in</span> cleaned_lines]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3：写入CSV文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;姓名,年龄\n&quot;</span>)</span><br><span class="line">    f.writelines([line + <span class="string">&quot;\n&quot;</span> <span class="keyword">for</span> line <span class="keyword">in</span> csv_lines])</span><br></pre></td></tr></table></figure>

<h3 id="（4）二进制文件读取（如图片、视频）"><a href="#（4）二进制文件读取（如图片、视频）" class="headerlink" title="（4）二进制文件读取（如图片、视频）"></a>（4）二进制文件读取（如图片、视频）</h3><p>二进制文件需用**“rb”模式**打开，读取的内容为字节串（bytes 类型），无需指定 encoding。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法示例1：文件复制（实际应用：备份图片/视频）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;image.jpg&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    img_data = f.read()  <span class="comment"># 读取二进制数据（bytes 类型）</span></span><br><span class="line"><span class="comment"># 写入新文件实现备份，保留原始格式</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;image_backup.jpg&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(img_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;图片备份完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法示例2：验证文件格式（实际应用：判断是否为JPG图片）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;unknown_file.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 检查文件头（前 2 字节）</span></span><br><span class="line">    header = f.read(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查文件尾（最后 2 字节）</span></span><br><span class="line">    f.seek(-<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 从文件末尾向前移动 2 字节</span></span><br><span class="line">    footer = f.read(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># JPG 文件：头部 0xFFD8，尾部 0xFFD9</span></span><br><span class="line"><span class="keyword">if</span> header == <span class="string">b&#x27;\xff\xd8&#x27;</span> <span class="keyword">and</span> footer == <span class="string">b&#x27;\xff\xd9&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该文件是完整的 JPG 图片格式&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> header == <span class="string">b&#x27;\xff\xd8&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该文件可能是 JPG 图片（头部匹配，但尾部不完整）&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;非 JPG 图片格式&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法示例3：截取部分字节数据（实际应用：提取图片缩略信息）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;video.mp4&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 读取前100字节数据（MP4文件头部包含格式信息）</span></span><br><span class="line">    video_header = f.read(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 将截取的头部信息写入新文件，用于格式分析</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;video_header.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(video_header)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;视频头部信息提取完成&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="补充：读取结果content"><a href="#补充：读取结果content" class="headerlink" title="补充：读取结果content"></a>补充：读取结果content</h3><h4 id="content的类型"><a href="#content的类型" class="headerlink" title="&lt;1&gt;content的类型"></a>&lt;1&gt;content的类型</h4><p><strong>1.文本模式（r、r+）</strong>：</p>
<ul>
<li>content 是 <strong>str 类型（字符串）</strong> ——&gt; 操作方式就是操作“字符串”</li>
<li>包含文件中的原始字符（如换行符 \n、空格等）</li>
</ul>
<p><strong>2.二进制模式（rb、rb+）</strong>：</p>
<ul>
<li>content 是 <strong>bytes 类型（字节串）</strong></li>
<li>格式为 b”xxx”，不涉及编码转换</li>
</ul>
<h4 id="content的生命周期"><a href="#content的生命周期" class="headerlink" title="&lt;2&gt;content的生命周期"></a>&lt;2&gt;content的生命周期</h4><p>content不是缩进在with块中定义吗，为什么with语句结束后仍能使用？</p>
<ul>
<li><strong>with 语句不会创建新的作用域！！</strong><ul>
<li>所以 with 块内定义的变量，在块外仍属于同一作用域，可以继续访问</li>
</ul>
</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(...) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.<span class="built_in">read</span>()</span><br><span class="line">    │</span><br><span class="line">    └── content 定义在 <span class="keyword">with</span> 块内</span><br><span class="line">        但 <span class="keyword">with</span> 不创建新作用域</span><br><span class="line">        ↓</span><br><span class="line">        content 属于外层作用域（通常是函数/模块级）</span><br><span class="line">        ↓</span><br><span class="line">        <span class="keyword">with</span> 结束后仍可访问 content</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：with 块内的变量在块外可用</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">    line_count = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(content)      <span class="comment"># ✅ 正常</span></span><br><span class="line"><span class="built_in">print</span>(line_count)   <span class="comment"># ✅ 正常，输出 10</span></span><br><span class="line"><span class="built_in">print</span>(f.closed)     <span class="comment"># ✅ 输出 True（文件已关闭，但 f 变量仍存在）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：for 循环同理</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    x = i * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(i)  <span class="comment"># ✅ 输出 4（循环变量在循环外可用）</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># ✅ 输出 8</span></span><br></pre></td></tr></table></figure>

<h2 id="4-写入文件"><a href="#4-写入文件" class="headerlink" title="4.写入文件"></a>4.写入文件</h2><ul>
<li>写入文件的核心逻辑：用 open() 以“写模式”打开文件，通过文件对象的写入方法写入数据，</li>
<li><strong>注意</strong>：“写模式”会覆盖原有内容，“追加模式”则在文件末尾添加。</li>
</ul>
<h3 id="（1）write-string-bytes-：写入字符串-字节串"><a href="#（1）write-string-bytes-：写入字符串-字节串" class="headerlink" title="（1）write(string&#x2F;bytes)：写入字符串&#x2F;字节串"></a>（1）write(string&#x2F;bytes)：写入字符串&#x2F;字节串</h3><ul>
<li>文本模式下写入字符串，二进制模式下写入字节串</li>
<li>返回写入的字符&#x2F;字节数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法示例1：文本写入（覆盖原有内容，模式 &quot;w&quot;）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    count = f.write(<span class="string">&quot;Hello Python!\n&quot;</span>)  <span class="comment"># 写入字符串，\n 表示换行</span></span><br><span class="line">    f.write(<span class="string">&quot;这是第二行内容&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;写入的字符数：<span class="subst">&#123;count&#125;</span>&quot;</span>)  <span class="comment"># 输出：写入的字符数：14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法示例2：文本追加（模式 &quot;a&quot;，在末尾添加，不覆盖原有内容）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;\n这是追加的内容&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法示例3：二进制写入（模式 &quot;wb&quot;）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">b&quot;Hello Binary!&quot;</span>)  <span class="comment"># 写入字节串，前缀 b 表示 bytes 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充示例4：读取文本文件内容，写入另一个文本文件（文本文件复制/格式转换）</span></span><br><span class="line"><span class="comment"># 场景：读取源文件，过滤空行后写入目标文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;source.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> read_f, <span class="built_in">open</span>(<span class="string">&quot;target.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> write_f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> read_f:  <span class="comment"># 逐行读取源文件，避免一次性加载大文件</span></span><br><span class="line">        <span class="keyword">if</span> line.strip():  <span class="comment"># 过滤空行（strip() 去除空白字符后判断是否为空）</span></span><br><span class="line">            write_f.write(line)  <span class="comment"># 将非空行写入目标文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文本文件内容过滤并写入完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充示例5：读取二进制文件内容，写入另一个二进制文件（文件备份）</span></span><br><span class="line"><span class="comment"># 场景：备份图片、视频等二进制文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;original.jpg&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> read_f, <span class="built_in">open</span>(<span class="string">&quot;backup.jpg&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> write_f:</span><br><span class="line">    <span class="comment"># 分块读取（每次1024字节），适用于大二进制文件，避免内存占用过高</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        chunk = read_f.read(<span class="number">1024</span>)  <span class="comment"># 读取1024字节块</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> chunk:  <span class="comment"># 读取完毕（chunk为空字节串）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        write_f.write(chunk)  <span class="comment"># 写入字节块到备份文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;二进制文件备份完成&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）writelines-iterable-：写入可迭代对象（列表-元组等）"><a href="#（2）writelines-iterable-：写入可迭代对象（列表-元组等）" class="headerlink" title="（2）writelines(iterable)：写入可迭代对象（列表&#x2F;元组等）"></a>（2）writelines(iterable)：写入可迭代对象（列表&#x2F;元组等）</h3><ul>
<li>接收字符串&#x2F;字节串组成的<strong>可迭代对象</strong>，批量写入</li>
<li>不会自动添加换行符，需手动在元素中添加 \n</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础示例：批量写入多行固定内容</span></span><br><span class="line">lines = [<span class="string">&quot;第一行\n&quot;</span>, <span class="string">&quot;第二行\n&quot;</span>, <span class="string">&quot;第三行\n&quot;</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(lines)  <span class="comment"># 批量写入列表中的字符串，\n 实现换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际应用1：读取多个文件内容，整合后批量写入新文件</span></span><br><span class="line"><span class="comment"># 场景：合并多个日志文件内容到一个汇总文件</span></span><br><span class="line">log_files = [<span class="string">&quot;log1.txt&quot;</span>, <span class="string">&quot;log2.txt&quot;</span>, <span class="string">&quot;log3.txt&quot;</span>]</span><br><span class="line">summary_lines = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先读取所有日志文件内容，添加到列表中（带文件标识）</span></span><br><span class="line"><span class="keyword">for</span> idx, log_file <span class="keyword">in</span> <span class="built_in">enumerate</span>(log_files, <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(log_file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 给每个文件的内容添加标识行，便于区分来源</span></span><br><span class="line">        summary_lines.append(<span class="string">f&quot;=== 日志文件<span class="subst">&#123;idx&#125;</span>：<span class="subst">&#123;log_file&#125;</span> ===\n&quot;</span>)</span><br><span class="line">        summary_lines.extend([line <span class="keyword">for</span> line <span class="keyword">in</span> f])  <span class="comment"># 读取文件所有行，添加到列表</span></span><br><span class="line">        summary_lines.append(<span class="string">&quot;\n&quot;</span>)  <span class="comment"># 每个文件内容后添加空行分隔</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量写入汇总文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;log_summary.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(summary_lines)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;多日志文件合并完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际应用2：结构化数据格式化批量写入（生成CSV文件）</span></span><br><span class="line"><span class="comment"># 场景：将字典列表格式的用户数据，转为CSV行后批量写入</span></span><br><span class="line">user_list = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;北京&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">28</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;广州&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先构造CSV表头和内容行（转为字符串列表）</span></span><br><span class="line">csv_lines = [<span class="string">&quot;姓名,年龄,城市\n&quot;</span>]  <span class="comment"># 表头</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</span><br><span class="line">    <span class="comment"># 格式化每个用户数据为CSV行字符串</span></span><br><span class="line">    csv_line = <span class="string">f&quot;<span class="subst">&#123;user[<span class="string">&#x27;name&#x27;</span>]&#125;</span>,<span class="subst">&#123;user[<span class="string">&#x27;age&#x27;</span>]&#125;</span>,<span class="subst">&#123;user[<span class="string">&#x27;city&#x27;</span>]&#125;</span>\n&quot;</span></span><br><span class="line">    csv_lines.append(csv_line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量写入CSV文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;user_info.csv&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(csv_lines)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户数据CSV文件生成完成&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5-读写模式（r-、w-、a-）"><a href="#5-读写模式（r-、w-、a-）" class="headerlink" title="5.读写模式（r+、w+、a+）"></a>5.读写模式（r+、w+、a+）</h2><p>若需同时实现读写操作，可使用带“+”的模式，核心区别如下：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260111211850795.png"><br><strong>注意</strong>：可读可写模式下，“读”、“写”共用一个“文件指针”，会相互影响</p>
<h3 id="（1）r-模式：读写（文件必须存在）"><a href="#（1）r-模式：读写（文件必须存在）" class="headerlink" title="（1）r+ 模式：读写（文件必须存在）"></a>（1）r+ 模式：读写（文件必须存在）</h3><p>假设 test.txt 初始内容为：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Python <span class="keyword">File</span></span><br><span class="line"><span class="keyword">End</span> of <span class="keyword">File</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># r+ 模式：从文件开头开始，可读可写</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 1. 先读取内容</span></span><br><span class="line">    content = f.read()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取内容：\n<span class="subst">&#123;content&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取后指针位置：<span class="subst">&#123;f.tell()&#125;</span>&quot;</span>)  <span class="comment"># 指针在文件末尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 直接写入（会追加到末尾，因为指针在末尾）</span></span><br><span class="line">    f.write(<span class="string">&quot;\n新增内容1&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 移动指针到开头再写入（会覆盖原内容）</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    f.write(<span class="string">&quot;COVER&quot;</span>)  <span class="comment"># 覆盖前5个字符 &quot;Hello&quot; -&gt; &quot;COVER&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 读取最终内容</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最终内容：\n<span class="subst">&#123;f.read()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">读取内容：</span><br><span class="line">Hello World</span><br><span class="line">Python <span class="keyword">File</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">of</span> <span class="keyword">File</span></span><br><span class="line">读取后指针位置：<span class="number">35</span></span><br><span class="line">最终内容：</span><br><span class="line"><span class="keyword">COVER</span> World</span><br><span class="line">Python <span class="keyword">File</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">of</span> <span class="keyword">File</span></span><br><span class="line">新增内容<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）w-模式：读写（清空文件-创建新文件）"><a href="#（2）w-模式：读写（清空文件-创建新文件）" class="headerlink" title="（2）w+ 模式：读写（清空文件&#x2F;创建新文件）"></a>（2）w+ 模式：读写（清空文件&#x2F;创建新文件）</h3><p>假设 test.txt 初始内容为：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Python <span class="keyword">File</span></span><br><span class="line"><span class="keyword">End</span> of <span class="keyword">File</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># w+ 模式：打开时清空文件，可读可写</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 1. 文件已被清空，直接读取为空</span></span><br><span class="line">    content = f.read()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;打开后读取：&#x27;<span class="subst">&#123;content&#125;</span>&#x27;&quot;</span>)  <span class="comment"># 空字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 写入新内容</span></span><br><span class="line">    f.write(<span class="string">&quot;第一行\n&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;第二行\n&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;第三行&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;写入后指针位置：<span class="subst">&#123;f.tell()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 必须移动指针才能读取</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取写入的内容：\n<span class="subst">&#123;f.read()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">打开后读取：&#x27;&#x27;</span><br><span class="line">写入后指针位置：<span class="number">21</span></span><br><span class="line">读取写入的内容：</span><br><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br></pre></td></tr></table></figure>

<h3 id="（3）a-模式：追加读写（不清空-创建新文件）"><a href="#（3）a-模式：追加读写（不清空-创建新文件）" class="headerlink" title="（3）a+ 模式：追加读写（不清空&#x2F;创建新文件）"></a>（3）a+ 模式：追加读写（不清空&#x2F;创建新文件）</h3><p>假设 test.txt 初始内容为：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Python <span class="keyword">File</span></span><br><span class="line"><span class="keyword">End</span> of <span class="keyword">File</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a+ 模式：写入永远在末尾，读取需要移动指针</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 1. 打开时指针在末尾</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;打开时指针位置：<span class="subst">&#123;f.tell()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 直接读取为空（指针在末尾）</span></span><br><span class="line">    content = f.read()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;直接读取：&#x27;<span class="subst">&#123;content&#125;</span>&#x27;&quot;</span>)  <span class="comment"># 空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 移动指针到开头再读取</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;移动指针后读取：\n<span class="subst">&#123;f.read()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 写入内容（无论指针在哪，都追加到末尾）</span></span><br><span class="line">    f.seek(<span class="number">0</span>)  <span class="comment"># 即使移动到开头</span></span><br><span class="line">    f.write(<span class="string">&quot;\n追加的内容&quot;</span>)  <span class="comment"># 仍然写到末尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5. 验证</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最终内容：\n<span class="subst">&#123;f.read()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">打开时指针位置：<span class="number">35</span></span><br><span class="line">直接读取：<span class="string">&#x27;&#x27;</span></span><br><span class="line">移动指针后读取：</span><br><span class="line">Hello World</span><br><span class="line">Python <span class="keyword">File</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">of</span> <span class="keyword">File</span></span><br><span class="line">最终内容：</span><br><span class="line">Hello World</span><br><span class="line">Python <span class="keyword">File</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">of</span> <span class="keyword">File</span></span><br><span class="line">追加的内容</span><br></pre></td></tr></table></figure>

<h3 id="（4）指针影响演示"><a href="#（4）指针影响演示" class="headerlink" title="（4）指针影响演示"></a>（4）指针影响演示</h3><p>假设 test.txt 初始内容为：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Python <span class="keyword">File</span></span><br><span class="line"><span class="keyword">End</span> of <span class="keyword">File</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;demo.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 写入内容</span></span><br><span class="line">    f.write(<span class="string">&quot;ABCDEFGHIJ&quot;</span>)  <span class="comment"># 指针在位置10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不移动指针直接读取</span></span><br><span class="line">    result1 = f.read()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;写入后直接读：&#x27;<span class="subst">&#123;result1&#125;</span>&#x27;&quot;</span>)  <span class="comment"># 空，因为指针在末尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 移动到位置5</span></span><br><span class="line">    f.seek(<span class="number">5</span>)</span><br><span class="line">    result2 = f.read()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;从位置5读取：&#x27;<span class="subst">&#123;result2&#125;</span>&#x27;&quot;</span>)  <span class="comment"># FGHIJ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在位置3写入，会覆盖</span></span><br><span class="line">    f.seek(<span class="number">3</span>)</span><br><span class="line">    f.write(<span class="string">&quot;XYZ&quot;</span>)  <span class="comment"># 覆盖 DEF -&gt; XYZ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取全部</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最终内容：&#x27;<span class="subst">&#123;f.read()&#125;</span>&#x27;&quot;</span>)  <span class="comment"># ABCXYZGHIJ</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">写入后直接读：&#x27;&#x27;</span><br><span class="line">从位置<span class="number">5</span>读取：&#x27;FGHIJ&#x27;</span><br><span class="line">最终内容：&#x27;ABCXYZGHIJ&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="补充1：seek-函数"><a href="#补充1：seek-函数" class="headerlink" title="补充1：seek() 函数"></a>补充1：seek() 函数</h3><p>在读写模式下，文件指针的位置直接影响读写结果，<strong>seek函数</strong>用于手动移动文件指针，是实现精准读写的关键。</p>
<ul>
<li><strong>核心功能</strong>：<ul>
<li>移动文件指针到指定位置，支持文本模式和二进制模式（二进制模式更精准，文本模式下 offset 建议为 0）</li>
</ul>
</li>
<li><strong>语法</strong>：<ul>
<li><strong>seek(offset, whence)</strong></li>
</ul>
</li>
<li><strong>参数说明</strong>：<ul>
<li><strong>offset</strong>：偏移量，即指针移动的字节数<ul>
<li>正数向右移动</li>
<li>负数向左移动</li>
<li>文本模式下不支持负数偏移</li>
</ul>
</li>
<li><strong>whence</strong>：基准位置，可选值为 0、1、2（<strong>默认值为 0</strong>）<ul>
<li><strong>whence&#x3D;0</strong>：以文件开头为基准（最常用，支持所有模式）；</li>
<li><strong>whence&#x3D;1</strong>：以当前指针位置为基准（仅支持二进制模式）；</li>
<li><strong>whence&#x3D;2</strong>：以文件末尾为基准（仅支持二进制模式）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>常见用法</strong>：<ul>
<li>f.seek(0)：指针移到文件开头（读写模式下读取前必用）；</li>
<li>f.seek(0, 2)：指针移到文件末尾（追加内容前可用，等同于 a 模式）；</li>
<li>f.seek(5)：指针从文件开头向右移动 5 个字节（精准定位修改位置）。</li>
</ul>
</li>
<li>**注意：**文本模式下 seek() 的限制<ul>
<li>whence&#x3D;1 和 whence&#x3D;2 仅支持二进制模式</li>
<li>文本模式下 offset 必须为 0，或者是 tell() 返回的值<ul>
<li>否则会报错：io.UnsupportedOperation: can’t do nonzero cur-relative seeks</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="补充2：tell-函数"><a href="#补充2：tell-函数" class="headerlink" title="补充2：tell() 函数"></a>补充2：tell() 函数</h3><p>tell() 是文件对象的方法，用于<strong>获取当前文件指针的位置</strong>。</p>
<h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="&lt;1&gt;介绍"></a>&lt;1&gt;介绍</h4><ul>
<li><strong>基本语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">position = f.tell()  <span class="comment"># 返回当前指针位置（字节数）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>核心特点</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260111220721101.png"></li>
<li><strong>与seek()的配合关系</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tell() ──► 获取当前位置（只读）</span><br><span class="line">seek() ──► 设置指针位置（可写）</span><br><span class="line"></span><br><span class="line">常见组合：</span><br><span class="line"><span class="number">1.</span> pos = f.tell()   <span class="comment"># 保存位置</span></span><br><span class="line"><span class="number">2.</span> f.read(...)      <span class="comment"># 读取操作</span></span><br><span class="line"><span class="number">3.</span> f.seek(pos)      <span class="comment"># 恢复位置</span></span><br></pre></td></tr></table></figure>

<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><h5 id="1）基本用法"><a href="#1）基本用法" class="headerlink" title="1）基本用法"></a>1）基本用法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.tell())      <span class="comment"># 输出：0（刚打开，指针在开头）</span></span><br><span class="line">    </span><br><span class="line">    f.read(<span class="number">5</span>)            <span class="comment"># 读取 5 个字符</span></span><br><span class="line">    <span class="built_in">print</span>(f.tell())      <span class="comment"># 输出：5（英文）或更大（含中文时）</span></span><br><span class="line">    </span><br><span class="line">    f.read()             <span class="comment"># 读取剩余全部内容</span></span><br><span class="line">    <span class="built_in">print</span>(f.tell())      <span class="comment"># 输出：文件总字节数（指针在末尾）</span></span><br></pre></td></tr></table></figure>
<h5 id="2）配合-seek-使用"><a href="#2）配合-seek-使用" class="headerlink" title="2）配合 seek() 使用"></a>2）配合 seek() 使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read(<span class="number">10</span>)</span><br><span class="line">    pos = f.tell()       <span class="comment"># 记录当前位置</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前位置：<span class="subst">&#123;pos&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    content = f.read(<span class="number">5</span>)  <span class="comment"># 继续读取</span></span><br><span class="line">    </span><br><span class="line">    f.seek(pos)          <span class="comment"># 回到之前记录的位置</span></span><br><span class="line">    <span class="built_in">print</span>(f.tell())      <span class="comment"># 输出：与之前的 pos 相同</span></span><br></pre></td></tr></table></figure>

<h5 id="3）读写模式下跟踪指针"><a href="#3）读写模式下跟踪指针" class="headerlink" title="3）读写模式下跟踪指针"></a>3）读写模式下跟踪指针</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;demo.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;写入前：<span class="subst">&#123;f.tell()&#125;</span>&quot;</span>)   <span class="comment"># 输出：0</span></span><br><span class="line">    </span><br><span class="line">    f.write(<span class="string">&quot;Hello Python&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;写入后：<span class="subst">&#123;f.tell()&#125;</span>&quot;</span>)   <span class="comment"># 输出：12</span></span><br><span class="line">    </span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;seek后：<span class="subst">&#123;f.tell()&#125;</span>&quot;</span>)   <span class="comment"># 输出：0</span></span><br><span class="line">    </span><br><span class="line">    f.read(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取后：<span class="subst">&#123;f.tell()&#125;</span>&quot;</span>)   <span class="comment"># 输出：5</span></span><br></pre></td></tr></table></figure>

<h5 id="4）中文字符的字节计算"><a href="#4）中文字符的字节计算" class="headerlink" title="4）中文字符的字节计算"></a>4）中文字符的字节计算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># UTF-8 编码下，中文字符占 3 个字节</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;chinese.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;你好世界&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;chinese.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read(<span class="number">1</span>)            <span class="comment"># 读取 1 个字符（&quot;你&quot;）</span></span><br><span class="line">    <span class="built_in">print</span>(f.tell())      <span class="comment"># 输出：3（1个中文 = 3字节）</span></span><br><span class="line">    </span><br><span class="line">    f.read(<span class="number">1</span>)            <span class="comment"># 读取 1 个字符（&quot;好&quot;）</span></span><br><span class="line">    <span class="built_in">print</span>(f.tell())      <span class="comment"># 输出：6</span></span><br></pre></td></tr></table></figure>

<h5 id="5）使用场景"><a href="#5）使用场景" class="headerlink" title="5）使用场景"></a>5）使用场景</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景1：记录读取进度（断点续读）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;large_file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">100</span>:</span><br><span class="line">            checkpoint = f.tell()  <span class="comment"># 记录第100行后的位置</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;检查点位置：<span class="subst">&#123;checkpoint&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景2：计算文件大小</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0</span>, <span class="number">2</span>)         <span class="comment"># 移动到文件末尾</span></span><br><span class="line">    file_size = f.tell() <span class="comment"># 获取文件大小（字节）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件大小：<span class="subst">&#123;file_size&#125;</span> 字节&quot;</span>)</span><br></pre></td></tr></table></figure>




<h2 id="6-结构化数据存储：JSON（持久化存储）"><a href="#6-结构化数据存储：JSON（持久化存储）" class="headerlink" title="6.结构化数据存储：JSON（持久化存储）"></a>6.结构化数据存储：JSON（持久化存储）</h2><ul>
<li>当需要存储列表、字典、类实例等结构化数据时，直接用文本文件读写会导致格式混乱，推荐使用 Python 标准库提供的序列化工具：json（通用格式，跨语言兼容）、pickle（Python 专属格式，支持更多数据类型）。</li>
<li>JSON（JavaScript Object Notation）是轻量级数据交换格式<ul>
<li>支持<strong>字符串</strong>、<strong>数字</strong>、<strong>列表</strong>、<strong>字典</strong>等基础数据类型</li>
<li>不支持 Python 专属类型（如<strong>类实例</strong>、<strong>元组</strong>、<strong>集合</strong>）<ul>
<li><strong>补充</strong>：JSON 中数组会被转为 Python 列表，Python 元组序列化后会变成列表。读取时无法还原为元组。</li>
</ul>
</li>
<li><strong>json.dump()</strong>：写入文件,实现序列化</li>
<li><strong>json.load()</strong>：读取文件，实现反序列化</li>
</ul>
</li>
</ul>
<h3 id="（1）写入JSON数据（序列化）"><a href="#（1）写入JSON数据（序列化）" class="headerlink" title="（1）写入JSON数据（序列化）"></a>（1）写入JSON数据（序列化）</h3><h4 id="json-dump-函数"><a href="#json-dump-函数" class="headerlink" title="&lt;1&gt;json.dump() 函数"></a>&lt;1&gt;json.dump() 函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 核心作用：将 Python 结构化数据（如字典、列表）序列化（转换）为 JSON 格式字符串，直接写入文件</span><br><span class="line"><span class="number">2.</span> 函数语法：json.dump(obj, fp, ensure_ascii=<span class="literal">True</span>, indent=<span class="literal">None</span>, separators=<span class="literal">None</span>, sort_keys=<span class="literal">False</span>, ...)</span><br><span class="line"><span class="number">3.</span> 关键参数说明：</span><br><span class="line">    - obj：必传参数，要序列化的 Python 数据（支持字典、列表、字符串、数字、布尔值、<span class="literal">None</span>）；</span><br><span class="line">    - fp：必传参数，文件对象（需以文本模式 <span class="string">&quot;w&quot;</span> 或 <span class="string">&quot;a&quot;</span> 打开），用于接收 JSON 数据；</span><br><span class="line">    - ensure_ascii：可选参数，默认 <span class="literal">True</span>，非 ASCII 字符（如中文）会转为 Unicode 转义符（\uXXX）；设为 <span class="literal">False</span> 可保留中文原样；</span><br><span class="line">    - indent：可选参数，默认 <span class="literal">None</span>（无格式化），传入整数时表示缩进空格数，用于格式化 JSON 输出（便于阅读）；</span><br><span class="line">    - sort_keys：可选参数，默认 <span class="literal">False</span>，设为 <span class="literal">True</span> 时会按字典的键（key）升序排序输出。</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实际示例：写入 JSON 数据</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要存储的结构化数据（字典）</span></span><br><span class="line">user_data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">&quot;hobbies&quot;</span>: [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;编程&quot;</span>],</span><br><span class="line">    <span class="string">&quot;is_student&quot;</span>: <span class="literal">False</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入 JSON 文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;user_data.json&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># ensure_ascii=False 确保中文正常显示，indent=2 格式化输出（便于阅读）</span></span><br><span class="line">    json.dump(user_data, f, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）读取-JSON-数据（反序列化）"><a href="#（2）读取-JSON-数据（反序列化）" class="headerlink" title="（2）读取 JSON 数据（反序列化）"></a>（2）读取 JSON 数据（反序列化）</h3><h4 id="json-load-函数"><a href="#json-load-函数" class="headerlink" title="&lt;1&gt;json.load()函数"></a>&lt;1&gt;json.load()函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 核心作用：从已打开的 JSON 文件中读取 JSON 格式字符串，反序列化为 Python 对应数据类型（字典/列表等）</span><br><span class="line"><span class="number">2.</span> 函数语法：json.load(fp, cls=<span class="literal">None</span>, object_hook=<span class="literal">None</span>, parse_float=<span class="literal">None</span>, parse_int=<span class="literal">None</span>, parse_constant=<span class="literal">None</span>, object_pairs_hook=<span class="literal">None</span>, ...)</span><br><span class="line"><span class="number">3.</span> 关键参数说明：</span><br><span class="line">   - fp：必传参数，文件对象（需以文本模式 <span class="string">&quot;r&quot;</span> 打开），用于读取 JSON 数据；</span><br><span class="line">   - object_hook：可选参数，自定义反序列化规则，接收一个字典参数，返回处理后的对象（如将 JSON 字典转为自定义类实例）；</span><br><span class="line">   - parse_float/parse_int：可选参数，自定义浮点数/整数的解析规则（如将浮点数转为 Decimal 类型，避免精度丢失）；</span><br><span class="line">   - cls：可选参数，指定自定义的 JSON 解码器类，用于扩展反序列化功能；</span><br><span class="line">   - 其他参数（如 object_pairs_hook）：用于控制 JSON 对象的解析顺序（如保留键的插入顺序）。</span><br><span class="line"><span class="number">4.</span> 返回值特征：</span><br><span class="line">   - 反序列化后的返回值类型与 JSON 数据结构对应：</span><br><span class="line">       - JSON 对象 → Python 字典</span><br><span class="line">       - JSON 数组 → Python 列表</span><br><span class="line">       - JSON 字符串 → Python 字符串</span><br><span class="line">       - JSON 数字 → Python 整数/浮点数</span><br><span class="line">       - JSON true/false/null → Python <span class="literal">True</span>/<span class="literal">False</span>/<span class="literal">None</span>。</span><br></pre></td></tr></table></figure>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础示例：读取 JSON 文件（反序列化）</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 JSON 文件（文件对象需以 &quot;r&quot; 模式打开，指定正确编码）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;user_data.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    loaded_data = json.load(f)  <span class="comment"># 反序列化为 Python 字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用读取的数据（验证返回值类型与数据可用性）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(loaded_data))  <span class="comment"># 输出：&lt;class &#x27;dict&#x27;&gt;，验证返回值为字典类型</span></span><br><span class="line"><span class="built_in">print</span>(loaded_data[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 输出：张三（正常访问字典键值）</span></span><br><span class="line"><span class="built_in">print</span>(loaded_data[<span class="string">&quot;hobbies&quot;</span>][<span class="number">0</span>])  <span class="comment"># 输出：篮球（访问字典中的列表元素）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展示例：使用 object_hook 自定义反序列化（将 JSON 字典转为自定义类实例）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, hobbies, is_student</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="variable language_">self</span>.hobbies = hobbies</span><br><span class="line">        <span class="variable language_">self</span>.is_student = is_student</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>，<span class="subst">&#123;self.age&#125;</span>岁，爱好<span class="subst">&#123;<span class="string">&#x27;,&#x27;</span>.join(self.hobbies)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义自定义反序列化函数，传入 object_hook</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">json_to_user</span>(<span class="params">dict_data</span>):</span><br><span class="line">    <span class="keyword">return</span> User(dict_data[<span class="string">&quot;name&quot;</span>], dict_data[<span class="string">&quot;age&quot;</span>], dict_data[<span class="string">&quot;hobbies&quot;</span>], dict_data[<span class="string">&quot;is_student&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 JSON 并转为 User 实例</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;user_data.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    user_instance = json.load(f, object_hook=json_to_user)</span><br><span class="line"></span><br><span class="line">user_instance.introduce()  <span class="comment"># 输出：我是张三，25岁，爱好篮球,编程</span></span><br></pre></td></tr></table></figure>

<h4 id="补充示例"><a href="#补充示例" class="headerlink" title="&lt;3&gt;补充示例"></a>&lt;3&gt;补充示例</h4><p>JSON 中数组会被转为 Python 列表，Python 元组序列化后会变成列表,读取时无法还原为元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;coords&quot;</span>: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;  <span class="comment"># 元组</span></span><br><span class="line">json_str = json.dumps(data)</span><br><span class="line"><span class="built_in">print</span>(json_str)  <span class="comment"># &#123;&quot;coords&quot;: [1, 2, 3]&#125;  ← 变成了数组</span></span><br><span class="line"></span><br><span class="line">loaded = json.loads(json_str)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(loaded[<span class="string">&quot;coords&quot;</span>]))  <span class="comment"># &lt;class &#x27;list&#x27;&gt;  ← 无法还原为元组</span></span><br></pre></td></tr></table></figure>

<h2 id="7-结构化数据存储：Pickle（Python-专属场景）"><a href="#7-结构化数据存储：Pickle（Python-专属场景）" class="headerlink" title="7.结构化数据存储：Pickle（Python 专属场景）"></a>7.结构化数据存储：Pickle（Python 专属场景）</h2><p>Pickle 是 Python 专属序列化工具，支持几乎所有 Python 数据类型（包括类实例、元组、集合、函数等），但生成的文件只能被 Python 解析，不支持跨语言。核心通过 pickle.dump()（写入）和 pickle.load()（读取）实现。</p>
<h3 id="（1）写入-Pickle-数据（序列化）"><a href="#（1）写入-Pickle-数据（序列化）" class="headerlink" title="（1）写入 Pickle 数据（序列化）"></a>（1）写入 Pickle 数据（序列化）</h3><h4 id="pickle-dump-函数"><a href="#pickle-dump-函数" class="headerlink" title="&lt;1&gt;pickle.dump() 函数"></a>&lt;1&gt;pickle.dump() 函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 核心作用：将 Python 任意数据类型（如类实例、字典、列表、元组等）序列化（转换）为二进制字节流，直接写入文件</span><br><span class="line"><span class="number">2.</span> 函数语法：pickle.dump(obj, file, protocol=<span class="literal">None</span>, fix_imports=<span class="literal">True</span>, buffer_callback=<span class="literal">None</span>)</span><br><span class="line"><span class="number">3.</span> 关键参数说明：</span><br><span class="line">   - obj：必传参数，要序列化的 Python 数据（支持几乎所有 Python 类型，包括类实例、函数、集合、元组等）；</span><br><span class="line">   - file：必传参数，文件对象（需以二进制模式 <span class="string">&quot;wb&quot;</span> 或 <span class="string">&quot;ab&quot;</span> 打开），用于接收序列化后的二进制字节流；</span><br><span class="line">   - protocol：可选参数，指定序列化协议版本（默认使用最高兼容版本），取值范围 <span class="number">0</span>-<span class="number">5</span>：</span><br><span class="line">     - protocol=<span class="number">0</span>：文本格式序列化（兼容性最强，速度慢，不推荐）；</span><br><span class="line">     - protocol&gt;=<span class="number">1</span>：二进制格式序列化（推荐，速度快、体积小），版本越高功能越全，需注意 Python 版本兼容性；</span><br><span class="line">   - fix_imports：可选参数，默认 <span class="literal">True</span>，用于在 Python <span class="number">2</span> 和 Python <span class="number">3</span> 之间兼容，处理导入路径差异；</span><br><span class="line">   - buffer_callback：可选参数，用于处理大数据对象的缓冲，自定义字节流写入方式（进阶用法）。</span><br><span class="line"><span class="number">4.</span> 核心特征：</span><br><span class="line">   - 支持 Python 专属类型：这是与 json.dump() 的核心区别，可直接序列化类实例、函数等 JSON 不支持的类型；</span><br><span class="line">   - 二进制输出：序列化后的数据是二进制字节流，需用二进制模式写入文件，生成的文件不可直接阅读；</span><br><span class="line">   - Python 专属：生成的文件只能被 Python 解析，无法跨语言使用（如 Java、JavaScript 无法读取）。</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实际示例：写入 Pickle 数据（序列化类实例）</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个类（Pickle 支持类实例序列化）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>，<span class="subst">&#123;self.age&#125;</span>岁&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类实例</span></span><br><span class="line">person = Person(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入 Pickle 文件（必须用二进制模式 &quot;wb&quot;，无需指定 encoding）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;person.pkl&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 使用默认最高协议版本序列化，也可指定 protocol=4（Python 3.4+ 支持）</span></span><br><span class="line">    pickle.dump(person, f)</span><br></pre></td></tr></table></figure>
<h3 id="（2）读取-Pickle-数据（反序列化）"><a href="#（2）读取-Pickle-数据（反序列化）" class="headerlink" title="（2）读取 Pickle 数据（反序列化）"></a>（2）读取 Pickle 数据（反序列化）</h3><h4 id="pickle-load-函数"><a href="#pickle-load-函数" class="headerlink" title="&lt;1&gt;pickle.load() 函数"></a>&lt;1&gt;pickle.load() 函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 核心作用：从已打开的 Pickle 二进制文件中读取序列化的字节流，反序列化为原本的 Python 数据类型（如类实例、字典、列表等）</span><br><span class="line"><span class="number">2.</span> 函数语法：pickle.load(file, fix_imports=<span class="literal">True</span>, encoding=<span class="string">&quot;ASCII&quot;</span>, errors=<span class="string">&quot;strict&quot;</span>, buffers=<span class="literal">None</span>)</span><br><span class="line"><span class="number">3.</span> 关键参数说明：</span><br><span class="line">   - file：必传参数，文件对象（需以二进制模式 <span class="string">&quot;rb&quot;</span> 打开），用于读取序列化的二进制字节流；</span><br><span class="line">   - fix_imports：可选参数，默认 <span class="literal">True</span>，用于解决 Python <span class="number">2</span> 和 Python <span class="number">3</span> 之间的导入兼容性问题，自动调整导入路径；</span><br><span class="line">   - encoding：可选参数，默认 <span class="string">&quot;ASCII&quot;</span>，指定反序列化时字符串的编码方式（针对 Python <span class="number">2</span> 序列化的文件）；</span><br><span class="line">     若读取 Python <span class="number">3</span> 序列化的文件，无需修改此参数，使用默认值即可；</span><br><span class="line">   - errors：可选参数，默认 <span class="string">&quot;strict&quot;</span>，指定编码错误的处理方式（如 <span class="string">&quot;ignore&quot;</span> 忽略错误、<span class="string">&quot;replace&quot;</span> 替换错误字符）；</span><br><span class="line">   - buffers：可选参数，进阶用法，用于处理大数据对象的缓冲，接收一个可迭代的缓冲对象。</span><br><span class="line"><span class="number">4.</span> 返回值特征：</span><br><span class="line">   - 反序列化后的返回值类型与序列化前的原始数据类型完全一致（核心优势）：</span><br><span class="line">     如序列化前是类实例 → 反序列化后仍是该类实例；序列化前是字典 → 反序列化后仍是字典；</span><br><span class="line">   - 无需手动转换类型，可直接使用原始数据的属性和方法（如类实例的成员方法）。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础示例：读取 Pickle 文件（反序列化为原始 Python 类型）</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 Pickle 文件（必须用二进制模式 &quot;rb&quot; 打开，无需指定 encoding）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;person.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    loaded_person = pickle.load(f)  <span class="comment"># 反序列化为原本的 Person 类实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证返回值类型与功能可用性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(loaded_person))  <span class="comment"># 输出：&lt;class &#x27;__main__.Person&#x27;&gt;，确认为 Person 类实例</span></span><br><span class="line">loaded_person.introduce()  <span class="comment"># 输出：我是李四，30岁（可直接调用类实例方法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展示例1：读取复杂 Pickle 数据（字典嵌套列表、元组）</span></span><br><span class="line"><span class="comment"># 先准备一个复杂数据并序列化</span></span><br><span class="line">complex_data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;scores&quot;</span>: [<span class="number">90</span>, <span class="number">85</span>, <span class="number">95</span>],</span><br><span class="line">    <span class="string">&quot;info&quot;</span>: (<span class="string">&quot;Python开发者&quot;</span>, <span class="number">25</span>),</span><br><span class="line">    <span class="string">&quot;is_valid&quot;</span>: <span class="literal">True</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;complex_data.pkl&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(complex_data, f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化读取</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;complex_data.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    loaded_complex = pickle.load(f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(loaded_complex))  <span class="comment"># 输出：&lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(loaded_complex[<span class="string">&quot;scores&quot;</span>][<span class="number">1</span>])  <span class="comment"># 输出：85（正常访问列表元素）</span></span><br><span class="line"><span class="built_in">print</span>(loaded_complex[<span class="string">&quot;info&quot;</span>][<span class="number">0</span>])  <span class="comment"># 输出：Python开发者（正常访问元组元素）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展示例2：处理 Python 2 序列化的 Pickle 文件（兼容性场景）</span></span><br><span class="line"><span class="comment"># 若读取的是 Python 2 生成的 .pkl 文件，可能需要指定 encoding 参数</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;python2_data.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 用 &quot;latin-1&quot; 编码兼容 Python 2 序列化的字符串</span></span><br><span class="line">        loaded_py2_data = pickle.load(f, encoding=<span class="string">&quot;latin-1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Python 2 序列化文件读取成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取失败：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="8-Python-文件操作函数速查表"><a href="#8-Python-文件操作函数速查表" class="headerlink" title="8.Python 文件操作函数速查表"></a>8.Python 文件操作函数速查表</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260111221730929.png"></p>
<h1 id="十一、异常处理"><a href="#十一、异常处理" class="headerlink" title="十一、异常处理"></a>十一、异常处理</h1><ul>
<li>在 Python 编程中，异常是程序运行时发生的非预期错误（如语法错误、逻辑错误、资源访问失败等），会导致程序中断。</li>
<li>异常处理的核心目标是<strong>捕获并处理这些错误</strong>，保证程序优雅运行而非直接崩溃，同时便于定位问题。</li>
</ul>
<h2 id="1-异常的本质"><a href="#1-异常的本质" class="headerlink" title="1.异常的本质"></a>1.异常的本质</h2><ul>
<li>Python 中所有异常都是 <strong>BaseException</strong> 类的子类，形成了层级分明的异常体系</li>
<li>常见的异常类（如 TypeError、FileNotFoundError）均继承自 <strong>Exception 类</strong>（BaseException 的子类）</li>
<li>BaseException 还包含 SystemExit（程序退出）、KeyboardInterrupt（用户中断，如 Ctrl+C）等特殊异常。</li>
</ul>
<h2 id="2-常见异常类型及触发场景"><a href="#2-常见异常类型及触发场景" class="headerlink" title="2.常见异常类型及触发场景"></a>2.常见异常类型及触发场景</h2><p>Python 内置了大量异常类，覆盖开发中常见的错误场景，以下是高频异常类型汇总：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260111225712830.png"><br><strong>注</strong>：这些异常类我们可以直接创建，并<a href="#raise">通过raise 语句主动抛出</a></p>
<h2 id="3-异常处理核心语法"><a href="#3-异常处理核心语法" class="headerlink" title="3.异常处理核心语法"></a>3.异常处理核心语法</h2><p>Python 提供 <strong>try-except-else-finally</strong> 语句块实现异常处理，各部分分工明确，可灵活组合使用。</p>
<h3 id="（1）基础结构：try-except"><a href="#（1）基础结构：try-except" class="headerlink" title="（1）基础结构：try-except"></a>（1）基础结构：try-except</h3><p>最核心的异常捕获结构：</p>
<ul>
<li><strong>try 块</strong>：包裹可能触发异常的代码</li>
<li><strong>except 块</strong>：捕获并处理指定异常。</li>
</ul>
<h4 id="语法格式-4"><a href="#语法格式-4" class="headerlink" title="&lt;1&gt;语法格式"></a>&lt;1&gt;语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能触发异常的代码块（被监控的代码）</span></span><br><span class="line">    危险操作</span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">1</span> [<span class="keyword">as</span> 异常对象]:</span><br><span class="line">    <span class="comment"># 捕获到“异常类型1”时执行的处理逻辑</span></span><br><span class="line">    处理方案<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">2</span> [<span class="keyword">as</span> 异常对象]:</span><br><span class="line">    <span class="comment"># 捕获到“异常类型2”时执行的处理逻辑</span></span><br><span class="line">    处理方案<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>as 异常对象</strong>(可选):<ul>
<li>用于获取异常的详细信息（如错误原因），通过异常对象.args 或直接打印异常对象查看。</li>
</ul>
</li>
<li><strong>多 except 顺序</strong>:<ul>
<li>异常类有层级关系时，<strong>需先捕获子类异常，再捕获父类异常</strong>（否则子类异常会被父类异常捕获，无法精准处理）</li>
</ul>
</li>
<li><strong>未捕获异常</strong>:<ul>
<li>若 try 块<strong>触发的异常</strong>未被任何 except 捕获，程序会中断并抛出默认错误信息。</li>
</ul>
</li>
</ul>
<h4 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：捕获指定异常（除零错误）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span>  <span class="comment"># 触发 ZeroDivisionError</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;除零错误：<span class="subst">&#123;e&#125;</span>&quot;</span>)  <span class="comment"># 输出：除零错误：division by zero</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;错误详情：<span class="subst">&#123;e.args&#125;</span>&quot;</span>)  <span class="comment"># 输出：错误详情：(&#x27;division by zero&#x27;,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：多异常捕获（类型不匹配 + 除零错误）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line">    result = <span class="number">10</span> / num</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;输入错误：<span class="subst">&#123;e&#125;</span>&quot;</span>)  <span class="comment"># 输入非数字时触发</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;除零错误：<span class="subst">&#123;e&#125;</span>&quot;</span>)  <span class="comment"># 输入0时触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3：捕获异常并修复（用户输入场景，引导修正错误）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_valid_number</span>(<span class="params">prompt</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 循环直到获取有效输入</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            num = <span class="built_in">int</span>(<span class="built_in">input</span>(prompt))  <span class="comment"># 尝试转换输入为整数</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 主动检测除零风险，抛出自定义提示的异常</span></span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;输入不能为0，否则会触发除零错误&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> num  <span class="comment"># 输入有效，返回结果</span></span><br><span class="line">        <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 捕获输入错误，提示用户并引导重新输入（修复异常）</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;输入无效：<span class="subst">&#123;e&#125;</span>，请重新输入！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数获取有效数字，确保后续计算正常执行</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = get_valid_number(<span class="string">&quot;请输入一个非零整数：&quot;</span>)</span><br><span class="line">    result = <span class="number">10</span> / num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;计算成功！10 ÷ <span class="subst">&#123;num&#125;</span> = <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;程序异常：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（2）扩展结构：try-except-else"><a href="#（2）扩展结构：try-except-else" class="headerlink" title="（2）扩展结构：try-except-else"></a>（2）扩展结构：try-except-else</h3><p>当 try 块未触发任何异常时，执行 else 块代码（else 块需紧跟所有 except 块之后）。</p>
<h4 id="语法格式-5"><a href="#语法格式-5" class="headerlink" title="&lt;1&gt;语法格式"></a>&lt;1&gt;语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能触发异常的代码</span><br><span class="line"><span class="keyword">except</span> 异常类型 <span class="keyword">as</span> e:</span><br><span class="line">    异常处理逻辑</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># try 块无异常时执行</span></span><br><span class="line">    正常执行的后续逻辑</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line">    result = <span class="number">10</span> / num</span><br><span class="line"><span class="keyword">except</span> (ValueError, ZeroDivisionError) <span class="keyword">as</span> e:  <span class="comment"># 用元组捕获多个异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;错误：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;计算成功，结果：<span class="subst">&#123;result&#125;</span>&quot;</span>)  <span class="comment"># 无异常时执行</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）完整结构：try-except-else-finally"><a href="#（3）完整结构：try-except-else-finally" class="headerlink" title="（3）完整结构：try-except-else-finally"></a>（3）完整结构：try-except-else-finally</h3><p>finally 块用于定义“无论是否触发异常，都必须执行”的代码（如资源释放、文件关闭、连接断开等），是资源管理的核心。</p>
<h4 id="语法格式-6"><a href="#语法格式-6" class="headerlink" title="&lt;1&gt;语法格式"></a>&lt;1&gt;语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能触发异常的代码</span><br><span class="line"><span class="keyword">except</span> 异常类型 <span class="keyword">as</span> e:</span><br><span class="line">    异常处理逻辑</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    无异常时执行的逻辑</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否异常，必执行</span></span><br><span class="line">    资源释放/清理逻辑</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>关键特性</strong><ul>
<li><strong>优先级最高！！</strong>：即使 try、except、else 块中有 return、break 等语句，finally 块仍会先执行。</li>
<li><strong>适用场景</strong>：文件关闭、数据库连接断开、锁释放等必须执行的清理操作（替代手动关闭，避免异常导致资源泄漏）</li>
</ul>
</li>
</ul>
<h4 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：演示 finally 的执行特性（注意：实际文件操作推荐用 with 语句）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_config</span>(<span class="params">filename</span>):</span><br><span class="line">    file = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        file = <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        content = file.read()</span><br><span class="line">        <span class="keyword">return</span> content  <span class="comment"># 即使这里 return，finally 仍会执行</span></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;文件不存在：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;编码错误：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 捕获其他未预料的异常，避免程序崩溃</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;读取文件时发生未知错误：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 关键：无论是否发生异常，finally 都会执行</span></span><br><span class="line">        <span class="keyword">if</span> file:</span><br><span class="line">            file.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;finally：文件已关闭&quot;</span>)</span><br><span class="line"></span><br><span class="line">result = read_config(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;返回值：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出顺序（以文件存在为例）：</span></span><br><span class="line"><span class="comment"># finally：文件已关闭</span></span><br><span class="line"><span class="comment"># 返回值：（文件内容或 None）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ⚠️ 注意：</span></span><br><span class="line"><span class="comment"># 上述代码仅用于演示 finally 的&quot;必执行&quot;特性</span></span><br><span class="line"><span class="comment"># 实际文件操作强烈推荐使用 with 语句（自动管理资源，代码更简洁安全）：</span></span><br><span class="line"><span class="comment"># with open(&quot;test.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:</span></span><br><span class="line"><span class="comment">#     content = f.read()</span></span><br></pre></td></tr></table></figure>
<p><strong>再次强调</strong>：上述代码仅用于演示 finally 的”必执行”特性，<strong>实际文件操作强烈推荐使用 with！！</strong> </p>
<h2 id="4-raise-语句（主动抛出异常）"><a href="#4-raise-语句（主动抛出异常）" class="headerlink" title="4.raise 语句（主动抛出异常）"></a>4.raise 语句（主动抛出异常）<a id="raise"></a></h2><p>除了捕获程序运行时的自然异常，还可通过 raise 语句主动触发异常，用于自定义错误校验逻辑（如参数合法性检查）。</p>
<h3 id="（1）基本语法"><a href="#（1）基本语法" class="headerlink" title="（1）基本语法"></a>（1）基本语法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法1：抛出指定类型的异常（无详细信息）</span></span><br><span class="line"><span class="keyword">raise</span> 异常类型</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法2：抛出异常并指定错误信息</span></span><br><span class="line"><span class="keyword">raise</span> 异常类型(<span class="string">&quot;错误描述&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法3：重新抛出捕获的异常（保留异常原始信息）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    危险操作</span><br><span class="line"><span class="keyword">except</span> 异常类型 <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 处理部分逻辑后，重新抛出异常</span></span><br><span class="line">    <span class="keyword">raise</span> e  <span class="comment"># 或直接 raise（保留完整异常栈）</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）使用示例"><a href="#（2）使用示例" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：参数合法性校验（主动抛出 ValueError）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(name, <span class="built_in">str</span>) <span class="keyword">or</span> <span class="built_in">len</span>(name) == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 主动抛出异常，说明参数错误</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;用户名必须是非空字符串&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(age, <span class="built_in">int</span>) <span class="keyword">or</span> age &lt; <span class="number">0</span> <span class="keyword">or</span> age &gt; <span class="number">150</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;年龄必须是 0-150 之间的整数&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;注册成功：姓名=<span class="subst">&#123;name&#125;</span>，年龄=<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，触发主动抛出的异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    register(<span class="string">&quot;&quot;</span>, <span class="number">25</span>)  <span class="comment"># 用户名空，触发异常</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;注册失败：<span class="subst">&#123;e&#125;</span>&quot;</span>)  <span class="comment"># 输出：注册失败：用户名必须是非空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：重新抛出异常（保留原始错误栈）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    register(<span class="string">&quot;张三&quot;</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;校验失败：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">raise</span>  <span class="comment"># 重新抛出异常，程序会中断并显示完整错误栈</span></span><br></pre></td></tr></table></figure>

<h2 id="5-自定义异常类"><a href="#5-自定义异常类" class="headerlink" title="5.自定义异常类"></a>5.自定义异常类</h2><p>当 Python 内置异常无法满足业务需求时（如自定义业务错误类型），可<strong>通过继承 Exception 类（或其子类）创建自定义异常</strong>。</p>
<h3 id="（1）语法规则"><a href="#（1）语法规则" class="headerlink" title="（1）语法规则"></a>（1）语法规则</h3><ul>
<li>需继承 Exception 类或其合法子类（如 ValueError、TypeError 等）</li>
<li>不建议直接继承 BaseException（避免捕获系统级异常，如KeyboardInterrupt）</li>
<li><strong>通常需重写__init__ 方法</strong>：可添加自定义属性（如错误码、详细描述），让异常信息更完整（可选，简单场景可直接使用父类构造方法）。</li>
</ul>
<h3 id="（2）使用示例-1"><a href="#（2）使用示例-1" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==================== 自定义异常类示例 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例1：最简单的自定义异常（直接继承，无额外属性）---</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBusinessError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;业务逻辑错误的基类&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例2：带自定义属性的异常（重写 __init__）---</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValidationError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;数据验证错误&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, field, message, error_code=<span class="literal">None</span></span>):</span><br><span class="line">       <span class="variable language_">self</span>.field = field          <span class="comment"># 出错的字段名</span></span><br><span class="line">       <span class="variable language_">self</span>.message = message      <span class="comment"># 错误描述</span></span><br><span class="line">       <span class="variable language_">self</span>.error_code = error_code  <span class="comment"># 错误码（可选）</span></span><br><span class="line">       <span class="comment"># 调用父类构造方法，设置异常的默认消息</span></span><br><span class="line">       <span class="built_in">super</span>().__init__(<span class="string">f&quot;[<span class="subst">&#123;error_code&#125;</span>] <span class="subst">&#123;field&#125;</span>: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 示例3：继承特定异常子类 ---</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeValueError</span>(<span class="title class_ inherited__">ValueError</span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;年龄值错误（继承 ValueError，语义更明确）&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, age, message=<span class="string">&quot;年龄必须在 0-150 之间&quot;</span></span>):</span><br><span class="line">       <span class="variable language_">self</span>.age = age</span><br><span class="line">       <span class="variable language_">self</span>.message = message</span><br><span class="line">       <span class="built_in">super</span>().__init__(<span class="string">f&quot;<span class="subst">&#123;message&#125;</span>，当前值：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== 使用示例 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register_user</span>(<span class="params">name, age, email</span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;用户注册函数（演示自定义异常的使用）&quot;&quot;&quot;</span></span><br><span class="line">   <span class="comment"># 验证姓名</span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">or</span> <span class="built_in">len</span>(name) &lt; <span class="number">2</span>:</span><br><span class="line">       <span class="keyword">raise</span> ValidationError(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;姓名长度不能少于2个字符&quot;</span>, <span class="string">&quot;E1001&quot;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 验证年龄</span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(age, <span class="built_in">int</span>) <span class="keyword">or</span> age &lt; <span class="number">0</span> <span class="keyword">or</span> age &gt; <span class="number">150</span>:</span><br><span class="line">       <span class="keyword">raise</span> AgeValueError(age)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 验证邮箱</span></span><br><span class="line">   <span class="keyword">if</span> <span class="string">&quot;@&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> email:</span><br><span class="line">       <span class="keyword">raise</span> ValidationError(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;邮箱格式不正确&quot;</span>, <span class="string">&quot;E1002&quot;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: name, <span class="string">&quot;age&quot;</span>: age, <span class="string">&quot;email&quot;</span>: email&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== 捕获自定义异常 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   user = register_user(<span class="string">&quot;张&quot;</span>, <span class="number">25</span>, <span class="string">&quot;test@example.com&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ValidationError <span class="keyword">as</span> e:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f&quot;验证失败 - 字段：<span class="subst">&#123;e.field&#125;</span>，原因：<span class="subst">&#123;e.message&#125;</span>，错误码：<span class="subst">&#123;e.error_code&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> AgeValueError <span class="keyword">as</span> e:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f&quot;年龄错误 - <span class="subst">&#123;e.message&#125;</span>，输入值：<span class="subst">&#123;e.age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f&quot;注册成功：<span class="subst">&#123;user&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：验证失败 - 字段：name，原因：姓名长度不能少于2个字符，错误码：E1001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十二、代码测试"><a href="#十二、代码测试" class="headerlink" title="十二、代码测试"></a>十二、代码测试</h1><h2 id="1-测试的分类"><a href="#1-测试的分类" class="headerlink" title="1.测试的分类"></a>1.测试的分类</h2><table>
<thead>
<tr>
<th>测试类型</th>
<th>说明</th>
<th>粒度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单元测试</strong></td>
<td>测试最小代码单元（函数&#x2F;方法）</td>
<td>最细</td>
</tr>
<tr>
<td><strong>集成测试</strong></td>
<td>测试模块间的协作</td>
<td>中等</td>
</tr>
<tr>
<td><strong>端到端测试</strong></td>
<td>测试完整业务流程</td>
<td>最粗</td>
</tr>
</tbody></table>
<h2 id="2-常用测试框架"><a href="#2-常用测试框架" class="headerlink" title="2.常用测试框架"></a>2.常用测试框架</h2><h3 id="（1）unittest（标准库，内置）"><a href="#（1）unittest（标准库，内置）" class="headerlink" title="（1）unittest（标准库，内置）"></a>（1）unittest（标准库，内置）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAdd</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add_positive</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add_negative</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(-<span class="number">1</span>, -<span class="number">2</span>), -<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add_zero</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个判断的作用是&quot;当直接运行该测试文件时执行测试，被导入时不执行&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<p><strong>常用断言方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>assertEqual(a, b)</code></td>
<td>a &#x3D;&#x3D; b</td>
</tr>
<tr>
<td><code>assertNotEqual(a, b)</code></td>
<td>a !&#x3D; b</td>
</tr>
<tr>
<td><code>assertTrue(x)</code></td>
<td>x 为真</td>
</tr>
<tr>
<td><code>assertFalse(x)</code></td>
<td>x 为假</td>
</tr>
<tr>
<td><code>assertIsNone(x)</code></td>
<td>x is None</td>
</tr>
<tr>
<td><code>assertRaises(Error)</code></td>
<td>检查是否抛出指定异常</td>
</tr>
</tbody></table>
<h3 id="（2）pytest（第三方，更推荐-⭐）"><a href="#（2）pytest（第三方，更推荐-⭐）" class="headerlink" title="（2）pytest（第三方，更推荐 ⭐）"></a>（2）pytest（第三方，更推荐 ⭐）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_demo.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名以 test_ 开头即可，无需继承类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_add_positive</span>():</span><br><span class="line">    <span class="keyword">assert</span> add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_add_negative</span>():</span><br><span class="line">    <span class="keyword">assert</span> add(-<span class="number">1</span>, -<span class="number">2</span>) == -<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试异常</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;除数不能为0&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_divide_by_zero</span>():</span><br><span class="line">    <span class="keyword">with</span> pytest.raises(ValueError):</span><br><span class="line">        divide(<span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>运行测试</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pytest                    <span class="comment"># 自动发现并运行所有 test_*.py</span></span><br><span class="line">pytest -v                 <span class="comment"># 详细输出</span></span><br><span class="line">pytest test_demo.py       <span class="comment"># 运行指定文件</span></span><br><span class="line">pytest -k <span class="string">&quot;add&quot;</span>           <span class="comment"># 只运行名称包含 &quot;add&quot; 的测试</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）pytest-参数化测试（批量测试多组数据）"><a href="#（3）pytest-参数化测试（批量测试多组数据）" class="headerlink" title="（3）pytest 参数化测试（批量测试多组数据）"></a>（3）pytest 参数化测试（批量测试多组数据）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;a, b, expected&quot;</span>, [</span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params">-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">a, b, expected</span>):</span><br><span class="line">    <span class="keyword">assert</span> add(a, b) == expected</span><br></pre></td></tr></table></figure>

<h2 id="3-测试夹具（Fixture）——-测试前后的准备-清理"><a href="#3-测试夹具（Fixture）——-测试前后的准备-清理" class="headerlink" title="3.测试夹具（Fixture）—— 测试前后的准备&#x2F;清理"></a>3.测试夹具（Fixture）—— 测试前后的准备&#x2F;清理</h2><h3 id="unittest-方式"><a href="#unittest-方式" class="headerlink" title="&lt;1&gt;unittest 方式"></a>&lt;1&gt;unittest 方式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestDatabase</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;每个测试方法前执行&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.db = connect_database()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tearDown</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;每个测试方法后执行&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.db.close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_query</span>(<span class="params">self</span>):</span><br><span class="line">        result = <span class="variable language_">self</span>.db.query(<span class="string">&quot;SELECT 1&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertIsNotNone(result)</span><br></pre></td></tr></table></figure>

<h3 id="pytest-方式（更灵活）"><a href="#pytest-方式（更灵活）" class="headerlink" title="&lt;2&gt;pytest 方式（更灵活）"></a>&lt;2&gt;pytest 方式（更灵活）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db_connection</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;夹具：建立数据库连接&quot;&quot;&quot;</span></span><br><span class="line">    conn = connect_database()</span><br><span class="line">    <span class="keyword">yield</span> conn  <span class="comment"># yield 之前是 setup，之后是 teardown</span></span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_query</span>(<span class="params">db_connection</span>):  <span class="comment"># 参数名 = 夹具函数名</span></span><br><span class="line">    result = db_connection.query(<span class="string">&quot;SELECT 1&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Mock-模拟（隔离外部依赖）"><a href="#4-Mock-模拟（隔离外部依赖）" class="headerlink" title="4.Mock 模拟（隔离外部依赖）"></a>4.Mock 模拟（隔离外部依赖）</h2><p>测试时模拟网络请求、数据库、文件等外部依赖，避免真实调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> Mock, patch</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：模拟 API 请求</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_name</span>(<span class="params">user_id</span>):</span><br><span class="line">    response = requests.get(<span class="string">f&quot;https://api.example.com/users/<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> response.json()[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试时模拟 requests.get</span></span><br><span class="line"><span class="meta">@patch(<span class="params"><span class="string">&quot;requests.get&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_get_user_name</span>(<span class="params">mock_get</span>):</span><br><span class="line">    <span class="comment"># 设置模拟返回值</span></span><br><span class="line">    mock_get.return_value.json.return_value = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    result = get_user_name(<span class="number">123</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span> result == <span class="string">&quot;张三&quot;</span></span><br><span class="line">    mock_get.assert_called_once()  <span class="comment"># 验证被调用过</span></span><br></pre></td></tr></table></figure>

<h2 id="5-测试覆盖率"><a href="#5-测试覆盖率" class="headerlink" title="5.测试覆盖率"></a>5.测试覆盖率</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pytest-cov</span><br><span class="line">pytest --cov=your_module --cov-report=html</span><br></pre></td></tr></table></figure>
<p>生成覆盖率报告，查看哪些代码未被测试覆盖。</p>
<h2 id="6-实际开发中的测试最佳实践"><a href="#6-实际开发中的测试最佳实践" class="headerlink" title="6.实际开发中的测试最佳实践"></a>6.实际开发中的测试最佳实践</h2><table>
<thead>
<tr>
<th>原则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>测试文件命名</strong></td>
<td><code>test_*.py</code> 或 <code>*_test.py</code></td>
</tr>
<tr>
<td><strong>测试函数命名</strong></td>
<td><code>test_功能_场景_预期结果</code></td>
</tr>
<tr>
<td><strong>一个测试一个断言</strong></td>
<td>每个测试只验证一个行为</td>
</tr>
<tr>
<td><strong>独立性</strong></td>
<td>测试之间互不依赖，可单独运行</td>
</tr>
<tr>
<td><strong>快速</strong></td>
<td>单元测试应毫秒级完成</td>
</tr>
<tr>
<td><strong>使用 Mock</strong></td>
<td>隔离外部依赖（网络、数据库、文件）</td>
</tr>
</tbody></table>
<h2 id="7-项目结构示例"><a href="#7-项目结构示例" class="headerlink" title="7.项目结构示例"></a>7.项目结构示例</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">my_project/</span><br><span class="line">├── src/</span><br><span class="line">│   └── calculator.py</span><br><span class="line">├── tests/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── test_calculator.py</span><br><span class="line">│   └── conftest.py        # pytest 共享夹具</span><br><span class="line">├── pytest.ini             # pytest 配置</span><br><span class="line">└── requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="8-快速对比"><a href="#8-快速对比" class="headerlink" title="8.快速对比"></a>8.快速对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>unittest</th>
<th>pytest</th>
</tr>
</thead>
<tbody><tr>
<td>安装</td>
<td>内置</td>
<td>需安装</td>
</tr>
<tr>
<td>语法</td>
<td>类 + 方法</td>
<td>函数即可</td>
</tr>
<tr>
<td>断言</td>
<td><code>self.assertEqual()</code></td>
<td>直接 <code>assert</code></td>
</tr>
<tr>
<td>参数化</td>
<td>繁琐</td>
<td><code>@pytest.mark.parametrize</code></td>
</tr>
<tr>
<td>夹具</td>
<td><code>setUp/tearDown</code></td>
<td><code>@pytest.fixture</code></td>
</tr>
<tr>
<td><strong>推荐度</strong></td>
<td>⭐⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：实际开发中 <strong>pytest 是主流选择</strong>，语法简洁、功能强大、插件丰富。结合 Mock 隔离依赖 + 覆盖率检测，可构建可靠的测试体系。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法笔记</title>
    <url>/2026/01/12/Markdown/Markdown%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="1-常用语法"><a href="#1-常用语法" class="headerlink" title="1.常用语法"></a>1.常用语法</h1><h2 id="（1）创建章内链接"><a href="#（1）创建章内链接" class="headerlink" title="（1）创建章内链接"></a>（1）创建章内链接</h2><h3 id="定义锚点"><a href="#定义锚点" class="headerlink" title="&lt;1&gt; 定义锚点"></a>&lt;1&gt; 定义锚点</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;describtion&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"># 标题1</span><br></pre></td></tr></table></figure>

<h3 id="生成链接"><a href="#生成链接" class="headerlink" title="&lt;2&gt; 生成链接"></a>&lt;2&gt; 生成链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">文字描述</span>](<span class="link">#describtion</span>)</span><br></pre></td></tr></table></figure>

<h2 id="（2）章外链接（引用其它文章）"><a href="#（2）章外链接（引用其它文章）" class="headerlink" title="（2）章外链接（引用其它文章）"></a>（2）章外链接（引用其它文章）</h2><h3 id="绝对路径链接"><a href="#绝对路径链接" class="headerlink" title="&lt;1&gt;绝对路径链接"></a>&lt;1&gt;绝对路径链接</h3><p><code>[显示文字](链接URL路径)</code></p>
<h3 id="Hexo-内置标签（推荐，不会失效）"><a href="#Hexo-内置标签（推荐，不会失效）" class="headerlink" title="&lt;2&gt;Hexo 内置标签（推荐，不会失效）"></a>&lt;2&gt;Hexo 内置标签（推荐，不会失效）</h3><p><code>&#123;% post_link "文件路径" '显示文本' %&#125;</code></p>
<p>如：</p>
<ul>
<li><a href="/2026/01/19/C++/C++%E7%89%B9%E6%80%A7/CPP%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="C++模板基础语法">C++模板基础语法</a></li>
</ul>
<h1 id="2-常用表情包（可直接复制使用）"><a href="#2-常用表情包（可直接复制使用）" class="headerlink" title="2.常用表情包（可直接复制使用）"></a>2.常用表情包（可直接复制使用）</h1><table>
<thead>
<tr>
<th>😊</th>
<th>😂</th>
<th>😫</th>
</tr>
</thead>
<tbody><tr>
<td>😄 大笑</td>
<td>🤮 吐饭</td>
<td>😩 疲惫</td>
</tr>
<tr>
<td>😊 微笑</td>
<td>😂 笑哭</td>
<td>🤷‍♂️ 难手</td>
</tr>
<tr>
<td>🎉 庆祝</td>
<td>🤣 打滚笑</td>
<td>😪 困倦</td>
</tr>
<tr>
<td>🎊 彩带</td>
<td>😏 坏笑</td>
<td>🤔 思考</td>
</tr>
<tr>
<td>😍 爱慕</td>
<td>😜 调皮</td>
<td>🎯 命中目标</td>
</tr>
<tr>
<td>😭 大哭</td>
<td>😱 惊恐</td>
<td>✅ 正确</td>
</tr>
<tr>
<td>😢 流泪</td>
<td>😳 目瞪口呆</td>
<td>❌ 错误</td>
</tr>
<tr>
<td>😿 委屈猫</td>
<td>🤯 脑袋爆炸</td>
<td>⚠️ 警告</td>
</tr>
<tr>
<td>😟 担忧</td>
<td>😠 生气</td>
<td></td>
</tr>
<tr>
<td>😞 失落</td>
<td>😒 不满</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Markdown</category>
        <category>Markdown语法笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CMakeLists笔记</title>
    <url>/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/CMakeLists%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、使用示例"><a href="#一、使用示例" class="headerlink" title="一、使用示例"></a>一、使用示例</h1><h2 id="1-顶层目录示例"><a href="#1-顶层目录示例" class="headerlink" title="1.顶层目录示例"></a>1.顶层目录示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="built_in">project</span>(UserService</span><br><span class="line">        VERSION <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">        LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)    # 指定使用 C+<span class="number">+17</span> 标准</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON) #强制要求编译器支持 C+<span class="number">+17</span>，若编译器不支持，直接报错</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_EXTENSIONS OFF) #禁用编译器扩展语法， 保证代码在不同编译器下行为一致</span><br><span class="line"></span><br><span class="line"># 核心逻辑：若用户未指定 CMAKE_BUILD_TYPE（如编译时未加 -DCMAKE_BUILD_TYPE=Debug），</span><br><span class="line"># 默认设置为 Release（优化编译，去除调试信息，适合部署）；</span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_BUILD_TYPE Release CACHE STRING <span class="string">&quot;Choose the build type&quot;</span> FORCE)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">option</span>(BUILD_TESTS <span class="string">&quot;Build unit tests&quot;</span> ON) # 控制是否编译单元测试代码（tests 子目录）</span><br><span class="line"># 控制生成 “动态库（.so/.dll）” 还是 “静态库（.a/.lib）”，默认 OFF 即生成静态库；</span><br><span class="line"><span class="built_in">option</span>(BUILD_SHARED_LIBS <span class="string">&quot;Build shared instead of static libs&quot;</span> OFF) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出目录</span><br><span class="line"><span class="built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/bin)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># YAML 配置</span><br><span class="line"><span class="built_in">find_package</span>(yaml-cpp CONFIG REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="meta"># spdlog 日志</span></span><br><span class="line"><span class="built_in">find_package</span>(spdlog CONFIG REQUIRED)</span><br><span class="line"></span><br><span class="line"># MySQL</span><br><span class="line"><span class="built_in">find_package</span>(PkgConfig REQUIRED)</span><br><span class="line"><span class="built_in">pkg_check_modules</span>(MYSQL REQUIRED mysqlclient)</span><br><span class="line"></span><br><span class="line"><span class="meta"># hiredis 库 </span></span><br><span class="line"><span class="built_in">find_path</span>(HIREDIS_HEADER hiredis)</span><br><span class="line"><span class="built_in">find_library</span>(HIREDIS_LIB hiredis)</span><br><span class="line"></span><br><span class="line"><span class="meta"># redis++ 库 </span></span><br><span class="line"># 注意：这里是 sw，不是 redis++</span><br><span class="line"><span class="built_in">find_path</span>(REDIS_PLUS_PLUS_HEADER sw)</span><br><span class="line"><span class="built_in">find_library</span>(REDIS_PLUS_PLUS_LIB redis++)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_subdirectory</span>(src)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># GTest 包</span><br><span class="line"><span class="built_in">find_package</span>(GTest REQUIRED)</span><br><span class="line"><span class="keyword">if</span>(BUILD_TESTS)</span><br><span class="line">    <span class="built_in">enable_testing</span>()</span><br><span class="line">    <span class="built_in">find_package</span>(GTest CONFIG REQUIRED)</span><br><span class="line">    <span class="built_in">add_subdirectory</span>(tests)</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure>


<h2 id="2-子目录"><a href="#2-子目录" class="headerlink" title="2.子目录"></a>2.子目录</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 添加可执行文件</span><br><span class="line"><span class="built_in">add_executable</span>(config_test config_test.cpp)</span><br><span class="line"></span><br><span class="line"># 指定可执行文件的“头文件目录”</span><br><span class="line"><span class="built_in">target_include_directories</span>(config_test PUBLIC </span><br><span class="line">    $&#123;PROJECT_SOURCE_DIR&#125;/src</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 指令可执行文件的“库文件目录”</span><br><span class="line"><span class="built_in">target_link_directories</span>(config_test PUBLIC</span><br><span class="line">    $&#123;PROJECT_SOURCE_DIR&#125;/include/lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 让可执行文件链接库</span><br><span class="line"><span class="built_in">target_link_libraries</span>(config_test PRIVATE</span><br><span class="line">    user_config</span><br><span class="line">    GTest::GTest</span><br><span class="line">    GTest::Main</span><br><span class="line">    pthread</span><br><span class="line">    yaml-cpp  # Config 模块需要 yaml-cpp 库</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 设置可执行文件的输出路径</span><br><span class="line"># set_target_properties：CMake 内置命令，用于设置目标（target）的属性</span><br><span class="line"># config_test：目标名称</span><br><span class="line"># PROPERTIES：关键字，表示后面是要设置的属性及其值</span><br><span class="line"># RUNTIME_OUTPUT_DIRECTORY：目标属性名</span><br><span class="line"># $&#123;CMAKE_RUNTIME_OUTPUT_DIRECTORY&#125;/tests：属性值（路径）</span><br><span class="line"><span class="built_in">set_target_properties</span>(config_test PROPERTIES</span><br><span class="line">    RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_RUNTIME_OUTPUT_DIRECTORY&#125;/tests</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PUBLIC 关键字</strong>:<ul>
<li><strong>作用</strong>：指定了包含目录的可见性范围<ul>
<li>编译 config_test 目标本身时会使用这些包含目录</li>
<li>任何链接到 config_test 的其他目标也会继承这些包含目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115103707646.png"></p>
<h1 id="二、CMake-变量设置顺序规范"><a href="#二、CMake-变量设置顺序规范" class="headerlink" title="二、CMake 变量设置顺序规范"></a>二、CMake 变量设置顺序规范</h1><h2 id="（1）完整概览"><a href="#（1）完整概览" class="headerlink" title="（1）完整概览"></a>（1）完整概览</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118163502364.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║                     <span class="number">1</span>️⃣ 项目信息变量                               ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"># 📌 为什么最先？<span class="built_in">project</span>() 定义 PROJECT_NAME、PROJECT_SOURCE_DIR 等基础变量</span><br><span class="line"># 📌 后续所有配置都依赖这些变量</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span>(MyApp</span><br><span class="line">    VERSION <span class="number">1.2</span><span class="number">.3</span>                              # → PROJECT_VERSION, PROJECT_VERSION_MAJOR/MINOR/PATCH</span><br><span class="line">    DESCRIPTION <span class="string">&quot;企业级应用程序&quot;</span>                 # → PROJECT_DESCRIPTION</span><br><span class="line">    HOMEPAGE_URL <span class="string">&quot;https://github.com/xxx&quot;</span>      # → PROJECT_HOMEPAGE_URL</span><br><span class="line">    LANGUAGES CXX                              # 启用 C++ 编译器检测</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║                     <span class="number">2</span>️⃣ 平台与系统变量                   ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"># 📌 为什么排第二？平台决定：编译器选项、路径格式、依赖位置</span><br><span class="line"># 📌 WIN32/APPLE/UNIX 是 CMake 内置变量，<span class="built_in">project</span>() 后自动可用</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(WIN32)                                      # Windows（包括<span class="number">64</span>位）</span><br><span class="line">    <span class="built_in">set</span>(PLATFORM_NAME <span class="string">&quot;windows&quot;</span>)</span><br><span class="line"><span class="built_in">elseif</span>(APPLE)                                  # macOS、<span class="function">iOS</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(PLATFORM_NAME <span class="string">&quot;macos&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">elseif</span><span class="params">(UNIX)</span>                                   # Linux、BSD 等</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(PLATFORM_NAME <span class="string">&quot;linux&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 架构检测</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(CMAKE_SIZEOF_VOID_P EQUAL <span class="number">8</span>)</span>                # 指针大小判断架构</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(ARCH_NAME <span class="string">&quot;x64&quot;</span>)</span>                       # 8字节 </span>= <span class="number">64</span>位</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="built_in">set</span>(ARCH_NAME <span class="string">&quot;x86&quot;</span>)                       # <span class="number">4</span>字节 = <span class="number">32</span>位</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;平台: $&#123;CMAKE_SYSTEM_NAME&#125; ($&#123;PLATFORM_NAME&#125;)&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;架构: $&#123;CMAKE_SYSTEM_PROCESSOR&#125; ($&#123;ARCH_NAME&#125;)&quot;</span>)</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║                     <span class="number">3</span>️⃣ 编译器与工具链变量                          ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"># 📌 为什么排这里？依赖平台检测结果（MSVC vs GCC 选项不同）</span><br><span class="line"># 📌 必须在 add_executable/add_library 之前设置，否则不生效！</span><br><span class="line"></span><br><span class="line"># C++ 标准</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)                     # 使用 C+<span class="number">+17</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)            # 强制要求，不满足则报错</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_EXTENSIONS OFF)                  # 禁用编译器扩展（如 GNU+<span class="number">+17</span>）</span><br><span class="line"></span><br><span class="line"># 编译器选项</span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS ON)          # 生成 compile_commands.json（IDE/LSP 用）</span><br><span class="line"></span><br><span class="line"># 平台相关编译选项</span><br><span class="line"><span class="keyword">if</span>(MSVC)                                       # Visual Studio 编译器</span><br><span class="line">    <span class="built_in">add_compile_options</span>(/W4 /utf<span class="number">-8</span>)            # 警告级别<span class="number">4</span> + UTF<span class="number">-8</span>源码</span><br><span class="line"><span class="built_in">else</span>()                                         # GCC / Clang</span><br><span class="line">    <span class="built_in">add_compile_options</span>(-Wall -Wextra -Wpedantic)  # 开启常用警告</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║                     <span class="number">4</span>️⃣ 构建类型变量                                ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"># 📌 为什么排这里？影响编译选项(-O0/-O3)和输出路径(Debug/Release子目录)</span><br><span class="line"># 📌 仅对单配置生成器生效（Makefile/Ninja），VS/Xcode 忽略此变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 默认构建类型</span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> CACHE STRING <span class="string">&quot;构建类型&quot;</span> FORCE)    # 未指定时默认 Release</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_property</span>(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS        # 在 cmake-gui 中提供下拉选项</span><br><span class="line">        <span class="string">&quot;Debug&quot;</span> <span class="string">&quot;Release&quot;</span> <span class="string">&quot;MinSizeRel&quot;</span> <span class="string">&quot;RelWithDebInfo&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;构建类型: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 自定义各构建类型的编译选项（覆盖默认值）</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;-g -O0 -DDEBUG&quot;</span>)    # 调试：无优化+调试符号</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-O3 -DNDEBUG&quot;</span>)    # 发布：最高优化+禁用assert</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║                     <span class="number">5</span>️⃣ 项目路径变量                                ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"># 📌 为什么排这里？依赖 PROJECT_SOURCE_DIR（由 <span class="built_in">project</span>() 定义）</span><br><span class="line"># 📌 统一管理路径，避免硬编码，方便后续引用</span><br><span class="line"></span><br><span class="line"># 自定义目录结构</span><br><span class="line"><span class="built_in">set</span>(PROJECT_ROOT_DIR     $&#123;PROJECT_SOURCE_DIR&#125;)            # 项目根目录</span><br><span class="line"><span class="built_in">set</span>(PROJECT_SRC_DIR      $&#123;PROJECT_SOURCE_DIR&#125;/src)        # 源码目录</span><br><span class="line"><span class="built_in">set</span>(PROJECT_INCLUDE_DIR  $&#123;PROJECT_SOURCE_DIR&#125;/include)    # 头文件目录</span><br><span class="line"><span class="built_in">set</span>(PROJECT_LIB_DIR      $&#123;PROJECT_SOURCE_DIR&#125;/lib)        # 预编译库目录</span><br><span class="line"><span class="built_in">set</span>(PROJECT_TEST_DIR     $&#123;PROJECT_SOURCE_DIR&#125;/tests)      # 测试目录</span><br><span class="line"><span class="built_in">set</span>(PROJECT_DOC_DIR      $&#123;PROJECT_SOURCE_DIR&#125;/docs)       # 文档目录</span><br><span class="line"><span class="built_in">set</span>(PROJECT_CMAKE_DIR    $&#123;PROJECT_SOURCE_DIR&#125;/cmake)      # CMake 模块目录</span><br><span class="line"><span class="built_in">set</span>(PROJECT_THIRD_PARTY  $&#123;PROJECT_SOURCE_DIR&#125;/third_party) # 第三方库目录</span><br><span class="line"></span><br><span class="line"># 添加自定义模块搜索路径（用于 <span class="built_in">include</span>() 和 <span class="built_in">find_package</span>()）</span><br><span class="line"><span class="built_in">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;PROJECT_CMAKE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║                     <span class="number">6</span>️⃣ 输出路径变量                                ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"># 📌 为什么排这里？依赖 PLATFORM_NAME、ARCH_NAME（第<span class="number">2</span>步）和 PROJECT_BINARY_DIR</span><br><span class="line"># 📌 统一输出结构：build/output/linux/x64/bin/</span><br><span class="line"></span><br><span class="line"># 统一输出目录（按平台/架构/构建类型组织）</span><br><span class="line"><span class="built_in">set</span>(OUTPUT_BASE_DIR $&#123;PROJECT_BINARY_DIR&#125;/output/$&#123;PLATFORM_NAME&#125;/$&#123;ARCH_NAME&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;OUTPUT_BASE_DIR&#125;/bin)      # 可执行文件</span><br><span class="line"><span class="built_in">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;OUTPUT_BASE_DIR&#125;/lib)      # 动态库</span><br><span class="line"><span class="built_in">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;OUTPUT_BASE_DIR&#125;/lib)      # 静态库</span><br><span class="line"></span><br><span class="line"># 多配置生成器（VS/Xcode）需要单独设置每种配置的输出路径</span><br><span class="line">foreach(CONFIG_TYPE $&#123;CMAKE_CONFIGURATION_TYPES&#125;)           # Debug;Release;...</span><br><span class="line">    <span class="built_in">string</span>(TOUPPER $&#123;CONFIG_TYPE&#125; CONFIG_TYPE_UPPER)        # DEBUG/<span class="function">RELEASE</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(CMAKE_RUNTIME_OUTPUT_DIRECTORY_$&#123;CONFIG_TYPE_UPPER&#125; $&#123;OUTPUT_BASE_DIR&#125;/$&#123;CONFIG_TYPE&#125;/bin)</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(CMAKE_LIBRARY_OUTPUT_DIRECTORY_$&#123;CONFIG_TYPE_UPPER&#125; $&#123;OUTPUT_BASE_DIR&#125;/$&#123;CONFIG_TYPE&#125;/lib)</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_$&#123;CONFIG_TYPE_UPPER&#125; $&#123;OUTPUT_BASE_DIR&#125;/$&#123;CONFIG_TYPE&#125;/lib)</span></span></span><br><span class="line"><span class="function"><span class="title">endforeach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║                     7️⃣ 安装路径变量                                ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"># 📌 为什么排这里？<span class="title">install</span><span class="params">()</span> 命令依赖这些路径</span></span><br><span class="line"><span class="function"># 📌 GNUInstallDirs 提供跨平台标准目录（bin/lib/include）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 安装前缀</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)</span></span></span><br><span class="line"><span class="function">    # 默认安装到构建目录下的 install/，而非系统目录</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(CMAKE_INSTALL_PREFIX <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/install&quot;</span> CACHE PATH <span class="string">&quot;安装路径&quot;</span> FORCE)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># GNUInstallDirs 标准目录</span></span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">(GNUInstallDirs)</span>  # 定义 <span class="title">CMAKE_INSTALL_BINDIR</span> <span class="params">(bin)</span></span></span><br><span class="line"><span class="function">                         #      <span class="title">CMAKE_INSTALL_LIBDIR</span> <span class="params">(lib/lib64)</span></span></span><br><span class="line"><span class="function">                         #      <span class="title">CMAKE_INSTALL_INCLUDEDIR</span> <span class="params">(include)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;安装路径: $&#123;CMAKE_INSTALL_PREFIX&#125;&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║                     8️⃣ 查找包相关变量                              ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"># 📌 为什么排这里？<span class="title">find_package</span><span class="params">()</span> 依赖 CMAKE_PREFIX_PATH 搜索路径</span></span><br><span class="line"><span class="function"># 📌 必须在 <span class="title">target_link_libraries</span><span class="params">()</span> 之前找到依赖</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 第三方库搜索路径</span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_PREFIX_PATH</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;$&#123;PROJECT_THIRD_PARTY&#125;&quot;</span>      # 项目内第三方库</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;/opt/Qt6&quot;</span>                    # 系统安装的 Qt</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;$ENV&#123;HOME&#125;/libs&quot;</span>             # 用户自定义库目录</span></span></span><br><span class="line"><span class="params"><span class="function">    $&#123;CMAKE_PREFIX_PATH&#125;          # 保留已有路径</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 查找必需依赖</span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Qt6 COMPONENTS Core Widgets REQUIRED)</span>  # REQUIRED </span>= 找不到则报错终止</span><br><span class="line"><span class="built_in">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"><span class="built_in">find_package</span>(Threads REQUIRED)</span><br><span class="line"></span><br><span class="line"># 查找可选依赖</span><br><span class="line"><span class="built_in">find_package</span>(ZLIB QUIET)    # QUIET = 找不到不报错，通过变量判断</span><br><span class="line"><span class="built_in">find_package</span>(Doxygen QUIET)</span><br><span class="line"></span><br><span class="line"># 打印依赖状态</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;========== 依赖状态 ==========&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;Qt6:     $&#123;Qt6_FOUND&#125; ($&#123;Qt6_VERSION&#125;)&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;OpenSSL: $&#123;OPENSSL_FOUND&#125; ($&#123;OPENSSL_VERSION&#125;)&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;ZLIB:    $&#123;ZLIB_FOUND&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;==============================&quot;</span>)</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║                     <span class="number">9</span>️⃣ 项目选项（可选功能开关）                     ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"># 📌 为什么排这里？用户可通过 -D 覆盖默认值，放在目标定义前可控制条件编译</span><br><span class="line"># 📌 <span class="built_in">option</span>() 定义 BOOL 类型缓存变量</span><br><span class="line"></span><br><span class="line"><span class="built_in">option</span>(BUILD_SHARED_LIBS <span class="string">&quot;构建动态库&quot;</span> ON)       # ON=动态库, OFF=静态库</span><br><span class="line"><span class="built_in">option</span>(BUILD_TESTS       <span class="string">&quot;构建测试&quot;</span>   ON)       # 控制是否编译测试</span><br><span class="line"><span class="built_in">option</span>(BUILD_DOCS        <span class="string">&quot;构建文档&quot;</span>   OFF)      # 控制是否生成文档</span><br><span class="line"><span class="built_in">option</span>(ENABLE_COVERAGE   <span class="string">&quot;启用覆盖率&quot;</span> OFF)      # 控制覆盖率编译选项</span><br><span class="line"></span><br><span class="line"># 使用：cmake -DBUILD_TESTS=OFF ..</span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║                     🔟 子目录与目标定义                           ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"># 📌 为什么放最后？所有配置就绪，目标可正确继承编译选项、链接依赖</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_subdirectory</span>(src)            # 主程序/库</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_TESTS)                  # 条件编译测试</span><br><span class="line">    <span class="built_in">enable_testing</span>()             # 启用 CTest</span><br><span class="line">    <span class="built_in">add_subdirectory</span>(tests)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_DOCS AND Doxygen_FOUND) # 条件生成文档</span><br><span class="line">    <span class="built_in">add_subdirectory</span>(docs)</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure>

<h2 id="（2）使用精简版"><a href="#（2）使用精简版" class="headerlink" title="（2）使用精简版"></a>（2）使用精简版</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║  <span class="number">1</span>️⃣ 项目信息                                                     ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"><span class="built_in">project</span>(MyApp VERSION <span class="number">1.0</span><span class="number">.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║  <span class="number">2</span>️⃣ 编译器设置                                                   ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)              # C+<span class="number">+17</span> 标准</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)     # 强制要求</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_EXTENSIONS OFF)           # 禁用扩展</span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS ON)   # 生成 compile_commands.json</span><br><span class="line"></span><br><span class="line"># ╔══════════════════════════════════════════════════════════════════╗</span><br><span class="line"># ║  <span class="number">3</span>️⃣ 构建类型                                                     ║</span><br><span class="line"># ╚══════════════════════════════════════════════════════════════════╝</span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">   <span class="built_in">set</span>(CMAKE_BUILD_TYPE Release CACHE STRING <span class="string">&quot;&quot;</span> FORCE)  # 默认 <span class="function">Release</span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║  4️⃣ 路径定义                                                     ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(PROJECT_INCLUDE_DIR $&#123;PROJECT_SOURCE_DIR&#125;/include)</span>   # 头文件目录</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║  5️⃣ 输出路径                                                     ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/bin)</span>  # 可执行文件</span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)</span>  # 动态库</span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)</span>  # 静态库</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║  6️⃣ 安装路径                                                     ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">(GNUInstallDirs)</span>  # 提供 CMAKE_INSTALL_BINDIR 等标准目录</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║  7️⃣ 查找依赖                                                     ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"># <span class="title">find_package</span><span class="params">(spdlog CONFIG REQUIRED)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║  8️⃣ 项目选项                                                     ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"><span class="title">option</span><span class="params">(BUILD_TESTS <span class="string">&quot;构建测试&quot;</span> ON)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║  9️⃣ 目标定义                                                     ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(BUILD_TESTS)</span></span></span><br><span class="line"><span class="function">   <span class="title">enable_testing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   <span class="title">add_subdirectory</span><span class="params">(tests)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ╔══════════════════════════════════════════════════════════════════╗</span></span><br><span class="line"><span class="function"># ║  🔟 安装规则                                                      ║</span></span><br><span class="line"><span class="function"># ╚══════════════════════════════════════════════════════════════════╝</span></span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">(TARGETS $&#123;PROJECT_NAME&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">   RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;   # bin/</span></span></span><br><span class="line"><span class="params"><span class="function">   LIBRARY DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;   # lib/</span></span></span><br><span class="line"><span class="params"><span class="function">   ARCHIVE DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">(DIRECTORY $&#123;PROJECT_INCLUDE_DIR&#125;/ DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>构建命令</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build                 # 配置</span><br><span class="line">cmake --build build                 # 编译</span><br><span class="line">cmake --install build               # 安装</span><br></pre></td></tr></table></figure>

<h1 id="三、常用变量"><a href="#三、常用变量" class="headerlink" title="三、常用变量"></a>三、常用变量</h1><h2 id="1-项目信息变量"><a href="#1-项目信息变量" class="headerlink" title="1.项目信息变量"></a>1.项目信息变量</h2><h3 id="（1）汇总表格"><a href="#（1）汇总表格" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118160323210.png"></p>
<h3 id="（2）使用示例"><a href="#（2）使用示例" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><h4 id="常用精简版"><a href="#常用精简版" class="headerlink" title="&lt;1&gt;常用精简版"></a>&lt;1&gt;常用精简版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="built_in">project</span>(MyApp </span><br><span class="line">    VERSION <span class="number">1.2</span><span class="number">.3</span></span><br><span class="line">    LANGUAGES CXX</span><br><span class="line">)</span><br><span class="line"># 打印项目信息</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;项目: $&#123;PROJECT_NAME&#125; v$&#123;PROJECT_VERSION&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">#                       ......</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>($&#123;PROJECT_NAME&#125; main.cpp)</span><br></pre></td></tr></table></figure>

<h4 id="完整版"><a href="#完整版" class="headerlink" title="&lt;2&gt;完整版"></a>&lt;2&gt;完整版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"># ==================== 项目定义 ====================</span><br><span class="line"><span class="built_in">project</span>(MyApp</span><br><span class="line">    VERSION <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>                           # 完整版本号（MAJOR.MINOR.PATCH.TWEAK）</span><br><span class="line">    DESCRIPTION <span class="string">&quot;一个示例应用程序&quot;</span>              # 项目描述</span><br><span class="line">    HOMEPAGE_URL <span class="string">&quot;https://github.com/user/myapp&quot;</span>  # 项目主页</span><br><span class="line">    LANGUAGES CXX                              # 使用的语言</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#                       ......</span><br><span class="line"></span><br><span class="line"># ==================== 打印项目信息 ====================</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;========== 项目信息 ==========&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;名称:     $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;版本:     $&#123;PROJECT_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;  主版本: $&#123;PROJECT_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;  次版本: $&#123;PROJECT_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;  补丁:   $&#123;PROJECT_VERSION_PATCH&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;  微调:   $&#123;PROJECT_VERSION_TWEAK&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;描述:     $&#123;PROJECT_DESCRIPTION&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;主页:     $&#123;PROJECT_HOMEPAGE_URL&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;==============================&quot;</span>)</span><br><span class="line"></span><br><span class="line">#                       ......</span><br><span class="line"></span><br><span class="line"># ==================== 创建目标 ====================</span><br><span class="line"><span class="built_in">add_executable</span>($&#123;PROJECT_NAME&#125; main.cpp)</span><br><span class="line"></span><br><span class="line"># 添加生成目录到头文件搜索路径</span><br><span class="line"><span class="built_in">target_include_directories</span>($&#123;PROJECT_NAME&#125; PRIVATE $&#123;PROJECT_BINARY_DIR&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>配套模板文件 config.h.in</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目信息（由 CMake 自动生成）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_NAME <span class="string">&quot;@PROJECT_NAME@&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_VERSION <span class="string">&quot;@PROJECT_VERSION@&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_VERSION_MAJOR @PROJECT_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_VERSION_MINOR @PROJECT_VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_VERSION_PATCH @PROJECT_VERSION_PATCH@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_DESCRIPTION <span class="string">&quot;@PROJECT_DESCRIPTION@&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_HOMEPAGE_URL <span class="string">&quot;@PROJECT_HOMEPAGE_URL@&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CONFIG_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>配套 main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; PROJECT_NAME &lt;&lt; <span class="string">&quot; v&quot;</span> &lt;&lt; PROJECT_VERSION &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;描述: &quot;</span> &lt;&lt; PROJECT_DESCRIPTION &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主页: &quot;</span> &lt;&lt; PROJECT_HOMEPAGE_URL &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-平台与系统变量"><a href="#2-平台与系统变量" class="headerlink" title="2.平台与系统变量"></a>2.平台与系统变量</h2><h3 id="（1）汇总表格-1"><a href="#（1）汇总表格-1" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118164449876.png"></p>
<h3 id="（2）使用示例-1"><a href="#（2）使用示例-1" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><h4 id="常用精简版-1"><a href="#常用精简版-1" class="headerlink" title="&lt;1&gt;常用精简版"></a>&lt;1&gt;常用精简版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#                       ......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(WIN32)                                      # Windows（包括<span class="number">64</span>位）</span><br><span class="line">    <span class="built_in">set</span>(PLATFORM_NAME <span class="string">&quot;windows&quot;</span>)</span><br><span class="line"><span class="built_in">elseif</span>(APPLE)                                  # macOS、<span class="function">iOS</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(PLATFORM_NAME <span class="string">&quot;macos&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">elseif</span><span class="params">(UNIX)</span>                                   # Linux、BSD 等</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(PLATFORM_NAME <span class="string">&quot;linux&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 架构检测</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(CMAKE_SIZEOF_VOID_P EQUAL <span class="number">8</span>)</span>                # 指针大小判断架构</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(ARCH_NAME <span class="string">&quot;x64&quot;</span>)</span>                       # 8字节 </span>= <span class="number">64</span>位</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="built_in">set</span>(ARCH_NAME <span class="string">&quot;x86&quot;</span>)                       # <span class="number">4</span>字节 = <span class="number">32</span>位</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;平台: $&#123;CMAKE_SYSTEM_NAME&#125; ($&#123;PLATFORM_NAME&#125;)&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;架构: $&#123;CMAKE_SYSTEM_PROCESSOR&#125; ($&#123;ARCH_NAME&#125;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">#                       ......</span><br></pre></td></tr></table></figure>
<p><strong>已经用“CMAKE_SYSTEM_NAME变量”了，为什么还要自定义“PLATFORM_NAME”？</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118164758165.png"></p>
<h4 id="完整版-1"><a href="#完整版-1" class="headerlink" title="&lt;2&gt;完整版"></a>&lt;2&gt;完整版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#                       ......</span><br><span class="line"></span><br><span class="line"># ══════════════════════════════════════════════════════════════════</span><br><span class="line"># 系统信息打印</span><br><span class="line"># ══════════════════════════════════════════════════════════════════</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;系统名称:   $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)        # Linux/Windows/<span class="function">Darwin</span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;系统版本:   $&#123;CMAKE_SYSTEM_VERSION&#125;&quot;</span>)</span>     # 5.15.0</span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;处理器:     $&#123;CMAKE_SYSTEM_PROCESSOR&#125;&quot;</span>)</span>   # x86_64/aarch64</span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;主机系统:   $&#123;CMAKE_HOST_SYSTEM_NAME&#125;&quot;</span>)</span>   # 交叉编译时有用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 平台检测（布尔变量）</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(WIN32)</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(PLATFORM_NAME <span class="string">&quot;windows&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;检测到 Windows&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">elseif</span><span class="params">(APPLE)</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(PLATFORM_NAME <span class="string">&quot;macos&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;检测到 macOS (Darwin)&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">elseif</span><span class="params">(UNIX)</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(PLATFORM_NAME <span class="string">&quot;linux&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;检测到 Linux/Unix&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 架构检测</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(CMAKE_SIZEOF_VOID_P EQUAL <span class="number">8</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(ARCH_NAME <span class="string">&quot;x64&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">else</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(ARCH_NAME <span class="string">&quot;x86&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(CMAKE_SYSTEM_PROCESSOR MATCHES <span class="string">&quot;arm|aarch64|ARM64&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(ARCH_NAME <span class="string">&quot;arm64&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 编译器检测</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(MSVC)</span></span></span><br><span class="line"><span class="function">    <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;编译器: MSVC&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">add_compile_options</span><span class="params">(/W4 /utf<span class="number">-8</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">elseif</span><span class="params">(CMAKE_CXX_COMPILER_ID STREQUAL <span class="string">&quot;GNU&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;编译器: GCC&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">add_compile_options</span><span class="params">(-Wall -Wextra)</span></span></span><br><span class="line"><span class="function"><span class="title">elseif</span><span class="params">(CMAKE_CXX_COMPILER_ID STREQUAL <span class="string">&quot;Clang&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;编译器: Clang&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">add_compile_options</span><span class="params">(-Wall -Wextra)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 交叉编译检测</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT CMAKE_SYSTEM_NAME STREQUAL CMAKE_HOST_SYSTEM_NAME)</span></span></span><br><span class="line"><span class="function">    <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;交叉编译: $&#123;CMAKE_HOST_SYSTEM_NAME&#125; → $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;最终: $&#123;PLATFORM_NAME&#125;/$&#123;ARCH_NAME&#125;&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#                       ......</span></span><br></pre></td></tr></table></figure>

<h2 id="3-编译器与工具链变量"><a href="#3-编译器与工具链变量" class="headerlink" title="3.编译器与工具链变量"></a>3.编译器与工具链变量</h2><h3 id="（1）汇总表格-2"><a href="#（1）汇总表格-2" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118153916817.png"></p>
<h3 id="（2）使用示例-2"><a href="#（2）使用示例-2" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="built_in">project</span>(MyProject LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"># ==================== C++ 标准设置 ====================</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_EXTENSIONS OFF)</span><br><span class="line"></span><br><span class="line"># ==================== 编译选项 ====================</span><br><span class="line"># 第<span class="number">3</span>类：定义编译选项的内容</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS         <span class="string">&quot;-Wall -Wextra&quot;</span>)      # 所有模式都用</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS_DEBUG   <span class="string">&quot;-g -O0&quot;</span>)             # Debug 专用</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-O3 -DNDEBUG&quot;</span>)       # Release 专用</span><br><span class="line"></span><br><span class="line"># ==================== 条件编译（利用只读变量） ====================</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID STREQUAL <span class="string">&quot;GNU&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;使用 GCC 编译器，版本: $&#123;CMAKE_CXX_COMPILER_VERSION&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">add_compile_options</span>(-Wno-unused-parameter)</span><br><span class="line"><span class="built_in">elseif</span>(CMAKE_CXX_COMPILER_ID STREQUAL <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;使用 Clang 编译器&quot;</span>)</span><br><span class="line">    <span class="built_in">add_compile_options</span>(-Wno-unused-lambda-capture)</span><br><span class="line"><span class="built_in">elseif</span>(CMAKE_CXX_COMPILER_ID STREQUAL <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;使用 MSVC 编译器&quot;</span>)</span><br><span class="line">    <span class="built_in">add_compile_options</span>(/W4 /utf<span class="number">-8</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># ==================== 版本检查示例 ====================</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID STREQUAL <span class="string">&quot;GNU&quot;</span> AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS <span class="number">9.0</span>)</span><br><span class="line">    <span class="built_in">message</span>(WARNING <span class="string">&quot;GCC 版本过低，建议升级到 9.0+&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 创建构建目录并进入</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 配置（选择构建类型）</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..    <span class="comment"># Debug 模式</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..  <span class="comment"># Release 模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 编译</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行（在 build 目录下）</span></span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB 调试（需要 Debug 构建）</span></span><br><span class="line">gdb ./main</span><br></pre></td></tr></table></figure>

<h2 id="4-构建类型变量"><a href="#4-构建类型变量" class="headerlink" title="4.构建类型变量"></a>4.构建类型变量</h2><h3 id="（1）汇总表格-3"><a href="#（1）汇总表格-3" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118202232268.png"></p>
<h3 id="（2）使用示例-3"><a href="#（2）使用示例-3" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><h4 id="常用精简版-2"><a href="#常用精简版-2" class="headerlink" title="&lt;1&gt;常用精简版"></a>&lt;1&gt;常用精简版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 单配置生成器（Makefile/Ninja）设置默认构建类型</span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_BUILD_TYPE Release CACHE STRING <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="完整版-2"><a href="#完整版-2" class="headerlink" title="&lt;2&gt;完整版"></a>&lt;2&gt;完整版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># ══════════════════════════════════════════════════════════════════</span><br><span class="line"># 构建类型设置</span><br><span class="line"># ══════════════════════════════════════════════════════════════════</span><br><span class="line"></span><br><span class="line"># 📌 判断条件说明：</span><br><span class="line">#    - CMAKE_BUILD_TYPE 空 → 单配置生成器未指定类型</span><br><span class="line">#    - CMAKE_CONFIGURATION_TYPES 空 → 不是多配置生成器（VS/Xcode）</span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_BUILD_TYPE)</span><br><span class="line">    # 📌 CACHE STRING：写入缓存，cmake-gui 可见</span><br><span class="line">    # 📌 FORCE：强制覆盖已有值</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span> CACHE STRING <span class="string">&quot;构建类型&quot;</span> FORCE)</span><br><span class="line">    </span><br><span class="line">    # 📌 cmake-gui 中显示下拉选项</span><br><span class="line">    <span class="built_in">set_property</span>(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS</span><br><span class="line">        <span class="string">&quot;Debug&quot;</span> <span class="string">&quot;Release&quot;</span> <span class="string">&quot;RelWithDebInfo&quot;</span> <span class="string">&quot;MinSizeRel&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;当前构建类型: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"># ══════════════════════════════════════════════════════════════════</span><br><span class="line"># 多配置生成器处理（VS/Xcode）</span><br><span class="line"># ══════════════════════════════════════════════════════════════════</span><br><span class="line"></span><br><span class="line"># 📌 CMAKE_CONFIGURATION_TYPES 仅多配置生成器有值</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CONFIGURATION_TYPES)</span><br><span class="line">    # 📌 限制只支持 Debug 和 <span class="function">Release</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(CMAKE_CONFIGURATION_TYPES <span class="string">&quot;Debug;Release&quot;</span> CACHE STRING <span class="string">&quot;&quot;</span> FORCE)</span></span></span><br><span class="line"><span class="function">    <span class="title">message</span><span class="params">(STATUS <span class="string">&quot;多配置类型: $&#123;CMAKE_CONFIGURATION_TYPES&#125;&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 按构建类型条件编译（生成器表达式，推荐）</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(myapp main.cpp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 📌 $&lt;CONFIG:xxx&gt; 在生成时根据实际配置展开</span></span><br><span class="line"><span class="function"># 📌 单配置和多配置生成器都适用</span></span><br><span class="line"><span class="function">target_compile_definitions(myapp PRIVATE</span></span><br><span class="line"><span class="function">    $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_MODE&gt;      # Debug 时定义 DEBUG_MODE</span></span><br><span class="line"><span class="function">    $&lt;$&lt;CONFIG:Release&gt;:NDEBUG&gt;        # Release 时定义 NDEBUG</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">target_compile_options(myapp PRIVATE</span></span><br><span class="line"><span class="function">    $&lt;$&lt;CONFIG:Debug&gt;:-g -O0&gt;          # Debug：无优化+调试符号</span></span><br><span class="line"><span class="function">    $&lt;$&lt;CONFIG:Release&gt;:-O3&gt;           # Release：最高优化</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118203157380.png"></p>
<h2 id="拓：编译器变量-vs-构建类型变量"><a href="#拓：编译器变量-vs-构建类型变量" class="headerlink" title="拓：编译器变量 vs 构建类型变量"></a>拓：编译器变量 vs 构建类型变量</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118203245613.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118203314548.png"></p>
<h2 id="5-项目路径变量"><a href="#5-项目路径变量" class="headerlink" title="5.项目路径变量"></a>5.项目路径变量</h2><h3 id="（1）汇总表格-4"><a href="#（1）汇总表格-4" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118105157843.png"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">myproject<span class="symbol">/</span>                      ← CMAKE_SOURCE_DIR <span class="symbol">/</span> PROJECT_SOURCE_DIR</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── build<span class="symbol">/</span>                      ← CMAKE_BINARY_DIR <span class="symbol">/</span> PROJECT_BINARY_DIR</span><br><span class="line">├── src<span class="symbol">/</span></span><br><span class="line">│   └── module<span class="symbol">/</span></span><br><span class="line">│       └── CMakeLists.txt      ← CMAKE_CURRENT_SOURCE_DIR (处理此文件时)</span><br><span class="line">└── cmake<span class="symbol">/</span></span><br><span class="line">    └── utils.cmake             ← CMAKE_CURRENT_LIST_DIR (include 此文件时)</span><br></pre></td></tr></table></figure>

<h3 id="（2）使用示例-4"><a href="#（2）使用示例-4" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><p><strong>以（1）中的目录为例</strong></p>
<h4 id="常用精简版-3"><a href="#常用精简版-3" class="headerlink" title="&lt;1&gt;常用精简版"></a>&lt;1&gt;常用精简版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="built_in">project</span>(MyApp VERSION <span class="number">1.0</span><span class="number">.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"># 加载自定义模块</span><br><span class="line"><span class="built_in">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 头文件 &amp; 源文件</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(src/<span class="keyword">module</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>($&#123;PROJECT_NAME&#125; src/main.cpp)</span><br></pre></td></tr></table></figure>

<h4 id="完整版-3"><a href="#完整版-3" class="headerlink" title="&lt;2&gt;完整版"></a>&lt;2&gt;完整版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="built_in">project</span>(MyApp VERSION <span class="number">1.0</span><span class="number">.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"></span><br><span class="line"># ==================== 目录变量演示 ====================</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;========== 顶层 CMakeLists.txt ==========&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;CMAKE_SOURCE_DIR:         $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;CMAKE_BINARY_DIR:         $&#123;CMAKE_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject/build</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;PROJECT_SOURCE_DIR:       $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject（与 CMAKE_SOURCE_DIR 相同）</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;PROJECT_BINARY_DIR:       $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject/build</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR: $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject（当前处理的文件所在目录）</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;CMAKE_CURRENT_BINARY_DIR: $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject/build</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;=============================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"># ==================== 加载自定义模块 ====================</span><br><span class="line"><span class="built_in">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"><span class="built_in">include</span>(utils)  # 加载 cmake/utils.cmake</span><br><span class="line"></span><br><span class="line"># ==================== 输出目录配置 ====================</span><br><span class="line"><span class="built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line"># ==================== 添加子目录 ====================</span><br><span class="line"><span class="built_in">add_subdirectory</span>(src/<span class="keyword">module</span>)</span><br><span class="line"></span><br><span class="line"># ==================== 主程序 ====================</span><br><span class="line"><span class="built_in">add_executable</span>($&#123;PROJECT_NAME&#125; src/main.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>($&#123;PROJECT_NAME&#125; PRIVATE <span class="keyword">module</span>)</span><br></pre></td></tr></table></figure>
<p><strong>子目录 myproject&#x2F;src&#x2F;module&#x2F;CMakeLists.txt</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># ==================== 子目录中的目录变量 ====================</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;========== src/module/CMakeLists.txt ==========&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;CMAKE_SOURCE_DIR:         $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject（不变，始终是顶层）</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;CMAKE_BINARY_DIR:         $&#123;CMAKE_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject/build（不变）</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;PROJECT_SOURCE_DIR:       $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject（没有新 <span class="built_in">project</span>()，沿用父级）</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR: $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject/src/<span class="keyword">module</span> ⭐ 变了</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;CMAKE_CURRENT_BINARY_DIR: $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line">#                                          → /home/user/myproject/build/src/<span class="keyword">module</span> ⭐ 变了</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;================================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"># ==================== 创建模块库 ====================</span><br><span class="line"><span class="built_in">add_library</span>(<span class="keyword">module</span> STATIC</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class="keyword">module</span>.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_include_directories</span>(<span class="keyword">module</span> PUBLIC</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="6-输出路径变量"><a href="#6-输出路径变量" class="headerlink" title="6.输出路径变量"></a>6.输出路径变量</h2><h3 id="（1）汇总表格-5"><a href="#（1）汇总表格-5" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118152755840.png"></p>
<h3 id="（2）使用示例-5"><a href="#（2）使用示例-5" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/bin)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)</span><br></pre></td></tr></table></figure>

<h2 id="7-安装路径"><a href="#7-安装路径" class="headerlink" title="7.安装路径"></a>7.安装路径</h2><p>你的项目编译产物的安装路径，即执行 cmake –install 或 make install 时，文件被复制到的目标位置。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">源码目录          构建目录              安装目录</span><br><span class="line">src<span class="regexp">/main.cpp  →  build/my</span>app      →  <span class="regexp">/usr/</span>local<span class="regexp">/bin/my</span>app</span><br><span class="line">src<span class="regexp">/mylib.cpp →  build/</span>libmy.so   →  <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>libmy.so</span><br><span class="line">include<span class="regexp">/*.h   →  （不变）          →  /u</span>sr<span class="regexp">/local/i</span>nclude/*.h</span><br><span class="line"></span><br><span class="line">    编译                 安装</span><br><span class="line">  cmake --build .    cmake --install .</span><br></pre></td></tr></table></figure>

<h3 id="（1）汇总表格-6"><a href="#（1）汇总表格-6" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118203635317.png"></p>
<h3 id="（2）使用示例-6"><a href="#（2）使用示例-6" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><h4 id="常用精简版-4"><a href="#常用精简版-4" class="headerlink" title="&lt;1&gt;常用精简版"></a>&lt;1&gt;常用精简版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 设置安装前缀</span><br><span class="line"><span class="built_in">set</span>(CMAKE_INSTALL_PREFIX <span class="string">&quot;/opt/myapp&quot;</span> CACHE PATH <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"></span><br><span class="line"># 安装可执行文件和库</span><br><span class="line"><span class="built_in">install</span>(TARGETS myapp mylib</span><br><span class="line">    RUNTIME DESTINATION bin</span><br><span class="line">    LIBRARY DESTINATION lib</span><br><span class="line">    ARCHIVE DESTINATION lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 安装头文件</span><br><span class="line"><span class="built_in">install</span>(DIRECTORY include/ DESTINATION include)</span><br></pre></td></tr></table></figure>
<h4 id="完整版-4"><a href="#完整版-4" class="headerlink" title="&lt;2&gt;完整版"></a>&lt;2&gt;完整版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># ══════════════════════════════════════════════════════════════════</span><br><span class="line"># 引入 GNUInstallDirs 模块（提供标准安装目录变量）</span><br><span class="line"># ══════════════════════════════════════════════════════════════════</span><br><span class="line"></span><br><span class="line"># 📌 自动设置 CMAKE_INSTALL_BINDIR、CMAKE_INSTALL_LIBDIR 等</span><br><span class="line"># 📌 会根据系统自动处理 <span class="function">lib vs lib64</span></span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">(GNUInstallDirs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 自定义安装前缀（可选）</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 📌 仅在未指定时设置默认值</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)</span></span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(CMAKE_INSTALL_PREFIX <span class="string">&quot;/opt/$&#123;PROJECT_NAME&#125;&quot;</span> CACHE PATH <span class="string">&quot;安装路径&quot;</span> FORCE)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;安装前缀: $&#123;CMAKE_INSTALL_PREFIX&#125;&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;  bin:     $&#123;CMAKE_INSTALL_BINDIR&#125;&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;  lib:     $&#123;CMAKE_INSTALL_LIBDIR&#125;&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">&quot;  include: $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 定义目标</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(myapp src/main.cpp)</span></span></span><br><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(mylib SHARED src/mylib.cpp)</span></span></span><br><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(mylib_static STATIC src/mylib.cpp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 安装可执行文件</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">(TARGETS myapp</span></span></span><br><span class="line"><span class="params"><span class="function">    RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;   # 📌 → prefix/bin</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 安装库文件</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">(TARGETS mylib mylib_static</span></span></span><br><span class="line"><span class="params"><span class="function">    LIBRARY DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;   # 📌 .so → prefix/lib</span></span></span><br><span class="line"><span class="params"><span class="function">    ARCHIVE DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;   # 📌 .a  → prefix/lib</span></span></span><br><span class="line"><span class="params"><span class="function">    RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;   # 📌 .dll（Windows）</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 安装头文件</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">(DIRECTORY include/</span></span></span><br><span class="line"><span class="params"><span class="function">    DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;       # 📌 → prefix/include</span></span></span><br><span class="line"><span class="params"><span class="function">    FILES_MATCHING PATTERN <span class="string">&quot;*.h&quot;</span> PATTERN <span class="string">&quot;*.hpp&quot;</span>  # 📌 只复制头文件</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 或安装单个头文件</span></span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">(FILES include/mylib.h</span></span></span><br><span class="line"><span class="params"><span class="function">    DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;/mylib</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 安装数据/资源文件</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">(DIRECTORY resources/</span></span></span><br><span class="line"><span class="params"><span class="function">    DESTINATION $&#123;CMAKE_INSTALL_DATADIR&#125;/$&#123;PROJECT_NAME&#125;  # 📌 → prefix/share/myapp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"># 安装配置文件</span></span><br><span class="line"><span class="function"># ══════════════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">(FILES config/myapp.conf</span></span></span><br><span class="line"><span class="params"><span class="function">    DESTINATION $&#123;CMAKE_INSTALL_SYSCONFDIR&#125;/$&#123;PROJECT_NAME&#125;  # 📌 → prefix/etc/myapp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>安装命令</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 配置</span><br><span class="line">cmake -S . -B build -DCMAKE_INSTALL_PREFIX=/opt/myapp</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">cmake --build build</span><br><span class="line"></span><br><span class="line"># 安装（可能需要 sudo）</span><br><span class="line">cmake --install build</span><br><span class="line"></span><br><span class="line"># 安装到临时目录（打包用）</span><br><span class="line">cmake --install build --prefix ./package</span><br></pre></td></tr></table></figure>


<h2 id="8-查包相关变量"><a href="#8-查包相关变量" class="headerlink" title="8.查包相关变量"></a>8.查包相关变量</h2><h3 id="（1）汇总表格-7"><a href="#（1）汇总表格-7" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118155211465.png"></p>
<h3 id="（2）使用示例-7"><a href="#（2）使用示例-7" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><h4 id="常用精简版-5"><a href="#常用精简版-5" class="headerlink" title="&lt;1&gt;常用精简版"></a>&lt;1&gt;常用精简版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="built_in">project</span>(MyProject LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"></span><br><span class="line"># ==================== 搜索路径 ====================</span><br><span class="line"><span class="built_in">set</span>(CMAKE_PREFIX_PATH <span class="string">&quot;/opt/Qt6&quot;</span> <span class="string">&quot;/usr/local&quot;</span>)</span><br><span class="line"></span><br><span class="line"># ==================== 查找包 ====================</span><br><span class="line"><span class="built_in">find_package</span>(Qt6 COMPONENTS Core Widgets REQUIRED)</span><br><span class="line"><span class="built_in">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"><span class="built_in">find_package</span>(ZLIB QUIET)  # 可选</span><br><span class="line"></span><br><span class="line"># ==================== 条件判断 ====================</span><br><span class="line"><span class="keyword">if</span>(ZLIB_FOUND)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;ZLIB 版本: $&#123;ZLIB_VERSION_STRING&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># ==================== 创建目标 ====================</span><br><span class="line"><span class="built_in">add_executable</span>(myapp main.cpp)</span><br><span class="line"></span><br><span class="line"># ==================== 链接库（现代方式） ====================</span><br><span class="line"><span class="built_in">target_link_libraries</span>(myapp PRIVATE</span><br><span class="line">    Qt6::Core</span><br><span class="line">    Qt6::Widgets</span><br><span class="line">    OpenSSL::SSL</span><br><span class="line">    OpenSSL::Crypto</span><br><span class="line">    $&lt;$&lt;BOOL:$&#123;ZLIB_FOUND&#125;&gt;:ZLIB::ZLIB&gt;  # 条件链接</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="完整版-5"><a href="#完整版-5" class="headerlink" title="&lt;2&gt;完整版"></a>&lt;2&gt;完整版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="built_in">project</span>(FindPackageDemo LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"></span><br><span class="line"># ==================== 搜索路径配置 ====================</span><br><span class="line"># 指定第三方库安装位置</span><br><span class="line"><span class="built_in">set</span>(CMAKE_PREFIX_PATH </span><br><span class="line">    <span class="string">&quot;/opt/Qt6&quot;</span></span><br><span class="line">    <span class="string">&quot;/usr/local&quot;</span></span><br><span class="line">    <span class="string">&quot;$ENV&#123;HOME&#125;/libs&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 添加自定义 CMake 模块路径</span><br><span class="line"><span class="built_in">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/cmake&quot;</span> $&#123;CMAKE_MODULE_PATH&#125;)</span><br><span class="line"></span><br><span class="line"># ==================== 查找包 ====================</span><br><span class="line"># 查找 Qt6（CONFIG 模式）</span><br><span class="line"><span class="built_in">find_package</span>(Qt6 COMPONENTS Core Widgets REQUIRED)</span><br><span class="line"></span><br><span class="line"># 查找 OpenSSL（MODULE 模式）</span><br><span class="line"><span class="built_in">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"></span><br><span class="line"># 查找 ZLIB（可选）</span><br><span class="line"><span class="built_in">find_package</span>(ZLIB QUIET)</span><br><span class="line"></span><br><span class="line"># ==================== 条件判断：_FOUND ====================</span><br><span class="line"><span class="keyword">if</span>(Qt6_FOUND)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;✅ Qt6 找到&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;   版本: $&#123;Qt6_VERSION&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;   配置文件: $&#123;Qt6_CONFIG&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">else</span>()</span><br><span class="line">    <span class="built_in">message</span>(FATAL_ERROR <span class="string">&quot;❌ Qt6 未找到&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(OpenSSL_FOUND)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;✅ OpenSSL 找到&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;   版本: $&#123;OPENSSL_VERSION&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;   头文件: $&#123;OPENSSL_INCLUDE_DIR&#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;   库文件: $&#123;OPENSSL_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ZLIB_FOUND)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;✅ ZLIB 找到，版本: $&#123;ZLIB_VERSION_STRING&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">else</span>()</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;⚠️ ZLIB 未找到，将使用内置实现&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># ==================== 版本检查：_VERSION_* ====================</span><br><span class="line"><span class="keyword">if</span>(Qt6_VERSION_MAJOR GREATER_EQUAL <span class="number">6</span> AND Qt6_VERSION_MINOR GREATER_EQUAL <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">message</span>(STATUS <span class="string">&quot;Qt6 版本 &gt;= 6.5，启用新特性&quot;</span>)</span><br><span class="line">    <span class="built_in">add_compile_definitions</span>(QT_NEW_FEATURES)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># 精确版本比较</span><br><span class="line"><span class="keyword">if</span>(Qt6_VERSION VERSION_LESS <span class="string">&quot;6.2.0&quot;</span>)</span><br><span class="line">    <span class="built_in">message</span>(WARNING <span class="string">&quot;Qt6 版本过低，建议升级到 6.2.0+&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># ==================== 创建目标 ====================</span><br><span class="line"><span class="built_in">add_executable</span>(myapp main.cpp)</span><br><span class="line"></span><br><span class="line"># ==================== 使用 _INCLUDE_DIRS ====================</span><br><span class="line"># 方式<span class="number">1</span>：现代 CMake（推荐，自动传递）</span><br><span class="line"><span class="built_in">target_link_libraries</span>(myapp PRIVATE </span><br><span class="line">    Qt6::Core </span><br><span class="line">    Qt6::Widgets</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span>：传统方式（显式指定）</span><br><span class="line"><span class="keyword">if</span>(OpenSSL_FOUND)</span><br><span class="line">    <span class="built_in">target_include_directories</span>(myapp PRIVATE $&#123;OPENSSL_INCLUDE_DIR&#125;)</span><br><span class="line">    <span class="built_in">target_link_libraries</span>(myapp PRIVATE $&#123;OPENSSL_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># ==================== 使用 _LIBRARIES ====================</span><br><span class="line"># 现代导入目标（推荐）</span><br><span class="line"># Qt6::Core, Qt6::Widgets 自动包含头文件路径和依赖</span><br><span class="line"></span><br><span class="line"># 传统库变量</span><br><span class="line"><span class="keyword">if</span>(ZLIB_FOUND)</span><br><span class="line">    <span class="built_in">target_include_directories</span>(myapp PRIVATE $&#123;ZLIB_INCLUDE_DIRS&#125;)</span><br><span class="line">    <span class="built_in">target_link_libraries</span>(myapp PRIVATE $&#123;ZLIB_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># ==================== 打印所有变量（调试用） ====================</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;========== 包信息汇总 ==========&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;Qt6_FOUND:         $&#123;Qt6_FOUND&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;Qt6_VERSION:       $&#123;Qt6_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;Qt6_VERSION_MAJOR: $&#123;Qt6_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;Qt6_VERSION_MINOR: $&#123;Qt6_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;Qt6_CONFIG:        $&#123;Qt6_CONFIG&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;================================&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka实战笔记</title>
    <url>/2026/01/18/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/Kafka%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、特殊情况的应对策略"><a href="#一、特殊情况的应对策略" class="headerlink" title="一、特殊情况的应对策略"></a>一、特殊情况的应对策略</h1><h2 id="1-Producer侧“消息队列”满的处理策略"><a href="#1-Producer侧“消息队列”满的处理策略" class="headerlink" title="1.Producer侧“消息队列”满的处理策略"></a>1.Producer侧“消息队列”满的处理策略</h2><p>实际开发中，队列满（ERR__QUEUE_FULL）的处理取决于业务对可靠性 vs 性能的权衡<br>📋 <strong>策略选择决策树</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">               消息丢失可接受吗？</span><br><span class="line">                     │</span><br><span class="line">       ┌────Yes──────┴──────No────┐</span><br><span class="line">       │                          │</span><br><span class="line">       ▼                          ▼</span><br><span class="line"> 丢弃+监控告警              延迟敏感吗？</span><br><span class="line">（日志/埋点）                    │</span><br><span class="line">                  ┌───Yes───────┴───────No───┐</span><br><span class="line">                  │                          │</span><br><span class="line">                  ▼                          ▼</span><br><span class="line">           有限重试+退避              本地持久化兜底</span><br><span class="line">          （交易/订单）               （核心业务）</span><br></pre></td></tr></table></figure>


<h3 id="（1）问题描述"><a href="#（1）问题描述" class="headerlink" title="（1）问题描述"></a>（1）问题描述</h3><p>使用producer调用send时，如果出现“消息队列已满”，该如何处理？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KafkaProducer::Send</span><span class="params">(<span class="type">const</span> std::string&amp; topic,<span class="type">const</span> std::string&amp; key,<span class="type">const</span> std::string&amp; value)</span></span>&#123;</span><br><span class="line">    RdKafka::ErrorCode err = producer_-&gt;<span class="built_in">produce</span>(</span><br><span class="line">        topic,</span><br><span class="line">        RdKafka::Topic::PARTITION_UA,</span><br><span class="line">        RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">        (<span class="type">void</span>*)value.<span class="built_in">data</span>(),value.<span class="built_in">size</span>(),</span><br><span class="line">        key.<span class="built_in">data</span>(),key.<span class="built_in">size</span>(),</span><br><span class="line">        <span class="number">0</span>,<span class="literal">nullptr</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err!=RdKafka::ERR_NO_ERROR)&#123;</span><br><span class="line">        <span class="keyword">if</span>(err==RdKafka::ERR__QUEUE_FULL)&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 如何处理“消息队列已满”比较好？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;kafka produce failed: topic=&#123;&#125;,error&#123;&#125;&quot;</span>,topic,RdKafka::<span class="built_in">err2str</span>(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发回调</span></span><br><span class="line">    producer_-&gt;<span class="built_in">poll</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Kafka message produced: topic=&#123;&#125;,key=&#123;&#125;&quot;</span>,topic,RdKafka::<span class="built_in">err2str</span>(err));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）kafka的配置项无法解决此场景吗？"><a href="#（2）kafka的配置项无法解决此场景吗？" class="headerlink" title="（2）kafka的配置项无法解决此场景吗？"></a>（2）kafka的配置项无法解决此场景吗？</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                              配置项关联关系                                              │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">                           ┌─────────────────┐</span><br><span class="line">                           │   <span class="built_in">produce</span>()     │</span><br><span class="line">                           └────────┬────────┘</span><br><span class="line">                                    │</span><br><span class="line">                    ┌───────────────┼───────────────┐</span><br><span class="line">                    │               │               │</span><br><span class="line">                    ▼               ▼               ▼</span><br><span class="line">        ┌───────────────┐  ┌──────────────┐  ┌─────────────────┐</span><br><span class="line">        │ 消息大小检查   │  │  队列容量检查 │  │   入队成功       │</span><br><span class="line">        │ message.max.  │  │ queue.buffer │  │                 │</span><br><span class="line">        │ bytes         │  │ ing.max.*    │  │                 │</span><br><span class="line">        └───────┬───────┘  └──────┬───────┘  └────────┬────────┘</span><br><span class="line">                │                 │                   │</span><br><span class="line">        ┌───────┴───────┐  ┌──────┴───────┐          │</span><br><span class="line">        │ ERR_MSG_SIZE  │  │ERR__QUEUE_   │          │</span><br><span class="line">        │ _TOO_LARGE    │  │FULL          │          │</span><br><span class="line">        │               │  │              │          │</span><br><span class="line">        │ ❌ 不触发重试  │  │ ❌ 不触发重试 │          │</span><br><span class="line">        └───────────────┘  └──────────────┘          │</span><br><span class="line">                                                     ▼</span><br><span class="line">                                          ┌──────────────────┐</span><br><span class="line">                                          │   批量组装       │</span><br><span class="line">                                          │ batch.size      │</span><br><span class="line">                                          │ batch.num.msgs  │</span><br><span class="line">                                          │ queue.buffering │</span><br><span class="line">                                          │ .max.ms         │</span><br><span class="line">                                          └────────┬─────────┘</span><br><span class="line">                                                   │</span><br><span class="line">                                                   ▼</span><br><span class="line">                                          ┌──────────────────┐</span><br><span class="line">                                          │   压缩处理       │</span><br><span class="line">                                          │ compression.    │</span><br><span class="line">                                          │ codec/level     │</span><br><span class="line">                                          └────────┬─────────┘</span><br><span class="line">                                                   │</span><br><span class="line">                                                   ▼</span><br><span class="line">                                          ┌──────────────────┐</span><br><span class="line">                                          │   发送请求       │</span><br><span class="line">                                          │ acks            │</span><br><span class="line">                                          │ request.timeout │</span><br><span class="line">                                          │ .ms             │</span><br><span class="line">                                          └────────┬─────────┘</span><br><span class="line">                                                   │</span><br><span class="line">                          ┌────────────────────────┼────────────────────────┐</span><br><span class="line">                          │                        │                        │</span><br><span class="line">                          ▼                        ▼                        ▼</span><br><span class="line">                   ┌─────────────┐         ┌─────────────┐         ┌─────────────┐</span><br><span class="line">                   │  发送成功    │         │ 可重试错误   │         │ 不可重试错误 │</span><br><span class="line">                   │             │         │             │         │             │</span><br><span class="line">                   │ delivery    │         │ ✅ 触发重试  │         │ ❌ 不触发重试│</span><br><span class="line">                   │ <span class="built_in">report</span>(OK)  │         │             │         │             │</span><br><span class="line">                   └─────────────┘         └──────┬──────┘         └─────────────┘</span><br><span class="line">                                                  │</span><br><span class="line">                                                  ▼</span><br><span class="line">                                          ┌──────────────────┐</span><br><span class="line">                                          │   重试控制       │</span><br><span class="line">                                          │ retries         │</span><br><span class="line">                                          │ retry.backoff.  │</span><br><span class="line">                                          │ ms/max.ms       │</span><br><span class="line">                                          └────────┬─────────┘</span><br><span class="line">                                                   │</span><br><span class="line">                                    ┌──────────────┴──────────────┐</span><br><span class="line">                                    │                             │</span><br><span class="line">                                    ▼                             ▼</span><br><span class="line">                            ┌─────────────┐               ┌─────────────┐</span><br><span class="line">                            │ 重试次数&gt;<span class="number">0</span>   │               │ 重试次数=<span class="number">0</span>   │</span><br><span class="line">                            │ 继续重试     │               │ 放弃重试     │</span><br><span class="line">                            └──────┬──────┘               └──────┬──────┘</span><br><span class="line">                                   │                             │</span><br><span class="line">                                   ▼                             │</span><br><span class="line">                            ┌─────────────┐                      │</span><br><span class="line">                            │delivery.    │                      │</span><br><span class="line">                            │timeout.ms   │                      │</span><br><span class="line">                            │超时检查     │                      │</span><br><span class="line">                            └──────┬──────┘                      │</span><br><span class="line">                                   │                             │</span><br><span class="line">                          ┌────────┴────────┐                    │</span><br><span class="line">                          │                 │                    │</span><br><span class="line">                          ▼                 ▼                    ▼</span><br><span class="line">                    ┌──────────┐      ┌──────────┐        ┌──────────┐</span><br><span class="line">                    │ 未超时    │      │ 已超时    │        │delivery  │</span><br><span class="line">                    │ 继续重试  │      │ 放弃      │        │report    │</span><br><span class="line">                    └──────────┘      └────┬─────┘        │(FAIL)    │</span><br><span class="line">                                           │              └──────────┘</span><br><span class="line">                                           └──────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（3）配置层面预防"><a href="#（3）配置层面预防" class="headerlink" title="（3）配置层面预防"></a>（3）配置层面预防</h3><p>调整 librdkafka 配置减少队列满的概率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">conf_ = <span class="built_in">KafkaConfBuilder</span>()</span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, brokers)</span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;queue.buffering.max.messages&quot;</span>, <span class="string">&quot;1000000&quot;</span>)  <span class="comment">// 增大队列容量</span></span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;queue.buffering.max.kbytes&quot;</span>, <span class="string">&quot;1048576&quot;</span>)    <span class="comment">// 1GB 缓冲区</span></span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;batch.num.messages&quot;</span>, <span class="string">&quot;10000&quot;</span>)              <span class="comment">// 批量发送</span></span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;queue.buffering.max.ms&quot;</span>, <span class="string">&quot;5&quot;</span>)                           <span class="comment">// 等待聚合</span></span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;message.send.max.retries&quot;</span>, <span class="string">&quot;3&quot;</span>)       <span class="comment">// librdkafka 内部重试</span></span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;retry.backoff.ms&quot;</span>, <span class="string">&quot;100&quot;</span>)             <span class="comment">// 内部重试退避</span></span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;delivery.timeout.ms&quot;</span>, <span class="string">&quot;120000&quot;</span>)       <span class="comment">// 投递总超时</span></span><br><span class="line">    .<span class="built_in">Set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>)                         <span class="comment">// 可靠性要求高时使用</span></span><br><span class="line">    .<span class="built_in">Build</span>();</span><br></pre></td></tr></table></figure>

<h3 id="（4）常见策略对比"><a href="#（4）常见策略对比" class="headerlink" title="（4）常见策略对比"></a>（4）常见策略对比</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118233422535.png"></p>
<h4 id="有限重试-指数退避（推荐）"><a href="#有限重试-指数退避（推荐）" class="headerlink" title="&lt;1&gt;有限重试 + 指数退避（推荐）"></a>&lt;1&gt;有限重试 + 指数退避（推荐）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KafkaProducer::Send</span><span class="params">(<span class="type">const</span> std::string&amp; topic, </span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::string&amp; key, </span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> kMaxRetries = <span class="number">3</span>;       <span class="comment">// 最大重试次数（队列满时）</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> kMaxBackoffMs = <span class="number">1000</span>;  <span class="comment">// 退避时间上限，防止等待过久</span></span><br><span class="line">    <span class="type">int</span> backoff_ms = <span class="number">50</span>;                 <span class="comment">// 初始退避时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试循环：retry=0 是首次发送，1~3 是重试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> retry = <span class="number">0</span>; retry &lt;= kMaxRetries; ++retry) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 librdkafka 发送消息</span></span><br><span class="line">        <span class="comment">// RK_MSG_COPY：librdkafka 会复制 value/key，函数返回后原数据可释放</span></span><br><span class="line">        <span class="comment">// PARTITION_UA：由 librdkafka 根据 key 哈希自动选择分区</span></span><br><span class="line">        RdKafka::ErrorCode err = producer_-&gt;<span class="built_in">produce</span>(</span><br><span class="line">            topic,</span><br><span class="line">            RdKafka::Topic::PARTITION_UA,</span><br><span class="line">            RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">            (<span class="type">void</span>*)value.<span class="built_in">data</span>(), value.<span class="built_in">size</span>(),</span><br><span class="line">            key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="number">0</span>,        <span class="comment">// timestamp: 0 表示使用当前时间</span></span><br><span class="line">            <span class="literal">nullptr</span>   <span class="comment">// msg_opaque: 传递给回调的用户数据，这里不需要</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送成功（仅表示入队成功，非真正送达 Kafka）</span></span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            producer_-&gt;<span class="built_in">poll</span>(<span class="number">0</span>);  <span class="comment">// 非阻塞触发回调，处理之前的发送结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非队列满错误（如 topic 不存在、消息过大等），不可恢复，直接失败</span></span><br><span class="line">        <span class="keyword">if</span> (err != RdKafka::ERR__QUEUE_FULL) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Kafka produce failed: topic=&#123;&#125;, err=&#123;&#125;&quot;</span>, </span><br><span class="line">                      topic, RdKafka::<span class="built_in">err2str</span>(err));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列满，准备重试</span></span><br><span class="line">        <span class="keyword">if</span> (retry &lt; kMaxRetries) &#123;</span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Kafka queue full, retry &#123;&#125;/&#123;&#125; after &#123;&#125;ms&quot;</span>, </span><br><span class="line">                     retry + <span class="number">1</span>, kMaxRetries, backoff_ms);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// poll 的双重作用：</span></span><br><span class="line">            <span class="comment">// 1. 阻塞等待 backoff_ms 毫秒</span></span><br><span class="line">            <span class="comment">// 2. 触发投递回调，释放已发送消息占用的队列空间</span></span><br><span class="line">            producer_-&gt;<span class="built_in">poll</span>(backoff_ms);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 指数退避 + 随机抖动</span></span><br><span class="line">            <span class="comment">// - 指数退避(x2)：50 → 100 → 200 → 400...</span></span><br><span class="line">            <span class="comment">// - 随机抖动(+rand%50)：避免多个生产者同时重试造成&quot;惊群效应&quot;</span></span><br><span class="line">            <span class="comment">// - min 限制上限：防止退避时间无限增长</span></span><br><span class="line">            backoff_ms = std::<span class="built_in">min</span>(backoff_ms * <span class="number">2</span> + <span class="built_in">rand</span>() % <span class="number">50</span>, kMaxBackoffMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试耗尽，消息发送失败</span></span><br><span class="line">    <span class="comment">// 调用方可选择：丢弃、写入 WAL、或其他兜底策略</span></span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Kafka queue full after &#123;&#125; retries, topic=&#123;&#125;&quot;</span>, kMaxRetries, topic);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="丢弃-监控告警（日志-埋点场景）"><a href="#丢弃-监控告警（日志-埋点场景）" class="headerlink" title="&lt;2&gt;丢弃 + 监控告警（日志&#x2F;埋点场景）"></a>&lt;2&gt;丢弃 + 监控告警（日志&#x2F;埋点场景）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KafkaProducer::SendBestEffort</span><span class="params">(<span class="type">const</span> std::string&amp; topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> std::string&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    RdKafka::ErrorCode err = producer_-&gt;<span class="built_in">produce</span>(</span><br><span class="line">        topic,</span><br><span class="line">        RdKafka::Topic::PARTITION_UA,</span><br><span class="line">        RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">        (<span class="type">void</span>*)value.<span class="built_in">data</span>(), value.<span class="built_in">size</span>(),</span><br><span class="line">        key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>(),</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    producer_-&gt;<span class="built_in">poll</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == RdKafka::ERR__QUEUE_FULL) &#123;</span><br><span class="line">        ++queue_full_count_;  <span class="comment">// 统计</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每 1000 次告警一次，避免日志爆炸</span></span><br><span class="line">        <span class="keyword">if</span> (queue_full_count_ % <span class="number">1000</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Kafka queue full, &#123;&#125; messages dropped&quot;</span>, queue_full_count_);</span><br><span class="line">            <span class="comment">// 可以发送告警到监控系统</span></span><br><span class="line">            <span class="comment">// AlertManager::Send(&quot;kafka_queue_full&quot;, queue_full_count_);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 直接丢弃</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Kafka produce failed: &#123;&#125;&quot;</span>, RdKafka::<span class="built_in">err2str</span>(err));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地持久化兜底（比较复杂）"><a href="#本地持久化兜底（比较复杂）" class="headerlink" title="&lt;3&gt;本地持久化兜底（比较复杂）"></a>&lt;3&gt;本地持久化兜底（比较复杂）</h4><p>核心逻辑：发送失败 → 写文件 → 后台线程定期重试 → 成功后删除记录。<br><strong>核心流程图</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">业务调用 SendReliable()</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ 尝试发送x3  │</span><br><span class="line">    └─────────────┘</span><br><span class="line">         │</span><br><span class="line">    成功? ──Yes──► <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">         │</span><br><span class="line">        No</span><br><span class="line">         ▼</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ 写入 WAL    │  ← 持久化到磁盘</span><br><span class="line">    └─────────────┘</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>（消息已被接管）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">后台线程（每<span class="number">5</span>秒）</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ 读取 WAL    │</span><br><span class="line">    └─────────────┘</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ 重试发送    │</span><br><span class="line">    └─────────────┘</span><br><span class="line">         │</span><br><span class="line">    成功? ──Yes──► MarkDone() 删除记录</span><br><span class="line">         │</span><br><span class="line">        No ──────► 保留，下次继续</span><br></pre></td></tr></table></figure>

<h4 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="&lt;4&gt;阻塞模式"></a>&lt;4&gt;阻塞模式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚠️ 阻塞模式：队列满时无限等待直到入队成功</span></span><br><span class="line"><span class="comment">// 适用场景：批处理/离线任务，对延迟不敏感但要求消息必须入队</span></span><br><span class="line"><span class="comment">// 风险：如果 Kafka 持续不可用，会永久阻塞调用线程</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KafkaProducer::SendBlocking</span><span class="params">(<span class="type">const</span> std::string&amp; topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::string&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        RdKafka::ErrorCode err = producer_-&gt;<span class="built_in">produce</span>(</span><br><span class="line">            topic,</span><br><span class="line">            RdKafka::Topic::PARTITION_UA,      <span class="comment">// 自动分区：按 key 哈希选择</span></span><br><span class="line">            RdKafka::Producer::RK_MSG_COPY,    <span class="comment">// 复制模式：librdkafka 复制数据，调用后可释放原数据</span></span><br><span class="line">            (<span class="type">void</span>*)value.<span class="built_in">data</span>(), value.<span class="built_in">size</span>(),</span><br><span class="line">            key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="number">0</span>,        <span class="comment">// timestamp: 0 = 使用当前时间</span></span><br><span class="line">            <span class="literal">nullptr</span>   <span class="comment">// msg_opaque: 回调透传数据，这里不需要</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队成功（注意：仅入队，非真正送达 Kafka）</span></span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            producer_-&gt;<span class="built_in">poll</span>(<span class="number">0</span>);  <span class="comment">// 非阻塞触发回调，处理历史投递结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列满：等待 + 重试（阻塞的核心逻辑）</span></span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR__QUEUE_FULL) &#123;</span><br><span class="line">            <span class="comment">// poll(100) 的双重作用：</span></span><br><span class="line">            <span class="comment">// 1. 阻塞等待 100ms，降低 CPU 空转</span></span><br><span class="line">            <span class="comment">// 2. 触发 delivery report 回调，已发送的消息出队，腾出空间</span></span><br><span class="line">            producer_-&gt;<span class="built_in">poll</span>(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 队列满可恢复，继续重试</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他错误（topic 不存在、消息过大等），不可恢复，直接失败</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Kafka produce failed: &#123;&#125;&quot;</span>, RdKafka::<span class="built_in">err2str</span>(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="附录1：配置项详解"><a href="#附录1：配置项详解" class="headerlink" title="附录1：配置项详解"></a>附录1：配置项详解</h1><h2 id="1-Producer端配置项生效场景"><a href="#1-Producer端配置项生效场景" class="headerlink" title="1.Producer端配置项生效场景"></a>1.Producer端配置项生效场景</h2><h3 id="（1）网络与连接相关（Global通用配置）"><a href="#（1）网络与连接相关（Global通用配置）" class="headerlink" title="（1）网络与连接相关（Global通用配置）"></a>（1）网络与连接相关（Global通用配置）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116144611415.png"></p>
<p><strong>触发时机总结表</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119091618544.png"></p>
<p><strong>生产环境配置建议</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 稳定网络环境</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;socket.timeout.ms&quot;</span>, <span class="string">&quot;60000&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;socket.connection.setup.timeout.ms&quot;</span>, <span class="string">&quot;30000&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;socket.keepalive.enable&quot;</span>, <span class="string">&quot;true&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;connections.max.idle.ms&quot;</span>, <span class="string">&quot;600000&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;reconnect.backoff.ms&quot;</span>, <span class="string">&quot;100&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;reconnect.backoff.max.ms&quot;</span>, <span class="string">&quot;10000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定网络/跨机房场景</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;socket.timeout.ms&quot;</span>, <span class="string">&quot;30000&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;socket.connection.setup.timeout.ms&quot;</span>, <span class="string">&quot;50000&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;socket.keepalive.enable&quot;</span>, <span class="string">&quot;true&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;connections.max.idle.ms&quot;</span>, <span class="string">&quot;300000&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;reconnect.backoff.ms&quot;</span>, <span class="string">&quot;50&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;reconnect.backoff.max.ms&quot;</span>, <span class="string">&quot;5000&quot;</span>, errstr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>生效机制（指数退避算法）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次重试: 等待 <span class="number">100</span>ms (reconnect.backoff.ms)</span><br><span class="line">第<span class="number">2</span>次重试: 等待 <span class="number">200</span>ms (<span class="number">100</span> * <span class="number">2</span>)</span><br><span class="line">第<span class="number">3</span>次重试: 等待 <span class="number">400</span>ms (<span class="number">200</span> * <span class="number">2</span>)</span><br><span class="line">第<span class="number">4</span>次重试: 等待 <span class="number">800</span>ms (<span class="number">400</span> * <span class="number">2</span>)</span><br><span class="line">   ...</span><br><span class="line">第N次重试: 等待 <span class="built_in">min</span>(计算值, reconnect.backoff.max.ms)</span><br></pre></td></tr></table></figure>

<h4 id="socket-connection-setup-timeout-ms触发点"><a href="#socket-connection-setup-timeout-ms触发点" class="headerlink" title="&lt;1&gt;socket.connection.setup.timeout.ms触发点"></a>&lt;1&gt;socket.connection.setup.timeout.ms触发点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发函数: RdKafka::Producer::create() 和内部连接建立</span></span><br><span class="line">RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;socket.connection.setup.timeout.ms&quot;</span>, <span class="string">&quot;30000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">RdKafka::Producer *producer = RdKafka::Producer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line"><span class="comment">// ↑ 此时触发与 bootstrap.servers 的首次连接</span></span><br><span class="line"><span class="comment">//   内部调用 rd_kafka_broker_connect() → rd_kafka_transport_connect()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 注意：此超时不仅在 create() 时触发</span></span><br><span class="line"><span class="comment">// 运行期间如果需要连接新 Broker（如 partition leader 变更），也会触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景举例：</span></span><br><span class="line"><span class="comment">// 1. 初始连接 bootstrap.servers</span></span><br><span class="line"><span class="comment">// 2. metadata 更新发现新 broker</span></span><br><span class="line"><span class="comment">// 3. leader 切换需要连接新 broker</span></span><br></pre></td></tr></table></figure>
<p><strong>内部触发链路</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Producer::<span class="built_in">create</span>()</span><br><span class="line">    └→ <span class="built_in">rd_kafka_new</span>()</span><br><span class="line">        └→ <span class="built_in">rd_kafka_brokers_add</span>()</span><br><span class="line">            └→ <span class="built_in">rd_kafka_broker_connect</span>()</span><br><span class="line">                └→ <span class="built_in">rd_kafka_transport_connect</span>()  ← 超时由此配置控制</span><br><span class="line">                    └→ <span class="built_in">connect</span>() 系统调用</span><br></pre></td></tr></table></figure>

<h4 id="socket-timeout-ms触发点"><a href="#socket-timeout-ms触发点" class="headerlink" title="&lt;2&gt;socket.timeout.ms触发点"></a>&lt;2&gt;socket.timeout.ms触发点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发函数: produce() + poll() + flush()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. produce() - 消息入队（不直接触发网络IO，但会唤醒后台线程）</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. poll() - 处理回调，驱动网络IO ← 这里会触发！</span></span><br><span class="line">producer-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);  <span class="comment">// ← socket读写受 socket.timeout.ms 控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. flush() - 内部循环调用 poll()</span></span><br><span class="line">producer-&gt;<span class="built_in">flush</span>(<span class="number">10000</span>);  <span class="comment">// ← 本质是 while(outq_len &gt; 0) poll()</span></span><br></pre></td></tr></table></figure>
<p><strong>内部触发路径</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                     socket.timeout.ms 触发路径                   │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="built_in">produce</span>()                     <span class="built_in">poll</span>()                    <span class="built_in">flush</span>()</span><br><span class="line">    │                           │                          │</span><br><span class="line">    │ 消息入队列                 │                          │</span><br><span class="line">    ▼                           │                          │</span><br><span class="line">┌─────────┐                     │                    ┌─────────┐</span><br><span class="line">│ 队列    │◄────────────────────┼────────────────────│ <span class="keyword">while</span>() │</span><br><span class="line">└────┬────┘                     │                    │ <span class="built_in">poll</span>()  │</span><br><span class="line">     │                          ▼                    └────┬────┘</span><br><span class="line">     │                    ┌───────────┐                   │</span><br><span class="line">     │                    │  <span class="built_in">poll</span>()   │◄──────────────────┘</span><br><span class="line">     │                    └─────┬─────┘</span><br><span class="line">     │                          │</span><br><span class="line">     ▼                          ▼</span><br><span class="line">┌─────────────────────────────────────────┐</span><br><span class="line">│         后台 IO 线程                      │</span><br><span class="line">│   <span class="built_in">rd_kafka_broker_serve</span>()               │</span><br><span class="line">│         │                               │</span><br><span class="line">│         ├→ <span class="built_in">rd_kafka_send</span>() ──┐          │</span><br><span class="line">│         │                    │          │</span><br><span class="line">│         └→ <span class="built_in">rd_kafka_recv</span>() ──┼─→ socket.timeout.ms 生效</span><br><span class="line">│                              │          │</span><br><span class="line">└─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h4 id="socket-keepalive-enable触发点"><a href="#socket-keepalive-enable触发点" class="headerlink" title="&lt;3&gt;socket.keepalive.enable触发点"></a>&lt;3&gt;socket.keepalive.enable触发点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 create() 时设置，连接建立后立即生效</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;socket.keepalive.enable&quot;</span>, <span class="string">&quot;true&quot;</span>, errstr);</span><br><span class="line">RdKafka::Producer *producer = RdKafka::Producer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line"><span class="comment">// 后续所有连接自动启用 TCP keepalive</span></span><br></pre></td></tr></table></figure>
<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rd_kafka_transport_connect</span>()</span><br><span class="line">    └→ <span class="built_in">rd_kafka_transport_post_connect_setup</span>()</span><br><span class="line">        └→ <span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_KEEPALIVE, ...)  ← 此处生效</span><br></pre></td></tr></table></figure>

<h4 id="connections-max-idle-ms触发点"><a href="#connections-max-idle-ms触发点" class="headerlink" title="&lt;4&gt;connections.max.idle.ms触发点"></a>&lt;4&gt;connections.max.idle.ms触发点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发场景: 长时间不调用 produce() 或 poll()</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);  <span class="comment">// 最后一次发送</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 10分钟没有任何操作 ...</span></span><br><span class="line"></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);  <span class="comment">// 此时连接已被关闭，需要重建</span></span><br></pre></td></tr></table></figure>
<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rd_kafka_thread_main</span>()  <span class="comment">// 后台轮询线程</span></span><br><span class="line">    └→ <span class="built_in">rd_kafka_broker_serve</span>()</span><br><span class="line">        └→ <span class="built_in">rd_kafka_broker_idle_check</span>()  ← 检查空闲时间</span><br><span class="line">            └→ 当前时间 - 最后活动时间 &gt; connections.max.idle.ms</span><br><span class="line">                └→ <span class="built_in">rd_kafka_broker_fail</span>()  ← 主动断开连接</span><br></pre></td></tr></table></figure>

<h4 id="reconnect-backoff-ms-reconnect-backoff-max-ms-触发点"><a href="#reconnect-backoff-ms-reconnect-backoff-max-ms-触发点" class="headerlink" title="&lt;5&gt; reconnect.backoff.ms &#x2F; reconnect.backoff.max.ms 触发点"></a>&lt;5&gt; reconnect.backoff.ms &#x2F; reconnect.backoff.max.ms 触发点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发场景: Broker 故障或网络断开后自动重连</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);  <span class="comment">// 发送时发现连接断开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部自动触发重连，无需用户调用任何函数</span></span><br><span class="line"><span class="comment">// 可通过回调观察重连过程:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEventCb</span> : <span class="keyword">public</span> RdKafka::EventCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">event_cb</span><span class="params">(RdKafka::Event &amp;event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.<span class="built_in">type</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_ERROR:</span><br><span class="line">                <span class="keyword">if</span> (event.<span class="built_in">err</span>() == RdKafka::ERR__TRANSPORT) &#123;</span><br><span class="line">                    <span class="comment">// 连接断开，即将触发 reconnect.backoff.ms</span></span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;Connection lost, reconnecting...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_LOG:</span><br><span class="line">                <span class="comment">// 可看到重连日志</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;event_cb&quot;</span>, &amp;my_event_cb, errstr);</span><br></pre></td></tr></table></figure>
<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rd_kafka_broker_fail</span>()  <span class="comment">// 连接失败</span></span><br><span class="line">    └→ <span class="built_in">rd_kafka_broker_set_state</span>(BROKER_STATE_INIT)</span><br><span class="line">        └→ <span class="built_in">rd_kafka_broker_reconnect_schedule</span>()</span><br><span class="line">            └→ 计算退避时间 = <span class="built_in">min</span>(backoff * <span class="number">2</span>^n, backoff_max)</span><br><span class="line">                └→ 定时器触发 <span class="built_in">rd_kafka_broker_connect</span>()</span><br></pre></td></tr></table></figure>

<h3 id="（2）消息发送与可靠性配置（Producer专属配置）"><a href="#（2）消息发送与可靠性配置（Producer专属配置）" class="headerlink" title="（2）消息发送与可靠性配置（Producer专属配置）"></a>（2）消息发送与可靠性配置（Producer专属配置）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119095109007.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119095142663.png"></p>
<h4 id="可靠性配置"><a href="#可靠性配置" class="headerlink" title="&lt;1&gt;可靠性配置"></a>&lt;1&gt;可靠性配置</h4><h5 id="1）acks"><a href="#1）acks" class="headerlink" title="1）acks"></a>1）acks</h5><p><strong>触发函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>, errstr);  <span class="comment">// 或 &quot;0&quot;, &quot;1&quot;, &quot;-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 发送消息后，后台线程等待 Broker 确认</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll() 中接收确认结果，触发 delivery report 回调</span></span><br><span class="line">producer-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">produce</span>()</span><br><span class="line">    └→ 消息入队列</span><br><span class="line">        └→ 后台线程 <span class="built_in">rd_kafka_broker_produce_toppar</span>()</span><br><span class="line">            └→ 发送 <span class="built_in">ProduceRequest</span> (携带 acks 参数)</span><br><span class="line">                └→ Broker 处理</span><br><span class="line">                    │</span><br><span class="line">        ┌───────────┴───────────────────────────────────┐</span><br><span class="line">        │                                               │</span><br><span class="line">        ▼ acks=<span class="number">0</span>                 ▼ acks=<span class="number">1</span>              ▼ acks=all</span><br><span class="line">   不等待响应              等待 Leader 确认        等待 ISR 全部确认</span><br><span class="line">        │                       │                      │</span><br><span class="line">        └───────────────────────┴──────────────────────┘</span><br><span class="line">                                │</span><br><span class="line">                                ▼</span><br><span class="line">                    <span class="built_in">poll</span>() → delivery report 回调</span><br></pre></td></tr></table></figure>

<p><strong>三种模式对比</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">┌─────────┬────────────────────┬──────────────┬──────────────┐</span><br><span class="line">│  acks   │      确认机制       │    可靠性    │     性能     │</span><br><span class="line">├─────────┼────────────────────┼──────────────┼──────────────┤</span><br><span class="line">│   <span class="number"> 0 </span>   │ 不等待任何确认      │    最低      │    最高      │</span><br><span class="line">│   <span class="number"> 1 </span>   │ Leader 写入即确认   │    中等      │    中等      │</span><br><span class="line">│ all/-1  │ ISR 全部写入确认    │    最高      │    最低      │</span><br><span class="line">└─────────┴────────────────────┴──────────────┴──────────────┘</span><br></pre></td></tr></table></figure>

<h5 id="2）enable-idempotence"><a href="#2）enable-idempotence" class="headerlink" title="2）enable.idempotence"></a>2）enable.idempotence</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.idempotence&quot;</span>, <span class="string">&quot;true&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段1: Producer::create() 时初始化 PID</span></span><br><span class="line">RdKafka::Producer *producer = RdKafka::Producer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line"><span class="comment">// ↑ 内部向 Broker 请求 Producer ID (PID) 和 Epoch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段2: produce() 时自动附加序列号</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 每条消息自动携带 (PID, Epoch, SequenceNumber)</span></span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Producer::<span class="built_in">create</span>()</span><br><span class="line">    └→ <span class="built_in">rd_kafka_new</span>()</span><br><span class="line">        └→ <span class="built_in">rd_kafka_idemp_init</span>()</span><br><span class="line">            └→ 向 Broker 发送 InitProducerId 请求</span><br><span class="line">                └→ 获取 PID + Epoch</span><br><span class="line">                    └→ 初始化 SequenceNumber = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">produce</span>()</span><br><span class="line">    └→ <span class="built_in">rd_kafka_produce</span>()</span><br><span class="line">        └→ 消息附加 (PID, Epoch, SeqNum++)</span><br><span class="line">            └→ 后台线程发送到 Broker</span><br><span class="line">                └→ Broker 检测</span><br><span class="line">                    │</span><br><span class="line">        ┌───────────┴───────────────────────┐</span><br><span class="line">        │                                   │</span><br><span class="line">        ▼ SeqNum 连续                       ▼ SeqNum 重复/乱序</span><br><span class="line">      正常写入                          丢弃/返回错误</span><br><span class="line">        │                                   │</span><br><span class="line">        └───────────────────────────────────┘</span><br><span class="line">                        │</span><br><span class="line">                        ▼</span><br><span class="line">                <span class="built_in">poll</span>() → delivery report</span><br></pre></td></tr></table></figure>

<p><strong>幂等性保障机制</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                     幂等性工作原理                               │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  Producer                         Broker                        │</span><br><span class="line">│     │                                │                          │</span><br><span class="line">│     │─── <span class="built_in">msg</span>(PID=<span class="number">1</span>, Seq=<span class="number">0</span>) ─────────→│ 写入成功                 │</span><br><span class="line">│     │                                │                          │</span><br><span class="line">│     │─── <span class="built_in">msg</span>(PID=<span class="number">1</span>, Seq=<span class="number">1</span>) ─────────→│ 写入成功                 │</span><br><span class="line">│     │                                │                          │</span><br><span class="line">│     │─── <span class="built_in">msg</span>(PID=<span class="number">1</span>, Seq=<span class="number">1</span>) ─────────→│ 检测重复，丢弃但返回成功  │</span><br><span class="line">│     │    (网络重试导致)              │                          │</span><br><span class="line">│     │                                │                          │</span><br><span class="line">│     │─── <span class="built_in">msg</span>(PID=<span class="number">1</span>, Seq=<span class="number">3</span>) ─────────→│ 检测乱序，返回错误       │</span><br><span class="line">│     │    (Seq=<span class="number">2</span> 丢失)                │                          │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h5 id="3）max-in-flight-requests-per-connection"><a href="#3）max-in-flight-requests-per-connection" class="headerlink" title="3）max.in.flight.requests.per.connection"></a>3）max.in.flight.requests.per.connection</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;max.in.flight.requests.per.connection&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 后台线程发送前检查</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 后台线程检查当前未确认请求数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// poll() 收到确认后释放槽位</span></span><br><span class="line">producer-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">produce</span>() → 消息入队列</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    后台线程准备发送</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    检查 in_flight_count &lt; <span class="built_in">max_in_flight</span> (<span class="number">5</span>)?</span><br><span class="line">              │</span><br><span class="line">    ┌─────────┴─────────┐</span><br><span class="line">    │                   │</span><br><span class="line">    ▼ 是                ▼ 否</span><br><span class="line"> 发送请求            暂不发送，等待确认</span><br><span class="line"> in_flight++              │</span><br><span class="line">    │                     │</span><br><span class="line">    └─────────────────────┘</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    <span class="built_in">poll</span>() → 收到 Broker 确认</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    in_flight_count--</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    触发 delivery report 回调</span><br></pre></td></tr></table></figure>

<p><strong>与幂等性的关系</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│              max.in.flight 与幂等性的约束关系                    │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  enable.idempotence = <span class="literal">false</span>:                                    │</span><br><span class="line">│      max.in.flight 可设任意值                                    │</span><br><span class="line">│      但值过大可能导致重试时消息乱序                               │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  enable.idempotence = <span class="literal">true</span>:                                     │</span><br><span class="line">│      max.in.flight 自动限制 ≤ <span class="number">5</span>                                  │</span><br><span class="line">│      即使配置更大值也会被覆盖                                     │</span><br><span class="line">│      原因: Broker 端只缓存最近<span class="number">5</span>个序列号用于去重                   │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h4 id="重试配置"><a href="#重试配置" class="headerlink" title="&lt;2&gt;重试配置"></a>&lt;2&gt;重试配置</h4><h5 id="1）retries"><a href="#1）retries" class="headerlink" title="1）retries"></a>1）retries</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: 发送失败后自动重试（无需用户调用）</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll() 中处理重试结果</span></span><br><span class="line">producer-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">produce</span>()</span><br><span class="line">    └→ 消息入队列</span><br><span class="line">        └→ 后台线程发送</span><br><span class="line">            └→ Broker 返回错误</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">            <span class="built_in">rd_kafka_handle_produce_err</span>()</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">            错误类型判断</span><br><span class="line">                │</span><br><span class="line">    ┌───────────┴───────────────┐</span><br><span class="line">    │                           │</span><br><span class="line">    ▼ 可重试错误                ▼ 不可重试错误</span><br><span class="line">检查 retries_remaining         直接触发 <span class="function">delivery <span class="title">report</span> <span class="params">(失败)</span></span></span><br><span class="line"><span class="function">    │</span></span><br><span class="line"><span class="function">    ├→ &gt; 0: retries_remaining--</span></span><br><span class="line"><span class="function">    │       等待 retry.backoff.ms</span></span><br><span class="line"><span class="function">    │       重新发送</span></span><br><span class="line"><span class="function">    │</span></span><br><span class="line"><span class="function">    └→ =</span> <span class="number">0</span>: 触发 <span class="function">delivery <span class="title">report</span> <span class="params">(失败)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>可重试 vs 不可重试错误</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────┬─────────────────────────────────────┐</span><br><span class="line">│           ✅ 可重试错误              │           ❌ 不可重试错误            │</span><br><span class="line">├─────────────────────────────────────┼─────────────────────────────────────┤</span><br><span class="line">│ • REQUEST_TIMED_OUT                 │ • MSG_SIZE_TOO_LARGE                │</span><br><span class="line">│ • NOT_LEADER_FOR_PARTITION          │ • TOPIC_AUTHORIZATION_FAILED        │</span><br><span class="line">│ • LEADER_NOT_AVAILABLE              │ • CLUSTER_AUTHORIZATION_FAILED      │</span><br><span class="line">│ • NOT_ENOUGH_REPLICAS               │ • UNSUPPORTED_FOR_MESSAGE_FORMAT    │</span><br><span class="line">│ • NOT_ENOUGH_REPLICAS_AFTER_APPEND  │ • INVALID_REQUIRED_ACKS             │</span><br><span class="line">│ • NETWORK_EXCEPTION                 │ • UNKNOWN_TOPIC_OR_PARTITION        │</span><br><span class="line">│ • BROKER_NOT_AVAILABLE              │   (且 allow.auto.create.<span class="attribute">topics</span>=<span class="literal">false</span>)│</span><br><span class="line">└─────────────────────────────────────┴─────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h5 id="2）retry-backoff-ms-retry-backoff-max-ms"><a href="#2）retry-backoff-ms-retry-backoff-max-ms" class="headerlink" title="2）retry.backoff.ms &#x2F; retry.backoff.max.ms"></a>2）retry.backoff.ms &#x2F; retry.backoff.max.ms</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retry.backoff.ms&quot;</span>, <span class="string">&quot;200&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retry.backoff.max.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: 发送失败后自动计算退避时间</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 失败后自动触发退避重试，无需用户调用</span></span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路（指数退避算法）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">发送失败（可重试错误）</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">计算退避时间 = <span class="built_in">min</span>(retry.backoff.ms * <span class="number">2</span>^(N<span class="number">-1</span>), retry.backoff.max.ms)</span><br><span class="line">    │</span><br><span class="line">    │   N=<span class="number">1</span>: <span class="built_in">min</span>(<span class="number">200</span> * <span class="number">1</span>, <span class="number">1000</span>) = <span class="number">200</span>ms</span><br><span class="line">    │   N=<span class="number">2</span>: <span class="built_in">min</span>(<span class="number">200</span> * <span class="number">2</span>, <span class="number">1000</span>) = <span class="number">400</span>ms</span><br><span class="line">    │   N=<span class="number">3</span>: <span class="built_in">min</span>(<span class="number">200</span> * <span class="number">4</span>, <span class="number">1000</span>) = <span class="number">800</span>ms</span><br><span class="line">    │   N=<span class="number">4</span>: <span class="built_in">min</span>(<span class="number">200</span> * <span class="number">8</span>, <span class="number">1000</span>) = <span class="number">1000</span>ms  ← 达到上限</span><br><span class="line">    │   N=<span class="number">5</span>: <span class="built_in">min</span>(<span class="number">200</span> * <span class="number">16</span>, <span class="number">1000</span>) = <span class="number">1000</span>ms ← 保持上限</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">等待退避时间</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">重新发送</span><br></pre></td></tr></table></figure>

<p><strong>退避时间示意图</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">retry.backoff.ms = <span class="number">200</span>, retry.backoff.max.ms = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">时间线:</span><br><span class="line"><span class="number">0</span>      <span class="number">200</span>ms    <span class="number">600</span>ms   <span class="number">1400</span>ms   <span class="number">2400</span>ms   <span class="number">3400</span>ms</span><br><span class="line">│       │        │        │        │        │</span><br><span class="line">▼       ▼        ▼        ▼        ▼        ▼</span><br><span class="line">发送   重试<span class="number">1</span>    重试<span class="number">2</span>    重试<span class="number">3</span>    重试<span class="number">4</span>    重试<span class="number">5</span></span><br><span class="line">失败    │        │        │        │        │</span><br><span class="line">│       │        │        │        │        │</span><br><span class="line">└──<span class="number">200</span>ms┘        │        │        │        │</span><br><span class="line">        └──<span class="number">400</span>ms─┘        │        │        │</span><br><span class="line">                 └──<span class="number">800</span>ms─┘        │        │</span><br><span class="line">                          └─<span class="number">1000</span>ms─┘        │</span><br><span class="line">                                   └─<span class="number">1000</span>ms─┘</span><br></pre></td></tr></table></figure>

<h4 id="超时配置"><a href="#超时配置" class="headerlink" title="&lt;3&gt;超时配置"></a>&lt;3&gt;超时配置</h4><h5 id="1）delivery-timeout-ms"><a href="#1）delivery-timeout-ms" class="headerlink" title="1）delivery.timeout.ms"></a>1）delivery.timeout.ms</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;delivery.timeout.ms&quot;</span>, <span class="string">&quot;60000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 开始计时</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 从此刻开始计时，包含排队、发送、重试全过程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// poll() 中检测超时或收到结果</span></span><br><span class="line">producer-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">produce</span>() 调用，记录 timestamp_enqueue</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">消息入队列等待发送</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">后台线程定期检查</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line"><span class="built_in">now</span>() - timestamp_enqueue &gt; delivery.timeout.ms ?</span><br><span class="line">    │</span><br><span class="line">    ├→ 否: 继续等待/发送/重试</span><br><span class="line">    │</span><br><span class="line">    └→ 是: 触发 <span class="function">delivery <span class="title">report</span> <span class="params">(ERR__MSG_TIMED_OUT)</span></span></span><br><span class="line"><span class="function">            消息从队列移除</span></span><br></pre></td></tr></table></figure>

<h5 id="2）request-timeout-ms"><a href="#2）request-timeout-ms" class="headerlink" title="2）request.timeout.ms"></a>2）request.timeout.ms</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;request.timeout.ms&quot;</span>, <span class="string">&quot;30000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: 后台线程发送单次请求时</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 后台线程发送 ProduceRequest 时开始计时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// poll() 中处理超时</span></span><br><span class="line">producer-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">后台线程发送 ProduceRequest</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">记录请求发送时间</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">等待 Broker 响应</span><br><span class="line">    │</span><br><span class="line">    ├→ 在 <span class="number">30</span>s 内收到响应: 处理响应</span><br><span class="line">    │</span><br><span class="line">    └→ 超过 <span class="number">30</span>s 未响应: </span><br><span class="line">            │</span><br><span class="line">            ▼</span><br><span class="line">        触发 REQUEST_TIMED_OUT</span><br><span class="line">            │</span><br><span class="line">            ▼</span><br><span class="line">        检查 retries &gt; <span class="number">0</span> ?</span><br><span class="line">            │</span><br><span class="line">            ├→ 是: 进入重试流程</span><br><span class="line">            │</span><br><span class="line">            └→ 否: <span class="function">delivery <span class="title">report</span> <span class="params">(失败)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3）message-timeout-ms"><a href="#3）message-timeout-ms" class="headerlink" title="3）message.timeout.ms"></a>3）message.timeout.ms</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;message.timeout.ms&quot;</span>, <span class="string">&quot;60000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: 消息在本地队列中等待时</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 消息入队后开始计时</span></span><br></pre></td></tr></table></figure>

<p><strong>与 delivery.timeout.ms 的区别</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    三种超时的作用范围                                    │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│  <span class="built_in">produce</span>() ─→ [本地队列等待] ─→ [发送] ─→ [等待确认] ─→ delivery report  │</span><br><span class="line">│     │              │              │           │              │          │</span><br><span class="line">│     │◄─────────────┼──────────────┼───────────┼──────────────┤          │</span><br><span class="line">│     │     message.timeout.<span class="built_in">ms</span> (消息存活时间)                   │          │</span><br><span class="line">│     │              │              │           │              │          │</span><br><span class="line">│     │◄─────────────┼──────────────┼───────────┼──────────────┤          │</span><br><span class="line">│     │        delivery.timeout.<span class="built_in">ms</span> (投递总超时，含重试)         │          │</span><br><span class="line">│     │              │              │           │              │          │</span><br><span class="line">│     │              │              │◄──────────┤              │          │</span><br><span class="line">│     │              │              │ request.  │              │          │</span><br><span class="line">│     │              │              │ timeout.ms│              │          │</span><br><span class="line">│     │              │              │ (单次请求)│              │          │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">建议: message.timeout.ms &gt;= delivery.timeout.ms</span><br><span class="line">      delivery.timeout.ms &gt;= request.timeout.ms</span><br></pre></td></tr></table></figure>

<h4 id="队列配置"><a href="#队列配置" class="headerlink" title="&lt;4&gt;队列配置"></a>&lt;4&gt;队列配置</h4><h5 id="1）queue-buffering-max-messages"><a href="#1）queue-buffering-max-messages" class="headerlink" title="1）queue.buffering.max.messages"></a>1）queue.buffering.max.messages</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;queue.buffering.max.messages&quot;</span>, <span class="string">&quot;500000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 入队前检查</span></span><br><span class="line">RdKafka::ErrorCode err = producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 入队前检查当前消息数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err == RdKafka::ERR__QUEUE_FULL) &#123;</span><br><span class="line">    <span class="comment">// 队列已满</span></span><br><span class="line">    producer-&gt;<span class="built_in">poll</span>(<span class="number">100</span>);  <span class="comment">// 等待释放空间</span></span><br><span class="line">    <span class="comment">// 重试 produce</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">producer-&gt;<span class="built_in">produce</span>(...)</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line"><span class="built_in">rd_kafka_produce</span>()</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line"><span class="built_in">rd_kafka_curr_msgs_cnt</span>() &gt;= queue.buffering.max.messages ?</span><br><span class="line">    │</span><br><span class="line">    ├→ 否: 消息入队成功</span><br><span class="line">    │       <span class="built_in">rd_kafka_curr_msgs_cnt</span>()++</span><br><span class="line">    │</span><br><span class="line">    └→ 是: 返回 ERR__QUEUE_FULL</span><br><span class="line">            消息不入队</span><br></pre></td></tr></table></figure>

<h5 id="2）queue-buffering-max-kbytes"><a href="#2）queue-buffering-max-kbytes" class="headerlink" title="2）queue.buffering.max.kbytes"></a>2）queue.buffering.max.kbytes</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;queue.buffering.max.kbytes&quot;</span>, <span class="string">&quot;524288&quot;</span>, errstr);  <span class="comment">// 512MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 入队前检查</span></span><br><span class="line">RdKafka::ErrorCode err = producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 入队前检查当前内存占用</span></span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">producer-&gt;<span class="built_in">produce</span>(payload, len, ...)</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line"><span class="built_in">rd_kafka_produce</span>()</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line"><span class="built_in">rd_kafka_curr_msgs_size</span>() + len &gt; queue.buffering.max.kbytes * <span class="number">1024</span> ?</span><br><span class="line">    │</span><br><span class="line">    ├→ 否: 消息入队成功</span><br><span class="line">    │       <span class="built_in">rd_kafka_curr_msgs_size</span>() += len</span><br><span class="line">    │</span><br><span class="line">    └→ 是: 返回 ERR__QUEUE_FULL</span><br></pre></td></tr></table></figure>

<p><strong>双重队列限制</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                   队列容量双重检查                               │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  <span class="built_in">produce</span>() 入队检查:                                            │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────┐    │</span><br><span class="line">│  │  条件<span class="number">1</span>: 消息数 &lt; queue.buffering.max.<span class="built_in">messages</span> (<span class="number">500000</span>)  │    │</span><br><span class="line">│  │                       AND                               │    │</span><br><span class="line">│  │  条件<span class="number">2</span>: 内存 &lt; queue.buffering.max.<span class="built_in">kbytes</span> (<span class="number">512</span>MB)       │    │</span><br><span class="line">│  └─────────────────────────────────────────────────────────┘    │</span><br><span class="line">│                          │                                      │</span><br><span class="line">│              ┌───────────┴───────────┐                          │</span><br><span class="line">│              │                       │                          │</span><br><span class="line">│              ▼ 均满足                ▼ 任一不满足                │</span><br><span class="line">│         入队成功                 返回 ERR__QUEUE_FULL           │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h4 id="批量配置"><a href="#批量配置" class="headerlink" title="&lt;5&gt;批量配置"></a>&lt;5&gt;批量配置</h4><h5 id="1）batch-num-messages"><a href="#1）batch-num-messages" class="headerlink" title="1）batch.num.messages"></a>1）batch.num.messages</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.num.messages&quot;</span>, <span class="string">&quot;10000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 后，后台线程检查批次消息数</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);  <span class="comment">// 多次调用</span></span><br><span class="line"><span class="comment">// ↑ 累计消息数达到 10000 时触发批量发送</span></span><br></pre></td></tr></table></figure>

<h5 id="2）batch-size"><a href="#2）batch-size" class="headerlink" title="2）batch.size"></a>2）batch.size</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.size&quot;</span>, <span class="string">&quot;1000000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 后，后台线程检查批次字节数</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);  <span class="comment">// 多次调用</span></span><br><span class="line"><span class="comment">// ↑ 累计字节数达到 1MB 时触发批量发送</span></span><br></pre></td></tr></table></figure>

<h5 id="3）queue-buffering-max-ms"><a href="#3）queue-buffering-max-ms" class="headerlink" title="3）queue.buffering.max.ms"></a>3）queue.buffering.max.ms</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;queue.buffering.max.ms&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 后，后台定时器检查</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"><span class="comment">// ↑ 首条消息入队后 5ms 内触发批量发送</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// poll() 驱动后台线程执行</span></span><br><span class="line">producer-&gt;<span class="built_in">poll</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>批量发送触发条件（三选一）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">produce</span>() → <span class="built_in">produce</span>() → <span class="built_in">produce</span>() → ...</span><br><span class="line">    │           │           │</span><br><span class="line">    ▼           ▼           ▼</span><br><span class="line">┌────────────────────────────────────────┐</span><br><span class="line">│          本地消息队列 (per partition)   │</span><br><span class="line">│  [msg1] [msg2] [msg3] [msg4] ...       │</span><br><span class="line">└────────────────────┬───────────────────┘</span><br><span class="line">                     │</span><br><span class="line">    ┌────────────────┼────────────────┬─────────────┐</span><br><span class="line">    │                │                │             │</span><br><span class="line">    ▼                ▼                ▼             ▼</span><br><span class="line"> 消息数&gt;=<span class="number">10000</span>    字节数&gt;=<span class="number">1</span>MB     时间&gt;=<span class="number">5</span>ms      <span class="built_in">flush</span>()调用</span><br><span class="line">    │                │                │             │</span><br><span class="line">    └────────────────┴────────────────┴─────────────┘</span><br><span class="line">                     │</span><br><span class="line">                     ▼ 任一条件满足</span><br><span class="line">            ┌────────────────────┐</span><br><span class="line">            │  rd_kafka_produce  │</span><br><span class="line">            │  _batch()          │</span><br><span class="line">            └─────────┬──────────┘</span><br><span class="line">                      │</span><br><span class="line">                      ▼</span><br><span class="line">            ┌────────────────────┐</span><br><span class="line">            │ 压缩 (如有配置)     │</span><br><span class="line">            └─────────┬──────────┘</span><br><span class="line">                      │</span><br><span class="line">                      ▼</span><br><span class="line">            ┌────────────────────┐</span><br><span class="line">            │ 发送到 Broker      │</span><br><span class="line">            └────────────────────┘</span><br></pre></td></tr></table></figure>

<p><strong>批量效果示意</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue.buffering.max.ms = <span class="number">5</span>ms</span><br><span class="line">batch.size = <span class="number">1</span>MB</span><br><span class="line">batch.num.messages = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">场景<span class="number">1</span>: 时间触发</span><br><span class="line"><span class="number">0</span>ms     <span class="number">1</span>ms     <span class="number">2</span>ms     <span class="number">3</span>ms     <span class="number">4</span>ms     <span class="number">5</span>ms</span><br><span class="line"> │       │       │       │       │       │</span><br><span class="line"> ▼       ▼       ▼       ▼       ▼       ▼</span><br><span class="line">[msg1] [msg2] [msg3]                  ──→ 触发发送（<span class="number">5</span>ms到期）</span><br><span class="line">                                           <span class="number">3</span>条消息组成批次</span><br><span class="line"></span><br><span class="line">场景<span class="number">2</span>: 消息数触发</span><br><span class="line"><span class="number">0</span>ms      ...     Xms</span><br><span class="line"> │               │</span><br><span class="line"> ▼               ▼</span><br><span class="line">[msg1]...[msg10000] ──→ 触发发送（达到<span class="number">10000</span>条）</span><br><span class="line">                        无需等待<span class="number">5</span>ms</span><br><span class="line"></span><br><span class="line">场景<span class="number">3</span>: 字节数触发</span><br><span class="line"><span class="number">0</span>ms          Xms</span><br><span class="line"> │            │</span><br><span class="line"> ▼            ▼</span><br><span class="line">[大消息<span class="number">1</span>][大消息<span class="number">2</span>] ──→ 触发发送（达到<span class="number">1</span>MB）</span><br><span class="line">                       <span class="number">2</span>条消息组成批次</span><br></pre></td></tr></table></figure>

<h4 id="压缩配置"><a href="#压缩配置" class="headerlink" title="&lt;6&gt;压缩配置"></a>&lt;6&gt;压缩配置</h4><h5 id="1）compression-codec"><a href="#1）compression-codec" class="headerlink" title="1）compression.codec"></a>1）compression.codec</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;compression.codec&quot;</span>, <span class="string">&quot;lz4&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: 后台线程批量发送前压缩</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);  <span class="comment">// 消息入队（原始数据）</span></span><br><span class="line"><span class="comment">// ↑ 后台线程收集批次后触发压缩</span></span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">produce</span>() → 消息入队列（原始数据）</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    后台线程收集批次（满足发送条件）</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    <span class="built_in">rd_kafka_msgset_writer_write</span>()</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    <span class="built_in">rd_kafka_compress</span>(codec, level, batch_data)</span><br><span class="line">              │</span><br><span class="line">    ┌─────────┴─────────────────────────────────────┐</span><br><span class="line">    │           │           │           │           │</span><br><span class="line">    ▼ none      ▼ lz4       ▼ zstd      ▼ gzip      ▼ snappy</span><br><span class="line">  不压缩     LZ4压缩     ZSTD压缩    GZIP压缩   Snappy压缩</span><br><span class="line">    │           │           │           │           │</span><br><span class="line">    └─────────┬─────────────────────────────────────┘</span><br><span class="line">              │</span><br><span class="line">              ▼</span><br><span class="line">    发送压缩后的数据到 Broker</span><br></pre></td></tr></table></figure>

<p><strong>压缩算法对比</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌──────────┬─────────────┬─────────────┬─────────────┬──────────────┐</span><br><span class="line">│   算法   │   压缩比    │  压缩速度   │  解压速度   │   适用场景   │</span><br><span class="line">├──────────┼─────────────┼─────────────┼─────────────┼──────────────┤</span><br><span class="line">│   none   │     <span class="number">1</span>:<span class="number">1</span>     │     -       │     -       │ 极低延迟     │</span><br><span class="line">│   lz4    │    ~<span class="number">2.5</span>:<span class="number">1</span>   │    最快     │    最快     │ 生产首选     │</span><br><span class="line">│   zstd   │    ~<span class="number">3.5</span>:<span class="number">1</span>   │    较快     │    较快     │ 大消息/带宽敏感│</span><br><span class="line">│   gzip   │    ~<span class="number">3</span>:<span class="number">1</span>     │    较慢     │    较慢     │ 兼容旧系统   │</span><br><span class="line">│  snappy  │    ~<span class="number">2</span>:<span class="number">1</span>     │    快       │    快       │ 兼容旧系统   │</span><br><span class="line">└──────────┴─────────────┴─────────────┴─────────────┴──────────────┘</span><br></pre></td></tr></table></figure>

<h5 id="2）compression-level"><a href="#2）compression-level" class="headerlink" title="2）compression.level"></a>2）compression.level</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;compression.level&quot;</span>, <span class="string">&quot;-1&quot;</span>, errstr);  <span class="comment">// 使用算法默认级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: 与 compression.codec 同时生效</span></span><br><span class="line">producer-&gt;<span class="built_in">produce</span>(...);</span><br></pre></td></tr></table></figure>

<p><strong>各压缩算法级别范围</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌──────────┬─────────────┬─────────────┬─────────────────────────────┐</span><br><span class="line">│   算法   │  级别范围   │  默认级别   │           说明              │</span><br><span class="line">├──────────┼─────────────┼─────────────┼─────────────────────────────┤</span><br><span class="line">│   lz4    │   <span class="number">1</span> ~ <span class="number">12</span>    │     <span class="number">1</span>       │ 级别越高压缩比越好，速度越慢 │</span><br><span class="line">│   zstd   │   <span class="number">1</span> ~ <span class="number">22</span>    │     <span class="number">3</span>       │ 推荐 <span class="number">1</span>~<span class="number">5</span>，更高级别收益递减   │</span><br><span class="line">│   gzip   │   <span class="number">1</span> ~ <span class="number">9</span>     │     <span class="number">6</span>       │ <span class="number">9</span>=最佳压缩，<span class="number">1</span>=最快          │</span><br><span class="line">│  snappy  │     -       │     -       │ 无可调级别                  │</span><br><span class="line">└──────────┴─────────────┴─────────────┴─────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">-1</span> = 使用算法默认级别（推荐）</span><br></pre></td></tr></table></figure>

<h4 id="消息配置"><a href="#消息配置" class="headerlink" title="&lt;7&gt;消息配置"></a>&lt;7&gt;消息配置</h4><h5 id="1）message-max-bytes"><a href="#1）message-max-bytes" class="headerlink" title="1）message.max.bytes"></a>1）message.max.bytes</h5><p><strong>触发函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置阶段</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;message.max.bytes&quot;</span>, <span class="string">&quot;1000000&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发阶段: produce() 入队前检查消息大小</span></span><br><span class="line">RdKafka::ErrorCode err = producer-&gt;<span class="built_in">produce</span>(</span><br><span class="line">    topic, partition, flags,</span><br><span class="line">    payload, len,  <span class="comment">// ← len 在此处被检查</span></span><br><span class="line">    key, key_len,</span><br><span class="line">    timestamp, headers, opaque</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息过大时立即返回错误</span></span><br><span class="line"><span class="keyword">if</span> (err == RdKafka::ERR_MSG_SIZE_TOO_LARGE) &#123;</span><br><span class="line">    <span class="comment">// 消息超过 1MB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部触发链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">producer-&gt;<span class="built_in">produce</span>(payload, len, ...)</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line"><span class="built_in">rd_kafka_produce</span>()</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">len &gt; message.max.bytes ?</span><br><span class="line">    │</span><br><span class="line">    ├→ 否: 继续处理，消息入队</span><br><span class="line">    │</span><br><span class="line">    └→ 是: 立即返回 ERR_MSG_SIZE_TOO_LARGE</span><br><span class="line">            消息不入队</span><br><span class="line">            不触发 delivery report</span><br><span class="line">            不计入 retries</span><br></pre></td></tr></table></figure>

<p><strong>与 Broker 端配置的关系</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    消息大小配置链路                                      │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│  Producer                    Broker                     Consumer        │</span><br><span class="line">│      │                         │                            │           │</span><br><span class="line">│  message.max.bytes         message.max.bytes           fetch.max.bytes  │</span><br><span class="line">│  (客户端配置)              (server.properties)          (客户端配置)    │</span><br><span class="line">│      │                         │                            │           │</span><br><span class="line">│      └─────────────────────────┴────────────────────────────┘           │</span><br><span class="line">│                                │                                        │</span><br><span class="line">│                    三者需保持一致或:                                     │</span><br><span class="line">│                    Broker &gt;= Producer                                   │</span><br><span class="line">│                    Consumer &gt;= Broker                                   │</span><br><span class="line">│                                                                         │</span><br><span class="line">│  否则可能出现:                                                          │</span><br><span class="line">│  • Producer 发送成功但 Broker 拒绝                                      │</span><br><span class="line">│  • Broker 存储成功但 Consumer 无法消费                                  │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h4 id="生产环境配置建议"><a href="#生产环境配置建议" class="headerlink" title="&lt;8&gt;生产环境配置建议"></a>&lt;8&gt;生产环境配置建议</h4><h5 id="1）核心业务（金融-交易）"><a href="#1）核心业务（金融-交易）" class="headerlink" title="1）核心业务（金融&#x2F;交易）"></a>1）核心业务（金融&#x2F;交易）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最高可靠性，允许牺牲部分性能</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.idempotence&quot;</span>, <span class="string">&quot;true&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;max.in.flight.requests.per.connection&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retry.backoff.ms&quot;</span>, <span class="string">&quot;200&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;delivery.timeout.ms&quot;</span>, <span class="string">&quot;60000&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;compression.codec&quot;</span>, <span class="string">&quot;lz4&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.size&quot;</span>, <span class="string">&quot;32768&quot;</span>, errstr);         <span class="comment">// 32KB，降低延迟</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;queue.buffering.max.ms&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2）日志采集（高吞吐）"><a href="#2）日志采集（高吞吐）" class="headerlink" title="2）日志采集（高吞吐）"></a>2）日志采集（高吞吐）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高吞吐，可接受少量丢失</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>, errstr);                    <span class="comment">// 仅 Leader 确认</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.idempotence&quot;</span>, <span class="string">&quot;false&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;3&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;compression.codec&quot;</span>, <span class="string">&quot;zstd&quot;</span>, errstr);   <span class="comment">// 最高压缩比</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.size&quot;</span>, <span class="string">&quot;1048576&quot;</span>, errstr);       <span class="comment">// 1MB 大批次</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.num.messages&quot;</span>, <span class="string">&quot;50000&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;queue.buffering.max.ms&quot;</span>, <span class="string">&quot;50&quot;</span>, errstr);<span class="comment">// 等待更多消息</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;queue.buffering.max.messages&quot;</span>, <span class="string">&quot;1000000&quot;</span>, errstr);</span><br></pre></td></tr></table></figure>

<h5 id="3）监控指标（低延迟）"><a href="#3）监控指标（低延迟）" class="headerlink" title="3）监控指标（低延迟）"></a>3）监控指标（低延迟）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最低延迟，实时性优先</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.idempotence&quot;</span>, <span class="string">&quot;false&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;0&quot;</span>, errstr);                <span class="comment">// 不重试</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;compression.codec&quot;</span>, <span class="string">&quot;none&quot;</span>, errstr);   <span class="comment">// 不压缩</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.size&quot;</span>, <span class="string">&quot;16384&quot;</span>, errstr);         <span class="comment">// 16KB 小批次</span></span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.num.messages&quot;</span>, <span class="string">&quot;100&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;queue.buffering.max.ms&quot;</span>, <span class="string">&quot;0&quot;</span>, errstr); <span class="comment">// 立即发送</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>gtest的使用</title>
    <url>/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/gtest%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1.常用命令"></a>1.常用命令</h1><h5 id="1-在命令行指定运行要运行的测试用例"><a href="#1-在命令行指定运行要运行的测试用例" class="headerlink" title="1.在命令行指定运行要运行的测试用例"></a>1.在命令行指定运行要运行的测试用例</h5><ul>
<li>通过 –gtest_filter 参数指定要运行的测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/tests/config_test --gtest_filter=<span class="string">&quot;测试套件名.测试用例名&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例1：运行单个测试用例</span></span><br><span class="line"><span class="comment"># 运行 ConfigTest 套件中的 InvalidYamlFormat 测试</span></span><br><span class="line">./bin/tests/config_test --gtest_filter=ConfigTest.InvalidYamlFormat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例2：运行多个测试用例（使用冒号分隔）</span></span><br><span class="line"><span class="comment"># 运行多个指定的测试</span></span><br><span class="line">./bin/tests/config_test --gtest_filter=ConfigTest.InvalidYamlFormat:ConfigTest.ValidConfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例3：运行整个测试套件</span></span><br><span class="line"><span class="comment"># 运行 ConfigTest 套件中的所有测试</span></span><br><span class="line">./bin/tests/config_test --gtest_filter=ConfigTest.*</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>gtest</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>json的使用</title>
    <url>/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/json%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、json库"><a href="#一、json库" class="headerlink" title="一、json库"></a>一、json库</h1><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115222201657.png"></p>
<h1 id="二、nlohmann-json"><a href="#二、nlohmann-json" class="headerlink" title="二、nlohmann&#x2F;json"></a>二、nlohmann&#x2F;json</h1><p><strong>注意</strong>：<br>	- 所有操作需引入头文件 #include &lt;nlohmann&#x2F;json.hpp&gt;，并使用命名空间 using json &#x3D; nlohmann::json;</p>
<h2 id="1-json支持的C-数据类型（直接转换）"><a href="#1-json支持的C-数据类型（直接转换）" class="headerlink" title="1.json支持的C++数据类型（直接转换）"></a>1.json支持的C++数据类型（直接转换）</h2><h3 id="（1）基本数据类型-支持列表"><a href="#（1）基本数据类型-支持列表" class="headerlink" title="（1）基本数据类型 支持列表"></a>（1）基本数据类型 支持列表</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115223125969.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ========== C++ → JSON ==========</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串</span></span><br><span class="line">    json j_str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    json j_str2 = std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 整数</span></span><br><span class="line">    json j_int = <span class="number">42</span>;</span><br><span class="line">    json j_long = <span class="number">9876543210LL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 浮点数</span></span><br><span class="line">    json j_float = <span class="number">3.14</span>;</span><br><span class="line">    json j_double = <span class="number">2.718281828</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 布尔</span></span><br><span class="line">    json <span class="type">j_bool_t</span> = <span class="literal">true</span>;</span><br><span class="line">    json j_bool_f = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空值</span></span><br><span class="line">    json j_null = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== JSON → C++ ==========</span></span><br><span class="line">    </span><br><span class="line">    std::string s = j_str.<span class="built_in">get</span>&lt;std::string&gt;();       <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line">    <span class="type">int</span> i = j_int.<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();                       <span class="comment">// 42</span></span><br><span class="line">    <span class="type">double</span> d = j_double.<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;();              <span class="comment">// 2.718281828</span></span><br><span class="line">    <span class="type">bool</span> b = <span class="type">j_bool_t</span>.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;();                  <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以用隐式转换</span></span><br><span class="line">    std::string s2 = j_str;</span><br><span class="line">    <span class="type">int</span> i2 = j_int;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 输出验证 ==========</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串: &quot;</span> &lt;&lt; j_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数:   &quot;</span> &lt;&lt; j_int &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浮点数: &quot;</span> &lt;&lt; j_double &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;布尔:   &quot;</span> &lt;&lt; <span class="type">j_bool_t</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;空值:   &quot;</span> &lt;&lt; j_null &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）STL容器-支持列表"><a href="#（2）STL容器-支持列表" class="headerlink" title="（2）STL容器 支持列表"></a>（2）STL容器 支持列表</h3><h4 id="1）序列容器-JSON-数组"><a href="#1）序列容器-JSON-数组" class="headerlink" title="1）序列容器 &lt;——&gt; JSON 数组"></a>1）序列容器 &lt;——&gt; JSON 数组</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115223530082.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ========== C++ STL 容器 → JSON 数组 ==========</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    json j_vec = vec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::list</span></span><br><span class="line">    std::list&lt;std::string&gt; lst = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">    json j_lst = lst;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::deque</span></span><br><span class="line">    std::deque&lt;<span class="type">double</span>&gt; deq = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line">    json j_deq = deq;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::array</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, 4&gt; arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    json j_arr = arr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::forward_list</span></span><br><span class="line">    std::forward_list&lt;<span class="type">bool</span>&gt; fwd = &#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    json j_fwd = fwd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== JSON 数组 → C++ STL 容器 ==========</span></span><br><span class="line">    </span><br><span class="line">    json j = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> vec2 = j.get&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">auto</span> lst2 = j.get&lt;std::list&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">auto</span> deq2 = j.get&lt;std::deque&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">auto</span> fwd2 = j.get&lt;std::forward_list&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">    <span class="comment">// std::array 需要大小匹配</span></span><br><span class="line">    <span class="keyword">auto</span> arr2 = j.get&lt;std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2）关联容器-JSON-对象-数组"><a href="#2）关联容器-JSON-对象-数组" class="headerlink" title="2）关联容器 &lt;——&gt; JSON 对象&#x2F;数组"></a>2）关联容器 &lt;——&gt; JSON 对象&#x2F;数组</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115223609650.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ==================== C++ → JSON ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// map&lt;string, T&gt; → JSON 对象 （Key 必须是 std::string）</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; str_map = &#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line">    json j_map = str_map;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unordered_map&lt;string, T&gt; → JSON 对象 （Key 必须是 std::string）</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">double</span>&gt; str_umap = &#123;&#123;<span class="string">&quot;pi&quot;</span>, <span class="number">3.14</span>&#125;, &#123;<span class="string">&quot;e&quot;</span>, <span class="number">2.71</span>&#125;&#125;;</span><br><span class="line">    json j_umap = str_umap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// map&lt;int, T&gt; → JSON 数组 [[k,v], ...]</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; int_map = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br><span class="line">    json j_int_map = int_map;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set&lt;T&gt; → JSON 数组</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    json j_set = s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unordered_set&lt;T&gt; → JSON 数组</span></span><br><span class="line">    std::unordered_set&lt;std::string&gt; us = &#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>&#125;;</span><br><span class="line">    json j_uset = us;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// multimap / multiset → JSON 数组</span></span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; ms = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    json j_mset = ms;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== JSON → C++ ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 对象 → map / unordered_map</span></span><br><span class="line">    json obj = <span class="string">R&quot;(&#123;&quot;x&quot;: 100, &quot;y&quot;: 200, &quot;z&quot;: 300&#125;)&quot;</span>_json;</span><br><span class="line">    <span class="keyword">auto</span> map_back = obj.get&lt;std::map&lt;std::string, <span class="type">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">auto</span> umap_back = obj.get&lt;std::unordered_map&lt;std::string, <span class="type">int</span>&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 数组 [[k,v],...] → map&lt;int, T&gt;</span></span><br><span class="line">    json arr_kv = <span class="string">R&quot;([[1, &quot;a&quot;], [2, &quot;b&quot;], [3, &quot;c&quot;]])&quot;</span>_json;</span><br><span class="line">    <span class="keyword">auto</span> int_map_back = arr_kv.get&lt;std::map&lt;<span class="type">int</span>, std::string&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 数组 → set / unordered_set</span></span><br><span class="line">    json arr = <span class="string">R&quot;([5, 3, 1, 4, 1, 5, 9])&quot;</span>_json;</span><br><span class="line">    <span class="keyword">auto</span> set_back = arr.get&lt;std::set&lt;<span class="type">int</span>&gt;&gt;();           <span class="comment">// 去重有序: &#123;1,3,4,5,9&#125;</span></span><br><span class="line">    <span class="keyword">auto</span> uset_back = arr.get&lt;std::unordered_set&lt;<span class="type">int</span>&gt;&gt;(); <span class="comment">// 去重无序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 数组 → multiset (保留重复)</span></span><br><span class="line">    <span class="keyword">auto</span> mset_back = arr.get&lt;std::multiset&lt;<span class="type">int</span>&gt;&gt;();     <span class="comment">// &#123;1,1,3,4,5,5,9&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）其他容器-类型"><a href="#3）其他容器-类型" class="headerlink" title="3）其他容器&#x2F;类型"></a>3）其他容器&#x2F;类型</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115223649449.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ==================== C++ → JSON ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::pair → JSON 数组 [key, value]</span></span><br><span class="line">    std::pair&lt;std::string, <span class="type">int</span>&gt; p = &#123;<span class="string">&quot;age&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    json j_pair = p;</span><br><span class="line">    </span><br><span class="line">    std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p2 = &#123;<span class="number">42</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line">    json j_pair2 = p2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::tuple → JSON 数组 [a, b, c, ...]</span></span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">bool</span>&gt; t = &#123;<span class="number">100</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    json j_tuple = t;</span><br><span class="line">    </span><br><span class="line">    std::tuple&lt;<span class="type">double</span>, <span class="type">double</span>, <span class="type">double</span>&gt; t2 = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line">    json j_tuple2 = t2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::optional → T 或 null</span></span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; opt_val = <span class="number">42</span>;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; opt_empty = std::<span class="literal">nullopt</span>;</span><br><span class="line">    std::optional&lt;std::string&gt; opt_str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    json j_opt_val = opt_val;      <span class="comment">// 42</span></span><br><span class="line">    json j_opt_empty = opt_empty;  <span class="comment">// null</span></span><br><span class="line">    json j_opt_str = opt_str;      <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== JSON → C++ ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 数组 → std::pair</span></span><br><span class="line">    json jp = <span class="string">R&quot;([&quot;name&quot;, 100])&quot;</span>_json;</span><br><span class="line">    <span class="keyword">auto</span> pair_back = jp.get&lt;std::pair&lt;std::string, <span class="type">int</span>&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 数组 → std::tuple</span></span><br><span class="line">    json jt = <span class="string">R&quot;([200, &quot;world&quot;, false, 9.99])&quot;</span>_json;</span><br><span class="line">    <span class="keyword">auto</span> tuple_back = jt.get&lt;std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">bool</span>, <span class="type">double</span>&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON → std::optional</span></span><br><span class="line">    json jv = <span class="number">999</span>;</span><br><span class="line">    json jn = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> opt_back = jv.get&lt;std::optional&lt;<span class="type">int</span>&gt;&gt;();       <span class="comment">// has_value() = true</span></span><br><span class="line">    <span class="keyword">auto</span> opt_null_back = jn.get&lt;std::optional&lt;<span class="type">int</span>&gt;&gt;(); <span class="comment">// has_value() = false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-复杂类型与json的转换"><a href="#2-复杂类型与json的转换" class="headerlink" title="2.复杂类型与json的转换"></a>2.复杂类型与json的转换</h2><p><strong>json与不少复杂类型都无法直接进行转换，这里主要列举了最常用到了几个复杂类型</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115230954500.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">//1.枚举类型</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">//方法一：使用宏（推荐，最简洁）</span></span><br><span class="line"><span class="comment">// 定义枚举</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">    Unknown</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义枚举与字符串的映射</span></span><br><span class="line"><span class="built_in">NLOHMANN_JSON_SERIALIZE_ENUM</span>(Color, &#123;</span><br><span class="line">    &#123;Color::Unknown, <span class="literal">nullptr</span>&#125;,   <span class="comment">// 默认值（可选）</span></span><br><span class="line">    &#123;Color::Red, <span class="string">&quot;red&quot;</span>&#125;,</span><br><span class="line">    &#123;Color::Green, <span class="string">&quot;green&quot;</span>&#125;,</span><br><span class="line">    &#123;Color::Blue, <span class="string">&quot;blue&quot;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：手动实现 to_json / from_json</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    Pending,</span><br><span class="line">    Active,</span><br><span class="line">    Completed,</span><br><span class="line">    Failed</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举 → JSON（转为字符串）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Status&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">        <span class="keyword">case</span> Status::Pending:   j = <span class="string">&quot;pending&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Status::Active:    j = <span class="string">&quot;active&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Status::Completed: j = <span class="string">&quot;completed&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Status::Failed:    j = <span class="string">&quot;failed&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:                j = <span class="string">&quot;unknown&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON → 枚举</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Status&amp; s)</span> </span>&#123;</span><br><span class="line">    std::string str = j.<span class="built_in">get</span>&lt;std::string&gt;();</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;pending&quot;</span>)        s = Status::Pending;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">&quot;active&quot;</span>)    s = Status::Active;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">&quot;completed&quot;</span>) s = Status::Completed;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">&quot;failed&quot;</span>)    s = Status::Failed;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unknown status: &quot;</span> + str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 1. 自定义 struct</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 方法一：使用宏（推荐，最简洁）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</span>(Person, name, age, salary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：手动实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    std::string id;</span><br><span class="line">    std::string department;</span><br><span class="line">    <span class="type">bool</span> active;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Employee&amp; e)</span> </span>&#123;</span><br><span class="line">    j[<span class="string">&quot;id&quot;</span>] = e.id;</span><br><span class="line">    j[<span class="string">&quot;department&quot;</span>] = e.department;</span><br><span class="line">    j[<span class="string">&quot;is_active&quot;</span>] = e.active;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Employee&amp; e)</span> </span>&#123;</span><br><span class="line">    e.id = j[<span class="string">&quot;id&quot;</span>];                    </span><br><span class="line">    e.department = j[<span class="string">&quot;department&quot;</span>];   </span><br><span class="line">    e.active = j[<span class="string">&quot;is_active&quot;</span>];        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：在结构体中使用枚举</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Role</span> &#123; Admin, User, Guest &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NLOHMANN_JSON_SERIALIZE_ENUM</span>(Role, &#123;</span><br><span class="line">    &#123;Role::Admin, <span class="string">&quot;admin&quot;</span>&#125;,</span><br><span class="line">    &#123;Role::User, <span class="string">&quot;user&quot;</span>&#125;,</span><br><span class="line">    &#123;Role::Guest, <span class="string">&quot;guest&quot;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    std::string username;</span><br><span class="line">    Role role;              <span class="comment">// 枚举成员</span></span><br><span class="line">    <span class="type">bool</span> active;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</span>(Account, username, role, active)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 2. 自定义 class（私有成员）</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：使用侵入式宏（INTRUSIVE）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string sku;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    <span class="type">int</span> stock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侵入式宏：可访问私有成员</span></span><br><span class="line">    <span class="built_in">NLOHMANN_DEFINE_TYPE_INTRUSIVE</span>(Product, sku, name, price, stock)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：使用友元函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string account_number;</span><br><span class="line">    std::string holder_name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">    <span class="type">bool</span> is_active;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BankAccount</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> BankAccount&amp; acc)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, BankAccount&amp; acc)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> BankAccount&amp; acc)</span> </span>&#123;</span><br><span class="line">    j[<span class="string">&quot;account_number&quot;</span>] = acc.account_number;</span><br><span class="line">    j[<span class="string">&quot;holder_name&quot;</span>] = acc.holder_name;</span><br><span class="line">    j[<span class="string">&quot;balance&quot;</span>] = acc.balance;</span><br><span class="line">    j[<span class="string">&quot;is_active&quot;</span>] = acc.is_active;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, BankAccount&amp; acc)</span> </span>&#123;</span><br><span class="line">    acc.account_number = j[<span class="string">&quot;account_number&quot;</span>]; </span><br><span class="line">    acc.holder_name = j[<span class="string">&quot;holder_name&quot;</span>];      </span><br><span class="line">    acc.balance = j[<span class="string">&quot;balance&quot;</span>];              </span><br><span class="line">    acc.is_active = j[<span class="string">&quot;is_active&quot;</span>];        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：通过 Getter/Setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    std::string color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>() : <span class="built_in">width</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">0</span>), <span class="built_in">color</span>(<span class="string">&quot;white&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> width; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> height; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getColor</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">double</span> w)</span> </span>&#123; width = w; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> h)</span> </span>&#123; height = h; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> std::string&amp; c)</span> </span>&#123; color = c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Getter/Setter 实现（类外部）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Rectangle&amp; r)</span> </span>&#123;</span><br><span class="line">    j[<span class="string">&quot;width&quot;</span>] = r.<span class="built_in">getWidth</span>();</span><br><span class="line">    j[<span class="string">&quot;height&quot;</span>] = r.<span class="built_in">getHeight</span>();</span><br><span class="line">    j[<span class="string">&quot;color&quot;</span>] = r.<span class="built_in">getColor</span>();</span><br><span class="line">    j[<span class="string">&quot;area&quot;</span>] = r.<span class="built_in">getArea</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Rectangle&amp; r)</span> </span>&#123;</span><br><span class="line">    r.<span class="built_in">setWidth</span>(j[<span class="string">&quot;width&quot;</span>]); </span><br><span class="line">    r.<span class="built_in">setHeight</span>(j[<span class="string">&quot;height&quot;</span>]); </span><br><span class="line">    r.<span class="built_in">setColor</span>(j[<span class="string">&quot;color&quot;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四：包含嵌套对象的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> order_id;</span><br><span class="line">    Person customer;     			<span class="comment">// 嵌套 struct</span></span><br><span class="line">    std::vector&lt;Product&gt; items;        <span class="comment">// 嵌套 class 数组</span></span><br><span class="line">    <span class="type">double</span> total_amount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Order</span>() : <span class="built_in">order_id</span>(<span class="number">0</span>), <span class="built_in">total_amount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*侵入式宏，前提：</span></span><br><span class="line"><span class="comment">        - 要么也使用 NLOHMANN_DEFINE_TYPE_INTRUSIVE 宏</span></span><br><span class="line"><span class="comment">        - 要么实现自定义的 to_json/from_json 函数</span></span><br><span class="line"><span class="comment">        - 要么使用其他 nlohmann json 支持的序列化方式*/</span></span><br><span class="line">    <span class="built_in">NLOHMANN_DEFINE_TYPE_INTRUSIVE</span>(Order, order_id, customer, items, total_amount)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法五：带继承的类</span></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string type;</span><br><span class="line">    std::string color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Shape</span>(std::string t, std::string c) : <span class="built_in">type</span>(std::<span class="built_in">move</span>(t)), <span class="built_in">color</span>(std::<span class="built_in">move</span>(c)) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getType</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> type; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getColor</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Shape&amp; s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Shape&amp; s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Shape&amp; s)</span> </span>&#123;</span><br><span class="line">    j[<span class="string">&quot;type&quot;</span>] = s.type;</span><br><span class="line">    j[<span class="string">&quot;color&quot;</span>] = s.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Shape&amp; s)</span> </span>&#123;</span><br><span class="line">    s.type = j[<span class="string">&quot;type&quot;</span>];</span><br><span class="line">    s.color = j[<span class="string">&quot;color&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() : <span class="built_in">Shape</span>(<span class="string">&quot;circle&quot;</span>, <span class="string">&quot;white&quot;</span>), <span class="built_in">radius</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r, std::string c) : <span class="built_in">Shape</span>(<span class="string">&quot;circle&quot;</span>, std::<span class="built_in">move</span>(c)), <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Circle&amp; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Circle&amp; c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Circle&amp; c)</span> </span>&#123;</span><br><span class="line">    j[<span class="string">&quot;type&quot;</span>] = c.type;</span><br><span class="line">    j[<span class="string">&quot;color&quot;</span>] = c.color;</span><br><span class="line">    j[<span class="string">&quot;radius&quot;</span>] = c.radius;</span><br><span class="line">    j[<span class="string">&quot;area&quot;</span>] = c.<span class="built_in">getArea</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Circle&amp; c)</span> </span>&#123;</span><br><span class="line">    c.type = j[<span class="string">&quot;type&quot;</span>];</span><br><span class="line">    c.color = j[<span class="string">&quot;color&quot;</span>];</span><br><span class="line">    c.radius = j[<span class="string">&quot;radius&quot;</span>]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 3. 裸指针 T*</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> T* ptr)</span> </span>&#123;</span><br><span class="line">    j = ptr ? <span class="built_in">json</span>(*ptr) : <span class="built_in">json</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, T*&amp; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (j.<span class="built_in">is_null</span>()) &#123;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">T</span>(j.<span class="built_in">get</span>&lt;T&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 4. std::shared_ptr&lt;T&gt;</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> std::shared_ptr&lt;T&gt;&amp; ptr)</span> </span>&#123;</span><br><span class="line">    j = ptr ? <span class="built_in">json</span>(*ptr) : <span class="built_in">json</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, std::shared_ptr&lt;T&gt;&amp; ptr)</span> </span>&#123;</span><br><span class="line">    ptr = j.<span class="built_in">is_null</span>() ? <span class="literal">nullptr</span> : std::<span class="built_in">make_shared</span>&lt;T&gt;(j.<span class="built_in">get</span>&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 5. std::unique_ptr&lt;T&gt;</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> std::unique_ptr&lt;T&gt;&amp; ptr)</span> </span>&#123;</span><br><span class="line">    j = ptr ? <span class="built_in">json</span>(*ptr) : <span class="built_in">json</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, std::unique_ptr&lt;T&gt;&amp; ptr)</span> </span>&#123;</span><br><span class="line">    ptr = j.<span class="built_in">is_null</span>() ? <span class="literal">nullptr</span> : std::<span class="built_in">make_unique</span>&lt;T&gt;(j.<span class="built_in">get</span>&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 6. std::variant&lt;...&gt;</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="keyword">using</span> MyVariant = std::variant&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> MyVariant&amp; v)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">visit</span>([&amp;j, &amp;v](<span class="keyword">auto</span>&amp;&amp; val) &#123;</span><br><span class="line">        j[<span class="string">&quot;type_index&quot;</span>] = v.<span class="built_in">index</span>();</span><br><span class="line">        j[<span class="string">&quot;value&quot;</span>] = val;</span><br><span class="line">    &#125;, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, MyVariant&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> idx = j[<span class="string">&quot;type_index&quot;</span>];  <span class="comment">// 直接赋值</span></span><br><span class="line">    <span class="keyword">switch</span> (idx) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: v = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(j[<span class="string">&quot;value&quot;</span>]); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: v = <span class="built_in">static_cast</span>&lt;std::string&gt;(j[<span class="string">&quot;value&quot;</span>]); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: v = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j[<span class="string">&quot;value&quot;</span>]); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unknown variant type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 7. std::chrono::* 时间类型</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="keyword">using</span> TimePoint = std::chrono::system_clock::time_point;</span><br><span class="line"><span class="keyword">using</span> Duration = std::chrono::milliseconds;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> TimePoint&amp; tp)</span> </span>&#123;</span><br><span class="line">    j = std::chrono::<span class="built_in">duration_cast</span>&lt;Duration&gt;(tp.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, TimePoint&amp; tp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> ms = j;  <span class="comment">// 直接赋值</span></span><br><span class="line">    tp = <span class="built_in">TimePoint</span>(<span class="built_in">Duration</span>(ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Duration&amp; d)</span> </span>&#123;</span><br><span class="line">    j = d.<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Duration&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> ms = j;  <span class="comment">// 直接赋值</span></span><br><span class="line">    d = <span class="built_in">Duration</span>(ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 8. std::stack&lt;T&gt; / std::queue&lt;T&gt;</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, std::stack&lt;T&gt; s)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;T&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    j = vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, std::stack&lt;T&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : j) &#123;</span><br><span class="line">        T val = item;</span><br><span class="line">        s.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, std::queue&lt;T&gt; q)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;T&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    j = vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, std::queue&lt;T&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : j) &#123;</span><br><span class="line">        T val = item;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-从文件读取-写入-JSON"><a href="#3-从文件读取-写入-JSON" class="headerlink" title="3.从文件读取&#x2F;写入 JSON"></a>3.从文件读取&#x2F;写入 JSON</h2><p>json重载了“&lt;&lt;”、“&gt;&gt;”运算符，所以可以直接从json读取&#x2F;写入json</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入 JSON 到文件</span></span><br><span class="line">json js = &#123;&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;赵六&quot;</span>&#125;, &#123;<span class="string">&quot;age&quot;</span>, <span class="number">35</span>&#125;&#125;;</span><br><span class="line"><span class="function">std::ofstream <span class="title">file_out</span><span class="params">(<span class="string">&quot;data.json&quot;</span>)</span></span>;</span><br><span class="line">file_out &lt;&lt; js.<span class="built_in">dump</span>(<span class="number">4</span>); <span class="comment">// 格式化写入</span></span><br><span class="line">file_out.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件读取 JSON</span></span><br><span class="line"><span class="function">std::ifstream <span class="title">file_in</span><span class="params">(<span class="string">&quot;data.json&quot;</span>)</span></span>;</span><br><span class="line">json js_read;</span><br><span class="line">file_in &gt;&gt; js_read;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;从文件读取：&quot;</span> &lt;&lt; js_read[<span class="string">&quot;name&quot;</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-json的核心函数"><a href="#4-json的核心函数" class="headerlink" title="4.json的核心函数"></a>4.json的核心函数</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115225628592.png"></p>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>异常处理</strong>：<ul>
<li>json::parse()、at() 等操作可能抛异常（如格式错误、键不存在），<strong>必须用 try-catch 捕获，避免程序崩溃</strong>。</li>
</ul>
</li>
<li><strong>类型匹配</strong>：<ul>
<li>读取值时要确保类型一致（如 JSON 是数字，不能直接转字符串），否则<strong>会抛 type_error</strong></li>
</ul>
</li>
<li><strong>性能考量</strong>：<ul>
<li>nlohmann&#x2F;json 易用但性能略低于 RapidJSON，若需极致性能（如高频解析&#x2F;生成），可替换为 RapidJSON。</li>
</ul>
</li>
<li><strong>编码问题</strong>：<ul>
<li>默认支持 UTF-8，若处理 GBK 等编码，需先转换为 UTF-8 再解析。</li>
</ul>
</li>
</ul>
<h2 id="5-序列化与反序列化"><a href="#5-序列化与反序列化" class="headerlink" title="5.序列化与反序列化"></a>5.序列化与反序列化</h2><ul>
<li><strong>序列化</strong>：<ul>
<li>C++类型先转为json，json在调用dump函数进行序列化，返回string</li>
</ul>
</li>
<li><strong>反序列化</strong>：<ul>
<li>对于json序列化后的string，通过parse进行反序列化，得到C++类型</li>
</ul>
</li>
</ul>
<h3 id="（1）class的序列化与反序列化"><a href="#（1）class的序列化与反序列化" class="headerlink" title="（1）class的序列化与反序列化"></a>（1）class的序列化与反序列化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用侵入式宏的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string username;</span><br><span class="line">    std::string email;</span><br><span class="line">    std::vector&lt;std::string&gt; roles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>() : <span class="built_in">id</span>(<span class="number">0</span>) &#123;&#125;  <span class="comment">// 默认构造函数必须存在</span></span><br><span class="line">    <span class="built_in">User</span>(<span class="type">int</span> id, std::string username, std::string email)</span><br><span class="line">        : <span class="built_in">id</span>(id), <span class="built_in">username</span>(username), <span class="built_in">email</span>(email) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addRole</span><span class="params">(<span class="type">const</span> std::string&amp; role)</span> </span>&#123; roles.<span class="built_in">push_back</span>(role); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter（用于验证反序列化结果）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getUsername</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> username; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::vector&lt;std::string&gt;&amp; <span class="title">getRoles</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> roles; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用宏简化序列化/反序列化定义</span></span><br><span class="line">    <span class="built_in">NLOHMANN_DEFINE_TYPE_INTRUSIVE</span>(User, id, username, email, roles)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="function">User <span class="title">user</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;johndoe&quot;</span>, <span class="string">&quot;john@example.com&quot;</span>)</span></span>;</span><br><span class="line">    user.<span class="built_in">addRole</span>(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    user.<span class="built_in">addRole</span>(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    json j = user;</span><br><span class="line">    std::string serialized = j.<span class="built_in">dump</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    User restoredUser = json::<span class="built_in">parse</span>(serialized);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）struct的序列化与反序列化"><a href="#（2）struct的序列化与反序列化" class="headerlink" title="（2）struct的序列化与反序列化"></a>（2）struct的序列化与反序列化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">bool</span> active;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非侵入式序列化 - 在结构体外部定义转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">    j = json&#123;&#123;<span class="string">&quot;name&quot;</span>, p.name&#125;, &#123;<span class="string">&quot;age&quot;</span>, p.age&#125;, &#123;<span class="string">&quot;active&quot;</span>, p.active&#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Person&amp; p)</span> </span>&#123;</span><br><span class="line">    p.name = j[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">    p.age = j[<span class="string">&quot;age&quot;</span>];</span><br><span class="line">    p.active = j[<span class="string">&quot;active&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    Person p1&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    json j = p1;</span><br><span class="line">    std::string serialized = j.<span class="built_in">dump</span>(<span class="number">4</span>);  <span class="comment">// 4是缩进空格数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;序列化结果:\n&quot;</span> &lt;&lt; serialized &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    json j2 = json::<span class="built_in">parse</span>(serialized);</span><br><span class="line">    <span class="built_in">from_json</span>(j2, p2);</span><br><span class="line">    <span class="comment">// 或简写为: p2 = j2.get&lt;Person&gt;();</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;反序列化后: &quot;</span> &lt;&lt; p<span class="number">2.</span>name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）文件读写示例（可用于“配置文件”）"><a href="#（3）文件读写示例（可用于“配置文件”）" class="headerlink" title="（3）文件读写示例（可用于“配置文件”）"></a>（3）文件读写示例（可用于“配置文件”）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    std::string host;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="type">bool</span> debug;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</span>(Config, host, port, debug)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ========== 写入文件 ==========</span></span><br><span class="line">    Config config&#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;config.json&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ofs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        json j = config;</span><br><span class="line">        ofs &lt;&lt; j.<span class="built_in">dump</span>(<span class="number">4</span>);  <span class="comment">// 4 空格缩进</span></span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;配置已保存到 config.json&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 从文件读取 ==========</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;config.json&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        json j = json::<span class="built_in">parse</span>(ifs);</span><br><span class="line">        Config loaded = j;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;读取配置: &quot;</span> &lt;&lt; loaded.host &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; loaded.port </span><br><span class="line">                  &lt;&lt; <span class="string">&quot; (debug=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; loaded.debug &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 异常处理 ==========</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">bad_file</span><span class="params">(<span class="string">&quot;not_exist.json&quot;</span>)</span></span>;</span><br><span class="line">        json j = json::<span class="built_in">parse</span>(bad_file);  <span class="comment">// 会抛异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> json::parse_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;解析错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="补充：指针类型序列化-信息损失问题"><a href="#补充：指针类型序列化-信息损失问题" class="headerlink" title="补充：指针类型序列化 信息损失问题"></a>补充：指针类型序列化 信息损失问题</h2><p>上面演示的指针的序列化与反序列化明显有很大问题，会造成信息的损失</p>
<ul>
<li><strong>指针的序列化</strong>：<ul>
<li>先转换为实体,然后进行序列化</li>
</ul>
</li>
<li><strong>指针的反序列化</strong>：<ul>
<li>先获取实体，再转为指针</li>
</ul>
</li>
<li>看个简单的例子：<ul>
<li>在植物大战僵尸中，需要实现存档功能，植物A持有僵尸B的指针，用来实现A攻击B，A、B在存档时都要进行序列化<ul>
<li>序列化前，A的指针执行B，序列化后进行存储；</li>
<li>但反序列化后，A的指针指向的是用B的数据新生成的对象，显然A已经不指向B了，A也就无法攻击到B了</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>解决方案</strong>：<br>个典型的解决方案是使用对象引用系统或对象ID映射:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于ID的对象引用系统</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;  <span class="comment">// 每个对象的唯一标识符</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> GameObject* <span class="title">findById</span><span class="params">(<span class="type">int</span> id)</span></span>; <span class="comment">// 全局查找对象的方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plant</span> : <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> zombieTargetId; <span class="comment">// 存储目标僵尸的ID而非指针</span></span><br><span class="line">    Zombie* zombieTarget; <span class="comment">// 运行时使用的指针</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(json&amp; j)</span> </span>&#123;</span><br><span class="line">        j[<span class="string">&quot;id&quot;</span>] = <span class="built_in">getId</span>();</span><br><span class="line">        j[<span class="string">&quot;zombieTargetId&quot;</span>] = zombieTarget ? zombieTarget-&gt;<span class="built_in">getId</span>() : <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 其他属性...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deserialize</span><span class="params">(<span class="type">const</span> json&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基本属性反序列化</span></span><br><span class="line">        zombieTargetId = j[<span class="string">&quot;zombieTargetId&quot;</span>];</span><br><span class="line">        <span class="comment">// 指针暂时不设置，等所有对象都加载完成后再解析引用关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析阶段二：重建对象引用关系</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resolveReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zombieTargetId != <span class="number">-1</span>) &#123;</span><br><span class="line">            zombieTarget = <span class="built_in">dynamic_cast</span>&lt;Zombie*&gt;(GameObject::<span class="built_in">findById</span>(zombieTargetId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 通用的对象管理器 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::shared_ptr&lt;T&gt;&gt; objects;</span><br><span class="line">    <span class="type">int</span> nextId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册对象，返回 ID</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">registerObject</span><span class="params">(std::shared_ptr&lt;T&gt; obj)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> id = nextId++;</span><br><span class="line">        objects[id] = obj;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 ID 查找对象</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">findById</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = objects.<span class="built_in">find</span>(id);</span><br><span class="line">        <span class="keyword">return</span> (it != objects.<span class="built_in">end</span>()) ? it-&gt;second : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取所有对象</span></span><br><span class="line">    <span class="type">const</span> std::map&lt;<span class="type">int</span>, std::shared_ptr&lt;T&gt;&gt;&amp; <span class="built_in">getAll</span>() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> objects;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        objects.<span class="built_in">clear</span>();</span><br><span class="line">        nextId = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 示例：植物大战僵尸 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zombie</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plant</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> health;</span><br><span class="line">    <span class="type">int</span> targetZombieId;  <span class="comment">// 存储目标 ID 而非指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行时指针（不序列化）</span></span><br><span class="line">    std::shared_ptr&lt;Zombie&gt; targetZombie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Plant</span>() : <span class="built_in">id</span>(<span class="number">0</span>), <span class="built_in">health</span>(<span class="number">100</span>), <span class="built_in">targetZombieId</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Plant</span>(<span class="type">int</span> id, std::string name, <span class="type">int</span> hp) </span><br><span class="line">        : <span class="built_in">id</span>(id), <span class="built_in">name</span>(std::<span class="built_in">move</span>(name)), <span class="built_in">health</span>(hp), <span class="built_in">targetZombieId</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; id = i; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTarget</span><span class="params">(<span class="type">int</span> zombieId)</span> </span>&#123; targetZombieId = zombieId; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTargetId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> targetZombieId; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTargetPtr</span><span class="params">(std::shared_ptr&lt;Zombie&gt; z)</span> </span>&#123; targetZombie = z; &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Zombie&gt; <span class="title">getTargetPtr</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> targetZombie; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Plant&amp; p)</span> </span>&#123;</span><br><span class="line">        j[<span class="string">&quot;id&quot;</span>] = p.id;</span><br><span class="line">        j[<span class="string">&quot;name&quot;</span>] = p.name;</span><br><span class="line">        j[<span class="string">&quot;health&quot;</span>] = p.health;</span><br><span class="line">        j[<span class="string">&quot;target_zombie_id&quot;</span>] = p.targetZombieId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Plant&amp; p)</span> </span>&#123;</span><br><span class="line">        p.id = j[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">        p.name = j[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">        p.health = j[<span class="string">&quot;health&quot;</span>];</span><br><span class="line">        p.targetZombieId = j[<span class="string">&quot;target_zombie_id&quot;</span>];</span><br><span class="line">        <span class="comment">// targetZombie 指针需要在解析阶段二设置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zombie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string type;</span><br><span class="line">    <span class="type">int</span> health;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Zombie</span>() : <span class="built_in">id</span>(<span class="number">0</span>), <span class="built_in">health</span>(<span class="number">200</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Zombie</span>(<span class="type">int</span> id, std::string type, <span class="type">int</span> hp) </span><br><span class="line">        : <span class="built_in">id</span>(id), <span class="built_in">type</span>(std::<span class="built_in">move</span>(type)), <span class="built_in">health</span>(hp) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; id = i; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getType</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> type; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">to_json</span><span class="params">(json&amp; j, <span class="type">const</span> Zombie&amp; z)</span> </span>&#123;</span><br><span class="line">        j[<span class="string">&quot;id&quot;</span>] = z.id;</span><br><span class="line">        j[<span class="string">&quot;type&quot;</span>] = z.type;</span><br><span class="line">        j[<span class="string">&quot;health&quot;</span>] = z.health;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j, Zombie&amp; z)</span> </span>&#123;</span><br><span class="line">        z.id = j[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">        z.type = j[<span class="string">&quot;type&quot;</span>];</span><br><span class="line">        z.health = j[<span class="string">&quot;health&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 游戏存档管理器 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameSaveManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ObjectManager&lt;Plant&gt; plantManager;</span><br><span class="line">    ObjectManager&lt;Zombie&gt; zombieManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加对象</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addPlant</span><span class="params">(std::shared_ptr&lt;Plant&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> id = plantManager.<span class="built_in">registerObject</span>(p);</span><br><span class="line">        p-&gt;<span class="built_in">setId</span>(id);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addZombie</span><span class="params">(std::shared_ptr&lt;Zombie&gt; z)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> id = zombieManager.<span class="built_in">registerObject</span>(z);</span><br><span class="line">        z-&gt;<span class="built_in">setId</span>(id);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置植物的攻击目标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPlantTarget</span><span class="params">(<span class="type">int</span> plantId, <span class="type">int</span> zombieId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> plant = plantManager.<span class="built_in">findById</span>(plantId);</span><br><span class="line">        <span class="keyword">auto</span> zombie = zombieManager.<span class="built_in">findById</span>(zombieId);</span><br><span class="line">        <span class="keyword">if</span> (plant &amp;&amp; zombie) &#123;</span><br><span class="line">            plant-&gt;<span class="built_in">setTarget</span>(zombieId);</span><br><span class="line">            plant-&gt;<span class="built_in">setTargetPtr</span>(zombie);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化整个游戏状态</span></span><br><span class="line">    <span class="function">json <span class="title">serialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        json j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 序列化所有僵尸</span></span><br><span class="line">        j[<span class="string">&quot;zombies&quot;</span>] = json::<span class="built_in">array</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [id, zombie] : zombieManager.<span class="built_in">getAll</span>()) &#123;</span><br><span class="line">            j[<span class="string">&quot;zombies&quot;</span>].<span class="built_in">push_back</span>(*zombie);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 序列化所有植物</span></span><br><span class="line">        j[<span class="string">&quot;plants&quot;</span>] = json::<span class="built_in">array</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [id, plant] : plantManager.<span class="built_in">getAll</span>()) &#123;</span><br><span class="line">            j[<span class="string">&quot;plants&quot;</span>].<span class="built_in">push_back</span>(*plant);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deserialize</span><span class="params">(<span class="type">const</span> json&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 清空现有数据</span></span><br><span class="line">        plantManager.<span class="built_in">clear</span>();</span><br><span class="line">        zombieManager.<span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阶段一：创建所有对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载僵尸</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; zj : j[<span class="string">&quot;zombies&quot;</span>]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> zombie = std::<span class="built_in">make_shared</span>&lt;Zombie&gt;(zj.<span class="built_in">get</span>&lt;Zombie&gt;());</span><br><span class="line">            zombieManager.<span class="built_in">registerObject</span>(zombie);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载植物</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pj : j[<span class="string">&quot;plants&quot;</span>]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> plant = std::<span class="built_in">make_shared</span>&lt;Plant&gt;(pj.<span class="built_in">get</span>&lt;Plant&gt;());</span><br><span class="line">            plantManager.<span class="built_in">registerObject</span>(plant);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阶段二：重建引用关系</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [id, plant] : plantManager.<span class="built_in">getAll</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> targetId = plant-&gt;<span class="built_in">getTargetId</span>();</span><br><span class="line">            <span class="keyword">if</span> (targetId != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> zombie = zombieManager.<span class="built_in">findById</span>(targetId);</span><br><span class="line">                plant-&gt;<span class="built_in">setTargetPtr</span>(zombie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;=== 游戏状态 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [id, plant] : plantManager.<span class="built_in">getAll</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;植物 [&quot;</span> &lt;&lt; plant-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;] (ID:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> target = plant-&gt;<span class="built_in">getTargetPtr</span>()) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot; → 攻击目标: &quot;</span> &lt;&lt; target-&gt;<span class="built_in">getType</span>() </span><br><span class="line">                          &lt;&lt; <span class="string">&quot; (ID:&quot;</span> &lt;&lt; target-&gt;<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [id, zombie] : zombieManager.<span class="built_in">getAll</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;僵尸 [&quot;</span> &lt;&lt; zombie-&gt;<span class="built_in">getType</span>() &lt;&lt; <span class="string">&quot;] (ID:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GameSaveManager game;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建游戏对象</span></span><br><span class="line">    <span class="keyword">auto</span> peashooter = std::<span class="built_in">make_shared</span>&lt;Plant&gt;(<span class="number">0</span>, <span class="string">&quot;豌豆射手&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">auto</span> sunflower = std::<span class="built_in">make_shared</span>&lt;Plant&gt;(<span class="number">0</span>, <span class="string">&quot;向日葵&quot;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="keyword">auto</span> zombie1 = std::<span class="built_in">make_shared</span>&lt;Zombie&gt;(<span class="number">0</span>, <span class="string">&quot;普通僵尸&quot;</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">auto</span> zombie2 = std::<span class="built_in">make_shared</span>&lt;Zombie&gt;(<span class="number">0</span>, <span class="string">&quot;路障僵尸&quot;</span>, <span class="number">300</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册到管理器</span></span><br><span class="line">    <span class="type">int</span> p1 = game.<span class="built_in">addPlant</span>(peashooter);</span><br><span class="line">    <span class="type">int</span> p2 = game.<span class="built_in">addPlant</span>(sunflower);</span><br><span class="line">    <span class="type">int</span> z1 = game.<span class="built_in">addZombie</span>(zombie1);</span><br><span class="line">    <span class="type">int</span> z2 = game.<span class="built_in">addZombie</span>(zombie2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置攻击关系</span></span><br><span class="line">    game.<span class="built_in">setPlantTarget</span>(p1, z1);  <span class="comment">// 豌豆射手攻击普通僵尸</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;========== 保存前 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    game.<span class="built_in">printStatus</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    json save = game.<span class="built_in">serialize</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== JSON 存档 ==========\n&quot;</span> &lt;&lt; save.<span class="built_in">dump</span>(<span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟游戏重启：创建新的管理器并加载存档</span></span><br><span class="line">    GameSaveManager newGame;</span><br><span class="line">    newGame.<span class="built_in">deserialize</span>(save);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== 加载后 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    newGame.<span class="built_in">printStatus</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">========== 保存前 ==========</span><br><span class="line">=== 游戏状态 ===</span><br><span class="line">植物 [豌豆射手] (ID:<span class="number">1</span>) → 攻击目标: 普通僵尸 (ID:<span class="number">1</span>)</span><br><span class="line">植物 [向日葵] (ID:<span class="number">2</span>)</span><br><span class="line">僵尸 [普通僵尸] (ID:<span class="number">1</span>)</span><br><span class="line">僵尸 [路障僵尸] (ID:<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">========== JSON 存档 ==========</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plants&quot;</span>: [</span><br><span class="line">    &#123;<span class="string">&quot;health&quot;</span>: <span class="number">100</span>, <span class="string">&quot;id&quot;</span>: <span class="number">1</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;豌豆射手&quot;</span>, <span class="string">&quot;target_zombie_id&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;health&quot;</span>: <span class="number">80</span>, <span class="string">&quot;id&quot;</span>: <span class="number">2</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;向日葵&quot;</span>, <span class="string">&quot;target_zombie_id&quot;</span>: <span class="number">-1</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;zombies&quot;</span>: [</span><br><span class="line">    &#123;<span class="string">&quot;health&quot;</span>: <span class="number">200</span>, <span class="string">&quot;id&quot;</span>: <span class="number">1</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;普通僵尸&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;health&quot;</span>: <span class="number">300</span>, <span class="string">&quot;id&quot;</span>: <span class="number">2</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;路障僵尸&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========== 加载后 ==========</span><br><span class="line">=== 游戏状态 ===</span><br><span class="line">植物 [豌豆射手] (ID:<span class="number">1</span>) → 攻击目标: 普通僵尸 (ID:<span class="number">1</span>)</span><br><span class="line">植物 [向日葵] (ID:<span class="number">2</span>)</span><br><span class="line">僵尸 [普通僵尸] (ID:<span class="number">1</span>)</span><br><span class="line">僵尸 [路障僵尸] (ID:<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="快速参考表"><a href="#快速参考表" class="headerlink" title="快速参考表"></a>快速参考表</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116000619101.png"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>json</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka使用教程</title>
    <url>/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、Kafka介绍"><a href="#一、Kafka介绍" class="headerlink" title="一、Kafka介绍"></a>一、Kafka介绍</h1><p>Kafka 是一款分布式、高吞吐量、高可靠性的<strong>分布式事件流平台</strong>（原定位为：<strong>分布式消息队列</strong>），基于<strong>发布&#x2F;订阅模式</strong>，主要用于处理实时数据管道、流处理、数据集成等场景，能够高效地收集、存储和分发大规模的实时数据流。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115205205304.png"></p>
<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h2><ul>
<li><strong>消息队列</strong>：替代传统消息队列（如 RabbitMQ），实现服务间的异步通信、解耦和削峰填谷（如秒杀场景的流量缓冲）。</li>
<li><strong>实时数据管道</strong>：在分布式系统间构建数据传输通道，实现不同系统（如数据库、缓存、业务系统）之间的实时数据同步。</li>
<li><strong>日志收集</strong>：集中收集分布式系统的日志数据（如 ELK 架构中的日志传输环节），便于日志分析和故障排查。</li>
<li><strong>流处理</strong>：作为流处理框架（如 Flink、Spark Streaming）的数据源和数据Sink，支撑实时计算场景（如实时监控、实时报表、风控预警）。</li>
<li><strong>事件溯源</strong>：记录系统中的关键事件，支持业务状态回溯和历史数据审计。</li>
</ul>
<h2 id="2-kafka作为“消息队列”"><a href="#2-kafka作为“消息队列”" class="headerlink" title="2.kafka作为“消息队列”"></a>2.kafka作为“消息队列”</h2><h3 id="（1）为什么需要kafka，它的作用是什么？"><a href="#（1）为什么需要kafka，它的作用是什么？" class="headerlink" title="（1）为什么需要kafka，它的作用是什么？"></a>（1）为什么需要kafka，它的作用是什么？</h3><p>下面我将以“<strong>用户注册场景</strong>”为例，简要讲解为什么要引入kafka作为消息队列，它作为工作流程的哪一个环节，如何使用。</p>
<h4 id="工作流程图对比"><a href="#工作流程图对比" class="headerlink" title="&lt;1&gt;工作流程图对比"></a>&lt;1&gt;工作流程图对比</h4><ul>
<li><p><strong>1.没有使用Kafka或任何任务队列的传统同步处理流程图</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115161939911.png"></p>
</li>
<li><p><strong>2.使用kafka的异步处理流程图</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115161159031.png"></p>
</li>
</ul>
<p><strong>看到这，敏锐的人可能想到：“不使用kafka，用多线程异步处理不是也可以吗？” 是的，也是可以的，但使用kafka有很多优势，这个之后在介绍。</strong></p>
<h4 id="完整的流程对比（场景：用户注册）"><a href="#完整的流程对比（场景：用户注册）" class="headerlink" title="&lt;2&gt;完整的流程对比（场景：用户注册）"></a>&lt;2&gt;完整的流程对比（场景：用户注册）</h4><h5 id="1）前景知识介绍"><a href="#1）前景知识介绍" class="headerlink" title="1）前景知识介绍"></a>1）前景知识介绍</h5><ul>
<li><strong>用户注册的“核心业务”</strong>：<ul>
<li>向数据库中插入新注册的用户信息（这里其实就“注册成功了！”）</li>
</ul>
</li>
<li><strong>用户注册的“附加业务”</strong>：<ul>
<li>发送邮件到注册用户的邮箱提示注册成功</li>
<li>注册成功后，返回后台数据用于渲染前端页面（如：现实中你注册成功时，显示“3s 跳转页面”，就是前端在等待后端数据进行渲染）</li>
<li>给你一些“信息提示”（如：在购物平台，提示你有优惠券可领）</li>
<li>…</li>
</ul>
</li>
<li>不同平台&#x2F;软件用户注册的“附加业务”各有不同，单“核心业务”都是在“向数据库插入新注册用户的信息”，插入成功其实就代表“注册成功”了，“附加业务”即使没有也可以。</li>
</ul>
<h5 id="2-没有Kafka（传统同步）"><a href="#2-没有Kafka（传统同步）" class="headerlink" title="2)没有Kafka（传统同步）"></a>2)没有Kafka（传统同步）</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115163026489.png"><br><strong>问题</strong>：</p>
<ul>
<li>❌ 用户等待 3+ 秒才看到响应（延迟高）</li>
<li>❌ 任一个环节出现问题（如：邮件服务挂了），注册失败（可靠性较低）</li>
<li>❌ 高并发时，线程全部阻塞“附加业务”上，“附加业务”是主要的“性能瓶颈”</li>
</ul>
<p><strong>再次提示</strong>：这里虽然也可以将“附加业务”再次用异步线程处理，但我们先不讨论它。</p>
<h5 id="3-有-Kafka（异步解耦）"><a href="#3-有-Kafka（异步解耦）" class="headerlink" title="3)有 Kafka（异步解耦）"></a>3)有 Kafka（异步解耦）</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115164615280.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115164736803.png"></p>
<p><a id="P1"></a></p>
<h4 id="后台服务器、kafka、后台任务服务-三者的关系"><a href="#后台服务器、kafka、后台任务服务-三者的关系" class="headerlink" title="&lt;3&gt;后台服务器、kafka、后台任务服务 三者的关系"></a>&lt;3&gt;后台服务器、kafka、后台任务服务 三者的关系</h4><ul>
<li><strong>类比进程池</strong>：<ul>
<li><strong>后台服务器</strong> ——&gt; <strong>master进程</strong></li>
<li><strong>kafka</strong>    ——&gt; <strong>任务队列</strong></li>
<li><strong>后台任务服务</strong> ——&gt; <strong>worker工作进程</strong></li>
</ul>
</li>
<li>客户端发送请求到达“后台服务器”（类比master进程）时，后台服务器完成“核心业务”（如：将新用户数据插入数据库），并将“附加业务”请求（高耗时）发送到kafka消息队列（类比任务队列）中，然后立即向前端回复执行结果。“后台任务服务”（类比worker进程）则不断从kafka的消息队列中取出“附加业务”请求进行处理<ul>
<li><strong>解耦了“核心业务”与“附加业务”，从而使“后台服务器”可以快速响应前端请求</strong></li>
</ul>
</li>
</ul>
<h4 id="“kafka消息队列”-vs-“进程池-线程池”"><a href="#“kafka消息队列”-vs-“进程池-线程池”" class="headerlink" title="&lt;4&gt;“kafka消息队列” vs “进程池&#x2F;线程池”"></a>&lt;4&gt;“kafka消息队列” vs “进程池&#x2F;线程池”</h4><p>从前面可以知道，使用kafka的模式与Reactor模式很像，但kafka模式有很多优点：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115204712186.png"></p>
<h1 id="二、kafka-核心概念"><a href="#二、kafka-核心概念" class="headerlink" title="二、kafka 核心概念"></a>二、kafka 核心概念</h1><p><strong>推荐阅读《Apache Kafka实战》了解详情</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115213709054.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115213729718.png"></p>
<p><strong>message格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                            消息头部 (message header)                      │</span><br><span class="line">├────────┬──────┬──────┬──────────┬──────────┬─────────┬──────────┬─────────┤</span><br><span class="line">│ CRC    │版本号 │ 属性 │ 时间戳   │ Key 长度 │ Key     │ Value 长度│ Value   │</span><br><span class="line">│ 4B     │ 1B   │ 1B   │ 8B       │ 4B       │ k bytes │ 4B       │ v bytes │</span><br><span class="line">└────────┴──────┴──────┴──────────┴──────────┴─────────┴──────────┴─────────┘</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>key</strong>：消息键，在对消息进行partition时使用 ——&gt;决定消息被存储在 该 Topic 的哪个 Partition。</li>
<li><strong>Value</strong>：消息体，消息的实际数据。</li>
<li><strong>Timestamp</strong>：消息发送时间戳。</li>
<li>每个消息由 <strong>&lt;topic,partition,offset&gt;三元组 唯一标识</strong></li>
</ul>
<h1 id="三、librdkafka的使用（C-2-13-0）"><a href="#三、librdkafka的使用（C-2-13-0）" class="headerlink" title="三、librdkafka的使用（C++ 2.13.0）"></a>三、librdkafka的使用（C++ 2.13.0）</h1><h2 id="1-Producer-与-Consumer-使用概述"><a href="#1-Producer-与-Consumer-使用概述" class="headerlink" title="1.Producer 与 Consumer 使用概述"></a>1.Producer 与 Consumer 使用概述</h2><h3 id="（1）Producer、kafka服务器、Consumer三者的关系"><a href="#（1）Producer、kafka服务器、Consumer三者的关系" class="headerlink" title="（1）Producer、kafka服务器、Consumer三者的关系"></a>（1）Producer、kafka服务器、Consumer三者的关系</h3><ul>
<li><strong>Producer</strong>（消息生产者）：<ul>
<li><strong>后台服务器</strong> 连接 kafka服务器的句柄 ——&gt;根据 “topic,partition” 向kafka服务器中写入消息</li>
</ul>
</li>
<li><strong>Consumer</strong>（消息消费者）：<ul>
<li><strong>后台任务服务</strong> 连接 kafka服务器的句柄 ——&gt; 根据 “&lt;topic,partition,offset&gt;” 从kafka中消费消息</li>
</ul>
</li>
<li>无论是<strong>Producer</strong>还是<strong>Consumer</strong>，都是<strong>kafka的客户端</strong>，kafka的服务器是两者的中介</li>
</ul>
<p><strong>如果对“后台服务器”、“后台任务服务”不了解</strong>，参考<a href="#P1">后台服务器、kafka、后台任务服务 三者的关系</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                          Kafka 架构角色                                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌─────────────────┐                         ┌─────────────────┐      │</span><br><span class="line">│   │    Producer     │                         │    Consumer     │      │</span><br><span class="line">│   │   (消息生产者)   │                         │   (消息消费者)   │      │</span><br><span class="line">│   │                 │                         │                 │      │</span><br><span class="line">│   │  后台服务器     │                         │  后台任务服务    │      │</span><br><span class="line">│   │  连接 Kafka 句柄 │                         │  连接 Kafka 句柄 │      │</span><br><span class="line">│   └────────┬────────┘                         └────────▲────────┘      │</span><br><span class="line">│            │                                           │               │</span><br><span class="line">│            │  写入消息                        消费消息  │               │</span><br><span class="line">│            │  &lt;topic, partition&gt;    &lt;topic, partition, offset&gt;         │</span><br><span class="line">│            │                                           │               │</span><br><span class="line">│            ▼                                           │               │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────┐      │</span><br><span class="line">│   │                      Kafka Server                           │      │</span><br><span class="line">│   │                       (中介/Broker)                          │      │</span><br><span class="line">│   │                                                             │      │</span><br><span class="line">│   │    ┌─────────┐    ┌─────────┐    ┌─────────┐               │      │</span><br><span class="line">│   │    │ Topic A │    │ Topic B │    │ Topic C │    ...        │      │</span><br><span class="line">│   │    │ ┌─────┐ │    │ ┌─────┐ │    │ ┌─────┐ │               │      │</span><br><span class="line">│   │    │ │ P0  │ │    │ │ P0  │ │    │ │ P0  │ │               │      │</span><br><span class="line">│   │    │ │ P1  │ │    │ │ P1  │ │    │ │ P1  │ │               │      │</span><br><span class="line">│   │    │ │ P2  │ │    │ │ P2  │ │    │ │ P2  │ │               │      │</span><br><span class="line">│   │    │ └─────┘ │    │ └─────┘ │    │ └─────┘ │               │      │</span><br><span class="line">│   │    └─────────┘    └─────────┘    └─────────┘               │      │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────┘      │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ※ Producer 和 Consumer 都是 Kafka 的客户端                           │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌──────────────┐         ┌──────────────┐         ┌──────────────┐</span><br><span class="line">│   Producer   │  ────►  │    Kafka     │  ────►  │   Consumer   │</span><br><span class="line">│  (后台服务器) │  写入    │   Server     │  消费    │ (后台任务服务) │</span><br><span class="line">└──────────────┘         │   (Broker)   │         └──────────────┘</span><br><span class="line">                         └──────────────┘</span><br><span class="line">                         </span><br><span class="line">写入定位：topic + partition</span><br><span class="line">消费定位：topic + partition + offset</span><br></pre></td></tr></table></figure>

<h3 id="（2）类层次总览"><a href="#（2）类层次总览" class="headerlink" title="（2）类层次总览"></a>（2）类层次总览</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        librdkafka C++ 类层次结构                             │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                             │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                         基础配置层                                   │   │</span><br><span class="line">│  │   ┌────────┐    ┌────────────────┐    ┌──────────────────────┐     │   │</span><br><span class="line">│  │   │  Conf  │    │  TopicPartition │    │      Headers        │     │   │</span><br><span class="line">│  │   └────────┘    └────────────────┘    └──────────────────────┘     │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                    │                                        │</span><br><span class="line">│                                    ▼                                        │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                          核心句柄层                                  │   │</span><br><span class="line">│  │                      ┌──────────────┐                               │   │</span><br><span class="line">│  │                      │    Handle    │ (抽象基类)                    │   │</span><br><span class="line">│  │                      └──────┬───────┘                               │   │</span><br><span class="line">│  │               ┌─────────────┴─────────────┐                         │   │</span><br><span class="line">│  │               ▼                           ▼                         │   │</span><br><span class="line">│  │        ┌──────────────┐           ┌───────────────┐                 │   │</span><br><span class="line">│  │        │   Producer   │           │ KafkaConsumer │                 │   │</span><br><span class="line">│  │        └──────────────┘           └───────────────┘                 │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                    │                                        │</span><br><span class="line">│                                    ▼                                        │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                          消息数据层                                  │   │</span><br><span class="line">│  │   ┌──────────┐    ┌──────────────────┐    ┌────────────────────┐   │   │</span><br><span class="line">│  │   │ Message  │    │ MessageTimestamp │    │       Error        │   │   │</span><br><span class="line">│  │   └──────────┘    └──────────────────┘    └────────────────────┘   │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                    │                                        │</span><br><span class="line">│                                    ▼                                        │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                          回调接口层                                  │   │</span><br><span class="line">│  │  ┌─────────────────┐ ┌─────────────┐ ┌─────────────┐ ┌───────────┐ │   │</span><br><span class="line">│  │  │DeliveryReportCb │ │ RebalanceCb │ │OffsetCommit │ │  EventCb  │ │   │</span><br><span class="line">│  │  │                 │ │             │ │     Cb      │ │           │ │   │</span><br><span class="line">│  │  └─────────────────┘ └─────────────┘ └─────────────┘ └───────────┘ │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                    │                                        │</span><br><span class="line">│                                    ▼                                        │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                          高级功能层                                  │   │</span><br><span class="line">│  │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌─────────────┐  │   │</span><br><span class="line">│  │   │ Metadata │    │  Queue   │    │  Topic   │    │ AdminClient │  │   │</span><br><span class="line">│  │   └──────────┘    └──────────┘    └──────────┘    └─────────────┘  │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                                                             │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（3）Producer的使用流程图"><a href="#（3）Producer的使用流程图" class="headerlink" title="（3）Producer的使用流程图"></a>（3）Producer的使用流程图</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         初始化阶段                                       │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐    ┌───────────────────┐    ┌────────────────┐ │</span><br><span class="line">│   │    创建 Conf      │───→│    设置参数       │───→│   注册回调     │ │</span><br><span class="line">│   │   (全局配置)      │    │  bootstrap.servers│    │                │ │</span><br><span class="line">│   │                   │    │  acks, retries 等 │    │ DeliveryReport │ │</span><br><span class="line">│   │ ┌───────────────┐ │    └───────────────────┘    │      Cb        │ │</span><br><span class="line">│   │ │  <span class="built_in">Conf</span> (GLOBAL)│ │                             │    EventCb     │ │</span><br><span class="line">│   │ └───────────────┘ │                             └───────┬────────┘ │</span><br><span class="line">│   └───────────────────┘                                     │          │</span><br><span class="line">│                                                             ▼          │</span><br><span class="line">│                                                 ┌───────────────────┐  │</span><br><span class="line">│                                                 │  创建 Producer    │  │</span><br><span class="line">│                                                 │ Producer::<span class="built_in">create</span>()│  │</span><br><span class="line">│                                                 │                   │  │</span><br><span class="line">│                                                 │ ┌───────────────┐ │  │</span><br><span class="line">│                                                 │ │   Producer    │ │  │</span><br><span class="line">│                                                 │ └───────────────┘ │  │</span><br><span class="line">│                                                 └─────────┬─────────┘  │</span><br><span class="line">└───────────────────────────────────────────────────────────┼─────────────┘</span><br><span class="line">                                                            │</span><br><span class="line">                                                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         生产阶段（循环）                                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐    ┌───────────────────┐    ┌────────────────┐ │</span><br><span class="line">│   │    构造消息       │───→│    <span class="built_in">produce</span>()      │───→│    <span class="built_in">poll</span>()      │ │</span><br><span class="line">│   │  topic/key/value  │    │   放入内部队列    │    │   触发回调     │ │</span><br><span class="line">│   │                   │    │                   │    │   处理事件     │ │</span><br><span class="line">│   │ ┌───────────────┐ │    │ ┌───────────────┐ │    └───────┬────────┘ │</span><br><span class="line">│   │ │    Topic      │ │    │ │   Producer    │ │            │        ◄─┐</span><br><span class="line">│   │ │    Headers    │ │    │ │   ::<span class="built_in">produce</span>() │ │            │          │</span><br><span class="line">│   │ └───────────────┘ │    │ └───────────────┘ │            │          │</span><br><span class="line">│   └───────────────────┘    └───────────────────┘            │          │</span><br><span class="line">│                                                             │          │</span><br><span class="line">│            ┌────────────────────────────────────────────────┘          │</span><br><span class="line">│            │                                                           │</span><br><span class="line">│            │    ┌─────────────────────────────────────────┐            │</span><br><span class="line">│            │    │  回调触发时涉及的类：                    │            │</span><br><span class="line">│            │    │  ┌─────────┐  ┌─────────┐  ┌─────────┐  │            │</span><br><span class="line">│            │    │  │ Message │  │  Event  │  │ErrorCode│  │            │</span><br><span class="line">│            │    │  └─────────┘  └─────────┘  └─────────┘  │            │</span><br><span class="line">│            │    └─────────────────────────────────────────┘            │</span><br><span class="line">│            │                                                           │</span><br><span class="line">│            └───────────────────────────────────────────────────────────┘</span><br><span class="line">│                                            (持续生产则循环)              │</span><br><span class="line">└───────────────────────────────────────────────────────────┬─────────────┘</span><br><span class="line">                                                            │</span><br><span class="line">                                                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         清理阶段                                         │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐         ┌───────────────────┐                  │</span><br><span class="line">│   │     <span class="built_in">flush</span>()       │────────→│  <span class="keyword">delete</span> producer  │                  │</span><br><span class="line">│   │   等待队列清空    │         │                   │                  │</span><br><span class="line">│   │                   │         │ ┌───────────────┐ │                  │</span><br><span class="line">│   │ ┌───────────────┐ │         │ │   Producer    │ │                  │</span><br><span class="line">│   │ │   Producer    │ │         │ │   (销毁)      │ │                  │</span><br><span class="line">│   │ │   ::<span class="built_in">flush</span>()   │ │         │ └───────────────┘ │                  │</span><br><span class="line">│   │ └───────────────┘ │         └───────────────────┘                  │</span><br><span class="line">│   └───────────────────┘                                                │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（4）Consumer的使用流程图"><a href="#（4）Consumer的使用流程图" class="headerlink" title="（4）Consumer的使用流程图"></a>（4）Consumer的使用流程图</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         初始化阶段                                       │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐    ┌───────────────────┐    ┌────────────────┐ │</span><br><span class="line">│   │    创建 Conf      │───→│    设置参数       │───→│   注册回调     │ │</span><br><span class="line">│   │   (全局配置)      │    │  bootstrap.servers│    │                │ │</span><br><span class="line">│   │                   │    │  group.<span class="built_in">id</span> (必需)  │    │  RebalanceCb   │ │</span><br><span class="line">│   │ ┌───────────────┐ │    │  <span class="keyword">auto</span>.offset.reset│    │OffsetCommitCb  │ │</span><br><span class="line">│   │ │  <span class="built_in">Conf</span> (GLOBAL)│ │    │  enable.<span class="keyword">auto</span>.     │    │    EventCb     │ │</span><br><span class="line">│   │ └───────────────┘ │    │      commit 等    │    └───────┬────────┘ │</span><br><span class="line">│   └───────────────────┘    └───────────────────┘            │          │</span><br><span class="line">│                                                             ▼          │</span><br><span class="line">│                                                 ┌───────────────────┐  │</span><br><span class="line">│                                                 │ 创建 KafkaConsumer│  │</span><br><span class="line">│                                                 │ KafkaConsumer::   │  │</span><br><span class="line">│                                                 │    <span class="built_in">create</span>()       │  │</span><br><span class="line">│                                                 │ ┌───────────────┐ │  │</span><br><span class="line">│                                                 │ │ KafkaConsumer │ │  │</span><br><span class="line">│                                                 │ └───────────────┘ │  │</span><br><span class="line">│                                                 └─────────┬─────────┘  │</span><br><span class="line">└───────────────────────────────────────────────────────────┼─────────────┘</span><br><span class="line">                                                            │</span><br><span class="line">                                                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         订阅阶段                                         │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────┐  │</span><br><span class="line">│   │                       两种订阅方式（二选一）                      |  |</span><br><span class="line">    |               用于确定从哪个（topic，partition）获取消息           │  │</span><br><span class="line">│   ├─────────────────────────────────┬───────────────────────────────┤  │</span><br><span class="line">│   │                                 │                               │  │</span><br><span class="line">│   │   ┌───────────────────────┐     │     ┌───────────────────────┐ │  │</span><br><span class="line">│   │   │    <span class="built_in">subscribe</span>()        │     │     │    <span class="built_in">assign</span>()           │ │  │</span><br><span class="line">│   │   │    订阅主题列表       │     │     │    手动分配分区       │ │  │</span><br><span class="line">│   │   │                       │     │     │                       │ │  │</span><br><span class="line">│   │   │ ┌───────────────────┐ │     │     │ ┌───────────────────┐ │ │  │</span><br><span class="line">│   │   │ │ vector&lt;string&gt;    │ │     │     │ │ TopicPartition    │ │ │  │</span><br><span class="line">│   │   │ │ &#123;<span class="string">&quot;topic1&quot;</span>,<span class="string">&quot;topic2&quot;</span>&#125;│ │     │     │ │ (topic, partition)│ │ │  │</span><br><span class="line">│   │   │ └───────────────────┘ │     │     │ └───────────────────┘ │ │  │</span><br><span class="line">│   │   │                       │     │     │                       │ │  │</span><br><span class="line">│   │   │ ✓ 自动负载均衡       │     │     │ ✗ 无自动负载均衡     │ │  │</span><br><span class="line">│   │   │ ✓ 触发 RebalanceCb   │     │     │ ✗ 不触发 RebalanceCb │ │  │</span><br><span class="line">│   │   └───────────────────────┘     │     └───────────────────────┘ │  │</span><br><span class="line">│   │                                 │                               │  │</span><br><span class="line">│   └─────────────────────────────────┴───────────────────────────────┘  │</span><br><span class="line">│                                                                         │</span><br><span class="line">└───────────────────────────────────────────────────────────┬─────────────┘</span><br><span class="line">                                                            │</span><br><span class="line">                                                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         消费阶段（循环）                                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐    ┌───────────────────┐    ┌────────────────┐ │</span><br><span class="line">│   │    <span class="built_in">consume</span>()      │───→│    处理消息       │───→│   提交 offset  │ │</span><br><span class="line">│   │   拉取消息(阻塞)  │    │   业务逻辑处理    │    │  (可选手动)    │ │</span><br><span class="line">│   │                   │    │                   │    │ 用于确定下次读取的位置│ │</span><br><span class="line">│   │ ┌───────────────┐ │    │ ┌───────────────┐ │    │ ┌────────────┐ │ │</span><br><span class="line">│   │ │ KafkaConsumer │ │    │ │    Message    │ │    │ │<span class="built_in">commitSync</span>()│ │ │</span><br><span class="line">│   │ │  ::<span class="built_in">consume</span>()  │ │    │ │  (返回消息)   │ │    │ │   或       │ │ │</span><br><span class="line">│   │ └───────────────┘ │    │ └───────────────┘ │    │ │commitAsync│ │ │</span><br><span class="line">│   └───────────────────┘    └───────────────────┘    │ └────────────┘ │ │</span><br><span class="line">│            ▲                                        └───────┬────────┘ │</span><br><span class="line">│            │                                                │          │</span><br><span class="line">│            │         ┌──────────────────────────────────────┘          │</span><br><span class="line">│            │         │                                                 │</span><br><span class="line">│            │         ▼                                                 │</span><br><span class="line">│            │    ┌─────────────────────────────────────────────────┐   │</span><br><span class="line">│            │    │  消费过程中涉及的类：                             │   │</span><br><span class="line">│            │    │  ┌─────────┐  ┌───────────────┐  ┌───────────┐  │   │</span><br><span class="line">│            │    │  │ Message │  │TopicPartition │  │  Headers  │  │   │</span><br><span class="line">│            │    │  │ payload │  │ offset 管理   │  │ (消息头)  │  │   │</span><br><span class="line">│            │    │  │ key     │  └───────────────┘  └───────────┘  │   │</span><br><span class="line">│            │    │  │ offset  │                                    │   │</span><br><span class="line">│            │    │  └─────────┘                                    │   │</span><br><span class="line">│            │    └─────────────────────────────────────────────────┘   │</span><br><span class="line">│            │                                                           │</span><br><span class="line">│            └───────────────────────────────────────────────────────────┘</span><br><span class="line">│                                            (持续消费则循环)              │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────┐  │</span><br><span class="line">│   │                    重平衡触发时                                   │  │</span><br><span class="line">│   │                                                                  │  │</span><br><span class="line">│   │   消费者加入/离开组 ───→ RebalanceCb 触发 ───→ 重新分配分区     │  │</span><br><span class="line">│   │                                                                  │  │</span><br><span class="line">│   │   ┌─────────────────────────────────────────────────────────┐   │  │</span><br><span class="line">│   │   │  ERR__ASSIGN_PARTITIONS  →  <span class="built_in">assign</span>() / incremental_assign│   │  │</span><br><span class="line">│   │   │  ERR__REVOKE_PARTITIONS  →  <span class="built_in">unassign</span>() / incremental_    │   │  │</span><br><span class="line">│   │   │                             <span class="built_in">unassign</span>()                   │   │  │</span><br><span class="line">│   │   └─────────────────────────────────────────────────────────┘   │  │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────────┘  │</span><br><span class="line">│                                                                         │</span><br><span class="line">└───────────────────────────────────────────────────────────────────────┬─┘</span><br><span class="line">                                                                        │</span><br><span class="line">                                                                        ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         清理阶段                                         │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐         ┌───────────────────┐                  │</span><br><span class="line">│   │     <span class="built_in">close</span>()       │────────→│ <span class="keyword">delete</span> consumer   │                  │</span><br><span class="line">│   │   关闭消费者      │         │                   │                  │</span><br><span class="line">│   │                   │         │ ┌───────────────┐ │                  │</span><br><span class="line">│   │ ┌───────────────┐ │         │ │ KafkaConsumer │ │                  │</span><br><span class="line">│   │ │ KafkaConsumer │ │         │ │   (销毁)      │ │                  │</span><br><span class="line">│   │ │   ::<span class="built_in">close</span>()   │ │         │ └───────────────┘ │                  │</span><br><span class="line">│   │ └───────────────┘ │         └───────────────────┘                  │</span><br><span class="line">│   │                   │                                                │</span><br><span class="line">│   │ • 提交最终offset  │                                                │</span><br><span class="line">│   │ • 离开消费者组    │                                                │</span><br><span class="line">│   │ • 触发重平衡      │                                                │</span><br><span class="line">│   └───────────────────┘                                                │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-Conf类（配置类）"><a href="#2-Conf类（配置类）" class="headerlink" title="2.Conf类（配置类）"></a>2.Conf类（配置类）</h2><p>dKafka::Conf 是 librdkafka 中<strong>配置管理的核心类</strong>，用于统一管理 Kafka 客户端（生产者 &#x2F; 消费者）的<strong>全局配置</strong>、<strong>主题级配置</strong>，是创建生产者 &#x2F; 消费者实例的基础。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116100012806.png"></p>
<h3 id="（1）Conf类的定义"><a href="#（1）Conf类的定义" class="headerlink" title="（1）Conf类的定义"></a>（1）Conf类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Conf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 配置类型</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ConfType</span> &#123;</span><br><span class="line">        CONF_GLOBAL, <span class="comment">// 全局配置</span></span><br><span class="line">        CONF_TOPIC   <span class="comment">// Topic配置</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set() 返回码</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ConfResult</span> &#123;</span><br><span class="line">        CONF_UNKNOWN = <span class="number">-2</span>, <span class="comment">// 未知属性</span></span><br><span class="line">        CONF_INVALID = <span class="number">-1</span>, <span class="comment">// 无效值</span></span><br><span class="line">        CONF_OK      = <span class="number">0</span>   <span class="comment">// 成功</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建配置对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Conf *<span class="title">create</span><span class="params">(ConfType type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Conf</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * @brief 设置字符串类型的配置属性</span></span><br><span class="line"><span class="comment">       * @param name 配置属性名称</span></span><br><span class="line"><span class="comment">       * @param value 配置值</span></span><br><span class="line"><span class="comment">       * @param errstr 错误时返回的错误描述</span></span><br><span class="line"><span class="comment">       * @return 配置结果码</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> std::string &amp;value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认 Topic 配置 (name = &quot;default_topic_conf&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> Conf *topic_conf, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===================================== 设置回调函数配置 =================================================</span></span><br><span class="line">    <span class="comment">/*    1.参数：</span></span><br><span class="line"><span class="comment">            - name：配置名（固定）</span></span><br><span class="line"><span class="comment">                - 特征很明显，如DeliveryReportCb *dr_cb ——&gt; name：&quot;dr_cb&quot;</span></span><br><span class="line"><span class="comment">            - xxxCb：回调对象（成员函数：回调函数）</span></span><br><span class="line"><span class="comment">            - errstr：错误时返回的错误描述</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.返回值：</span></span><br><span class="line"><span class="comment">            - ConfResult：配置结果码（见上）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  1.DeliveryReportCb - 消息投递报告回调（⭐⭐⭐⭐⭐ 极高（生产者常用））</span></span><br><span class="line"><span class="comment">            - 功能：生产者发送消息后，通知消息是否成功投递到 Broker </span></span><br><span class="line"><span class="comment">            - 使用场景：确认消息发送成功/失败，处理发送失败的重试逻辑*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, DeliveryReportCb *dr_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2.EventCb - 事件回调（⭐⭐⭐⭐⭐ 极高（生产者/消费者都常用））</span></span><br><span class="line"><span class="comment">            - 功能：接收 Kafka 客户端的各种事件（错误、统计信息、日志、限流等）</span></span><br><span class="line"><span class="comment">            - 使用场景：监控连接状态、记录错误日志、获取统计数据*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, EventCb *event_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*    3.RebalanceCb - 消费者重平衡回调</span></span><br><span class="line"><span class="comment">            - 功能：消费者组发生分区重新分配时触发（成员加入/离开）（⭐⭐⭐⭐ 高（消费者组常用））</span></span><br><span class="line"><span class="comment">            - 使用场景：在重平衡前保存 offset、释放资源；重平衡后初始化状态*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, RebalanceCb *rebalance_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    4.OffsetCommitCb - 偏移量提交回调（⭐⭐⭐ 中等（需要精确控制 offset 时使用））</span></span><br><span class="line"><span class="comment">            - 功能：offset 提交完成后的通知（成功或失败）</span></span><br><span class="line"><span class="comment">            - 使用场景：确认 offset 提交状态，处理提交失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, OffsetCommitCb *cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    5.PartitionerCb - 自定义分区器回调（⭐⭐⭐ 中等（默认分区器够用时不需要））</span></span><br><span class="line"><span class="comment">            - 功能：自定义消息路由到哪个分区的逻辑</span></span><br><span class="line"><span class="comment">            - 使用场景：需要特殊分区策略（如按业务 ID 分区、地理位置分区）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, PartitionerCb *partitioner_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*    6.ConsumeCb - 消息消费回调（⭐⭐⭐ 中等（通常直接用 poll() 更常见））</span></span><br><span class="line"><span class="comment">        - 功能：消费到消息时的回调处理</span></span><br><span class="line"><span class="comment">        - 使用场景：回调式消费模式（替代 poll 循环）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, ConsumeCb *consume_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面使用频率较低，就不详细注释了</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, OAuthBearerTokenRefreshCb *cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">//令牌刷新回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, SslCertificateVerifyCb *cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">//SSL 证书验证回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, SocketCb *socket_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">//Socket 创建回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, OpenCb *open_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">//文件打开回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, PartitionerKeyPointerCb *cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">// 键指针分区器回调</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 SSL 证书/密钥</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set_ssl_cert</span><span class="params">(RdKafka::CertificateType cert_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RdKafka::CertificateEncoding cert_enc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询字符串配置值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(<span class="type">const</span> std::string &amp;name, std::string &amp;value)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 获取回调函数 ==========</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(DeliveryReportCb *&amp;dr_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(OAuthBearerTokenRefreshCb *&amp;cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(EventCb *&amp;event_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(PartitionerCb *&amp;partitioner_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(PartitionerKeyPointerCb *&amp;cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(SocketCb *&amp;socket_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(OpenCb *&amp;open_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(RebalanceCb *&amp;rebalance_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(OffsetCommitCb *&amp;cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(SslCertificateVerifyCb *&amp;cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出所有配置 (name, value) 列表</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::list&lt;std::string&gt; *<span class="title">dump</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取底层 C 句柄（不推荐直接使用）</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">struct</span> <span class="title class_">rd_kafka_conf_s</span> *<span class="built_in">c_ptr_global</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">struct</span> <span class="title class_">rd_kafka_topic_conf_s</span> *<span class="built_in">c_ptr_topic</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 SSL 引擎回调数据</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set_engine_callback_data</span><span class="params">(<span class="type">void</span> *value, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 SASL 专用队列</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">enable_sasl_queue</span><span class="params">(<span class="type">bool</span> enable, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（2）Conf类的使用"><a href="#（2）Conf类的使用" class="headerlink" title="（2）Conf类的使用"></a>（2）Conf类的使用</h3><h4 id="创建-RdKafka-Conf"><a href="#创建-RdKafka-Conf" class="headerlink" title="&lt;1&gt;创建 RdKafka::Conf"></a>&lt;1&gt;创建 RdKafka::Conf</h4><ul>
<li>RdKafka::Conf 的创建非常简单，使用<strong>静态工厂方法 create()</strong></li>
<li><strong>推荐</strong>：使用“智能指针”自动管理内存，避免手动 delete</li>
</ul>
<h5 id="1）使用智能指针直接创建"><a href="#1）使用智能指针直接创建" class="headerlink" title="1）使用智能指针直接创建"></a>1）使用智能指针直接创建</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ==================== 1. 使用 unique_ptr 创建全局配置 ====================</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">global_conf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        RdKafka::Conf::create(RdKafka::Conf::CONF_GLOBAL)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!global_conf) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建全局配置失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;全局配置创建成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== 2. 使用 unique_ptr 创建 Topic 配置 ====================</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">topic_conf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        RdKafka::Conf::create(RdKafka::Conf::CONF_TOPIC)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!topic_conf) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建 Topic 配置失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Topic 配置创建成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）封装为工厂函数"><a href="#2）封装为工厂函数" class="headerlink" title="2）封装为工厂函数"></a>2）封装为工厂函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数：创建全局配置</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">createGlobalConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;RdKafka::Conf&gt;(</span><br><span class="line">        RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数：创建 Topic 配置</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">createTopicConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;RdKafka::Conf&gt;(</span><br><span class="line">        RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_TOPIC)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> global_conf = <span class="built_in">createGlobalConf</span>();</span><br><span class="line">    <span class="keyword">auto</span> topic_conf = <span class="built_in">createTopicConf</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!global_conf || !topic_conf) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;配置创建失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;配置创建并设置成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3）不使用“智能指针”（不推荐！）"><a href="#3）不使用“智能指针”（不推荐！）" class="headerlink" title="3）不使用“智能指针”（不推荐！）"></a>3）不使用“智能指针”（不推荐！）</h5><p>在“RdKafka::Conf类的结构”部分可知：create返回 “裸指针”，所以需要“<strong>手动释放资源</strong>”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== 1. 创建配置（裸指针） ====================</span></span><br><span class="line">    RdKafka::Conf *global_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    RdKafka::Conf *topic_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_TOPIC);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须检查是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (!global_conf || !topic_conf) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;配置创建失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// ⚠️ 问题1：如果一个成功一个失败，需要处理部分释放</span></span><br><span class="line">        <span class="keyword">delete</span> global_conf;  <span class="comment">// 可能是 nullptr，但 delete nullptr 是安全的</span></span><br><span class="line">        <span class="keyword">delete</span> topic_conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设置-RdKafka-Conf"><a href="#设置-RdKafka-Conf" class="headerlink" title="&lt;2&gt;设置 RdKafka::Conf"></a>&lt;2&gt;设置 RdKafka::Conf</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer 最小配置</span></span><br><span class="line">RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;dr_cb&quot;</span>, &amp;delivery_cb, errstr);  <span class="comment">// 投递回调</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer 最小配置</span></span><br><span class="line">RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;my-consumer-group&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>, errstr);</span><br></pre></td></tr></table></figure>
<p><strong>实战使用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Kafka配置构建器（Builder模式）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KafkaConfBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">KafkaConfBuilder</span><span class="params">(RdKafka::Conf::ConfType type = RdKafka::Conf::CONF_GLOBAL)</span> </span></span><br><span class="line"><span class="function">        : conf_(RdKafka::Conf::create(type)) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!conf_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;RdKafka::Conf create failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">KafkaConfBuilder</span>(<span class="type">const</span> KafkaConfBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    KafkaConfBuilder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> KafkaConfBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许移动</span></span><br><span class="line">    <span class="built_in">KafkaConfBuilder</span>(KafkaConfBuilder&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    KafkaConfBuilder&amp; <span class="keyword">operator</span>=(KafkaConfBuilder&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置字符串类型配置项</span></span><br><span class="line"><span class="comment">     * @param key 配置键名</span></span><br><span class="line"><span class="comment">     * @param value 配置值</span></span><br><span class="line"><span class="comment">     * @return 当前Builder引用（支持链式调用）</span></span><br><span class="line"><span class="comment">     * @throws std::runtime_error 配置失败时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">KafkaConfBuilder&amp; <span class="title">set</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::string errstr;</span><br><span class="line">        <span class="keyword">if</span> (conf_-&gt;<span class="built_in">set</span>(key, value, errstr) != RdKafka::Conf::CONF_OK) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Kafka Conf [&quot;</span> + key + <span class="string">&quot;] error: &quot;</span> + errstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置回调对象</span></span><br><span class="line"><span class="comment">     * @tparam T 回调类型（如 RdKafka::DeliveryReportCb*）</span></span><br><span class="line"><span class="comment">     * @param key 配置键名（如 &quot;dr_cb&quot;）</span></span><br><span class="line"><span class="comment">     * @param cb 回调对象指针</span></span><br><span class="line"><span class="comment">     * @return 当前Builder引用</span></span><br><span class="line"><span class="comment">     * @throws std::runtime_error 配置失败时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    KafkaConfBuilder&amp; <span class="title">setCallback</span><span class="params">(<span class="type">const</span> std::string&amp; key, T* cb)</span> </span>&#123;</span><br><span class="line">        std::string errstr;</span><br><span class="line">        <span class="keyword">if</span> (conf_-&gt;<span class="built_in">set</span>(key, cb, errstr) != RdKafka::Conf::CONF_OK) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Kafka Conf [&quot;</span> + key + <span class="string">&quot;] error: &quot;</span> + errstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构建并返回配置对象</span></span><br><span class="line"><span class="comment">     * @return 配置对象的unique_ptr（所有权转移）</span></span><br><span class="line"><span class="comment">     * @note 调用后当前Builder失效，不可再使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(conf_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检查Builder是否有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conf_ != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;RdKafka::Conf&gt; conf_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 使用示例 ====================</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> producer_conf = <span class="built_in">KafkaConfBuilder</span>()</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;my-producer&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;batch.size&quot;</span>, <span class="string">&quot;16384&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;linger.ms&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">            .<span class="built_in">build</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> consumer_conf = <span class="built_in">KafkaConfBuilder</span>()</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;my-consumer-group&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;my-consumer&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>)</span><br><span class="line">            .<span class="built_in">build</span>();</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;配置创建成功！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>“回调类”参考</strong>：<a href="#cb">回调类</a></p>
<h5 id="1）生产者常用配置"><a href="#1）生产者常用配置" class="headerlink" title="1）生产者常用配置"></a>1）生产者常用配置</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116161810771.png"></p>
<h5 id="2）消费者常用配置"><a href="#2）消费者常用配置" class="headerlink" title="2）消费者常用配置"></a>2）消费者常用配置</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116161420955.png"></p>
<p>想了解更多配置项，<strong>参考</strong>：<a href="#config">附录1：常用配置项</a></p>
<h2 id="3-TopicPartition类（主题分区类）"><a href="#3-TopicPartition类（主题分区类）" class="headerlink" title="3.TopicPartition类（主题分区类）"></a>3.TopicPartition类（主题分区类）</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用"><a href="#作用" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>封装**&lt;topic, partition, offset&gt;**三元组的核心类</li>
<li>客户端与 Kafka 集群交互「<strong>分区级操作</strong>」的基础载体</li>
<li>所有和「<strong>指定分区、控制消费位置、提交偏移量</strong>」相关的操作都依赖该类</li>
</ul>
<h4 id="核心定位"><a href="#核心定位" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>元数据载体</strong>：<ul>
<li>本质是存储「主题名（string）、分区号（int）、偏移量（int64_t）」的轻量级类，仅记录 “要操作的目标分区 + 位置”，<strong>不包含任何集群交互逻辑</strong>；</li>
</ul>
</li>
<li><strong>操作桥梁</strong>：<ul>
<li>作为 assign()（手动分配分区）、commitSync()&#x2F;commitAsync()（提交 offset）、seek()（重置消费位置）等核心 API 的入参 &#x2F; 返回值，是<strong>客户端向 Kafka 传递 “分区操作指令” 的标准化格式</strong>；</li>
</ul>
</li>
<li><strong>无状态特性</strong>：<ul>
<li>该类对象仅存储静态元数据，不关联 Kafka 连接状态，<strong>修改对象属性（如 offset）仅影响本地，需调用 API 才能同步到集群</strong>。</li>
</ul>
</li>
</ul>
<h3 id="（2）TopicPartition类的定义"><a href="#（2）TopicPartition类的定义" class="headerlink" title="（2）TopicPartition类的定义"></a>（2）TopicPartition类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> TopicPartition &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//==================== 高频使用（必用） ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建 topic+partition 关联对象（无 offset）</span></span><br><span class="line"><span class="comment">     * 需使用 delete 释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> TopicPartition *<span class="title">create</span><span class="params">(<span class="type">const</span> std::string &amp;topic, <span class="type">int</span> partition)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建 topic+partition+offset 关联对象</span></span><br><span class="line"><span class="comment">     * 需使用 delete 释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> TopicPartition *<span class="title">create</span><span class="params">(<span class="type">const</span> std::string &amp;topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int64_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string &amp;<span class="title">topic</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;    <span class="comment">// 获取 topic 名</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">partition</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;               <span class="comment">// 获取分区 ID</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;              <span class="comment">// 获取 offset</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================== 中频使用（常用） ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions)</span></span>;  <span class="comment">// 批量销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">err</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;               <span class="comment">// 获取错误码</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_offset</span><span class="params">(<span class="type">int64_t</span> offset)</span> </span>= <span class="number">0</span>;     <span class="comment">// 设置 offset</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TopicPartition</span>() = <span class="number">0</span>;                   <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================== 低频使用（高级场景） ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">get_leader_epoch</span><span class="params">()</span> </span>= <span class="number">0</span>;          <span class="comment">// 获取 leader epoch</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_leader_epoch</span><span class="params">(<span class="type">int32_t</span> leader_epoch)</span> </span>= <span class="number">0</span>;  <span class="comment">//设置 leader epoch</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================== 极少使用（特殊场景） ====================</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">get_metadata</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 获取分区元数据</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_metadata</span><span class="params">(std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; &amp;metadata)</span> </span>= <span class="number">0</span>; <span class="comment">// 设置分区元数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊 offset 常量（按使用频率）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> OFFSET_STORED    = <span class="number">-1000</span>; <span class="comment">// ★★★ 最常用：从上次提交位置继续</span></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> OFFSET_END       = <span class="number">-1</span>;    <span class="comment">// ★★  常用：只消费新消息</span></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> OFFSET_BEGINNING = <span class="number">-2</span>;    <span class="comment">// ★★  常用：从头消费所有消息</span></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> OFFSET_INVALID   = <span class="number">-1001</span>; <span class="comment">// ★   少用：表示无效状态</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116211851723.png"></p>
<h3 id="（3）典型使用场景（结合核心-API）"><a href="#（3）典型使用场景（结合核心-API）" class="headerlink" title="（3）典型使用场景（结合核心 API）"></a>（3）典型使用场景（结合核心 API）</h3><h4 id="手动分配分区"><a href="#手动分配分区" class="headerlink" title="&lt;1&gt; 手动分配分区"></a>&lt;1&gt; 手动分配分区</h4><p>无需指定偏移量，仅关联「主题 + 分区」，依赖 auto.offset.reset 配置确定消费位置：    </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">1</span>));</span><br><span class="line">consumer-&gt;<span class="built_in">assign</span>(partitions); <span class="comment">// 仅指定要消费的分区</span></span><br></pre></td></tr></table></figure>

<h4 id="指定偏移量消费"><a href="#指定偏移量消费" class="headerlink" title="&lt;2&gt;指定偏移量消费"></a>&lt;2&gt;指定偏移量消费</h4><p>创建时指定偏移量，重置消费位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 topic1-0 分区的第 100 条消息开始消费</span></span><br><span class="line">RdKafka::TopicPartition *tp = RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">consumer-&gt;<span class="built_in">seek</span>(tp, <span class="number">5000</span>); <span class="comment">// 5000ms 超时时间</span></span><br><span class="line"><span class="keyword">delete</span> tp;</span><br></pre></td></tr></table></figure>

<h4 id="手动提交指定-offset"><a href="#手动提交指定-offset" class="headerlink" title="&lt;3&gt;手动提交指定 offset"></a>&lt;3&gt;手动提交指定 offset</h4><p>修改对象偏移量后提交，实现精准的 offset 管理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">partitions[<span class="number">0</span>]-&gt;<span class="built_in">set_offset</span>(<span class="number">200</span>); <span class="comment">// 提交 topic1-0 的 offset=200</span></span><br><span class="line">consumer-&gt;<span class="built_in">commitSync</span>(partitions); <span class="comment">// 同步提交</span></span><br></pre></td></tr></table></figure>

<h4 id="批量操作所有分区"><a href="#批量操作所有分区" class="headerlink" title="&lt;4&gt;批量操作所有分区"></a>&lt;4&gt;批量操作所有分区</h4><p>使用 partition&#x3D;-1 代表主题的所有分区：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交 topic1 所有分区的 offset=300</span></span><br><span class="line">RdKafka::TopicPartition *tp = RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">-1</span>, <span class="number">300</span>);</span><br><span class="line">consumer-&gt;<span class="built_in">commitSync</span>(&#123;tp&#125;);</span><br><span class="line"><span class="keyword">delete</span> tp;</span><br></pre></td></tr></table></figure>

<h4 id="destroy-的使用示例"><a href="#destroy-的使用示例" class="headerlink" title="&lt;5&gt;destroy() 的使用示例"></a>&lt;5&gt;destroy() 的使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量创建</span></span><br><span class="line">std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">1</span>));</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic2&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 使用完毕后 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：手动逐个删除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : partitions) </span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">partitions.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：使用 destroy() 一次性销毁并清空（推荐）</span></span><br><span class="line">RdKafka::TopicPartition::<span class="built_in">destroy</span>(partitions);  <span class="comment">// 删除所有元素 + 清空 vector</span></span><br><span class="line"><span class="comment">// 此时 partitions.size() == 0，且原指针已被 delete</span></span><br><span class="line"><span class="comment">// ❌ 不能再访问 partitions 中的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）内存管理（核心注意事项）"><a href="#（4）内存管理（核心注意事项）" class="headerlink" title="（4）内存管理（核心注意事项）"></a>（4）内存管理（核心注意事项）</h3><p><strong>必须释放资源</strong>：</p>
<ul>
<li>create 方法返回的是动态分配的裸指针，未释放会导致内存泄漏，推荐两种方式：<ul>
<li>手动 delete（基础方式）</li>
<li>封装智能指针（生产环境推荐）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动 delete</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : partitions) &#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>; <span class="comment">// 避免野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用智能指针</span></span><br><span class="line"><span class="keyword">using</span> TopicPartitionPtr = std::unique_ptr&lt;RdKafka::TopicPartition&gt;;</span><br><span class="line"><span class="function">TopicPartitionPtr <span class="title">tp</span><span class="params">(RdKafka::TopicPartition::create(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// 自动释放，无需手动 delete</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）核心易错点与最佳实践"><a href="#（5）核心易错点与最佳实践" class="headerlink" title="（5）核心易错点与最佳实践"></a>（5）核心易错点与最佳实践</h3><h4 id="易错点"><a href="#易错点" class="headerlink" title="&lt;1&gt;易错点"></a>&lt;1&gt;易错点</h4><ul>
<li><strong>混淆「客户端对象创建」和「集群物理创建」</strong>：<ul>
<li>TopicPartition::create 仅创建<strong>本地对象</strong>，不会在 Kafka 集群创建主题 &#x2F; 分区；</li>
</ul>
</li>
<li><strong>忽略内存释放</strong>：<ul>
<li>生产环境需严格管理 TopicPartition 指针，<strong>建议封装智能指针</strong>；</li>
</ul>
</li>
<li><strong>偏移量设置后未调用 API</strong>：<ul>
<li><strong>修改 offset 仅改本地值</strong>，需调用 commitSync()&#x2F;seek() 等 API 才能同步到集群；</li>
</ul>
</li>
<li><strong>分区号越界</strong>：<ul>
<li>指定的分区号超出主题实际分区数，会导致 assign()&#x2F;commitSync() 返回 ERR_UNKNOWN_PARTITION 错误。</li>
</ul>
</li>
</ul>
<h2 id="4-Headers类（消息头类）"><a href="#4-Headers类（消息头类）" class="headerlink" title="4.Headers类（消息头类）"></a>4.Headers类（消息头类）</h2><h3 id="（1）概述-1"><a href="#（1）概述-1" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Headers 是 librdkafka 中<strong>封装 Kafka 消息头（Header）的核心类</strong><ul>
<li>用于为消息附<strong>加键值对</strong>形式的元数据（如业务标识、追踪 ID、消息类型等）</li>
<li>是消息内容之外的 “<strong>辅助信息载体</strong>”，不影响消息的分区路由，仅用于业务侧的消息溯源、过滤、扩展。</li>
</ul>
</li>
</ul>
<h4 id="核心定位-1"><a href="#核心定位-1" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>元数据扩展</strong>：<ul>
<li><strong>弥补 Kafka 消息 Key&#x2F;Value 仅能存储业务数据的不足</strong></li>
<li>支持附加多组键值对元数据（如 trace-id: 123456、msg-type: order）；</li>
</ul>
</li>
<li><strong>可写 &#x2F; 只读特性</strong>：<ul>
<li>生产者侧可创建并写入 Headers</li>
<li>消费者侧仅能读取 Headers（<strong>消息一旦发送，Headers 不可修改</strong>）；</li>
</ul>
</li>
<li><strong>轻量级设计</strong>：<ul>
<li>Headers 存储的是字符串键值对，<strong>建议仅存放轻量元数据</strong>（避免增大消息体积）。</li>
</ul>
</li>
<li><strong>跨系统兼容</strong>：<ul>
<li>消息头是 Kafka 协议标准特性，可与其他 Kafka 客户端（如 Java、Python）互通，便于多语言系统协作；</li>
</ul>
</li>
</ul>
<h3 id="（2）Headers类的定义"><a href="#（2）Headers类的定义" class="headerlink" title="（2）Headers类的定义"></a>（2）Headers类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Headers &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Headers</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 单个 Header 对象（键值对 + 错误码）</span></span><br><span class="line"><span class="comment">     * @remark 不支持动态分配（new）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Header</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @brief 构造 Header</span></span><br><span class="line"><span class="comment">         * @param key    Header 的键（字符串）</span></span><br><span class="line"><span class="comment">         * @param value  Header 的值（二进制，可为 NULL）</span></span><br><span class="line"><span class="comment">         * @param value_size  值的字节长度</span></span><br><span class="line"><span class="comment">         * @remark key 和 value 会被复制</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">Header</span>(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> value_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @brief 构造 Header（带错误码）</span></span><br><span class="line"><span class="comment">         * @param key    Header 的键</span></span><br><span class="line"><span class="comment">         * @param value  Header 的值</span></span><br><span class="line"><span class="comment">         * @param value_size  值的字节长度</span></span><br><span class="line"><span class="comment">         * @param err    错误码（用于 get_last() 内部构造失败结果）</span></span><br><span class="line"><span class="comment">         * @remark 若 err != ERR_NO_ERROR，value 和 value_size 字段未定义</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">Header</span>(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> value_size, </span><br><span class="line">               <span class="type">const</span> RdKafka::ErrorCode err);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Header</span>(<span class="type">const</span> Header &amp;other);              <span class="comment">// 拷贝构造</span></span><br><span class="line">        Header &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Header &amp;other);   <span class="comment">// 赋值运算符</span></span><br><span class="line">        ~<span class="built_in">Header</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">key</span><span class="params">()</span> <span class="type">const</span></span>;                  <span class="comment">// 获取键名</span></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">void</span> *<span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 获取二进制值（可能为 NULL）</span></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">value_string</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">// 获取值并转为 C 字符串（可能为 NULL）</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">value_size</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 获取值的字节长度</span></span><br><span class="line">        <span class="function">RdKafka::ErrorCode <span class="title">err</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// 获取错误码（通常为 ERR_NO_ERROR）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">char</span> *<span class="title">copy_value</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> value_size)</span></span>;</span><br><span class="line">        std::string key_;</span><br><span class="line">        RdKafka::ErrorCode err_;</span><br><span class="line">        <span class="type">char</span> *value_;</span><br><span class="line">        <span class="type">size_t</span> value_size_;</span><br><span class="line">        <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;               <span class="comment">// 禁止动态分配</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建空的 Headers 对象</span></span><br><span class="line"><span class="comment">     * @returns 空 Headers 列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Headers *<span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从 std::vector 创建 Headers 对象</span></span><br><span class="line"><span class="comment">     * @param headers  Header 向量（会被复制，非引用）</span></span><br><span class="line"><span class="comment">     * @returns Headers 列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Headers *<span class="title">create</span><span class="params">(<span class="type">const</span> std::vector&lt;Header&gt; &amp;headers)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加 Header（二进制值）</span></span><br><span class="line"><span class="comment">     * @param key    键名</span></span><br><span class="line"><span class="comment">     * @param value  二进制值（可为 NULL）</span></span><br><span class="line"><span class="comment">     * @param value_size  值的字节长度</span></span><br><span class="line"><span class="comment">     * @returns 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">add</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> value_size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加 Header（字符串值，便捷方法）</span></span><br><span class="line"><span class="comment">     * @param key    键名</span></span><br><span class="line"><span class="comment">     * @param value  字符串值</span></span><br><span class="line"><span class="comment">     * @returns 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">add</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加 Header（复制已有 Header 对象）</span></span><br><span class="line"><span class="comment">     * @param header  要复制的 Header</span></span><br><span class="line"><span class="comment">     * @returns 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">add</span><span class="params">(<span class="type">const</span> Header &amp;header)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 移除指定 key 的所有 Header</span></span><br><span class="line"><span class="comment">     * @param key  要移除的键名</span></span><br><span class="line"><span class="comment">     * @returns 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">remove</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取指定 key 的所有 Header</span></span><br><span class="line"><span class="comment">     * @param key  键名</span></span><br><span class="line"><span class="comment">     * @returns 包含所有匹配 Header 的向量（支持重复 key）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;Header&gt; <span class="title">get</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取指定 key 的最后一个 Header</span></span><br><span class="line"><span class="comment">     * @param key  键名</span></span><br><span class="line"><span class="comment">     * @returns 找到则返回 Header，未找到则返回 err=ERR__NOENT 的 Header</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Header <span class="title">get_last</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取所有 Header</span></span><br><span class="line"><span class="comment">     * @returns 包含所有 Header 的向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;Header&gt; <span class="title">get_all</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取 Header 数量</span></span><br><span class="line"><span class="comment">     * @returns Header 个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）使用示例"><a href="#（3）使用示例" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><h4 id="生产者写入-Headers-示例"><a href="#生产者写入-Headers-示例" class="headerlink" title="&lt;1&gt;生产者写入 Headers 示例"></a>&lt;1&gt;生产者写入 Headers 示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 Headers 对象</span></span><br><span class="line">RdKafka::Headers *headers = RdKafka::Headers::<span class="built_in">create</span>();</span><br><span class="line"><span class="keyword">if</span> (!headers) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;创建 Headers 失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加键值对（支持多组）</span></span><br><span class="line">headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;trace-id&quot;</span>, <span class="string">&quot;trace-789012&quot;</span>);              <span class="comment">// 字符串重载（推荐）</span></span><br><span class="line">headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;msg-type&quot;</span>, <span class="string">&quot;payment&quot;</span>);                   <span class="comment">// 字符串重载</span></span><br><span class="line">headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;timestamp&quot;</span>, std::<span class="built_in">to_string</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>)));  <span class="comment">// 字符串重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用二进制形式</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* binary_data = <span class="string">&quot;binary-value&quot;</span>;</span><br><span class="line">headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;binary-key&quot;</span>, binary_data, <span class="built_in">strlen</span>(binary_data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 发送消息时附加 Headers</span></span><br><span class="line">std::string payload = <span class="string">&quot;order-payload&quot;</span>;</span><br><span class="line">std::string key = <span class="string">&quot;order-key&quot;</span>;</span><br><span class="line">RdKafka::ErrorCode err = producer-&gt;<span class="built_in">produce</span>(</span><br><span class="line">    <span class="string">&quot;my-topic&quot;</span>,</span><br><span class="line">    RdKafka::Topic::PARTITION_UA,</span><br><span class="line">    RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">    (<span class="type">void</span>*)payload.<span class="built_in">data</span>(), <span class="number">13</span>,</span><br><span class="line">    key.<span class="built_in">data</span>(), <span class="number">9</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    headers,    <span class="comment">// 附加消息头</span></span><br><span class="line">    <span class="literal">nullptr</span>     <span class="comment">// opaque</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;发送失败：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> headers;  <span class="comment">// ⚠️ produce() 失败时需手动释放</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// ⚠️ produce() 成功后，headers 所有权转移给 librdkafka，无需手动 delete</span></span><br></pre></td></tr></table></figure>

<h4 id="消费者读取-Headers-示例"><a href="#消费者读取-Headers-示例" class="headerlink" title="&lt;2&gt;消费者读取 Headers 示例"></a>&lt;2&gt;消费者读取 Headers 示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费消息并读取 Headers</span></span><br><span class="line">RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (!msg || msg-&gt;<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">delete</span> msg;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取消息的 Headers 对象（无 Headers 则返回 nullptr）</span></span><br><span class="line">RdKafka::Headers *headers = msg-&gt;<span class="built_in">headers</span>();</span><br><span class="line"><span class="keyword">if</span> (headers) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;消息头数量：&quot;</span> &lt;&lt; headers-&gt;<span class="built_in">size</span>() &lt;&lt; std::endl;  <span class="comment">// ✅ 用 size()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 读取指定 key 的所有值（支持重复 key）</span></span><br><span class="line">    std::vector&lt;RdKafka::Headers::Header&gt; trace_headers = headers-&gt;<span class="built_in">get</span>(<span class="string">&quot;trace-id&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; h : trace_headers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h.<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;trace-id：&quot;</span> &lt;&lt; h.<span class="built_in">value_string</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 读取指定 key 的最后一个值</span></span><br><span class="line">    RdKafka::Headers::Header last_trace = headers-&gt;<span class="built_in">get_last</span>(<span class="string">&quot;trace-id&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (last_trace.<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个 trace-id：&quot;</span> &lt;&lt; last_trace.<span class="built_in">value_string</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到 trace-id&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 遍历所有 Headers</span></span><br><span class="line">    std::vector&lt;RdKafka::Headers::Header&gt; all_headers = headers-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; all_headers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; h = all_headers[i];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Header[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]：&quot;</span> &lt;&lt; h.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (h.<span class="built_in">value</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; h.<span class="built_in">value_string</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;(null)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;该消息无消息头&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> msg;</span><br></pre></td></tr></table></figure>

<h3 id="（4）核心注意事项"><a href="#（4）核心注意事项" class="headerlink" title="（4）核心注意事项"></a>（4）核心注意事项</h3><ul>
<li><strong>内存管理</strong>：<ul>
<li><strong>生产者侧</strong>：create() 创建的 Headers<ul>
<li>若 produce() <strong>成功</strong>：则所有权转移给 librdkafka，<strong>无需手动释放</strong>；</li>
<li>若 produce() <strong>失败</strong>：则<strong>需手动 delete</strong>；</li>
</ul>
</li>
<li><strong>消费者</strong>侧从 msg-&gt;headers() 获取的 Headers 由 Message 对象管理<ul>
<li><strong>无需手动释放</strong>（释放 Message 时自动释放）；</li>
</ul>
</li>
</ul>
</li>
<li><strong>空值处理</strong>：<ul>
<li>Header 的 Value 可以为空（value&#x3D;nullptr，value_len&#x3D;0），需在读取时判断 val 是否为 nullptr；</li>
</ul>
</li>
<li><strong>get_last() 错误处理</strong>：<ul>
<li>未找到时返回 err&#x3D;ERR__NOENT 的 Header，需检查 h.err() 后再使用 value()；</li>
</ul>
</li>
<li><strong>性能影响</strong>：<ul>
<li>Headers 会增加消息体积，建议单条消息的 Headers 总大小不超过 1KB，避免影响吞吐量。</li>
</ul>
</li>
</ul>
<h2 id="5-Handle类（句柄基类）"><a href="#5-Handle类（句柄基类）" class="headerlink" title="5.Handle类（句柄基类）"></a>5.Handle类（句柄基类）</h2><h3 id="（1）概述-2"><a href="#（1）概述-2" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Handle 是 librdkafka 中<strong>生产者和消费者客户端</strong>（Producer &#x2F; Consumer &#x2F; KafkaConsumer）<strong>的抽象基类</strong><ul>
<li><strong>定义了客户端的通用能力</strong>（事件轮询（poll）、元数据&#x2F;偏移量查询、流控（pause&#x2F;resume）、集群信息获取等），是整个 librdkafka 客户端的 “基础骨架”</li>
<li><strong>生产者和消费者客户端</strong>（如 Producer、Consumer、KafkaConsumer）均继承自 Handle，因此<strong>具备统一的基础行为</strong>。</li>
</ul>
</li>
</ul>
<h4 id="核心定位-2"><a href="#核心定位-2" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>抽象通用能力</strong>：<ul>
<li>提取生产者、消费者的共性操作（如配置获取、错误码转换、资源销毁），避免代码冗余；</li>
</ul>
</li>
<li><strong>生命周期管理</strong>：<ul>
<li>定义客户端的创建 &#x2F; 销毁规范，统一管理与 Kafka 集群的连接资源；</li>
</ul>
</li>
<li><strong>状态与配置统一</strong>：<ul>
<li>提供全局的配置查询、错误处理、日志相关接口，保证不同客户端的使用体验一致；</li>
</ul>
</li>
<li><strong>纯抽象类特性</strong>：<ul>
<li>Handle 包含纯虚函数，无法直接实例化，仅能通过子类（Producer&#x2F;Consumer&#x2F;KafkaConsumer）使用其接口。</li>
</ul>
</li>
</ul>
<h3 id="（2）Handle-类的定义"><a href="#（2）Handle-类的定义" class="headerlink" title="（2）Handle 类的定义"></a>（2）Handle 类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Handle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handle</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第一梯队】几乎每个应用都会用到</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 轮询事件</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间（毫秒）</span></span><br><span class="line"><span class="comment">         - 0：非阻塞，立即返回（处理已就绪的事件）</span></span><br><span class="line"><span class="comment">         - 大于0：最多等待 timeout_ms 毫秒，有事件则提前返回 （推荐：100 ~ 1000）</span></span><br><span class="line"><span class="comment">         - -1：无限阻塞，直到有事件发生</span></span><br><span class="line"><span class="comment">     * @returns 处理的事件数量</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 触发已注册的回调函数（如 DeliveryCb、EventCb）</span></span><br><span class="line"><span class="comment">         - 1. 检查内部事件队列</span></span><br><span class="line"><span class="comment">         - 2. 如果有待处理事件 → 触发对应回调 → 立即返回</span></span><br><span class="line"><span class="comment">         - 3. 如果没有事件 → 等待最多 timeout 毫秒</span></span><br><span class="line"><span class="comment">         - 4. 返回本次处理的事件数量</span></span><br><span class="line"><span class="comment">     * @warning 禁止在 KafkaConsumer 中使用，应使用 consume() 代替</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取客户端名称</span></span><br><span class="line"><span class="comment">     * @returns 客户端名称字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取待发送/待确认的消息队列长度</span></span><br><span class="line"><span class="comment">     * @returns 队列中的消息数量</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 常用于优雅关闭时等待所有消息发送完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">outq_len</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第二梯队】元数据与偏移量查询（常用）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从 Broker 请求元数据</span></span><br><span class="line"><span class="comment">     * @param all_topics   true=请求所有 Topic，false=仅本地已知 Topic</span></span><br><span class="line"><span class="comment">     * @param only_rkt     仅请求指定 Topic 的元数据（可为 NULL）</span></span><br><span class="line"><span class="comment">     * @param metadatap    [out] 元数据结果指针，需用 delete 释放</span></span><br><span class="line"><span class="comment">     * @param timeout_ms   超时时间（毫秒）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，ERR__TIMED_OUT 超时，其他为错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">metadata</span><span class="params">(<span class="type">bool</span> all_topics,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Topic *only_rkt,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Metadata **metadatap,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 查询分区的水位偏移量（从 Broker 实时查询）</span></span><br><span class="line"><span class="comment">     * @param topic      Topic 名称</span></span><br><span class="line"><span class="comment">     * @param partition  分区号</span></span><br><span class="line"><span class="comment">     * @param low        [out] 最低偏移量（最早消息）</span></span><br><span class="line"><span class="comment">     * @param high       [out] 最高偏移量（最新消息）</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，其他为错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">query_watermark_offsets</span><span class="params">(<span class="type">const</span> std::string &amp;topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int64_t</span> *low,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int64_t</span> *high,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取缓存的分区水位偏移量（本地缓存，不请求 Broker）</span></span><br><span class="line"><span class="comment">     * @param topic      Topic 名称</span></span><br><span class="line"><span class="comment">     * @param partition  分区号</span></span><br><span class="line"><span class="comment">     * @param low        [out] 最低偏移量</span></span><br><span class="line"><span class="comment">     * @param high       [out] 最高偏移量</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，其他为错误码</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅适用于活跃的消费者实例</span></span><br><span class="line"><span class="comment">     * @remark 无缓存时返回 OFFSET_INVALID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">get_watermark_offsets</span><span class="params">(<span class="type">const</span> std::string &amp;topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int64_t</span> *low,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int64_t</span> *high)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 根据时间戳查找偏移量</span></span><br><span class="line"><span class="comment">     * @param offsets    [in/out] TopicPartition 列表，输入 offset 字段为时间戳，</span></span><br><span class="line"><span class="comment">     *                   输出 offset 字段为对应偏移量</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功（可能有部分分区失败，需检查各分区的 err()）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 时间戳为毫秒级 Unix 时间戳（UTC）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">offsetsForTimes</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;offsets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第三梯队】流控与集群信息</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 暂停指定分区的生产/消费</span></span><br><span class="line"><span class="comment">     * @param partitions 分区列表，每个分区的结果会写入其 err() 字段</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">pause</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 恢复指定分区的生产/消费</span></span><br><span class="line"><span class="comment">     * @param partitions 分区列表，每个分区的结果会写入其 err() 字段</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">resume</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取 Kafka 集群 ID</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 无缓存时的最大等待时间，0=非阻塞</span></span><br><span class="line"><span class="comment">     * @returns 集群 ID 字符串，失败返回空字符串</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 要求 Broker 版本 &gt;= 0.10.0 且 api.version.request=true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">clusterid</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前 Controller Broker 的 ID</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 无缓存时的最大等待时间</span></span><br><span class="line"><span class="comment">     * @returns Controller ID，失败返回 -1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 要求 Broker 版本 &gt;= 0.10.0 且 api.version.request=true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">controllerid</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取消费者的组成员 ID</span></span><br><span class="line"><span class="comment">     * @returns 成员 ID，非组成员时返回空字符串</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅适用于高级消费者（KafkaConsumer）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">memberid</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第四梯队】队列管理与回调控制</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取指定分区的 Fetch 队列</span></span><br><span class="line"><span class="comment">     * @param partition 分区对象</span></span><br><span class="line"><span class="comment">     * @returns 队列指针，失败返回 NULL</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅适用于消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Queue *<span class="title">get_partition_queue</span><span class="params">(<span class="type">const</span> TopicPartition *partition)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 将日志转发到指定队列</span></span><br><span class="line"><span class="comment">     * @param queue 目标队列，NULL 表示转发到主队列</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 需同时设置配置项 log.queue=true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">set_log_queue</span><span class="params">(Queue *queue)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取后台线程队列</span></span><br><span class="line"><span class="comment">     * @returns 后台队列指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Queue *<span class="title">get_background_queue</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 取消当前的回调分发（立即从 poll/consume 返回）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 只能在 librdkafka 回调函数内部调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">yield</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第五梯队】错误处理与认证（特定场景）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取首个致命错误</span></span><br><span class="line"><span class="comment">     * @param errstr [out] 错误描述字符串</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 表示无致命错误，其他为错误码</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 主要用于幂等生产者的错误检测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">fatal_error</span><span class="params">(std::string &amp;errstr)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置 SASL PLAIN/SCRAM 认证凭据</span></span><br><span class="line"><span class="comment">     * @param username 用户名</span></span><br><span class="line"><span class="comment">     * @param password 密码</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 新凭据在下次认证时生效，不会断开现有连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">sasl_set_credentials</span><span class="params">(<span class="type">const</span> std::string &amp;username,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> std::string &amp;password)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置 SASL/OAUTHBEARER Token</span></span><br><span class="line"><span class="comment">     * @param token_value      Token 值（通常为 JWS 格式）</span></span><br><span class="line"><span class="comment">     * @param md_lifetime_ms   Token 过期时间（毫秒级 Unix 时间戳）</span></span><br><span class="line"><span class="comment">     * @param md_principal_name Kafka Principal 名称</span></span><br><span class="line"><span class="comment">     * @param extensions       扩展键值对列表（key1, value1, key2, value2...）</span></span><br><span class="line"><span class="comment">     * @param errstr           [out] 错误描述</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，ERR__INVALID_ARG 参数错误，</span></span><br><span class="line"><span class="comment">     *          ERR__NOT_IMPLEMENTED 不支持，ERR__STATE 未配置 OAUTHBEARER</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">oauthbearer_set_token</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string &amp;token_value,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> md_lifetime_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string &amp;md_principal_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::list&lt;std::string&gt; &amp;extensions,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 标记 SASL/OAUTHBEARER Token 刷新失败</span></span><br><span class="line"><span class="comment">     * @param errstr 失败原因描述</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">oauthbearer_set_token_failure</span><span class="params">(<span class="type">const</span> std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 在后台线程启用 SASL OAUTHBEARER 刷新回调</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 适用于不定期调用 poll() 的应用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">sasl_background_callbacks_enable</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取 SASL 回调队列</span></span><br><span class="line"><span class="comment">     * @returns 队列指针，未启用时返回 NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Queue *<span class="title">get_sasl_queue</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第六梯队】底层操作（高级用法）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取底层 C 语言句柄</span></span><br><span class="line"><span class="comment">     * @returns rd_kafka_t* 指针</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @warning 不推荐直接调用 C API，无官方支持</span></span><br><span class="line"><span class="comment">     * @remark 需在 rdkafkacpp.h 之前包含 rdkafka.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">struct</span> <span class="title class_">rd_kafka_s</span> *<span class="built_in">c_ptr</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 使用 librdkafka 的分配器申请内存</span></span><br><span class="line"><span class="comment">     * @param size 字节数</span></span><br><span class="line"><span class="comment">     * @returns 内存指针</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须使用 mem_free() 释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">mem_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 释放 librdkafka 返回的内存</span></span><br><span class="line"><span class="comment">     * @param ptr 内存指针</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅用于 API 明确说明需使用此函数释放的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）核心特性与注意事项"><a href="#（3）核心特性与注意事项" class="headerlink" title="（3）核心特性与注意事项"></a>（3）核心特性与注意事项</h3><ul>
<li><strong>继承关系</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RdKafka::Handle（抽象基类）</span><br><span class="line">├─ RdKafka::Producer          <span class="comment">// 生产者</span></span><br><span class="line">├─ RdKafka::Consumer          <span class="comment">// 低级消费者（Simple Consumer，很少用）</span></span><br><span class="line">└─ RdKafka::KafkaConsumer     <span class="comment">// 高级消费者（High-Level Consumer，90%+用它）</span></span><br><span class="line"></span><br><span class="line">RdKafka::AdminClient          <span class="comment">// 管理客户端（独立，不继承 Handle）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>资源管理</strong>：</p>
<ul>
<li>客户端实例由 Conf::create() + Producer&#x2F;KafkaConsumer::create() 创建</li>
<li>必须通过 delete 释放</li>
</ul>
</li>
<li><p>Handle 内部管理与 Broker 的连接池、IO 线程、定时器，销毁时会自动清理所有资源，避免内存泄漏。</p>
</li>
<li><p><strong>线程模型</strong>：</p>
<ul>
<li>Handle 子类会启动内部 IO 线程（默认 1 个，可通过 io_threads 配置），处理网络通信、消息发送 &#x2F; 接收；</li>
<li>业务线程调用 poll()&#x2F;produce() 等 API 时，仅触发逻辑调度，核心 IO 由内部线程处理。</li>
</ul>
</li>
</ul>
<h2 id="6-Producer类（生产者类）"><a href="#6-Producer类（生产者类）" class="headerlink" title="6.Producer类（生产者类）"></a>6.Producer类（生产者类）</h2><h3 id="（1）概述-3"><a href="#（1）概述-3" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Producer 是 librdkafka 中实现 Kafka <strong>“消息生产逻辑”的核心类</strong>，继承自 RdKafka::Handle 抽象基类</li>
<li>封装了消息异步发送、分区路由、回调通知、资源管理等全量生产能力，是<strong>客户端向 Kafka 集群发送消息的唯一入口</strong>。</li>
</ul>
<h4 id="核心定位-3"><a href="#核心定位-3" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>异步发送</strong>：<ul>
<li>默认采用 “<strong>异步非阻塞</strong>” 模式，<strong>produce()</strong> 仅将消息放入<strong>本地队列</strong>，由内部 IO 线程发送至 Broker</li>
<li>仅 flush()&#x2F; 同步发送会阻塞</li>
</ul>
</li>
<li><strong>回调驱动</strong>：<ul>
<li>通过 <strong>DeliveryReportCb</strong> “<strong>异步通知</strong>”消息发送结果（成功 &#x2F; 失败）</li>
</ul>
</li>
<li><strong>分区路由</strong>：<ul>
<li>支持<strong>内置分区器</strong>（按 Key 哈希 &#x2F; 随机）或<strong>自定义分区器</strong>（PartitionerCb）</li>
</ul>
</li>
<li><strong>资源管理</strong>：<ul>
<li>继承 Handle 基类的生命周期管理能力，通过 <strong>delete</strong> 或 <strong>flush() + delete</strong> 安全释放连接、线程、队列等资源</li>
</ul>
</li>
<li><strong>高可用设计</strong>：<ul>
<li>支持<strong>消息重试</strong>、<strong>批量发送</strong>、<strong>压缩</strong>（gzip&#x2F;snappy&#x2F;lz4），提升吞吐量和可靠性</li>
</ul>
</li>
<li><strong>可靠性</strong>：<ul>
<li>支持消息重试（retries）、ACK 确认（acks）、幂等 &#x2F; 事务（需配置）；</li>
</ul>
</li>
<li><strong>高性能</strong>：<ul>
<li>支持批量发送（batch.size）、异步 IO，减少网络请求次数；</li>
</ul>
</li>
</ul>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="&lt;3&gt;继承关系"></a>&lt;3&gt;继承关系</h4><ul>
<li>Producer 继承自 Handle 抽象基类，因此具备以下 Handle 通用能力：<ul>
<li><strong>poll()</strong>：轮询事件，触发回调（<strong>生产者必须定期调用</strong>）</li>
<li><strong>name()</strong>：获取客户端名称</li>
<li><strong>outq_len()</strong>：获取待发送消息队列长度</li>
<li>元数据查询、流控等其他 Handle 方法</li>
</ul>
</li>
</ul>
<h3 id="（2）Producer类的定义"><a href="#（2）Producer类的定义" class="headerlink" title="（2）Producer类的定义"></a>（2）Producer类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Producer : <span class="keyword">public</span> <span class="keyword">virtual</span> Handle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第一梯队】几乎每个生产者应用都会用到</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建 Kafka 生产者实例</span></span><br><span class="line"><span class="comment">     * @param conf 配置对象（可选），不传则使用默认配置；配置对象可复用</span></span><br><span class="line"><span class="comment">     * @param errstr [out] 错误描述字符串</span></span><br><span class="line"><span class="comment">     * @returns 成功返回生产者实例，失败返回 NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Producer *<span class="title">create</span><span class="params">(<span class="type">const</span> Conf *conf, std::string &amp;errstr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Producer</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 消息标志位（用于 produce() 的 msgflags 参数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        <span class="comment">// ⚠️ 详情见类定义末尾</span></span><br><span class="line">        RK_MSG_FREE  = <span class="number">0x1</span>,  <span class="comment">/**&lt; librdkafka 使用完 payload 后会自动 free()</span></span><br><span class="line"><span class="comment">                              *   与 RK_MSG_COPY 互斥 */</span></span><br><span class="line">        RK_MSG_COPY  = <span class="number">0x2</span>,  <span class="comment">/**&lt; librdkafka 会复制 payload 数据，</span></span><br><span class="line"><span class="comment">                              *   调用返回后不再使用原指针</span></span><br><span class="line"><span class="comment">                              *   与 RK_MSG_FREE 互斥 */</span></span><br><span class="line">        RK_MSG_BLOCK = <span class="number">0x4</span>   <span class="comment">/**&lt; 当消息队列满时阻塞 produce() 调用</span></span><br><span class="line"><span class="comment">                              *   警告：使用时必须在另一个线程调用 poll()</span></span><br><span class="line"><span class="comment">                              *   否则会导致无限阻塞 */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 生产并发送单条消息到 Broker（异步非阻塞）</span></span><br><span class="line"><span class="comment">     * @param topic      Topic 对象</span></span><br><span class="line"><span class="comment">     * @param partition  目标分区：PARTITION_UA 自动分区(不手动指定分区，让 librdkafka 根据 key 自动决定)，</span></span><br><span class="line"><span class="comment">         或 0..N 手动指定分区</span></span><br><span class="line"><span class="comment">     * @param msgflags   消息标志：RK_MSG_FREE / RK_MSG_COPY / RK_MSG_BLOCK (⚠️ 详情见类定义末尾)</span></span><br><span class="line"><span class="comment">     * @param payload    消息内容指针</span></span><br><span class="line"><span class="comment">     * @param len        消息长度（字节）</span></span><br><span class="line"><span class="comment">     * @param key        消息 Key（可选），用于分区选择和传递给消费者</span></span><br><span class="line"><span class="comment">     * @param msg_opaque 用户自定义指针，会在投递回调中返回</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功入队</span></span><br><span class="line"><span class="comment">     *          ERR__QUEUE_FULL 队列满</span></span><br><span class="line"><span class="comment">     *          ERR_MSG_SIZE_TOO_LARGE 消息过大</span></span><br><span class="line"><span class="comment">     *          ERR__UNKNOWN_PARTITION / ERR__UNKNOWN_TOPIC 未知分区/Topic</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 若返回错误且使用了 RK_MSG_FREE，调用方仍需负责释放 payload</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(Topic *topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> msgflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> std::string *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief produce() 重载：Key 使用指针+长度形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(Topic *topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> msgflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">void</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief produce() 重载：Topic 使用字符串，支持指定时间戳（推荐）</span></span><br><span class="line"><span class="comment">     * @param topic_name Topic 名称（无需创建 Topic 对象）</span></span><br><span class="line"><span class="comment">     * @param timestamp  消息时间戳（毫秒级 Unix 时间戳，UTC）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(<span class="type">const</span> std::string topic_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> msgflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">void</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int64_t</span> timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief produce() 重载：支持消息头（Headers）</span></span><br><span class="line"><span class="comment">     * @param headers 消息头对象，成功时会被释放，失败时保持不变</span></span><br><span class="line"><span class="comment">     * @warning 成功调用后 headers 会被自动释放，失败时需调用方处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(<span class="type">const</span> std::string topic_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> msgflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">void</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int64_t</span> timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RdKafka::Headers *headers,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief produce() 重载：使用 vector 传递 key 和 payload（自动复制）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(Topic *topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt; *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt; *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 等待所有待发送消息完成（刷新）</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间（毫秒）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 全部完成，ERR__TIMED_OUT 超时</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 销毁生产者前应调用此方法，确保所有消息发送完成</span></span><br><span class="line"><span class="comment">     * @remark 会忽略 linger.ms 配置，立即发送队列中的消息</span></span><br><span class="line"><span class="comment">     * @remark 内部会调用 poll()，因此会触发回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">flush</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第二梯队】特殊场景使用</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 清除生产者当前处理的消息</span></span><br><span class="line"><span class="comment">     * @param purge_flags 清除标志</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 清除后需调用 poll() 或 flush() 处理投递报告回调</span></span><br><span class="line"><span class="comment">     * @remark 队列中的消息会收到 ERR__PURGE_QUEUE 错误</span></span><br><span class="line"><span class="comment">     * @remark 传输中的消息会收到 ERR__PURGE_INFLIGHT 错误</span></span><br><span class="line"><span class="comment">     * @warning 清除传输中消息会导致无法确认消息是否成功，可能产生重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">purge</span><span class="params">(<span class="type">int</span> purge_flags)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 清除标志位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        PURGE_QUEUE        = <span class="number">0x1</span>,  <span class="comment">/**&lt; 清除内部队列中的消息 */</span></span><br><span class="line">        PURGE_INFLIGHT     = <span class="number">0x2</span>,  <span class="comment">/**&lt; 清除传输中的消息（可能导致重复） */</span></span><br><span class="line">        PURGE_NON_BLOCKING = <span class="number">0x4</span>   <span class="comment">/**&lt; 不等待后台队列清除完成 */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第三梯队】事务 API（需要 Broker &gt;= 0.11.0）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 初始化事务</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 最大阻塞时间，超时后可在后台继续，允许重试</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 使用事务前必须先调用此方法（仅需一次）</span></span><br><span class="line"><span class="comment">     * @remark 通过 Error::is_retriable() 判断是否可重试</span></span><br><span class="line"><span class="comment">     * @remark 通过 Error::is_fatal() 判断是否为致命错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">init_transactions</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 开始新事务</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须先调用 init_transactions() 成功后才能使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">begin_transaction</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 提交当前事务</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 最大阻塞时间，-1 表示使用剩余事务超时时间（推荐）</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 强烈建议 timeout_ms 传 -1</span></span><br><span class="line"><span class="comment">     * @remark 提交前会自动 flush 所有待发送消息</span></span><br><span class="line"><span class="comment">     * @remark 通过 Error::txn_requires_abort() 判断是否需要中止事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">commit_transaction</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 中止当前事务</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 最大阻塞时间，-1 表示使用剩余事务超时时间（推荐）</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 用于从可中止的事务错误中恢复</span></span><br><span class="line"><span class="comment">     * @remark 会清除所有待发送消息，触发 ERR__PURGE_INFLIGHT/QUEUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">abort_transaction</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 发送消费偏移量到事务（Consume-Transform-Produce 模式）</span></span><br><span class="line"><span class="comment">     * @param offsets        要提交的偏移量列表（应为下一条要消费的偏移量）</span></span><br><span class="line"><span class="comment">     * @param group_metadata 消费者组元数据（从 KafkaConsumer::groupMetadata() 获取）</span></span><br><span class="line"><span class="comment">     * @param timeout_ms     最大阻塞时间</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须在生产者实例上调用，不是消费者</span></span><br><span class="line"><span class="comment">     * @remark 消费者必须禁用自动提交（enable.auto.commit=false）</span></span><br><span class="line"><span class="comment">     * @remark 在 commit_transaction() 之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">send_offsets_to_transaction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;offsets,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ConsumerGroupMetadata *group_metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│  RK_MSG_COPY（推荐）                                            │</span><br><span class="line">│  ─────────────────                                              │</span><br><span class="line">│  • librdkafka 立即复制你的数据到内部缓冲区                       │</span><br><span class="line">│  • <span class="built_in">produce</span>() 返回后，你的 payload 可以立即释放/修改              │</span><br><span class="line">│  • 代价：多一次内存拷贝                                          │</span><br><span class="line">│                                                                  │</span><br><span class="line">│  你的代码               librdkafka                              │</span><br><span class="line">│  ┌────────┐   复制    ┌────────────┐                            │</span><br><span class="line">│  │payload │ ───────► │ 内部缓冲区 │ ────► Kafka                 │</span><br><span class="line">│  └────────┘          └────────────┘                             │</span><br><span class="line">│      ↓                                                          │</span><br><span class="line">│  <span class="built_in">produce</span>()返回后                                                 │</span><br><span class="line">│  你可以 <span class="keyword">delete</span> payload                                          │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│  RK_MSG_FREE（零拷贝，但危险）                                   │</span><br><span class="line">│  ──────────────────────────                                      │</span><br><span class="line">│  • librdkafka 不复制，直接使用你的指针                           │</span><br><span class="line">│  • 发送完成后，librdkafka 会调用 <span class="built_in">free</span>(payload)                   │</span><br><span class="line">│  • 你必须用 <span class="built_in">malloc</span>() 分配，不能用 <span class="keyword">new</span>/栈/string                  │</span><br><span class="line">│  • <span class="built_in">produce</span>() 返回后，你不能再访问 payload！                      │</span><br><span class="line">│                                                                  │</span><br><span class="line">│  你的代码               librdkafka                              │</span><br><span class="line">│  ┌────────┐   直接使用  ┌────────────┐                          │</span><br><span class="line">│  │payload │ ──────────►│   待发送   │ ────► Kafka              │</span><br><span class="line">│  └────────┘            └────────────┘                           │</span><br><span class="line">│      ↑                       ↓                                  │</span><br><span class="line">│  不能再访问！            发送完成后                              │</span><br><span class="line">│                         <span class="built_in">free</span>(payload) ← librdkafka 自动调用     │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│  RK_MSG_BLOCK（阻塞模式）                                        │</span><br><span class="line">│  ──────────────────────                                          │</span><br><span class="line">│  • 与上面两个正交，可组合使用                                     │</span><br><span class="line">│  • 当内部队列满时：                                              │</span><br><span class="line">│    - 不加此标志：<span class="built_in">produce</span>() 立即返回错误 ERR__QUEUE_FULL         │</span><br><span class="line">│    - 加此标志：<span class="built_in">produce</span>() 阻塞等待队列有空间                      │</span><br><span class="line">│  • ⚠️ 必须有另一个线程调用 <span class="built_in">poll</span>()，否则死锁！                    │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（3）核心配置"><a href="#（3）核心配置" class="headerlink" title="（3）核心配置"></a>（3）核心配置</h3><p><a href="#config">全局配置</a><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116154712623.png"></p>
<h3 id="（4）使用示例"><a href="#（4）使用示例" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><h4 id="异步发送示例（生产环境首选）"><a href="#异步发送示例（生产环境首选）" class="headerlink" title="&lt;1&gt;异步发送示例（生产环境首选）"></a>&lt;1&gt;异步发送示例（生产环境首选）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 全局标志：控制生产者退出</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> run = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义投递结果回调（继承 DeliveryReportCb）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeliveryReportCb</span> : <span class="keyword">public</span> RdKafka::DeliveryReportCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dr_cb</span><span class="params">(RdKafka::Message &amp;msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理消息发送结果</span></span><br><span class="line">        <span class="keyword">if</span> (msg.<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 发送失败</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[发送失败] Topic：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 错误：&quot;</span> &lt;&lt; msg.<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 可选：获取失败消息的 Key/内容（需设置 RK_MSG_COPY）</span></span><br><span class="line">            std::string key_str = msg.<span class="built_in">key</span>() ? *msg.<span class="built_in">key</span>() : <span class="string">&quot;无Key&quot;</span>;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;  Key：&quot;</span> &lt;&lt; key_str &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送成功</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[发送成功] Topic：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 偏移量：&quot;</span> &lt;&lt; msg.<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理：优雅退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigterm</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    run = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ========== 1. 初始化配置 ==========</span></span><br><span class="line">    std::string errstr;</span><br><span class="line">    <span class="comment">// 创建全局配置（CONF_GLOBAL）</span></span><br><span class="line">    RdKafka::Conf *global_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    <span class="comment">// 创建主题配置（CONF_TOPIC，可选）</span></span><br><span class="line">    RdKafka::Conf *topic_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_TOPIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置核心参数</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr); <span class="comment">// 必填</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;order-producer-01&quot;</span>, errstr);      <span class="comment">// 生产者标识</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>, errstr);                           <span class="comment">// ACK级别：Leader确认</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;3&quot;</span>, errstr);                        <span class="comment">// 重试3次</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.size&quot;</span>, <span class="string">&quot;16384&quot;</span>, errstr);                 <span class="comment">// 批量大小16KB</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;linger.ms&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr);                      <span class="comment">// 延迟5ms发送（批量）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定投递回调（核心：异步获取发送结果）</span></span><br><span class="line">    MyDeliveryReportCb dr_cb;</span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;dr_cb&quot;</span>, &amp;dr_cb, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 创建生产者实例 ==========</span></span><br><span class="line">    RdKafka::Producer *producer = RdKafka::Producer::<span class="built_in">create</span>(global_conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!producer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建生产者失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> global_conf;</span><br><span class="line">        <span class="keyword">delete</span> topic_conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放配置对象（生产者创建后，配置已拷贝，可释放）</span></span><br><span class="line">    <span class="keyword">delete</span> global_conf;</span><br><span class="line">    <span class="keyword">delete</span> topic_conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 注册信号处理（优雅退出） ==========</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 循环发送消息 ==========</span></span><br><span class="line">    <span class="type">int</span> msg_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (run &amp;&amp; msg_count &lt; <span class="number">10</span>) &#123; <span class="comment">// 发送10条测试消息</span></span><br><span class="line">        std::string msg_payload = <span class="string">&quot;order_&quot;</span> + std::<span class="built_in">to_string</span>(msg_count); <span class="comment">// 消息内容</span></span><br><span class="line">        std::string msg_key = <span class="string">&quot;user_1001&quot;</span>;                              <span class="comment">// 消息Key（用于分区路由）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消息头（可选，附加元数据）</span></span><br><span class="line">        RdKafka::Headers *headers = RdKafka::Headers::<span class="built_in">create</span>();</span><br><span class="line">        std::string trace_id = <span class="string">&quot;trace_789012&quot;</span>;</span><br><span class="line">        std::string msg_type = <span class="string">&quot;order_create&quot;</span>;</span><br><span class="line">        headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;trace-id&quot;</span>, trace_id.<span class="built_in">c_str</span>(), trace_id.<span class="built_in">size</span>());</span><br><span class="line">        headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;msg-type&quot;</span>, msg_type.<span class="built_in">c_str</span>(), msg_type.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步发送消息</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// - &quot;order_topic&quot;：目标Topic</span></span><br><span class="line">        <span class="comment">// - RdKafka::Topic::PARTITION_UA（-1）：自动分配分区（由分区器决定）</span></span><br><span class="line">        <span class="comment">// - RK_MSG_COPY：拷贝消息内容（避免本地内存释放导致问题）</span></span><br><span class="line">        <span class="comment">// - payload/len：消息内容及长度</span></span><br><span class="line">        <span class="comment">// - key/key_len：消息Key及长度</span></span><br><span class="line">        <span class="comment">// - 0：自定义时间戳（0=使用Broker时间）</span></span><br><span class="line">        <span class="comment">// - headers：消息头</span></span><br><span class="line">        <span class="comment">// - nullptr：透传上下文（msg_opaque）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步发送消息</span></span><br><span class="line">        RdKafka::ErrorCode err = producer-&gt;<span class="built_in">produce</span>(</span><br><span class="line">            <span class="string">&quot;order_topic&quot;</span>,</span><br><span class="line">            RdKafka::Topic::PARTITION_UA,</span><br><span class="line">            RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">            (<span class="type">void</span>*)msg_payload.<span class="built_in">data</span>(), msg_payload.<span class="built_in">size</span>(),</span><br><span class="line">            msg_key.<span class="built_in">data</span>(), msg_key.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="number">0</span>,       <span class="comment">// 时间戳</span></span><br><span class="line">            headers, <span class="comment">// 消息头</span></span><br><span class="line">            <span class="literal">nullptr</span>  <span class="comment">// msg_opaque</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚠️ produce成功调用后 headers 会被自动释放，失败时需手动释放</span></span><br><span class="line">        <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;发送消息失败（即时）：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">delete</span> headers;  <span class="comment">// produce 失败时需手动释放 headers</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 队列满时，等待并重试</span></span><br><span class="line">            <span class="keyword">if</span> (err == RdKafka::ERR__QUEUE_FULL) &#123;</span><br><span class="line">                producer-&gt;<span class="built_in">poll</span>(<span class="number">100</span>); <span class="comment">// 处理内部事件，腾出队列空间</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// produce() 成功：headers 已被 librdkafka 接管，禁止再 delete</span></span><br><span class="line">        <span class="comment">// ⚠️ 此时 headers 指针已失效，不要再使用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定期调用poll：驱动回调执行、处理重试（核心！异步发送必须调用）</span></span><br><span class="line">        producer-&gt;<span class="built_in">poll</span>(<span class="number">0</span>); <span class="comment">// 0ms超时：非阻塞处理</span></span><br><span class="line"></span><br><span class="line">        msg_count++;</span><br><span class="line">        <span class="comment">// 模拟业务延迟</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. 优雅关闭生产者 ==========</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;等待所有消息发送完成...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// flush：阻塞等待所有未发送的消息完成（超时5秒）</span></span><br><span class="line">    producer-&gt;<span class="built_in">flush</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有未发送完成的消息</span></span><br><span class="line">    <span class="keyword">if</span> (producer-&gt;<span class="built_in">outq_len</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;仍有 &quot;</span> &lt;&lt; producer-&gt;<span class="built_in">outq_len</span>() &lt;&lt; <span class="string">&quot; 条消息未发送完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 6. 释放资源 ==========</span></span><br><span class="line">    <span class="keyword">delete</span> producer; <span class="comment">// 释放生产者资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步发送示例（特殊场景使用）"><a href="#同步发送示例（特殊场景使用）" class="headerlink" title="&lt;2&gt;同步发送示例（特殊场景使用）"></a>&lt;2&gt;同步发送示例（特殊场景使用）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步发送：通过 msg_opaque 阻塞等待结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync_produce</span><span class="params">(RdKafka::Producer *producer, <span class="type">const</span> std::string &amp;topic, <span class="type">const</span> std::string &amp;payload)</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::ErrorCode err;</span><br><span class="line">    <span class="comment">// 用于阻塞的信号量</span></span><br><span class="line">    <span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息（msg_opaque 传递上下文）</span></span><br><span class="line">    err = producer-&gt;<span class="built_in">produce</span>(</span><br><span class="line">        topic,</span><br><span class="line">        RdKafka::Topic::PARTITION_UA,</span><br><span class="line">        RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">        (<span class="type">void</span>*)payload.<span class="built_in">data</span>(), payload.<span class="built_in">size</span>(),</span><br><span class="line">        <span class="literal">nullptr</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,        <span class="comment">// timestamp</span></span><br><span class="line">        <span class="literal">nullptr</span>,  <span class="comment">// headers</span></span><br><span class="line">        &amp;done     <span class="comment">// msg_opaque</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;同步发送失败：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待发送结果（轮询+sleep）</span></span><br><span class="line">    <span class="type">int</span> timeout = <span class="number">5000</span>; <span class="comment">// 5秒超时</span></span><br><span class="line">    <span class="type">int</span> poll_interval = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done &amp;&amp; timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        producer-&gt;<span class="built_in">poll</span>(poll_interval);</span><br><span class="line">        timeout -= poll_interval;</span><br><span class="line">        <span class="built_in">usleep</span>(poll_interval * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;同步发送超时&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需修改投递回调，设置 done 标志：</span></span><br><span class="line"><span class="comment">// void dr_cb(RdKafka::Message &amp;msg) override &#123;</span></span><br><span class="line"><span class="comment">//     bool *done = static_cast&lt;bool*&gt;(msg.opaque());</span></span><br><span class="line"><span class="comment">//     *done = true;</span></span><br><span class="line"><span class="comment">//     // ... 原有逻辑</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）关键注意事项"><a href="#（5）关键注意事项" class="headerlink" title="（5）关键注意事项"></a>（5）关键注意事项</h3><ul>
<li><p><strong>异步发送</strong>：</p>
<ul>
<li>produce() <strong>仅</strong>将消息写入<strong>本地环形队列</strong>，内部 IO 线程异步发送</li>
<li>返回 ERR_NO_ERROR <strong>仅代表 “入队成功”</strong>，<strong>不代表 “发送成功”</strong></li>
</ul>
</li>
<li><p><strong>poll () 必须调用</strong>：</p>
<ul>
<li>异步发送时，poll() 是<strong>驱动回调执行、处理重试、清理队列</strong>的核心，需定期调用（建议每次 produce() 后或定时调用）；</li>
<li>若不调用 poll()，<strong>回调不会执行，消息重试也会停滞</strong>，最终导致发送队列满（ERR__QUEUE_FULL）</li>
</ul>
</li>
<li><p><strong>消息可靠性</strong>：</p>
<ul>
<li>关闭生产者前必须调用 flush()，否则队列中的消息会丢失；</li>
<li>acks&#x3D;all + retries&#x3D;N 是最高可靠性配置，但会降低吞吐量；</li>
<li>启用 enable.idempotence&#x3D;true 可避免重复发送（幂等性）；</li>
</ul>
</li>
<li><p><strong>分区策略</strong>：</p>
<ul>
<li>指定 partition 数值：直接发送到该分区；</li>
<li>PARTITION_UA（-1）：按 key 哈希分区（无 key 则随机）；</li>
<li>自定义 PartitionerCb：按业务规则路由（如用户 ID 取模）；</li>
</ul>
</li>
<li><p><strong>消息重试</strong>：</p>
<ul>
<li>配置 retries（重试次数）、retry.backoff.ms（重试间隔），处理网络抖动导致的发送失败；</li>
</ul>
</li>
<li><p><strong>压缩配置</strong>：</p>
<ul>
<li>通过 compression.type 配置（gzip&#x2F;snappy&#x2F;lz4），降低网络传输量。</li>
</ul>
</li>
</ul>
<h2 id="7-KafkaConsumer类（消费者类）"><a href="#7-KafkaConsumer类（消费者类）" class="headerlink" title="7.KafkaConsumer类（消费者类）"></a>7.KafkaConsumer类（消费者类）</h2><h3 id="（1）概述-4"><a href="#（1）概述-4" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::KafkaConsumer 是 librdkafka 中最常用的消费者实现类，继承自 RdKafka::Handle</li>
<li>封装了 Kafka <strong>消费者组模式</strong>下的消息消费能力，包括：<ul>
<li><strong>subscribe()</strong> 自动分区模式（依赖消费者组协调器自动分配分区）</li>
<li><strong>assign()</strong> 手动分区模式（精准指定要消费的分区列表）</li>
<li><strong>offset 管理</strong>（自动&#x2F;手动提交）</li>
<li><strong>Rebalance 处理</strong>（分区重分配）</li>
</ul>
</li>
<li>是客户端从 Kafka 集群消费消息的核心入口</li>
</ul>
<h4 id="核心定位-4"><a href="#核心定位-4" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>消费者组支持</strong>：<ul>
<li>实现 Kafka 消费者组协议，支持自动&#x2F;手动分区分配</li>
<li>依赖 Broker 协调器（Coordinator）实现分区重平衡</li>
</ul>
</li>
<li><strong>消费模式</strong>：<ul>
<li><strong>subscribe()</strong> 自动分区模式：由消费者组自动分配，支持 Rebalance</li>
<li><strong>assign()</strong> 手动分区模式：精准控制分区，无自动 Rebalance</li>
</ul>
</li>
<li><strong>偏移量管理</strong>：<ul>
<li>支持自动提交（enable.auto.commit&#x3D;true）</li>
<li>支持手动提交（commitSync&#x2F;commitAsync）</li>
</ul>
</li>
<li><strong>事件驱动</strong>：<ul>
<li><strong>consume()</strong> 是核心消费方法，同时触发 Rebalance、心跳、回调等事件</li>
<li><strong>禁止使用 poll()</strong>，KafkaConsumer 的 consume() 方法已整合了 poll() 的功能，因此无需单独调用 poll()</li>
</ul>
</li>
<li><strong>资源管理</strong>：<ul>
<li>继承 Handle 基类，通过 <strong>close() + delete</strong> 安全释放资源</li>
</ul>
</li>
<li><strong>线程安全</strong>：<ul>
<li><strong>非线程安全</strong>，所有 API 需在单线程调用（或加锁）</li>
</ul>
</li>
</ul>
<h3 id="（2）KafkaConsumer类的定义"><a href="#（2）KafkaConsumer类的定义" class="headerlink" title="（2）KafkaConsumer类的定义"></a>（2）KafkaConsumer类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> KafkaConsumer : <span class="keyword">public</span> <span class="keyword">virtual</span> Handle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第一梯队】几乎每个消费者应用都会用到</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建 KafkaConsumer 实例</span></span><br><span class="line"><span class="comment">     * @param conf 配置对象，必须设置 group.id（消费者组 ID）</span></span><br><span class="line"><span class="comment">     * @param errstr [out] 错误描述字符串</span></span><br><span class="line"><span class="comment">     * @returns 成功返回消费者实例，失败返回 NULL</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 使用 close() 关闭消费者</span></span><br><span class="line"><span class="comment">     * @sa RebalanceCb, CONFIGURATION.md 中的 group.id, session.timeout.ms 等配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> KafkaConsumer *<span class="title">create</span><span class="params">(<span class="type">const</span> Conf *conf, std::string &amp;errstr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">KafkaConsumer</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 订阅 Topic 列表</span></span><br><span class="line"><span class="comment">     * @param topics 要订阅的 Topic 名称列表</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，否则返回错误码</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 之前的订阅会被自动取消</span></span><br><span class="line"><span class="comment">     * @remark 支持正则表达式（以 &quot;^&quot; 开头，如 &quot;^myPfx[0-9]_.*&quot;）</span></span><br><span class="line"><span class="comment">     * @remark 订阅是异步操作，不可用的 Topic 会通过 consume() 返回错误</span></span><br><span class="line"><span class="comment">     * @remark 不存在的 Topic 返回 ERR_UNKNOWN_TOPIC_OR_PART</span></span><br><span class="line"><span class="comment">     * @remark 无权限的 Topic 返回 ERR_TOPIC_AUTHORIZATION_FAILED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">subscribe</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt; &amp;topics)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 消费消息或获取错误事件（核心消费方法）</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间（毫秒）</span></span><br><span class="line"><span class="comment">     * @returns Message 对象，需用 delete 释放</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 会自动触发已注册的回调（RebalanceCb、EventCb、OffsetCommitCb 等）</span></span><br><span class="line"><span class="comment">     * @remark 即使没有消息，也应定期调用以处理回调（尤其是 RebalanceCb）</span></span><br><span class="line"><span class="comment">     * @remark 返回值判断：</span></span><br><span class="line"><span class="comment">     *         - Message::err() == ERR_NO_ERROR：正常消息</span></span><br><span class="line"><span class="comment">     *         - Message::err() == ERR__TIMED_OUT：超时，无消息</span></span><br><span class="line"><span class="comment">     *         - 其他：错误事件</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @warning KafkaConsumer 禁止调用 poll()，只能用 consume()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Message *<span class="title">consume</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 关闭消费者（同步阻塞）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 会依次执行：触发 Rebalance → 停止消费 → 提交偏移量 → 离开消费者组</span></span><br><span class="line"><span class="comment">     * @remark 最大阻塞时间约为 session.timeout.ms</span></span><br><span class="line"><span class="comment">     * @remark 关闭过程中可能触发回调（RebalanceCb、OffsetCommitCb 等）</span></span><br><span class="line"><span class="comment">     * @remark 关闭后必须用 delete 释放消费者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">close</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交当前分配的所有分区偏移量</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，否则返回错误码</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 阻塞直到提交完成或失败</span></span><br><span class="line"><span class="comment">     * @remark 若注册了 OffsetCommitCb，会在后续 consume() 中回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 异步提交当前分配的所有分区偏移量</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功入队</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 非阻塞，提交结果通过 OffsetCommitCb 回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitAsync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第二梯队】常用但非必需</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交单条消息的偏移量</span></span><br><span class="line"><span class="comment">     * @param message 要提交的消息</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 提交的偏移量 = message.offset() + 1（即下一条待消费位置）</span></span><br><span class="line"><span class="comment">     * @remark 阻塞直到提交完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">(Message *message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 异步提交单条消息的偏移量</span></span><br><span class="line"><span class="comment">     * @param message 要提交的消息</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功入队</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 提交的偏移量 = message.offset() + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitAsync</span><span class="params">(Message *message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交指定分区列表的偏移量</span></span><br><span class="line"><span class="comment">     * @param offsets 分区偏移量列表（offset 应为下一条待消费位置）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;offsets)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 异步提交指定分区列表的偏移量</span></span><br><span class="line"><span class="comment">     * @param offsets 分区偏移量列表</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitAsync</span><span class="params">(<span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;offsets)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交并通过回调获取结果</span></span><br><span class="line"><span class="comment">     * @param offset_commit_cb 提交完成后的回调函数</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 回调会在此函数内部被调用（同步）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">(OffsetCommitCb *offset_commit_cb)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交指定分区偏移量并通过回调获取结果</span></span><br><span class="line"><span class="comment">     * @param offsets 分区偏移量列表</span></span><br><span class="line"><span class="comment">     * @param offset_commit_cb 提交完成后的回调函数</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;offsets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 OffsetCommitCb *offset_commit_cb)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 取消当前订阅</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">unsubscribe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前订阅的 Topic 列表</span></span><br><span class="line"><span class="comment">     * @param topics [out] 输出当前订阅的 Topic 名称</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">subscription</span><span class="params">(std::vector&lt;std::string&gt; &amp;topics)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前分配的分区列表</span></span><br><span class="line"><span class="comment">     * @param partitions [out] 输出当前分配的分区</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">assignment</span><span class="params">(std::vector&lt;RdKafka::TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 查询已提交的偏移量（从 Broker 获取）</span></span><br><span class="line"><span class="comment">     * @param partitions [in/out] 输入分区列表，输出时填充 offset 或 err</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">committed</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前消费位置（内存中的偏移量）</span></span><br><span class="line"><span class="comment">     * @param partitions [in/out] 输入分区列表，输出时填充 offset 或 err</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 与 committed() 区别：position() 返回内存中的位置，committed() 查询 Broker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">position</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第三梯队】手动分区管理（不使用消费者组自动分配时）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 手动分配分区（不使用消费者组）</span></span><br><span class="line"><span class="comment">     * @param partitions 要消费的分区列表</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 与 subscribe() 互斥，手动分配时不参与消费者组 Rebalance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">assign</span><span class="params">(<span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 取消当前分区分配并停止消费</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">unassign</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 跳转到指定偏移量位置</span></span><br><span class="line"><span class="comment">     * @param partition 目标分区及偏移量</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间（0=异步，&gt;0=同步等待）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，ERR__TIMED_OUT 超时</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须先通过 assign() 分配分区后才能 seek</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">seek</span><span class="params">(<span class="type">const</span> TopicPartition &amp;partition, <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 存储偏移量（不立即提交，等待自动提交或手动 commit）</span></span><br><span class="line"><span class="comment">     * @param offsets 分区偏移量列表</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark offset 值直接存储，不会 +1</span></span><br><span class="line"><span class="comment">     * @remark 必须设置 enable.auto.offset.store=false 才能使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">offsets_store</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;offsets)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第四梯队】协作式 Rebalance（COOPERATIVE 协议）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 增量添加分区到当前分配（协作式 Rebalance）</span></span><br><span class="line"><span class="comment">     * @param partitions 要添加的分区列表</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 用于 COOPERATIVE 协议的 Rebalance 回调中处理 ERR__ASSIGN_PARTITIONS</span></span><br><span class="line"><span class="comment">     * @remark 也可在 Rebalance 回调外使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">incremental_assign</span><span class="params">(<span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 增量移除分区从当前分配（协作式 Rebalance）</span></span><br><span class="line"><span class="comment">     * @param partitions 要移除的分区列表</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 用于 COOPERATIVE 协议的 Rebalance 回调中处理 ERR__REVOKE_PARTITIONS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">incremental_unassign</span><span class="params">(<span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前 Rebalance 协议类型</span></span><br><span class="line"><span class="comment">     * @returns &quot;NONE&quot;（未加入组）、&quot;EAGER&quot;（急切式）、&quot;COOPERATIVE&quot;（协作式）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">rebalance_protocol</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检查当前分配是否为非自愿丢失</span></span><br><span class="line"><span class="comment">     * @returns true 表示分区分配已丢失（可能已被其他消费者接管）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅在 Rebalance 回调中有意义</span></span><br><span class="line"><span class="comment">     * @remark 分配丢失后提交偏移量可能失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">assignment_lost</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第五梯队】事务支持 &amp; 高级功能</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取消费者组元数据（用于事务）</span></span><br><span class="line"><span class="comment">     * @returns ConsumerGroupMetadata 对象（需 delete），未配置 group.id 时返回 NULL</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 用于 Producer::send_offsets_to_transaction() 的参数</span></span><br><span class="line"><span class="comment">     * @sa Producer::send_offsets_to_transaction()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConsumerGroupMetadata *<span class="title">groupMetadata</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 异步关闭消费者（后台执行）</span></span><br><span class="line"><span class="comment">     * @param queue 用于接收 Rebalance 等事件的队列</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须持续 poll 该 queue 直到 closed() 返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">close</span><span class="params">(Queue *queue)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检查消费者是否已关闭</span></span><br><span class="line"><span class="comment">     * @returns true 已关闭，false 未关闭</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @sa close(Queue *queue)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">closed</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）核心配置-1"><a href="#（3）核心配置-1" class="headerlink" title="（3）核心配置"></a>（3）核心配置</h3><p><a href="#config">全局配置</a><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116155332043.png"></p>
<h3 id="（4）使用示例-1"><a href="#（4）使用示例-1" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><h4 id="基础消费示例（消费者组模式，最常用）"><a href="#基础消费示例（消费者组模式，最常用）" class="headerlink" title="&lt;1&gt;基础消费示例（消费者组模式，最常用）"></a>&lt;1&gt;基础消费示例（消费者组模式，最常用）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局标志：控制消费者退出</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> run = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理：优雅退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigterm</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    run = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Rebalance 回调（可选，用于监控分区分配变化）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRebalanceCb</span> : <span class="keyword">public</span> RdKafka::RebalanceCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebalance_cb</span><span class="params">(RdKafka::KafkaConsumer *consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::vector&lt;RdKafka::TopicPartition *&gt; &amp;partitions)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR__ASSIGN_PARTITIONS) &#123;</span><br><span class="line">            <span class="comment">// 分区分配</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 分配分区: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> *tp : partitions) &#123;</span><br><span class="line">                std::cout &lt;&lt; tp-&gt;<span class="built_in">topic</span>() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">partition</span>() &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">            consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == RdKafka::ERR__REVOKE_PARTITIONS) &#123;</span><br><span class="line">            <span class="comment">// 分区撤销</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 撤销分区&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            consumer-&gt;<span class="built_in">unassign</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[Rebalance] 错误: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 1. 创建配置 ==========</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必填配置</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;my-consumer-group&quot;</span>, errstr);  <span class="comment">// 消费者组 ID（必填）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选配置</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);  <span class="comment">// 无偏移量时从头消费</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>, errstr);     <span class="comment">// 自动提交偏移量</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;5000&quot;</span>, errstr); <span class="comment">// 自动提交间隔 5秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 Rebalance 回调（可选）</span></span><br><span class="line">    MyRebalanceCb rebalance_cb;</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;rebalance_cb&quot;</span>, &amp;rebalance_cb, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 创建消费者实例 ==========</span></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败: &quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> conf;  <span class="comment">// 配置已拷贝，可释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 订阅 Topic ==========</span></span><br><span class="line">    std::vector&lt;std::string&gt; topics = &#123;<span class="string">&quot;order_topic&quot;</span>, <span class="string">&quot;user_topic&quot;</span>&#125;;</span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">subscribe</span>(topics);</span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;订阅失败: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;已订阅 Topic: order_topic, user_topic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 注册信号处理 ==========</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. 消费循环 ==========</span></span><br><span class="line">    <span class="keyword">while</span> (run) &#123;</span><br><span class="line">        <span class="comment">// consume() 是核心方法，会触发所有回调</span></span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);  <span class="comment">// 超时 1 秒</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg-&gt;<span class="built_in">err</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR_NO_ERROR:</span><br><span class="line">                <span class="comment">// 正常消息</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[消息] Topic: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">topic_name</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 分区: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; Key: &quot;</span> &lt;&lt; (msg-&gt;<span class="built_in">key</span>() ? msg-&gt;<span class="built_in">key</span>()-&gt;<span class="built_in">c_str</span>() : <span class="string">&quot;null&quot;</span>)</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 内容: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                          &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR__TIMED_OUT:</span><br><span class="line">                <span class="comment">// 超时，无消息（正常情况）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR__PARTITION_EOF:</span><br><span class="line">                <span class="comment">// 到达分区末尾</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[EOF] 分区 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() &lt;&lt; <span class="string">&quot; 已读取完毕&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 错误</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[错误] &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> msg;  <span class="comment">// ⚠️ 必须释放消息对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 6. 优雅关闭 ==========</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在关闭消费者...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();  <span class="comment">// 阻塞等待：Rebalance → 提交偏移量 → 离开组</span></span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;消费者已关闭&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手动提交偏移量示例（精确控制）"><a href="#手动提交偏移量示例（精确控制）" class="headerlink" title="&lt;2&gt;手动提交偏移量示例（精确控制）"></a>&lt;2&gt;手动提交偏移量示例（精确控制）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;manual-commit-group&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>, errstr);  <span class="comment">// ⚠️ 禁用自动提交</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;order_topic&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> msg_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running &amp;&amp; msg_count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;处理消息: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">            msg_count++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式1：每条消息立即同步提交（最安全，但性能差）</span></span><br><span class="line">            <span class="comment">// consumer-&gt;commitSync(msg);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式2：每 10 条消息批量提交</span></span><br><span class="line">            <span class="keyword">if</span> (msg_count % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">commitSync</span>();</span><br><span class="line">                <span class="keyword">if</span> (err == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;已提交偏移量（批次 &quot;</span> &lt;&lt; msg_count / <span class="number">10</span> &lt;&lt; <span class="string">&quot;）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;提交失败: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式3：异步提交（高性能，但可能丢失确认）</span></span><br><span class="line">            <span class="comment">// consumer-&gt;commitAsync(msg);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出前提交剩余偏移量</span></span><br><span class="line">    consumer-&gt;<span class="built_in">commitSync</span>();</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手动分区分配示例（不使用消费者组）"><a href="#手动分区分配示例（不使用消费者组）" class="headerlink" title="&lt;3&gt; 手动分区分配示例（不使用消费者组）"></a>&lt;3&gt; 手动分区分配示例（不使用消费者组）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    <span class="comment">// ⚠️ 手动分配模式下 group.id 可选（不参与消费者组协调）</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;manual-assign-group&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动指定要消费的分区和起始偏移量</span></span><br><span class="line">    std::vector&lt;RdKafka::TopicPartition *&gt; partitions;</span><br><span class="line">    partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">0</span>, <span class="number">0</span>));     <span class="comment">// 分区0，从头开始</span></span><br><span class="line">    partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">1</span>, <span class="number">100</span>));   <span class="comment">// 分区1，从偏移量100开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️ 使用 assign() 而非 subscribe()</span></span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;分配分区失败: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 TopicPartition 对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *tp : partitions) &#123;</span><br><span class="line">        <span class="keyword">delete</span> tp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;分区 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 偏移量 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 内容: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>((<span class="type">char</span>*)msg-&gt;<span class="built_in">payload</span>(), msg-&gt;<span class="built_in">len</span>()) </span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">unassign</span>();  <span class="comment">// 取消分配</span></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Seek-跳转偏移量示例"><a href="#Seek-跳转偏移量示例" class="headerlink" title="&lt;4&gt;Seek 跳转偏移量示例"></a>&lt;4&gt;Seek 跳转偏移量示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seek_to_offset</span><span class="params">(RdKafka::KafkaConsumer *consumer, </span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> std::string &amp;topic, <span class="type">int</span> partition, <span class="type">int64_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 TopicPartition 对象</span></span><br><span class="line">    RdKafka::TopicPartition *tp = RdKafka::TopicPartition::<span class="built_in">create</span>(topic, partition, offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步 seek（等待 5 秒）</span></span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">seek</span>(*tp, <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;已跳转到 &quot;</span> &lt;&lt; topic &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; partition &lt;&lt; <span class="string">&quot;] 偏移量 &quot;</span> &lt;&lt; offset &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;跳转失败: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;seek-demo-group&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分配分区</span></span><br><span class="line">    std::vector&lt;RdKafka::TopicPartition *&gt; partitions;</span><br><span class="line">    partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">0</span>));</span><br><span class="line">    consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *tp : partitions) <span class="keyword">delete</span> tp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费几条消息后跳转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转到偏移量 100</span></span><br><span class="line">    <span class="built_in">seek_to_offset</span>(consumer, <span class="string">&quot;order_topic&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续消费</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;跳转后偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协作式-Rebalance-示例（COOPERATIVE-协议）"><a href="#协作式-Rebalance-示例（COOPERATIVE-协议）" class="headerlink" title="&lt;5&gt;协作式 Rebalance 示例（COOPERATIVE 协议）"></a>&lt;5&gt;协作式 Rebalance 示例（COOPERATIVE 协议）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协作式 Rebalance 回调</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CooperativeRebalanceCb</span> : <span class="keyword">public</span> RdKafka::RebalanceCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebalance_cb</span><span class="params">(RdKafka::KafkaConsumer *consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::vector&lt;RdKafka::TopicPartition *&gt; &amp;partitions)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        std::string protocol = consumer-&gt;<span class="built_in">rebalance_protocol</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 协议: &quot;</span> &lt;&lt; protocol &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR__ASSIGN_PARTITIONS) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 增量分配分区: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> *tp : partitions) &#123;</span><br><span class="line">                std::cout &lt;&lt; tp-&gt;<span class="built_in">topic</span>() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">partition</span>() &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (protocol == <span class="string">&quot;COOPERATIVE&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 协作式：增量添加</span></span><br><span class="line">                RdKafka::Error *error = consumer-&gt;<span class="built_in">incremental_assign</span>(partitions);</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;增量分配失败: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">delete</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 急切式：全量替换</span></span><br><span class="line">                consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == RdKafka::ERR__REVOKE_PARTITIONS) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 增量撤销分区&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (protocol == <span class="string">&quot;COOPERATIVE&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 协作式：增量移除</span></span><br><span class="line">                RdKafka::Error *error = consumer-&gt;<span class="built_in">incremental_unassign</span>(partitions);</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;增量撤销失败: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">delete</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 急切式：全量撤销</span></span><br><span class="line">                consumer-&gt;<span class="built_in">unassign</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;cooperative-group&quot;</span>, errstr);</span><br><span class="line">    <span class="comment">// 使用协作式分配策略</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;partition.assignment.strategy&quot;</span>, <span class="string">&quot;cooperative-sticky&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    CooperativeRebalanceCb rebalance_cb;</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;rebalance_cb&quot;</span>, &amp;rebalance_cb, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;order_topic&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费循环...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;消息: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）对比图"><a href="#（5）对比图" class="headerlink" title="（5）对比图"></a>（5）对比图</h3><h4 id="KafkaConsumer-vs-Producer"><a href="#KafkaConsumer-vs-Producer" class="headerlink" title="&lt;1&gt;KafkaConsumer vs Producer"></a>&lt;1&gt;KafkaConsumer vs Producer</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103143018.png"></p>
<h4 id="subscribe-vs-assign"><a href="#subscribe-vs-assign" class="headerlink" title="&lt;2&gt;subscribe vs assign"></a>&lt;2&gt;subscribe vs assign</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103427689.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103455545.png"></p>
<h3 id="（6）关键注意事项"><a href="#（6）关键注意事项" class="headerlink" title="（6）关键注意事项"></a>（6）关键注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103734641.png"></p>
<h2 id="8-RdKafka-Message类（消息类）"><a href="#8-RdKafka-Message类（消息类）" class="headerlink" title="8.RdKafka::Message类（消息类）"></a>8.RdKafka::Message类（消息类）</h2><h3 id="（1）概述-5"><a href="#（1）概述-5" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Message 是 librdkafka 中<strong>消息的核心载体类</strong>,承载消息的元数据、状态（如错误码）等关键信息，用于：<ul>
<li>生产者端：在 DeliveryReportCb 回调中获取投递结果</li>
<li>消费者端：通过 consume() 获取拉取到的消息</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                      Message 使用场景                            │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│   Producer                              Consumer                │</span><br><span class="line">│      │                                      │                   │</span><br><span class="line">│      │ <span class="built_in">produce</span>()                            │ <span class="built_in">consume</span>()         │</span><br><span class="line">│      ▼                                      ▼                   │</span><br><span class="line">│   ┌──────────┐                        ┌──────────┐             │</span><br><span class="line">│   │ 内部队列 │                        │ Message  │◄── 拉取结果  │</span><br><span class="line">│   └────┬─────┘                        └──────────┘             │</span><br><span class="line">│        │ 发送完成                                               │</span><br><span class="line">│        ▼                                                       │</span><br><span class="line">│   ┌────────────────┐                                           │</span><br><span class="line">│   │DeliveryReportCb│                                           │</span><br><span class="line">│   │   <span class="built_in">dr_cb</span>()      │                                           │</span><br><span class="line">│   │  ┌──────────┐  │                                           │</span><br><span class="line">│   │  │ Message  │◄─┼── 投递结果                                 │</span><br><span class="line">│   │  └──────────┘  │                                           │</span><br><span class="line">│   └────────────────┘                                           │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116203247930.png"></p>
<h4 id="核心定位-5"><a href="#核心定位-5" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>消息数据载体</strong>：<ul>
<li>存储消息的「<strong>内容、Key、分区、偏移量</strong>」等“核心业务数据”，是生产者 &#x2F; 消费者处理消息的直接对象；</li>
</ul>
</li>
<li><strong>元数据容器</strong>：<ul>
<li>附带消息的「<strong>主题名、时间戳、生产 &#x2F; 消费状态、错误码</strong>」等“元数据”，支撑消息溯源、异常排查；</li>
</ul>
</li>
<li><strong>状态标识</strong>：<ul>
<li>不仅封装正常消息，也可表示 “空消息”“错误消息”（如消费超时、分区 EOF），是 API 反馈操作结果的重要形式；</li>
</ul>
</li>
<li><strong>内存管理差异</strong>：<ul>
<li>消费者侧：consume() 返回的 Message 需手动 delete</li>
<li>生产者侧：回调中的 Message 由 librdkafka 管理，无需释放</li>
</ul>
</li>
</ul>
<h3 id="（2）Message类的定义"><a href="#（2）Message类的定义" class="headerlink" title="（2）Message类的定义"></a>（2）Message类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Message &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ================================= 错误相关 =================================</span></span><br><span class="line">    <span class="comment">/** @returns 如果对象表示错误事件则返回错误字符串，否则返回空字符串。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">errstr</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @returns 如果对象表示错误事件则返回错误码，否则返回 ERR_NO_ERROR（0）。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">err</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ================================= 位置信息 =================================</span></span><br><span class="line">    <span class="comment">/** @returns 消息对应的 RdKafka::Topic 对象（如果适用），</span></span><br><span class="line"><span class="comment">    *           如果没有通过 RdKafka::Topic::create() 显式创建对应的</span></span><br><span class="line"><span class="comment">    *           RdKafka::Topic 对象则返回 NULL。</span></span><br><span class="line"><span class="comment">    *           在这种情况下请改用 topic_name()。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Topic *<span class="title">topic</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @returns 主题名称（如果适用，否则返回空字符串） */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">topic_name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @returns 分区号（如果适用） */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">partition</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @returns 消息或错误的偏移量（如果适用） */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================= 消息内容 =================================</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">payload</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;           <span class="comment">// 消息体指针（二进制数据，消息体指针，需转换类型）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">len</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;              <span class="comment">// 消息体长度</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string *<span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 消息 Key（可能为 NULL）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">key_len</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;          <span class="comment">// Key 长度</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">void</span> *<span class="title">key_pointer</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// Key 指针（二进制 Key）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================= 时间戳 =================================</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MessageTimestamp <span class="title">timestamp</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 时间戳（含类型）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">latency</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;         <span class="comment">// 消息延迟（微秒，仅生产者）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ================================= 消息头 =================================</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Headers *<span class="title">headers</span><span class="params">()</span> </span>= <span class="number">0</span>;              <span class="comment">// 获取消息头（可修改）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Headers *<span class="title">headers</span><span class="params">(ErrorCode *err)</span> </span>= <span class="number">0</span>;<span class="comment">// 获取消息头，并返回错误码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ================================= 其他 =================================</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">broker_id</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;       <span class="comment">// 处理该消息的 Broker ID</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 为已消费的消息存储 offset + 1。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 消息的 offset + 1 将根据 \c `auto.commit.interval.ms` 配置</span></span><br><span class="line"><span class="comment">    * 或手动无偏移量的 commit() 调用提交到 broker。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @warning 此方法只能对当前已分配的分区调用。</span></span><br><span class="line"><span class="comment">    *          对未分配的分区调用将失败并返回 ERR__STATE。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @warning 避免在调用 seek() 等方法后存储偏移量，</span></span><br><span class="line"><span class="comment">    *          因为这可能会干扰后续恢复暂停的分区，</span></span><br><span class="line"><span class="comment">    *          应在调用 seek 之前存储偏移量。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @remark 使用此 API 时必须将 \c `enable.auto.offset.store` 设置为 &quot;false&quot;。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @returns 成功时返回 NULL，失败时返回错误对象。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">offset_store</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @brief 消息持久化状态，应用程序可以用它来判断生产的消息是否已被持久化到主题日志中。 */</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">        <span class="comment">/** 消息从未发送到 broker，或者发送失败且错误表明消息未写入日志。</span></span><br><span class="line"><span class="comment">        *  应用程序重试可能导致乱序，但不会导致重复。 */</span></span><br><span class="line">        MSG_STATUS_NOT_PERSISTED = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 消息已发送到 broker，但未收到确认。</span></span><br><span class="line"><span class="comment">        *  应用程序重试可能导致乱序和重复。 */</span></span><br><span class="line">        MSG_STATUS_POSSIBLY_PERSISTED = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 消息已写入日志并被完全确认。</span></span><br><span class="line"><span class="comment">        *  应用程序无需重试。</span></span><br><span class="line"><span class="comment">        *  注意：此值仅在 \c acks=all 时才可完全信任。 */</span></span><br><span class="line">        MSG_STATUS_PERSISTED = <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@brief 返回消息在主题日志中的持久化状态。（生产者专用）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Message</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    Message 核心属性                          │</span><br><span class="line">├──────────────┬──────────────────────────────────────────────┤</span><br><span class="line">│   内容       │  <span class="built_in">payload</span>() + <span class="built_in">len</span>()  /  <span class="built_in">key</span>() + <span class="built_in">key_len</span>()     │</span><br><span class="line">├──────────────┼──────────────────────────────────────────────┤</span><br><span class="line">│   位置       │  <span class="built_in">topic_name</span>() + <span class="built_in">partition</span>() + <span class="built_in">offset</span>()       │</span><br><span class="line">├──────────────┼──────────────────────────────────────────────┤</span><br><span class="line">│   状态       │  <span class="built_in">err</span>() + <span class="built_in">errstr</span>() + <span class="built_in">status</span>()                 │</span><br><span class="line">├──────────────┼──────────────────────────────────────────────┤</span><br><span class="line">│   元数据     │  <span class="built_in">timestamp</span>() + <span class="built_in">headers</span>() + <span class="built_in">broker_id</span>()       │</span><br><span class="line">└──────────────┴──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（3）常见错误码-ErrorCode"><a href="#（3）常见错误码-ErrorCode" class="headerlink" title="（3）常见错误码 ErrorCode"></a>（3）常见错误码 ErrorCode</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116205721363.png"></p>
<h3 id="（4）使用示例-2"><a href="#（4）使用示例-2" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><h4 id="消费者接收并处理消息（核心场景）"><a href="#消费者接收并处理消息（核心场景）" class="headerlink" title="&lt;1&gt;消费者接收并处理消息（核心场景）"></a>&lt;1&gt;消费者接收并处理消息（核心场景）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="comment">// consume() 方法返回 Message 对象，超时时间 1000ms</span></span><br><span class="line">    RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过 err() 判断消息状态</span></span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;<span class="built_in">err</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR_NO_ERROR: &#123;</span><br><span class="line">            <span class="comment">// 正常消息</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *payload = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>());</span><br><span class="line">            <span class="type">size_t</span> len = msg-&gt;<span class="built_in">len</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// key() 返回 const std::string*</span></span><br><span class="line">            <span class="type">const</span> std::string *key = msg-&gt;<span class="built_in">key</span>();</span><br><span class="line">            std::string key_str = key ? *key : <span class="string">&quot;无Key&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// timestamp() 返回 MessageTimestamp 结构体</span></span><br><span class="line">            RdKafka::MessageTimestamp ts = msg-&gt;<span class="built_in">timestamp</span>();</span><br><span class="line">            std::string ts_type = (ts.type == RdKafka::MessageTimestamp::MSG_TIMESTAMP_CREATE_TIME) </span><br><span class="line">                                  ? <span class="string">&quot;生产时间&quot;</span> : <span class="string">&quot;写入时间&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息：&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  主题：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">topic_name</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  分区：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  偏移量：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  Key：&quot;</span> &lt;&lt; key_str &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  内容：&quot;</span> &lt;&lt; std::<span class="built_in">string</span>(payload, len) &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  时间戳：&quot;</span> &lt;&lt; ts.timestamp &lt;&lt; <span class="string">&quot;（&quot;</span> &lt;&lt; ts_type &lt;&lt; <span class="string">&quot;）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR__TIMED_OUT:</span><br><span class="line">            <span class="comment">// 超时，无消息，继续</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR__PARTITION_EOF:</span><br><span class="line">            <span class="comment">// 到达分区末尾</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;分区 EOF：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">topic_name</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 其他错误</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;消费错误：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️ 必须释放（关键：避免内存泄漏）</span></span><br><span class="line">    <span class="keyword">delete</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生产者发送消息后处理回调（异步发送）"><a href="#生产者发送消息后处理回调（异步发送）" class="headerlink" title="&lt;2&gt;生产者发送消息后处理回调（异步发送）"></a>&lt;2&gt;生产者发送消息后处理回调（异步发送）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeliveryReportCb</span> : <span class="keyword">public</span> RdKafka::DeliveryReportCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数是引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dr_cb</span><span class="params">(RdKafka::Message &amp;msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 发送失败</span></span><br><span class="line">            <span class="type">const</span> std::string *key = msg.<span class="built_in">key</span>();</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;消息发送失败：&quot;</span> &lt;&lt; msg.<span class="built_in">errstr</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  Key：&quot;</span> &lt;&lt; (key ? *key : <span class="string">&quot;无Key&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送成功</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;消息发送成功：&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  主题：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>() &lt;&lt; std::endl  <span class="comment">// ✅ 用 . 不用 -&gt;</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  偏移量：&quot;</span> &lt;&lt; msg.<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ⚠️ 回调中的 msg 由 librdkafka 管理，不要 delete</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（5）核心特性与注意事项"><a href="#（5）核心特性与注意事项" class="headerlink" title="（5）核心特性与注意事项"></a>（5）核心特性与注意事项</h3><h4 id="核心特征"><a href="#核心特征" class="headerlink" title="&lt;1&gt;核心特征"></a>&lt;1&gt;核心特征</h4><ul>
<li><strong>只读性</strong>：<ul>
<li>消费者侧的 Message 对象所有属性均为只读；</li>
<li>生产者侧仅发送回调中的 Message 包含发送结果，无法修改消息内容；</li>
</ul>
</li>
<li><strong>分区号特殊值</strong>：<ul>
<li>RdKafka::Topic::PARTITION_UA（等价于 -1）代表 “让 Kafka 自动分配分区”（生产者发送时使用）；</li>
</ul>
</li>
<li><strong>内存管理</strong>：<ul>
<li><strong>消费者</strong> consume() 返回的 Message 指针<strong>需手动 delete，否则内存泄漏</strong>；</li>
<li><strong>生产者回调中</strong>的 Message 对象由 librdkafka 管理，<strong>无需手动释放</strong>；</li>
</ul>
</li>
<li><strong>错误消息判断</strong>：<ul>
<li>consume() 始终返回 Message 对象（不会返回 nullptr）</li>
<li>通过 <strong>err()</strong> 判断状态：<ul>
<li><strong>ERR_NO_ERROR</strong>：正常消息</li>
<li><strong>ERR__TIMED_OUT</strong>：超时，无可用消息</li>
<li><strong>ERR__PARTITION_EOF</strong>：到达分区末尾</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="易错点与最佳实践"><a href="#易错点与最佳实践" class="headerlink" title="&lt;2&gt;易错点与最佳实践"></a>&lt;2&gt;易错点与最佳实践</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116221010502.png"></p>
<h2 id="9-ErrorCode枚举（错误码枚举）"><a href="#9-ErrorCode枚举（错误码枚举）" class="headerlink" title="9.ErrorCode枚举（错误码枚举）"></a>9.ErrorCode枚举（错误码枚举）</h2><h3 id="（1）概述-6"><a href="#（1）概述-6" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-6"><a href="#作用-6" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>是 librdkafka 中封装所有操作结果状态的<strong>核心枚举类型</strong>（本质是整型枚举）</li>
<li>是客户端与 Kafka 集群交互的“<strong>状态反馈中枢</strong>”——所有核心 API（如 produce()&#x2F;assign()&#x2F;commitSync()&#x2F;poll()）的返回值、回调函数的入参均通过该枚举标识操作成功&#x2F;失败原因</li>
<li>是错误处理、问题排查的核心依据。</li>
</ul>
<h4 id="核心定位-6"><a href="#核心定位-6" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>类型本质</strong>：<ul>
<li>typedef int RdKafka::ErrorCode，底层是<strong>整型枚举</strong>（librdkafka 定义了数百个错误码常量）；</li>
</ul>
</li>
<li><strong>分层设计</strong>：<ul>
<li><strong>0</strong>：<ul>
<li><strong>正常状态</strong>（ERR_NO_ERROR）；</li>
</ul>
</li>
<li><strong>负数</strong>：<ul>
<li><strong>客户端内部错误&#x2F;事件</strong>（librdkafka 本地产生，如队列满、超时、重平衡事件）</li>
</ul>
</li>
<li><strong>正数</strong>：<ul>
<li><strong>真正的错误</strong>（如 ERR_UNKNOWN_TOPIC_OR_PART&#x2F;ERR_LEADER_NOT_AVAILABLE）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）核心分类（按业务场景）"><a href="#（2）核心分类（按业务场景）" class="headerlink" title="（2）核心分类（按业务场景）"></a>（2）核心分类（按业务场景）</h3><p>ErrorCode 可按“场景+严重程度”分为 6 大类，覆盖客户端全生命周期：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117113059844.png"></p>
<h3 id="（3）核心错误码详解"><a href="#（3）核心错误码详解" class="headerlink" title="（3）核心错误码详解"></a>（3）核心错误码详解</h3><h4 id="基础通用错误码（所有场景必知）"><a href="#基础通用错误码（所有场景必知）" class="headerlink" title="&lt;1&gt;基础通用错误码（所有场景必知）"></a>&lt;1&gt;基础通用错误码（所有场景必知）</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112530324.png"></p>
<h4 id="生产者核心错误码"><a href="#生产者核心错误码" class="headerlink" title="&lt;2&gt;生产者核心错误码"></a>&lt;2&gt;生产者核心错误码</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112653492.png"></p>
<h4 id="消费者核心错误码"><a href="#消费者核心错误码" class="headerlink" title="&lt;3&gt;消费者核心错误码"></a>&lt;3&gt;消费者核心错误码</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112755227.png"></p>
<h4 id="权限-集群核心错误码"><a href="#权限-集群核心错误码" class="headerlink" title="&lt;4&gt; 权限&#x2F;集群核心错误码"></a>&lt;4&gt; 权限&#x2F;集群核心错误码</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112844123.png"></p>
<h3 id="（4）核心注意事项-1"><a href="#（4）核心注意事项-1" class="headerlink" title="（4）核心注意事项"></a>（4）核心注意事项</h3><ul>
<li><strong>负数不一定是错误</strong>：<ul>
<li>如 ERR__ASSIGN_PARTITIONS（-175）、ERR__REVOKE_PARTITIONS（-174）、ERR__TIMED_OUT（-185）是”事件标识”，仅用于业务逻辑分支，无需告警；</li>
</ul>
</li>
<li><strong>0 一定是成功</strong>：<ul>
<li>所有 API 返回 ERR_NO_ERROR（0）均代表操作成功；</li>
</ul>
</li>
<li><strong>正数一定是错误</strong>：<ul>
<li>如 ERR_UNKNOWN_TOPIC_OR_PART（3）、ERR_MSG_SIZE_TOO_LARGE（10）是真正的错误，需处理&#x2F;告警。</li>
</ul>
</li>
</ul>
<h2 id="10-Error类（错误类）"><a href="#10-Error类（错误类）" class="headerlink" title="10.Error类（错误类）"></a>10.Error类（错误类）</h2><h3 id="（1）概述-7"><a href="#（1）概述-7" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-7"><a href="#作用-7" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Error 是 librdkafka 中<strong>封装错误详情的核心类</strong>（区别于 RdKafka::ErrorCode 枚举）</li>
<li>它不仅包含错误码（ErrorCode），还提供了错误描述、错误来源、额外上下文等维度的信息，是对“原始错误码”的增强版封装</li>
<li>在复杂场景（如消息发送失败、重平衡异常）中，Error 类能提供比单纯错误码更丰富的排查依据，是精细化错误处理的关键。</li>
<li>该类主要出现在 Message 对象、回调函数、高级 API 返回值中，与 ErrorCode 枚举是“配套使用”的关系<ul>
<li>ErrorCode 是“错误类型标识”，Error 是“错误详情载体”。</li>
</ul>
</li>
</ul>
<h4 id="核心定位-7"><a href="#核心定位-7" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><p><strong>类的定位</strong>：</p>
<ul>
<li>是<strong>对 ErrorCode 的“包装器”</strong>，补充错误的可读描述、来源、额外信息；</li>
</ul>
</li>
<li><p><strong>核心价值</strong>：</p>
<ul>
<li>统一错误信息的获取方式（无需手动调用 err2str()）；</li>
<li>提供错误的“上下文维度”（如错误来源的 Broker 节点、错误发生的 Topic&#x2F;分区）；</li>
<li>支持错误链（嵌套错误），便于排查多层级异常；</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>Message::error()：返回消费&#x2F;生产消息的 Error 对象；</li>
<li>高级 API（如事务、AdminClient）的返回值；</li>
<li>部分回调函数的入参（如事务回调）。</li>
</ul>
</li>
</ul>
<h4 id="与-ErrorCode-的核心区别"><a href="#与-ErrorCode-的核心区别" class="headerlink" title="&lt;3&gt;与 ErrorCode 的核心区别"></a>&lt;3&gt;与 ErrorCode 的核心区别</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117114455324.png"></p>
<h3 id="（2）Error类的定义"><a href="#（2）Error类的定义" class="headerlink" title="（2）Error类的定义"></a>（2）Error类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Error &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 创建错误对象（静态工厂方法）</span></span><br><span class="line"><span class="comment">   * @param code 错误码枚举值</span></span><br><span class="line"><span class="comment">   * @param errstr 错误描述字符串指针（可为空）</span></span><br><span class="line"><span class="comment">   * @returns 错误对象指针，需调用方负责释放内存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Error *<span class="title">create</span><span class="params">(ErrorCode code, <span class="type">const</span> std::string *errstr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 虚析构函数（支持多态释放）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Error</span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * ========================================</span></span><br><span class="line"><span class="comment">   *        错误访问器方法（按使用频率排序）</span></span><br><span class="line"><span class="comment">   * ========================================</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★★★★ 最高】</span></span><br><span class="line"><span class="comment">   * @brief 获取错误码枚举值</span></span><br><span class="line"><span class="comment">   * @returns 错误码，如 RdKafka::ERR_UNKNOWN_MEMBER_ID</span></span><br><span class="line"><span class="comment">   * @note 最常用——用于 switch/if 分支判断错误类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">code</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★★★☆ 高】</span></span><br><span class="line"><span class="comment">   * @brief 获取人类可读的错误描述字符串</span></span><br><span class="line"><span class="comment">   * @returns 错误描述，如 &quot;Broker: Unknown member&quot;</span></span><br><span class="line"><span class="comment">   * @note 常用——用于日志记录、错误提示</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">str</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★★☆☆ 中】</span></span><br><span class="line"><span class="comment">   * @brief 判断是否为致命错误</span></span><br><span class="line"><span class="comment">   * @returns true 表示客户端实例不可用，需重建；false 表示可恢复</span></span><br><span class="line"><span class="comment">   * @note 用于决定是否需要重启客户端</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">is_fatal</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★★☆☆ 中】</span></span><br><span class="line"><span class="comment">   * @brief 判断操作是否可重试</span></span><br><span class="line"><span class="comment">   * @returns true 表示可重试；false 表示不可重试</span></span><br><span class="line"><span class="comment">   * @note 用于实现重试逻辑</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">is_retriable</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★☆☆☆ 较低】</span></span><br><span class="line"><span class="comment">   * @brief 获取错误码名称字符串</span></span><br><span class="line"><span class="comment">   * @returns 错误码常量名，如 &quot;ERR_UNKNOWN_MEMBER_ID&quot;</span></span><br><span class="line"><span class="comment">   * @note 主要用于调试日志、监控指标上报</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★☆☆☆☆ 低】</span></span><br><span class="line"><span class="comment">   * @brief 判断是否为需要中止的事务错误</span></span><br><span class="line"><span class="comment">   * @returns true 表示必须调用 abort_transaction() 中止事务；false 表示无需中止</span></span><br><span class="line"><span class="comment">   * @note 仅在使用事务 API 时有意义，普通生产/消费场景无需关注</span></span><br><span class="line"><span class="comment">   * @remark 返回值仅对事务 API 返回的错误有效</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">txn_requires_abort</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）使用示例-1"><a href="#（3）使用示例-1" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="comment">// 示例1：生产者事务场景中的错误处理</span></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleProducerError</span><span class="params">(RdKafka::Producer* producer)</span> </span>&#123;</span><br><span class="line">    RdKafka::Error* error = producer-&gt;<span class="built_in">begin_transaction</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 【最常用】获取错误码进行分支判断</span></span><br><span class="line">        RdKafka::ErrorCode code = error-&gt;<span class="built_in">code</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【常用】记录错误日志</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;事务开始失败: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误码名称: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【中频】判断是否为致命错误</span></span><br><span class="line">        <span class="keyword">if</span> (error-&gt;<span class="built_in">is_fatal</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;致命错误！需要重建生产者实例&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 重建生产者逻辑...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【中频】判断是否可重试</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (error-&gt;<span class="built_in">is_retriable</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;可重试错误，稍后重试...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 重试逻辑...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【低频】事务场景：判断是否需要中止事务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (error-&gt;<span class="built_in">txn_requires_abort</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;需要中止事务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            producer-&gt;<span class="built_in">abort_transaction</span>(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放错误对象（重要！避免内存泄漏）</span></span><br><span class="line">        <span class="keyword">delete</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="comment">// 示例2：提交事务的完整错误处理</span></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">commitTransaction</span><span class="params">(RdKafka::Producer* producer, <span class="type">int</span> timeout_ms)</span> </span>&#123;</span><br><span class="line">    RdKafka::Error* error = producer-&gt;<span class="built_in">commit_transaction</span>(timeout_ms);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;事务提交成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据错误码进行精细化处理</span></span><br><span class="line">    <span class="keyword">switch</span> (error-&gt;<span class="built_in">code</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR__TIMED_OUT:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;事务提交超时: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">if</span> (error-&gt;<span class="built_in">is_retriable</span>()) &#123;</span><br><span class="line">                <span class="keyword">delete</span> error;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">commitTransaction</span>(producer, timeout_ms);  <span class="comment">// 重试</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR__FENCED:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;生产者被隔离，需要重建实例&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;事务提交失败 [&quot;</span> &lt;&lt; error-&gt;<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;]: &quot;</span> </span><br><span class="line">                      &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (error-&gt;<span class="built_in">txn_requires_abort</span>()) &#123;</span><br><span class="line">                producer-&gt;<span class="built_in">abort_transaction</span>(timeout_ms);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> error;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="comment">// 示例3：封装通用错误处理函数</span></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ErrorAction</span> &#123;</span><br><span class="line">    SUCCESS,      <span class="comment">// 成功，无需处理</span></span><br><span class="line">    RETRY,        <span class="comment">// 可重试</span></span><br><span class="line">    ABORT_TXN,    <span class="comment">// 需中止事务</span></span><br><span class="line">    FATAL,        <span class="comment">// 致命错误，需重建客户端</span></span><br><span class="line">    FAIL          <span class="comment">// 失败，不可恢复</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ErrorAction <span class="title">analyzeError</span><span class="params">(RdKafka::Error* error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorAction::SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录错误信息</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;[ERROR] Code: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">code</span>() </span><br><span class="line">              &lt;&lt; <span class="string">&quot; | Name: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">name</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; | Desc: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error-&gt;<span class="built_in">is_fatal</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorAction::FATAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error-&gt;<span class="built_in">is_retriable</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorAction::RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error-&gt;<span class="built_in">txn_requires_abort</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorAction::ABORT_TXN;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ErrorAction::FAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleUsage</span><span class="params">(RdKafka::Producer* producer)</span> </span>&#123;</span><br><span class="line">    RdKafka::Error* error = producer-&gt;<span class="built_in">begin_transaction</span>();</span><br><span class="line">    </span><br><span class="line">    ErrorAction action = <span class="built_in">analyzeError</span>(error);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::SUCCESS:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;操作成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::RETRY:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;准备重试...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::ABORT_TXN:</span><br><span class="line">            producer-&gt;<span class="built_in">abort_transaction</span>(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::FATAL:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;致命错误，退出程序&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::FAIL:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;操作失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">delete</span> error;  <span class="comment">// 始终记得释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）核心注意事项-2"><a href="#（4）核心注意事项-2" class="headerlink" title="（4）核心注意事项"></a>（4）核心注意事项</h3><ul>
<li><strong>内存管理</strong>：<ul>
<li>Error* 指针由 API 返回（如 begin_transaction()、commit_transaction()），<strong>调用方负责 delete</strong>，否则内存泄漏；</li>
<li><strong>核心原则</strong>：凡是 API 返回 Error* 的，用完必须 delete。</li>
</ul>
</li>
<li><strong>关键使用原则</strong>：<ul>
<li><strong>常规场景优先使用 ErrorCode</strong>：<ul>
<li>高频调用（如消息循环）中，整型比较开销极低；</li>
</ul>
</li>
<li><strong>复杂场景使用 Error 类</strong>：<ul>
<li>事务 API、需要判断 is_fatal()&#x2F;is_retriable() 时，Error 类更合适；</li>
</ul>
</li>
<li><strong>日志记录</strong>：<ul>
<li>简单错误用 err2str(code)，需要上下文时用 Error::str()。</li>
</ul>
</li>
</ul>
</li>
<li><strong>致命错误处理</strong>：<ul>
<li>is_fatal()&#x3D;true 时，客户端无法恢复，需记录核心日志并重启客户端；</li>
</ul>
</li>
</ul>
<h2 id="11-MessageTimestamp类（时间戳类）"><a href="#11-MessageTimestamp类（时间戳类）" class="headerlink" title="11.MessageTimestamp类（时间戳类）"></a>11.MessageTimestamp类（时间戳类）</h2><h3 id="（1）概述-8"><a href="#（1）概述-8" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-8"><a href="#作用-8" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::MessageTimestamp 是 librdkafka 中封装 Kafka <strong>消息时间戳</strong>的专用类，用于统一管理消息的「<strong>时间戳值 + 时间戳类型</strong>」，是消费&#x2F;生产场景中<strong>获取消息时间维度信息的核心入口</strong>。</li>
<li>Kafka 消息的时间戳是其元数据的重要组成部分（如生产时间、日志追加时间），该类通过清晰的 API 封装了时间戳的类型判断、数值获取能力，解决了不同时间戳语义的区分问题。</li>
<li>该类<strong>仅用于读取</strong>（生产者发送消息时可指定时间戳，但最终由 Message 对象承载），<strong>所有方法均为只读，线程安全</strong>，是处理消息时间相关逻辑（如按时间过滤、数据回溯、延时消费）的基础。</li>
</ul>
<h4 id="核心定位-8"><a href="#核心定位-8" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>类的定位</strong>：<ul>
<li>轻量级值对象（Value Object），仅包含「<strong>时间戳类型（枚举）+ 时间戳数值（毫秒级）</strong>」两个核心属性；</li>
</ul>
</li>
<li><strong>核心价值</strong>：<ul>
<li>区分时间戳的语义（生产时间&#x2F;日志追加时间），避免业务误解；<ul>
<li>统一时间戳的单位（毫秒级 Unix 时间戳），简化跨语言&#x2F;跨版本兼容；</li>
<li>提供类型安全的 API，替代原始的“数值+标记位”模式；</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li>消费者 consume() 获取消息后，通过 Message::timestamp() 获取该类实例；</li>
<li>生产者 produce() 时指定自定义时间戳（最终体现在消费端的 MessageTimestamp）；</li>
<li>按时间戳过滤消息（如仅处理近1小时的消息）、定位历史数据。</li>
</ul>
</li>
</ul>
<h3 id="（2）MessageTimestamp类的定义"><a href="#（2）MessageTimestamp类的定义" class="headerlink" title="（2）MessageTimestamp类的定义"></a>（2）MessageTimestamp类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> MessageTimestamp &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 消息时间戳类型枚举</span></span><br><span class="line"><span class="comment">   * @details 标识时间戳的来源/含义</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">MessageTimestampType</span> &#123;</span><br><span class="line">    MSG_TIMESTAMP_NOT_AVAILABLE,  <span class="comment">/**&lt; 时间戳不可用（消息无时间戳信息） */</span></span><br><span class="line">    MSG_TIMESTAMP_CREATE_TIME,    <span class="comment">/**&lt; 消息创建时间（由生产者在发送时设置） */</span></span><br><span class="line">    MSG_TIMESTAMP_LOG_APPEND_TIME <span class="comment">/**&lt; 日志追加时间（由 Broker 在写入日志时设置） */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  MessageTimestampType type; <span class="comment">/**&lt; 时间戳类型 */</span></span><br><span class="line">  <span class="type">int64_t</span> timestamp;         <span class="comment">/**&lt; 时间戳值：自 Unix 纪元（1970-01-01 00:00:00 UTC）以来的毫秒数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）使用示例-2"><a href="#（3）使用示例-2" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1：基本使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processMessage</span><span class="params">(RdKafka::Message* message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取消息时间戳</span></span><br><span class="line">    RdKafka::MessageTimestamp ts = message-&gt;<span class="built_in">timestamp</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (ts.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> RdKafka::MessageTimestamp::MSG_TIMESTAMP_CREATE_TIME:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;消息创建时间: &quot;</span> &lt;&lt; ts.timestamp &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> RdKafka::MessageTimestamp::MSG_TIMESTAMP_LOG_APPEND_TIME:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Broker 追加时间: &quot;</span> &lt;&lt; ts.timestamp &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> RdKafka::MessageTimestamp::MSG_TIMESTAMP_NOT_AVAILABLE:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;时间戳不可用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为可读时间（示例）</span></span><br><span class="line">    <span class="keyword">if</span> (ts.type != RdKafka::MessageTimestamp::MSG_TIMESTAMP_NOT_AVAILABLE) &#123;</span><br><span class="line">        <span class="type">time_t</span> seconds = ts.timestamp / <span class="number">1000</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;可读时间: &quot;</span> &lt;&lt; std::<span class="built_in">ctime</span>(&amp;seconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：时间戳单位与转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将毫秒级时间戳转换为本地时间字符串</span></span><br><span class="line"><span class="comment"> * @param ts_ms 毫秒级 Unix 时间戳</span></span><br><span class="line"><span class="comment"> * @returns 格式化字符串，如 &quot;2025-01-01 08:00:00.123&quot;</span></span><br><span class="line"><span class="comment"> * @note 线程安全版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">timestamp_to_local</span><span class="params">(<span class="type">int64_t</span> ts_ms)</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> ts_sec = ts_ms / <span class="number">1000</span>;</span><br><span class="line">    tm local_tm;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">localtime_s</span>(&amp;local_tm, &amp;ts_sec);  <span class="comment">// Windows</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">localtime_r</span>(&amp;ts_sec, &amp;local_tm);  <span class="comment">// POSIX (Linux/macOS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; std::<span class="built_in">put_time</span>(&amp;local_tm, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) </span><br><span class="line">        &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; (ts_ms % <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）注意事项"><a href="#（4）注意事项" class="headerlink" title="（4）注意事项"></a>（4）注意事项</h3><ul>
<li><strong>时间戳单位</strong>：<ul>
<li>毫秒级 Unix 时间戳，转秒级需 “&#x2F;1000”</li>
</ul>
</li>
<li><strong>时区</strong>：<ul>
<li>存储的是 UTC 时间，显示时需转换本地时区</li>
</ul>
</li>
<li><strong>配置依赖</strong>：<ul>
<li>Topic 级别 <strong>message.timestamp.type</strong> 决定使用 <strong>CreateTime</strong> 还是 LogAppendTime**</li>
</ul>
</li>
</ul>
<p><a id="cb"></a></p>
<h2 id="12-RdKafka-xxxCb回调类"><a href="#12-RdKafka-xxxCb回调类" class="headerlink" title="12.RdKafka::xxxCb回调类"></a>12.RdKafka::xxxCb回调类</h2><ul>
<li>RdKafka::xxxCb 是 librdkafka 中一组<strong>抽象回调基类</strong>的统称，用于实现客户端与 Kafka 集群交互的 “<strong>异步事件通知” 机制</strong><ul>
<li>客户端通过继承这些回调类并实现纯虚函数，<strong>可监听生产 &#x2F; 消费过程中的关键事件</strong></li>
<li>如:消息发送结果、消费错误、重平衡、日志输出等，是实现<strong>异步化、定制化业务</strong>逻辑的核心。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116110908752.png"></p>
<h3 id="（1）DeliveryReportCb（生产者投递结果回调）"><a href="#（1）DeliveryReportCb（生产者投递结果回调）" class="headerlink" title="（1）DeliveryReportCb（生产者投递结果回调）"></a>（1）DeliveryReportCb（生产者投递结果回调）</h3><ul>
<li><strong>作用</strong>：<ul>
<li>生产者<strong>异步发送消息（produce()）<strong>后，通过该回调获取最终发送结果，是</strong>处理消息发送失败</strong>的核心入口；</li>
</ul>
</li>
<li><strong>注意</strong>：<ul>
<li><strong>仅异步发送生效</strong>，同步发送（produce()+flush()）无需该回调；</li>
</ul>
</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="&lt;1&gt;定义"></a>&lt;1&gt;定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> DeliveryReportCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// @brief 消息投递报告回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dr_cb</span><span class="params">(Message &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DeliveryReportCb</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 自定义投递结果回调类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeliveryReportCb</span> : <span class="keyword">public</span> RdKafka::DeliveryReportCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dr_cb</span><span class="params">(RdKafka::Message &amp;msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[发送失败] 主题：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 错误：&quot;</span> &lt;&lt; msg.<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[发送成功] 主题：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 偏移量：&quot;</span> &lt;&lt; msg.<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定到生产者配置</span></span><br><span class="line">MyDeliveryReportCb dr_cb;</span><br><span class="line">producer_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;dr_cb&quot;</span>, &amp;dr_cb, errstr);</span><br></pre></td></tr></table></figure>

<h3 id="（2）EventCb（客户端底层事件回调）"><a href="#（2）EventCb（客户端底层事件回调）" class="headerlink" title="（2）EventCb（客户端底层事件回调）"></a>（2）EventCb（客户端底层事件回调）</h3><ul>
<li><strong>作用</strong>：<ul>
<li>监听 librdkafka 底层核心事件（如 Broker 连接 &#x2F; 断开、元数据更新、分区 Leader 切换、限流），是精细化监控客户端状态、调试底层问题的关键；</li>
</ul>
</li>
<li><strong>区别于 ErrorCb</strong>：<ul>
<li>ErrorCb 仅监听 “错误事件”，EventCb 覆盖 “错误 + 正常事件”（如连接成功、元数据更新），粒度更细</li>
</ul>
</li>
<li><strong>事件类型</strong>：<ul>
<li>通过 <strong>Event::type()</strong> 获取，核心类型包括：<ul>
<li><strong>EVENT_ERROR</strong>：错误事件（等价于 ErrorCb）；</li>
<li><strong>EVENT_REBALANCE</strong>：重平衡事件（等价于 RebalanceCb）；</li>
<li><strong>EVENT_LOG</strong>：日志事件（等价于 LogCb）；</li>
<li><strong>EVENT_THROTTLE</strong>：限流事件（等价于 ThrottleCb）；</li>
<li><strong>EVENT_CONNECT</strong>：Broker 连接成功；</li>
<li><strong>EVENT_DISCONNECT</strong>：Broker 连接断开；</li>
<li><strong>EVENT_METADATA_UPDATED</strong>：元数据更新（如 Topic 分区变化）；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="&lt;1&gt;定义"></a>&lt;1&gt;定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> EventCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// @brief 事件回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">event_cb</span><span class="params">(Event &amp;event)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventCb</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 自定义底层事件回调类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEventCb</span> : <span class="keyword">public</span> RdKafka::EventCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数实现：event=事件对象（包含事件类型、详情、关联的 Broker/分区）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">event_cb</span><span class="params">(RdKafka::Event &amp;event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据事件类型分类处理</span></span><br><span class="line">        <span class="keyword">switch</span> (event.<span class="built_in">type</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_CONNECT:</span><br><span class="line">                <span class="comment">// Broker 连接成功</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[事件] 连接 Broker 成功：&quot;</span> &lt;&lt; event.<span class="built_in">broker_name</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_DISCONNECT:</span><br><span class="line">                <span class="comment">// Broker 连接断开</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[事件] 断开 Broker 连接：&quot;</span> &lt;&lt; event.<span class="built_in">broker_name</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_METADATA_UPDATED:</span><br><span class="line">                <span class="comment">// 元数据更新（如 Topic 分区数变化、Leader 切换）</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[事件] 元数据更新：&quot;</span> &lt;&lt; event.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_THROTTLE:</span><br><span class="line">                <span class="comment">// 被 Broker 限流（等价于 ThrottleCb）</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[事件] 被 Broker 限流：&quot;</span> &lt;&lt; event.<span class="built_in">broker_name</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 限流时长：&quot;</span> &lt;&lt; event.<span class="built_in">throttle_time_ms</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_ERROR:</span><br><span class="line">                <span class="comment">// 错误事件（等价于 ErrorCb）</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[事件] 错误：&quot;</span> &lt;&lt; event.<span class="built_in">str</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 是否致命：&quot;</span> &lt;&lt; (event.<span class="built_in">fatal</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_REBALANCE:</span><br><span class="line">                <span class="comment">// 重平衡事件（等价于 RebalanceCb）</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[事件] 重平衡：&quot;</span> &lt;&lt; event.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其他事件（如日志、统计）</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[事件] 未知类型：&quot;</span> &lt;&lt; event.<span class="built_in">type</span>() &lt;&lt; <span class="string">&quot; 详情：&quot;</span> &lt;&lt; event.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定到全局配置（生产者/消费者均可）</span></span><br><span class="line">MyEventCb event_cb;</span><br><span class="line">RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"><span class="keyword">if</span> (conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;event_cb&quot;</span>, &amp;event_cb, errstr) != RdKafka::CONF_OK) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;绑定底层事件回调失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="（3）RebalanceCb（消费者重平衡回调）"><a href="#（3）RebalanceCb（消费者重平衡回调）" class="headerlink" title="（3）RebalanceCb（消费者重平衡回调）"></a>（3）RebalanceCb（消费者重平衡回调）</h3><ul>
<li><strong>作用</strong>：<ul>
<li>消费者组发生“<strong>重平衡</strong>”时触发，是保证消费不丢数据、清理分区资源的关键；</li>
</ul>
</li>
<li><strong>重平衡场景</strong>：<ul>
<li>消费者加入 &#x2F; 退出组、Topic 分区数调整、Broker 重选举；</li>
</ul>
</li>
</ul>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="&lt;1&gt;定义"></a>&lt;1&gt;定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> RebalanceCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 消费者组重平衡回调，配合 RdKafka::KafkaConsumer 使用</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 注册 rebalance_cb 后，librdkafka 将关闭自动分区分配/撤销机制，</span></span><br><span class="line"><span class="comment">  * 改由应用程序的 rebalance_cb 全权负责。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 重平衡回调需要根据两种事件更新 librdkafka 的分区分配集合：</span></span><br><span class="line"><span class="comment">  * - RdKafka::ERR__ASSIGN_PARTITIONS（分配分区）</span></span><br><span class="line"><span class="comment">  * - RdKafka::ERR__REVOKE_PARTITIONS（撤销分区）</span></span><br><span class="line"><span class="comment">  * 同时也要能处理其他任意的重平衡错误（err 不是上述两种的情况）。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @remark 对于其他错误情况，应用程序必须调用 unassign() 来同步状态。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 【Eager 全量分配策略】（如 range、roundrobin）：</span></span><br><span class="line"><span class="comment">  *   - 分配时调用 assign() 设置全部分区</span></span><br><span class="line"><span class="comment">  *   - 撤销时调用 unassign() 清空全部分区</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 【Cooperative 增量分配策略】（如 cooperative-sticky）：</span></span><br><span class="line"><span class="comment">  *   - 分配时调用 incremental_assign() 增量添加分区</span></span><br><span class="line"><span class="comment">  *   - 撤销时调用 incremental_unassign() 增量移除分区</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 不注册回调时，librdkafka 会自动完成上述操作。</span></span><br><span class="line"><span class="comment">  * 注册回调后，应用程序可以在分配/撤销时执行额外操作，例如：</span></span><br><span class="line"><span class="comment">  *   - 分配时：从外部存储加载自定义 offset</span></span><br><span class="line"><span class="comment">  *   - 撤销时：手动提交 offset（当 auto.commit.enable=false 时）</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::assign()</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::incremental_assign()</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::incremental_unassign()</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::assignment_lost()</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::rebalance_protocol()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">rebalance_cb</span><span class="params">(RdKafka::KafkaConsumer *consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">RebalanceCb</span>() &#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRebalanceCb</span> : <span class="keyword">public</span> RdKafka::RebalanceCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebalance_cb</span><span class="params">(RdKafka::KafkaConsumer *consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::vector&lt;RdKafka::TopicPartition*&gt; &amp;partitions)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR__ASSIGN_PARTITIONS) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[重平衡] 分配分区数：&quot;</span> &lt;&lt; partitions.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) &#123;</span><br><span class="line">                tp-&gt;<span class="built_in">set_offset</span>(RdKafka::Topic::OFFSET_STORED);</span><br><span class="line">            &#125;</span><br><span class="line">            consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == RdKafka::ERR__REVOKE_PARTITIONS) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[重平衡] 回收分区数：&quot;</span> &lt;&lt; partitions.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">            consumer-&gt;<span class="built_in">commitSync</span>();  <span class="comment">// 提交当前 offset</span></span><br><span class="line">            consumer-&gt;<span class="built_in">unassign</span>();   <span class="comment">//取消分区分配</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[重平衡失败] 错误：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">            consumer-&gt;<span class="built_in">unassign</span>();   <span class="comment">//取消分区分配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定到消费者配置</span></span><br><span class="line">MyRebalanceCb rebalance_cb;</span><br><span class="line">consumer_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;rebalance_cb&quot;</span>, &amp;rebalance_cb, errstr);</span><br></pre></td></tr></table></figure>

<h3 id="（4）OffsetCommitCb（消费者-Offset-提交结果回调）"><a href="#（4）OffsetCommitCb（消费者-Offset-提交结果回调）" class="headerlink" title="（4）OffsetCommitCb（消费者 Offset 提交结果回调）"></a>（4）OffsetCommitCb（消费者 Offset 提交结果回调）</h3><ul>
<li><strong>作用</strong>：<ul>
<li>消费者<strong>异步提交 offset</strong>（commitAsync()）后，通过该回调获取提交结果；</li>
<li>同步提交（commitSync()）无需此回调，可直接通过返回值判断结果；</li>
</ul>
</li>
<li><strong>关键场景</strong>：<ul>
<li>异步提交 offset 是生产环境首选（非阻塞），该回调是监控 offset 提交失败的核心入口，避免因提交失败导致重复消费；</li>
</ul>
</li>
</ul>
<h4 id="定义-3"><a href="#定义-3" class="headerlink" title="&lt;1&gt;定义"></a>&lt;1&gt;定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> OffsetCommitCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 设置 offset 提交回调，用于消费者组</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 自动提交或手动提交 offset 的结果会被调度到此回调，</span></span><br><span class="line"><span class="comment">  * 并通过 RdKafka::KafkaConsumer::consume() 触发执行。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 如果没有分区有有效的 offset 可提交，此回调会以 err == ERR__NO_OFFSET 被调用，</span></span><br><span class="line"><span class="comment">  * 这不应被视为错误。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * offsets 列表包含每个分区的信息：</span></span><br><span class="line"><span class="comment">  *   - topic      提交的 Topic 名称</span></span><br><span class="line"><span class="comment">  *   - partition  提交的分区号</span></span><br><span class="line"><span class="comment">  *   - offset     已提交的 offset（尝试提交的值）</span></span><br><span class="line"><span class="comment">  *   - err        提交错误码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">offset_commit_cb</span><span class="params">(RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                               std::vector&lt;TopicPartition *&gt; &amp;offsets)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">OffsetCommitCb</span>() &#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><p><strong>自动&#x2F;手动提交 offset 完成后触发</strong></p>
<ul>
<li>提交重试、消费进度监控、lag 告警</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 自定义 Offset 提交结果回调类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOffsetCommitCb</span> : <span class="keyword">public</span> RdKafka::OffsetCommitCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数实现：</span></span><br><span class="line">    <span class="comment">// err=整体提交错误码，partitions=提交的分区列表（含每个分区的提交结果）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">offset_commit_cb</span><span class="params">(RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                          std::vector&lt;RdKafka::TopicPartition*&gt; &amp;partitions)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 整体提交失败（如网络异常、无权限）</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[Offset 提交失败] 整体错误：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历分区，检查每个分区的提交结果（精细化处理）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tp-&gt;<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">                <span class="comment">// 单个分区提交失败</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[Offset 提交失败] 主题：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">topic</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 错误：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(tp-&gt;<span class="built_in">err</span>()) &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 业务逻辑：记录失败的 offset、触发重试、告警</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 单个分区提交成功</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[Offset 提交成功] 主题：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">topic</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 提交的 offset：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定到消费者配置</span></span><br><span class="line">MyOffsetCommitCb offset_commit_cb;</span><br><span class="line">std::string errstr;</span><br><span class="line">RdKafka::Conf *consumer_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"><span class="comment">// 关键：将回调对象绑定到 &quot;offset_commit_cb&quot; 配置项</span></span><br><span class="line"><span class="keyword">if</span> (consumer_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;offset_commit_cb&quot;</span>, &amp;offset_commit_cb, errstr) != RdKafka::CONF_OK) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;绑定 Offset 提交回调失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 异步提交 Offset（触发回调）</span></span><br><span class="line">std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">partitions[<span class="number">0</span>]-&gt;<span class="built_in">set_offset</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 异步提交：非阻塞，结果通过 OffsetCommitCb 返回</span></span><br><span class="line">consumer-&gt;<span class="built_in">commitAsync</span>(partitions, <span class="literal">nullptr</span>); <span class="comment">// 第二个参数为 opaque（透传上下文）</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）回调类通用规则与注意事项"><a href="#（5）回调类通用规则与注意事项" class="headerlink" title="（5）回调类通用规则与注意事项"></a>（5）回调类通用规则与注意事项</h3><h4 id="核心通用规则"><a href="#核心通用规则" class="headerlink" title="&lt;1&gt;核心通用规则"></a>&lt;1&gt;核心通用规则</h4><ul>
<li><strong>抽象类特性</strong>：<ul>
<li>所有 xxxCb 类均包含纯虚函数，必须实现所有纯虚函数才能实例化（未实现会编译失败）；</li>
</ul>
</li>
<li><strong>线程安全</strong>：<ul>
<li>回调函数由 librdkafka 内部线程调用（<strong>非业务线程</strong>），需保证： <ul>
<li>回调内操作（如写日志、更新变量）需<strong>加锁</strong>（std::mutex）；</li>
<li><strong>避免</strong>在回调内执行<strong>耗时操作</strong>（如网络请求、磁盘 IO），会阻塞客户端核心逻辑；</li>
</ul>
</li>
</ul>
</li>
<li><strong>生命周期管理</strong>：<ul>
<li><strong>回调对象的生命周期必须 ≥ 客户端对象（生产者 &#x2F; 消费者）</strong>，否则会导致野指针崩溃；</li>
<li><strong>禁止</strong>在回调内销毁客户端对象（如 delete consumer）；</li>
</ul>
</li>
<li><strong>配置项命名</strong>：<ul>
<li>绑定回调时的配置项名与回调类名对应（如 DeliveryReportCb → dr_cb，RebalanceCb → rebalance_cb），需严格匹配 librdkafka 规范。</li>
</ul>
</li>
</ul>
<h4 id="高频易错点"><a href="#高频易错点" class="headerlink" title="&lt;2&gt;高频易错点"></a>&lt;2&gt;高频易错点</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116224028039.png"></p>
<h2 id="13-Topic类（主题类）"><a href="#13-Topic类（主题类）" class="headerlink" title="13.Topic类（主题类）"></a>13.Topic类（主题类）</h2><h3 id="（1）概述-9"><a href="#（1）概述-9" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-9"><a href="#作用-9" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>是 librdkafka 中封装 Kafka <strong>Topic（主题）句柄</strong>的类，提供主题名称访问、<br>偏移量常量定义及分区可用性检查等功能，是客户端与<strong>具体 Kafka 主题</strong>交互的 “具象化载体”</li>
<li>它不仅定义了主题的名称、分区数、专属配置等核心属性，还提供了消费偏移量控制的关键常量（如 OFFSET_BEGINNING），是<strong>生产者指定发送目标、消费者控制消费范围</strong>的基础类。</li>
</ul>
<h4 id="核心定位-9"><a href="#核心定位-9" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>类的定位</strong>：<ul>
<li>轻量级封装类，代表一个具体的 Kafka 主题，是 “主题元数据 + 主题级配置 + 核心常量” 的集合体；</li>
</ul>
</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>不可修改</strong>：<ul>
<li>Topic 实例创建后，名称、配置等核心属性只读；</li>
</ul>
</li>
<li><strong>轻量级</strong>：<ul>
<li>无复杂内部状态，拷贝 &#x2F; 销毁成本极低；</li>
</ul>
</li>
<li><strong>工厂模式创建</strong>：<ul>
<li>仅能通过 Topic::create() 静态方法实例化，避免手动构造。</li>
</ul>
</li>
</ul>
</li>
<li><strong>核心价值</strong>：<ul>
<li><strong>分离 “全局配置” 与 “主题级配置”</strong>：<ul>
<li>支持为不同 Topic 设置差异化配置（如 Topic A 用 acks&#x3D;all，Topic B 用 acks&#x3D;1）；</li>
</ul>
</li>
<li><strong>提供消费偏移量的标准化常量</strong>：<ul>
<li>统一消费起始位置的控制逻辑（如从最开始 &#x2F; 最新消息消费）；</li>
</ul>
</li>
<li><strong>封装主题元数据查询</strong>：<ul>
<li>简化分区数、配置等信息的获取；</li>
</ul>
</li>
</ul>
</li>
<li>⚠️<strong>注意</strong>：<ul>
<li>大多数常用配置（如 acks、retries、compression.type），实际是<strong>全局配置</strong>，真正的 Topic 级配置项较少（如 partitioner）。</li>
<li><strong>现代用法中，Topic 配置的使用场景已大幅减少。</strong></li>
</ul>
</li>
</ul>
<h3 id="（2）Topic类的定义"><a href="#（2）Topic类的定义" class="headerlink" title="（2）Topic类的定义"></a>（2）Topic类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Topic &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 静态常量（使用频率：⭐⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 未分配分区标识</span></span><br><span class="line"><span class="comment">   * @details 生产者发送消息时使用此值，表示由分区器自动选择目标分区</span></span><br><span class="line"><span class="comment">   * @note 值为 -1，是 produce() 最常用的分区参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> PARTITION_UA;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 从分区最早的消息开始消费</span></span><br><span class="line"><span class="comment">   * @details 值为 -2，用于数据回溯、全量消费历史数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int64_t</span> OFFSET_BEGINNING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 从分区最新的消息开始消费</span></span><br><span class="line"><span class="comment">   * @details 值为 -1，仅消费后续新增消息，用于实时业务场景</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int64_t</span> OFFSET_END;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 使用已存储的偏移量</span></span><br><span class="line"><span class="comment">   * @details 值为 -1000，从 Broker 中恢复上次消费位置，用于断点续传</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int64_t</span> OFFSET_STORED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 无效偏移量标识</span></span><br><span class="line"><span class="comment">   * @details 值为 -1001，用于标记异常场景或偏移量转换失败</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int64_t</span> OFFSET_INVALID;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 静态工厂方法（使用频率：⭐⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 创建 Topic 句柄</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param base      关联的 Producer 或 Consumer 句柄</span></span><br><span class="line"><span class="comment">   * @param topic_str Topic 名称</span></span><br><span class="line"><span class="comment">   * @param conf      可选的 Topic 配置（可为 nullptr 使用默认配置）</span></span><br><span class="line"><span class="comment">   * @param errstr    [out] 错误信息输出</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns 成功返回 Topic 指针，失败返回 nullptr</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note conf 对象在调用后可复用</span></span><br><span class="line"><span class="comment">   * @note 调用者负责 delete 返回的 Topic 对象</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * std::string errstr;</span></span><br><span class="line"><span class="comment">   * RdKafka::Topic* topic = RdKafka::Topic::create(</span></span><br><span class="line"><span class="comment">   *     producer, &quot;my-topic&quot;, nullptr, errstr);</span></span><br><span class="line"><span class="comment">   * if (!topic) &#123;</span></span><br><span class="line"><span class="comment">   *     std::cerr &lt;&lt; &quot;创建 Topic 失败: &quot; &lt;&lt; errstr &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Topic *<span class="title">create</span><span class="params">(Handle *base,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> std::string &amp;topic_str,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Conf *conf,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::string &amp;errstr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 实例方法（使用频率：⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 获取 Topic 名称</span></span><br><span class="line"><span class="comment">   * @returns Topic 名称字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 实例方法（使用频率：⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 检查指定分区是否可用（有 Leader）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param partition 分区编号</span></span><br><span class="line"><span class="comment">   * @returns true 表示分区可用，false 表示不可用</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @warning 仅能在 PartitionerCb 回调函数内部调用！</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">partition_available</span><span class="params">(<span class="type">int32_t</span> partition)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 已废弃方法（使用频率：⭐ - 不推荐使用）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 存储偏移量（已废弃）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param partition 分区编号</span></span><br><span class="line"><span class="comment">   * @param offset    偏移量（实际存储 offset + 1）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns ERR_NO_ERROR 成功，其他值表示错误</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @deprecated 此 API 不支持分区 Leader Epoch，存在日志截断风险</span></span><br><span class="line"><span class="comment">   *             请使用 KafkaConsumer::offsets_store() 或 Message::offset_store() 替代</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note 使用前必须设置 enable.auto.offset.store = false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">offset_store</span><span class="params">(<span class="type">int32_t</span> partition, <span class="type">int64_t</span> offset)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 底层访问（使用频率：⭐ - 仅特殊场景）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 获取底层 C API 句柄</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns rd_kafka_topic_t* 指针</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @warning 直接调用 C API 无官方支持，仅在 C++ API 无法满足需求时使用</span></span><br><span class="line"><span class="comment">   * @note 返回指针生命周期与 Topic 对象相同</span></span><br><span class="line"><span class="comment">   * @note 使用前需 #include &lt;rdkafka/rdkafka.h&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">struct</span> <span class="title class_">rd_kafka_topic_t</span> *<span class="built_in">c_ptr</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 虚析构函数</span></span><br><span class="line"><span class="comment">   * @note 纯虚函数，Topic 为抽象基类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Topic</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117160922667.png"></p>
<ul>
<li><strong>注意</strong>：OFFSET_STORED 的行为依赖配置项 auto.offset.reset：<ul>
<li>若无已存储 offset，会根据 auto.offset.reset 决定回退到 earliest 或 latest</li>
<li>默认值为 latest</li>
</ul>
</li>
</ul>
<h3 id="（3）使用示例-3"><a href="#（3）使用示例-3" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><h4 id="Producer-创建-Topic-句柄并查询元数据"><a href="#Producer-创建-Topic-句柄并查询元数据" class="headerlink" title="&lt;1&gt;Producer 创建 Topic 句柄并查询元数据"></a>&lt;1&gt;Producer 创建 Topic 句柄并查询元数据</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建全局配置（客户端级）</span></span><br><span class="line">    RdKafka::Conf *global_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;topic-demo-producer&quot;</span>, errstr);</span><br><span class="line">    </span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>, errstr); </span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr); </span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;lz4&quot;</span>, errstr); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 Topic 级配置（仅包含真正的 Topic 级配置项）</span></span><br><span class="line">    RdKafka::Conf *topic_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_TOPIC);</span><br><span class="line">    <span class="comment">// Topic 级配置示例（实际可用的配置项）：</span></span><br><span class="line">    <span class="comment">// topic_conf-&gt;set(&quot;partitioner&quot;, &quot;consistent_random&quot;, errstr);  // 分区策略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 Topic 配置绑定到全局配置（可选）</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;default_topic_conf&quot;</span>, topic_conf, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建 Producer 实例</span></span><br><span class="line">    RdKafka::Producer *producer = RdKafka::Producer::<span class="built_in">create</span>(global_conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!producer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建 Producer 失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> topic_conf;</span><br><span class="line">        <span class="keyword">delete</span> global_conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> global_conf;  <span class="comment">// Producer 创建后可释放</span></span><br><span class="line">    <span class="keyword">delete</span> topic_conf;   <span class="comment">// 已绑定到 global_conf，可释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 创建 Topic 实例</span></span><br><span class="line">    RdKafka::Topic *topic = RdKafka::Topic::<span class="built_in">create</span>(producer, <span class="string">&quot;order_topic&quot;</span>, <span class="literal">nullptr</span>, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!topic) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建 Topic 实例失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> producer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 验证 Topic 元数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Topic 名称：&quot;</span> &lt;&lt; topic-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取分区数需要通过 Metadata API</span></span><br><span class="line">    RdKafka::Metadata *metadata = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (producer-&gt;<span class="built_in">metadata</span>(<span class="literal">false</span>, topic, &amp;metadata, <span class="number">5000</span>) == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// 遍历 Topic 元数据获取分区数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> RdKafka::TopicMetadata* t : *metadata-&gt;<span class="built_in">topics</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;<span class="built_in">topic</span>() == topic-&gt;<span class="built_in">name</span>()) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Topic 分区数：&quot;</span> &lt;&lt; t-&gt;<span class="built_in">partitions</span>()-&gt;<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> metadata;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;加载 Topic 元数据失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 销毁资源</span></span><br><span class="line">    <span class="keyword">delete</span> topic;</span><br><span class="line">    <span class="keyword">delete</span> producer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 等待后台线程清理（可选但推荐）</span></span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Consumer-使用-Topic-偏移量常量控制消费位置"><a href="#Consumer-使用-Topic-偏移量常量控制消费位置" class="headerlink" title="&lt;2&gt; Consumer 使用 Topic 偏移量常量控制消费位置"></a>&lt;2&gt; Consumer 使用 Topic 偏移量常量控制消费位置</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局运行标志，用于优雅退出</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号处理（支持 Ctrl+C 优雅退出）</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者配置</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    <span class="keyword">if</span> (conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr) != RdKafka::Conf::CONF_OK ||</span><br><span class="line">        conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;offset-demo-group&quot;</span>, errstr) != RdKafka::Conf::CONF_OK ||</span><br><span class="line">        conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>, errstr) != RdKafka::Conf::CONF_OK ||</span><br><span class="line">        conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr) != RdKafka::Conf::CONF_OK) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;配置设置失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建消费者</span></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line">    conf = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 构建分区列表，使用 Topic 常量指定偏移量</span></span><br><span class="line">    std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line"></span><br><span class="line">    partitions.<span class="built_in">push_back</span>(</span><br><span class="line">        RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">0</span>, RdKafka::Topic::OFFSET_BEGINNING));</span><br><span class="line">    partitions.<span class="built_in">push_back</span>(</span><br><span class="line">        RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">1</span>, RdKafka::Topic::OFFSET_END));</span><br><span class="line">    partitions.<span class="built_in">push_back</span>(</span><br><span class="line">        RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">2</span>, RdKafka::Topic::OFFSET_STORED));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 应用分区分配</span></span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;分配分区失败：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) <span class="keyword">delete</span> tp;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始消费，按 Ctrl+C 退出...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 消费循环（添加退出条件）</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!msg) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 防御性检查</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg-&gt;<span class="built_in">err</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR_NO_ERROR:</span><br><span class="line">                <span class="comment">// 安全处理 payload（可能为空或不以 null 结尾）</span></span><br><span class="line">                <span class="keyword">if</span> (msg-&gt;<span class="built_in">payload</span>() &amp;&amp; msg-&gt;<span class="built_in">len</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;分区 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() </span><br><span class="line">                              &lt;&lt; <span class="string">&quot; | 偏移量 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>()</span><br><span class="line">                              &lt;&lt; <span class="string">&quot; | Key: &quot;</span> &lt;&lt; (msg-&gt;<span class="built_in">key</span>() ? *msg-&gt;<span class="built_in">key</span>() : <span class="string">&quot;(null)&quot;</span>)</span><br><span class="line">                              &lt;&lt; <span class="string">&quot; | 内容: &quot;</span> </span><br><span class="line">                              &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                              &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR__TIMED_OUT:</span><br><span class="line">                <span class="comment">// 超时是正常的，静默处理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR__PARTITION_EOF:</span><br><span class="line">                <span class="comment">// 到达分区末尾（可选：输出提示）</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;分区 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() &lt;&lt; <span class="string">&quot; 已到达末尾&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其他错误</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;消费错误：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n正在关闭消费者...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清理资源（正确顺序）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) &#123;</span><br><span class="line">        <span class="keyword">delete</span> tp;</span><br><span class="line">    &#125;</span><br><span class="line">    partitions.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();  <span class="comment">// 先 close</span></span><br><span class="line">    <span class="keyword">delete</span> consumer;    <span class="comment">// 再 delete</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待后台线程清理</span></span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;消费者已关闭&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>⚠️<strong>注意</strong>：<ul>
<li>OFFSET_STORED 依赖 auto.offset.reset 配置,若 Broker 中<strong>无已存储的 offset</strong>，会根据 auto.offset.reset 回退：</li>
<li><strong>earliest</strong> → 等效于 OFFSET_BEGINNING</li>
<li><strong>latest</strong> → 等效于 OFFSET_END（默认值）</li>
</ul>
</li>
</ul>
<h3 id="（4）注意事项-1"><a href="#（4）注意事项-1" class="headerlink" title="（4）注意事项"></a>（4）注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117161830580.png"></p>
<h2 id="14-Queue类（队列类）"><a href="#14-Queue类（队列类）" class="headerlink" title="14.Queue类（队列类）"></a>14.Queue类（队列类）</h2><h3 id="（1）概述-10"><a href="#（1）概述-10" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-10"><a href="#作用-10" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>是 librdkafka 中<strong>封装客户端异步操作队列</strong>的核心类，用于管理生产者 &#x2F; 消费者的消息队列、事件队列（如投递报告、重平衡事件）</li>
<li>是实现异步 IO、回调触发的底层核心 ——&gt; 所有异步操作（如消息发送、事件处理）均通过 Queue 类的队列机制完成，<strong>其行为直接影响客户端的性能、可靠性和资源占用</strong>。</li>
</ul>
<h4 id="核心定位-10"><a href="#核心定位-10" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><p><strong>类的定位</strong>：</p>
<ul>
<li>底层封装 librdkafka 的 rd_kafka_queue_t 结构体，是<strong>消费者端</strong>的 “消息&#x2F;事件缓冲区” 封装类；</li>
</ul>
</li>
<li><p><strong>核心价值</strong>：</p>
<ul>
<li><strong>分区级消费隔离</strong>：<ul>
<li>可为不同分区创建独立队列，实现并行消费，避免相互阻塞；</li>
</ul>
</li>
<li><strong>事件转发与隔离</strong>：<ul>
<li>支持将消费者回调事件（如重平衡）转发到独立队列，便于自定义处理逻辑；</li>
</ul>
</li>
<li><strong>细粒度 poll 控制</strong>：<ul>
<li>支持对单个队列进行阻塞&#x2F;非阻塞轮询（poll() &#x2F; consume()）；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>主要使用场景</strong>：</p>
<ul>
<li><strong>分区队列</strong>：<ul>
<li>通过 Consumer::get_partition_queue() 获取指定分区的消息队列；</li>
</ul>
</li>
<li><strong>事件队列</strong>：<ul>
<li>通过 Handle::get_queue() 或 Queue::create() 获取&#x2F;创建事件队列；</li>
</ul>
</li>
<li><strong>独立轮询</strong>：<ul>
<li>使用 queue-&gt;poll(timeout) 单独处理该队列的消息&#x2F;事件；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）Queue类的定义"><a href="#（2）Queue类的定义" class="headerlink" title="（2）Queue类的定义"></a>（2）Queue类的定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Queue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 静态工厂方法（使用频率：⭐⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 创建独立队列对象</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param handle 关联的 Producer 或 Consumer 句柄</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns 成功返回 Queue 指针，失败返回 nullptr</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note 调用者负责 delete 返回的 Queue 对象</span></span><br><span class="line"><span class="comment">   * @note 主要用于消费者端创建分区级队列或事件队列</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * RdKafka::Queue *queue = RdKafka::Queue::create(consumer);</span></span><br><span class="line"><span class="comment">   * if (!queue) &#123;</span></span><br><span class="line"><span class="comment">   *     std::cerr &lt;&lt; &quot;创建队列失败&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Queue *<span class="title">create</span><span class="params">(Handle *handle)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 核心消费方法（使用频率：⭐⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 从队列中消费消息或获取错误事件</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param timeout_ms 超时时间（毫秒），0 表示非阻塞，-1 表示无限等待</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns 返回以下情况之一：</span></span><br><span class="line"><span class="comment">   *   - 正常消息：Message::err() == ERR_NO_ERROR</span></span><br><span class="line"><span class="comment">   *   - 错误事件：Message::err() != ERR_NO_ERROR</span></span><br><span class="line"><span class="comment">   *   - 超时：Message::err() == ERR__TIMED_OUT</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note 使用 delete 释放返回的 Message 对象</span></span><br><span class="line"><span class="comment">   * @note 此方法用于包含消息的队列（消费者分区队列）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * RdKafka::Message *msg = queue-&gt;consume(1000);</span></span><br><span class="line"><span class="comment">   * if (msg-&gt;err() == RdKafka::ERR_NO_ERROR) &#123;</span></span><br><span class="line"><span class="comment">   *     // 处理消息</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * delete msg;</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Message *<span class="title">consume</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 事件轮询方法（使用频率：⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 轮询队列，处理队列中的回调事件</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param timeout_ms 超时时间（毫秒）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns 处理的事件数量，超时返回 0</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @warning 禁止用于包含消息的队列！仅用于事件队列</span></span><br><span class="line"><span class="comment">   * @note 用于驱动回调事件（如投递报告、统计信息等）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * // 用于事件队列</span></span><br><span class="line"><span class="comment">   * int events = event_queue-&gt;poll(100);</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 队列转发方法（使用频率：⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 将当前队列的内容转发/路由到目标队列</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param dst 目标队列，传入 nullptr 可取消转发</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns ERR_NO_ERROR 成功，其他值表示错误</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note 调用后，两个队列的内部引用计数都会增加</span></span><br><span class="line"><span class="comment">   * @note 无论 dst 是否为 nullptr，调用后当前队列都不会再向消费者队列转发消息</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @remark 使用场景：</span></span><br><span class="line"><span class="comment">   *   - 将多个分区队列合并到一个队列统一处理</span></span><br><span class="line"><span class="comment">   *   - 将事件队列转发到自定义队列</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * // 将分区队列转发到统一队列</span></span><br><span class="line"><span class="comment">   * partition_queue-&gt;forward(unified_queue);</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * // 取消转发</span></span><br><span class="line"><span class="comment">   * partition_queue-&gt;forward(nullptr);</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">forward</span><span class="params">(Queue *dst)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// IO 事件集成方法（使用频率：⭐⭐ - 高级用法）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 启用队列的 IO 事件触发机制</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param fd      文件描述符，传入 -1 可禁用事件触发</span></span><br><span class="line"><span class="comment">   * @param payload 当队列有新元素入队时写入 fd 的数据</span></span><br><span class="line"><span class="comment">   * @param size    payload 的字节大小</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @details 用于与基于 IO 的事件循环（如 epoll/select/libevent）集成：</span></span><br><span class="line"><span class="comment">   *   - 当空队列收到新元素时，librdkafka 会向 fd 写入 payload</span></span><br><span class="line"><span class="comment">   *   - 应用程序监听 fd 的可读事件，触发后调用 consume()/poll()</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note librdkafka 会维护 payload 的副本</span></span><br><span class="line"><span class="comment">   * @warning 使用转发队列时，仅在最终目标队列上启用 IO 事件</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * // 创建 eventfd 用于通知</span></span><br><span class="line"><span class="comment">   * int efd = eventfd(0, EFD_NONBLOCK);</span></span><br><span class="line"><span class="comment">   * uint64_t notify_val = 1;</span></span><br><span class="line"><span class="comment">   * queue-&gt;io_event_enable(efd, &amp;notify_val, sizeof(notify_val));</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * // 在事件循环中监听 efd</span></span><br><span class="line"><span class="comment">   * // 当 efd 可读时，调用 queue-&gt;consume() 获取消息</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * // 禁用</span></span><br><span class="line"><span class="comment">   * queue-&gt;io_event_enable(-1, nullptr, 0);</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">io_event_enable</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 虚析构函数</span></span><br><span class="line"><span class="comment">   * @note 纯虚函数，Queue 为抽象基类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Queue</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117163118116.png"></p>
<h3 id="（3）使用示例-4"><a href="#（3）使用示例-4" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><h4 id="基础用法-创建队列并消费消息"><a href="#基础用法-创建队列并消费消息" class="headerlink" title="&lt;1&gt;基础用法 - 创建队列并消费消息"></a>&lt;1&gt;基础用法 - 创建队列并消费消息</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者配置</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;queue-demo-group&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建消费者</span></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 订阅主题</span></span><br><span class="line">    consumer-&gt;<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;order_topic&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建独立队列</span></span><br><span class="line">    RdKafka::Queue *queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line">    <span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建队列失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始消费（使用独立队列）...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 消费循环</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        RdKafka::Message *msg = queue-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!msg) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息 | 分区: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; | 偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; | 内容: &quot;</span> </span><br><span class="line">                      &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() != RdKafka::ERR__TIMED_OUT) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;错误：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清理</span></span><br><span class="line">    <span class="keyword">delete</span> queue;</span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分区队列-并行消费不同分区"><a href="#分区队列-并行消费不同分区" class="headerlink" title="&lt;2&gt;分区队列 - 并行消费不同分区"></a>&lt;2&gt;分区队列 - 并行消费不同分区</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区消费线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_partition</span><span class="params">(RdKafka::Queue *queue, <span class="type">int</span> partition_id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[线程-&quot;</span> &lt;&lt; partition_id &lt;&lt; <span class="string">&quot;] 开始消费分区 &quot;</span> &lt;&lt; partition_id &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        RdKafka::Message *msg = queue-&gt;<span class="built_in">consume</span>(<span class="number">500</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!msg) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[线程-&quot;</span> &lt;&lt; partition_id &lt;&lt; <span class="string">&quot;] &quot;</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;分区: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; | 偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; | 内容: &quot;</span> </span><br><span class="line">                      &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() != RdKafka::ERR__TIMED_OUT) &#123;</span><br><span class="line">            <span class="comment">// 非超时错误才输出</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[线程-&quot;</span> &lt;&lt; partition_id &lt;&lt; <span class="string">&quot;] 错误: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[线程-&quot;</span> &lt;&lt; partition_id &lt;&lt; <span class="string">&quot;] 退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者配置</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;parallel-queue-group&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建消费者</span></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 手动分配分区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> partition_count = <span class="number">3</span>;</span><br><span class="line">    std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; partition_count; ++i) &#123;</span><br><span class="line">        partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;分配分区失败：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) <span class="keyword">delete</span> tp;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 为每个分区获取独立队列（核心：使用 get_partition_queue）</span></span><br><span class="line">    std::vector&lt;RdKafka::Queue*&gt; queues;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; partition_count; ++i) &#123;</span><br><span class="line">        <span class="comment">//通过 get_partition_queue 获取分区专属队列</span></span><br><span class="line">        RdKafka::Queue *queue = consumer-&gt;<span class="built_in">get_partition_queue</span>(partitions[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (queue) &#123;</span><br><span class="line">            queues.<span class="built_in">push_back</span>(queue);</span><br><span class="line">            <span class="comment">// 启动独立线程消费该分区</span></span><br><span class="line">            threads.<span class="built_in">emplace_back</span>(consume_partition, queue, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;获取分区 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 的队列失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;已启动 &quot;</span> &lt;&lt; threads.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; 个消费线程，按 Ctrl+C 退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 主线程等待退出信号</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="comment">// 主线程需要定期 poll 以处理心跳等内部事件</span></span><br><span class="line">        <span class="comment">// 注意：消息已被分区队列接管，这里的 consume 主要用于保持连接</span></span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg) &#123;</span><br><span class="line">            <span class="comment">// 如果有消息到达主队列（通常不会），也处理掉</span></span><br><span class="line">            <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[主线程] 收到消息: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 等待所有消费线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 清理资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q : queues) <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) <span class="keyword">delete</span> tp;</span><br><span class="line">    </span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="队列转发-合并多个队列"><a href="#队列转发-合并多个队列" class="headerlink" title="&lt;3&gt;队列转发 - 合并多个队列"></a>&lt;3&gt;队列转发 - 合并多个队列</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;forward-demo-group&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建统一目标队列</span></span><br><span class="line">    RdKafka::Queue *unified_queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建多个源队列并转发到统一队列</span></span><br><span class="line">    RdKafka::Queue *queue_a = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line">    RdKafka::Queue *queue_b = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 queue_a 和 queue_b 的内容转发到 unified_queue</span></span><br><span class="line">    RdKafka::ErrorCode err_a = queue_a-&gt;forward(unified_queue);</span><br><span class="line">    RdKafka::ErrorCode err_b = queue_b-&gt;forward(unified_queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err_a == RdKafka::ERR_NO_ERROR &amp;&amp; err_b == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列转发设置成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从统一队列消费（可以收到来自 queue_a 和 queue_b 的消息）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        RdKafka::Message *msg = unified_queue-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息: &quot;</span> </span><br><span class="line">                      &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 取消转发</span></span><br><span class="line">    queue_a-&gt;forward(<span class="literal">nullptr</span>);</span><br><span class="line">    queue_b-&gt;forward(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清理</span></span><br><span class="line">    <span class="keyword">delete</span> queue_a;</span><br><span class="line">    <span class="keyword">delete</span> queue_b;</span><br><span class="line">    <span class="keyword">delete</span> unified_queue;</span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-事件集成-与-epoll-配合使用"><a href="#IO-事件集成-与-epoll-配合使用" class="headerlink" title="&lt;4&gt;IO 事件集成 - 与 epoll 配合使用"></a>&lt;4&gt;IO 事件集成 - 与 epoll 配合使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;io-event-demo-group&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;order_topic&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建队列</span></span><br><span class="line">    RdKafka::Queue *queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建 eventfd 用于 IO 事件通知</span></span><br><span class="line">    <span class="type">int</span> efd = <span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (efd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建 eventfd 失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> queue;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 启用 IO 事件触发</span></span><br><span class="line">    <span class="type">uint64_t</span> notify_value = <span class="number">1</span>;</span><br><span class="line">    queue-&gt;<span class="built_in">io_event_enable</span>(efd, &amp;notify_value, <span class="built_in">sizeof</span>(notify_value));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 创建 epoll 实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = efd;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, efd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用 epoll + eventfd 监听队列事件...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 事件循环</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epfd, events, <span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == efd) &#123;</span><br><span class="line">                <span class="comment">// 读取并清除 eventfd</span></span><br><span class="line">                <span class="type">uint64_t</span> val;</span><br><span class="line">                <span class="built_in">read</span>(efd, &amp;val, <span class="built_in">sizeof</span>(val));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理队列中所有消息</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    RdKafka::Message *msg = queue-&gt;<span class="built_in">consume</span>(<span class="number">0</span>);  <span class="comment">// 非阻塞</span></span><br><span class="line">                    <span class="keyword">if</span> (!msg || msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR__TIMED_OUT) &#123;</span><br><span class="line">                        <span class="keyword">delete</span> msg;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;[IO Event] 收到消息: &quot;</span></span><br><span class="line">                                  &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                                  &lt;&lt; std::endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 清理</span></span><br><span class="line">    queue-&gt;<span class="built_in">io_event_enable</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);  <span class="comment">// 禁用 IO 事件</span></span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="built_in">close</span>(efd);</span><br><span class="line">    <span class="keyword">delete</span> queue;</span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）注意事项-2"><a href="#（4）注意事项-2" class="headerlink" title="（4）注意事项"></a>（4）注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117163442568.png"><br><strong>poll() 与 consume() 的区别（关键！）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：对消息队列使用 poll()</span></span><br><span class="line">RdKafka::Queue *msg_queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line">msg_queue-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);  <span class="comment">// 禁止！poll() 不处理消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：消息队列使用 consume()</span></span><br><span class="line">RdKafka::Message *msg = msg_queue-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：事件队列使用 poll()</span></span><br><span class="line">RdKafka::Queue *event_queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line">event_queue-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);  <span class="comment">// 处理回调事件</span></span><br></pre></td></tr></table></figure>

<p><a id="config"></a></p>
<h1 id="附录1：常用配置项"><a href="#附录1：常用配置项" class="headerlink" title="附录1：常用配置项"></a>附录1：常用配置项</h1><h2 id="1-Global通用配置（生产者-消费者共用）"><a href="#1-Global通用配置（生产者-消费者共用）" class="headerlink" title="1.Global通用配置（生产者&#x2F;消费者共用）"></a>1.Global通用配置（生产者&#x2F;消费者共用）</h2><h3 id="（1）关键配置"><a href="#（1）关键配置" class="headerlink" title="（1）关键配置"></a>（1）关键配置</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116144249346.png"></p>
<h3 id="（2）网络与连接相关（网络优化）"><a href="#（2）网络与连接相关（网络优化）" class="headerlink" title="（2）网络与连接相关（网络优化）"></a>（2）网络与连接相关（网络优化）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116144611415.png"></p>
<h3 id="（3）安全认证相关（生产环境）"><a href="#（3）安全认证相关（生产环境）" class="headerlink" title="（3）安全认证相关（生产环境）"></a>（3）安全认证相关（生产环境）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116153411714.png"></p>
<h3 id="（4）元数据相关"><a href="#（4）元数据相关" class="headerlink" title="（4）元数据相关"></a>（4）元数据相关</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116151134440.png"><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116151233728.png"></p>
<h2 id="2-生产者专用"><a href="#2-生产者专用" class="headerlink" title="2.生产者专用"></a>2.生产者专用</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119095109007.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119095142663.png"></p>
<h2 id="3-消费者专用"><a href="#3-消费者专用" class="headerlink" title="3.消费者专用"></a>3.消费者专用</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116155332043.png"></p>
<h2 id="4-Cb回调配置项"><a href="#4-Cb回调配置项" class="headerlink" title="4.Cb回调配置项"></a>4.Cb回调配置项</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118103329248.png"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL_C的使用</title>
    <url>/2026/01/07/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/mysql%E5%9C%A8cpp%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-MySQL-C-常用API"><a href="#1-MySQL-C-常用API" class="headerlink" title="1.MySQL C 常用API"></a>1.MySQL C 常用API</h1><p><strong>注：如果要详细了解相关结构体或细节，可以参考”MySQL 8.4 C API 开发者指南”</strong><br><a href="https://dev.mysqlserver.cn/doc/c-api/8.4/en/c-api-introduction.html">MySQL 8.4 C API 开发者指南</a></p>
<h2 id="1-创建并初始化MYSQL句柄"><a href="#1-创建并初始化MYSQL句柄" class="headerlink" title="1.创建并初始化MYSQL句柄"></a>1.创建并初始化MYSQL句柄</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107202349321.png"></p>
<h2 id="2-设置连接配置参数（可选）"><a href="#2-设置连接配置参数（可选）" class="headerlink" title="2.设置连接配置参数（可选）"></a>2.设置连接配置参数（可选）</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107202427224.png"></p>
<h2 id="3-尝试连接数据库"><a href="#3-尝试连接数据库" class="headerlink" title="3.尝试连接数据库"></a>3.尝试连接数据库</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107202454744.png"></p>
<h2 id="4-执行SQL操作"><a href="#4-执行SQL操作" class="headerlink" title="4.执行SQL操作"></a>4.执行SQL操作</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108081201418.png"></p>
<h2 id="5-释放资源"><a href="#5-释放资源" class="headerlink" title="5.释放资源"></a>5.释放资源</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107202723688.png"></p>
<p><strong>1.必须手动释放的资源</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107215343290.png"></p>
<p><strong>2.不需要手动释放的资源</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107215419114.png"></p>
<h2 id="6-其它"><a href="#6-其它" class="headerlink" title="6.其它"></a>6.其它</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107230322030.png"></p>
<h2 id="7-游标相关"><a href="#7-游标相关" class="headerlink" title="7.游标相关"></a>7.游标相关</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107233502220.png"></p>
<h2 id="8-事务操作"><a href="#8-事务操作" class="headerlink" title="8.事务操作"></a>8.事务操作</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107213938986.png"></p>
<h2 id="9-防SQL注入"><a href="#9-防SQL注入" class="headerlink" title="9.防SQL注入"></a>9.防SQL注入</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108085257356.png"></p>
<p><strong>(1)缺点：</strong></p>
<ul>
<li>1.API繁琐</li>
<li>2.结果获取更麻烦：预处理语句获取结果需要预先绑定输出缓冲区，代码量是普通查询的 2-3 倍。</li>
<li>3.大多数场景性能差异不大：预处理的性能优势主要在重复执行同一 SQL 时，单次查询差别很小。</li>
</ul>
<p><strong>(2)优点：</strong></p>
<ul>
<li>1.“批量插入同结构数据”性能明显提升</li>
<li>2.高频重复查询，SQL解析只做一次</li>
<li>3.二进制数据(BLOB),避免转义问题</li>
</ul>
<p><strong>(3)使用场景</strong></p>
<ul>
<li>1.实际开发中，使用 “ORM框架”、“数据库抽象层”、“参数化拼接+转义”较多，原生 mysql_stmt_*	使用较少</li>
<li>2.适用：批量插入、高频查询、BLOB 时再考虑</li>
</ul>
<hr>
<h1 id="2-mysql在cpp中使用的基本流程"><a href="#2-mysql在cpp中使用的基本流程" class="headerlink" title="2.mysql在cpp中使用的基本流程"></a>2.mysql在cpp中使用的基本流程</h1><p><strong>1.创建并初始化MYSQL句柄</strong></p>
<ul>
<li>mysql_init(conn_)</li>
<li>需检查初始化是否成功</li>
<li>注意：初始化成功后就分配资源了，后续任意一步出问题，都需要通过 mysql_close释放资源</li>
</ul>
<p><strong>2.设置配置参数(可选)</strong></p>
<ul>
<li>设置连接超时： mysql_options(conn_, MYSQL_OPT_CONNECT_TIMEOUT, &amp;seconds)</li>
<li>设置字符集：mysql_options(conn_, MYSQL_SET_CHARSET_NAME, “utf8mb4”)</li>
<li>设置读超时： mysql_options(conn_, MYSQL_OPT_READ_TIMEOUT, &amp;seconds)</li>
<li>设置写超时： mysql_options(conn_, MYSQL_OPT_WRITE_TIMEOUT, &amp;seconds)</li>
<li>设置自动重连：mysql_options(conn_, MYSQL_OPT_RECONNECT, &amp;reconnect)</li>
</ul>
<p>mysql_options一般很少出错，这里就不考虑出错</p>
<p><strong>3.尝试连接数据库</strong></p>
<ul>
<li>mysql_real_connect</li>
<li>需检查是否连接成功,失败则mysql_close(conn_)</li>
</ul>
<p><strong>4.执行SQL操作</strong></p>
<ul>
<li>mysql_query</li>
<li>mysql_affected_rows</li>
<li>mysql_store_result</li>
<li>mysql_fetch_row</li>
<li>……</li>
</ul>
<p><strong>5.关闭连接 + 销毁句柄（释放资源）</strong></p>
<ul>
<li>mysql_free_result</li>
<li>mysql_close</li>
</ul>
<h1 id="3-封装示例"><a href="#3-封装示例" class="headerlink" title="3.封装示例"></a>3.封装示例</h1><p><strong>由于本人目前能力有限，可能实现并不是很好，仅作API使用演示</strong></p>
<h2 id="1-连接封装"><a href="#1-连接封装" class="headerlink" title="1.连接封装"></a>1.连接封装</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mysql_connection.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysql_result.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> user&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnection</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Param=std::variant&lt;<span class="type">nullptr_t</span>,<span class="type">int64_t</span>,<span class="type">uint64_t</span>,<span class="type">double</span>,std::string&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySQLConnection</span><span class="params">(<span class="type">const</span> MySQLConfig&amp; config)</span></span>;</span><br><span class="line">    ~<span class="built_in">MySQLConnection</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁止拷贝，允许移动</span></span><br><span class="line">    <span class="built_in">MySQLConnection</span>(<span class="type">const</span> MySQLConnection&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    MySQLConnection&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySQLConnection&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MySQLConnection</span>(MySQLConnection&amp;&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">    MySQLConnection&amp; <span class="keyword">operator</span>=(MySQLConnection&amp;&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效性检查</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Valid</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> mysql_ &amp;&amp; <span class="built_in">mysql_ping</span>(mysql_)==<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">MYSQL* <span class="title">Get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> mysql_;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Select操作</span></span><br><span class="line">    <span class="comment">//存在限制：“sql中不可以包含非占位符&#x27;?&#x27;”</span></span><br><span class="line">    <span class="function">MySQLResult <span class="title">Query</span><span class="params">(<span class="type">const</span> std::string&amp; sql,std::initializer_list&lt;Param&gt; param=&#123;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Insert/Update/Delete操作</span></span><br><span class="line">    <span class="comment">//存在限制：“sql中不可以包含非占位符&#x27;?&#x27;”</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">Execute</span><span class="params">(<span class="type">const</span> std::string&amp; sql,std::initializer_list&lt;Param&gt; params=&#123;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流式查询（逐行获取，适合大结果集）</span></span><br><span class="line">    <span class="comment">// 注意：遍历期间不能执行其他查询！</span></span><br><span class="line">    <span class="comment">// MySQLResult QueryUnbuffered(const std::string&amp; sql);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Insert后的id</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">LastInsertId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 初始化并设置选项</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitAndSetOptions</span><span class="params">(<span class="type">const</span> MySQLConfig&amp; config)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 判断错误是否值得重试</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsRetryableError</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> err_code)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重试连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConnectWithRetry</span><span class="params">(<span class="type">const</span> MySQLConfig&amp; config)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转义方法（只能用于转义“参数值”）（防SQL注入的简单处理）</span></span><br><span class="line">    <span class="function">std::string <span class="title">Escape</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SQL语句包装器： “？为占位符 ——&gt;sql语句中不可以包含非占位符 ？”</span></span><br><span class="line">    <span class="function">std::string <span class="title">BuildSQL</span><span class="params">(<span class="type">const</span> std::string&amp; sql, std::initializer_list&lt;Param&gt; params)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL* mysql_=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mysql_connection.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysql_connection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server/exception.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> user&#123;</span><br><span class="line"></span><br><span class="line">MySQLConnection::<span class="built_in">MySQLConnection</span>(<span class="type">const</span> MySQLConfig&amp; config)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化并设置选项</span></span><br><span class="line">        <span class="built_in">InitAndSetOptions</span>(config);</span><br><span class="line">    &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mysql_)&#123;</span><br><span class="line">            <span class="built_in">mysql_close</span>(mysql_);</span><br><span class="line">            mysql_=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">mysql_real_connect</span>(mysql_,</span><br><span class="line">                            config.host.<span class="built_in">c_str</span>(),</span><br><span class="line">                            config.username.<span class="built_in">c_str</span>(),</span><br><span class="line">                            config.password.<span class="built_in">c_str</span>(),</span><br><span class="line">                            config.database.<span class="built_in">c_str</span>(),</span><br><span class="line">                            config.port,</span><br><span class="line">                            <span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="comment">//一定要先保存错误信息，否则释放mysql_后就无法获取了</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> err_code = <span class="built_in">mysql_errno</span>(mysql_);</span><br><span class="line">        std::string err_msg = <span class="built_in">mysql_error</span>(mysql_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接失败</span></span><br><span class="line">        <span class="built_in">mysql_close</span>(mysql_);</span><br><span class="line">        mysql_=<span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> should_retry = config.auto_reconnect.<span class="built_in">value_or</span>(<span class="literal">false</span>) &amp;&amp; </span><br><span class="line">                    config.max_retries &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    <span class="built_in">IsRetryableError</span>(err_code);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!should_retry) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;mysql_real_connect failed [&#123;&#125;]: &#123;&#125;&quot;</span>, err_code, err_msg);</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">MySQLException</span>(err_code, err_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重连</span></span><br><span class="line">        <span class="built_in">ConnectWithRetry</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySQLConnection::~<span class="built_in">MySQLConnection</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(mysql_)&#123;</span><br><span class="line">        <span class="built_in">mysql_close</span>(mysql_);</span><br><span class="line">        mysql_=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">MySQLResult <span class="title">MySQLConnection::Query</span><span class="params">(<span class="type">const</span> std::string&amp; sql,std::initializer_list&lt;Param&gt; params)</span></span>&#123;</span><br><span class="line">    std::string new_sql=<span class="built_in">BuildSQL</span>(sql,params);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql_, new_sql.<span class="built_in">c_str</span>()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> err_code = <span class="built_in">mysql_errno</span>(mysql_);</span><br><span class="line">        std::string err_msg = <span class="built_in">mysql_error</span>(mysql_);</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Query failed [&#123;&#125;]: &#123;&#125; | SQL: &#123;&#125;&quot;</span>, err_code, err_msg, new_sql);</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MySQLException</span>(err_code, err_msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果集</span></span><br><span class="line">    MYSQL_RES* res=<span class="built_in">mysql_store_result</span>(mysql_);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：SELECT 语句执行出错时， res为nullptr（空集时不会为nullptr）</span></span><br><span class="line">    <span class="comment">// 但如果是非 SELECT 语句调用了 Query，res 也会是 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">mysql_field_count</span>(mysql_) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 应该有结果但没拿到，说明出错了</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> err_code = <span class="built_in">mysql_errno</span>(mysql_);</span><br><span class="line">        std::string err_msg = <span class="built_in">mysql_error</span>(mysql_);</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;mysql_store_result failed [&#123;&#125;]: &#123;&#125;&quot;</span>, err_code, err_msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MySQLException</span>(err_code, err_msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MySQLResult</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">MySQLConnection::Execute</span><span class="params">(<span class="type">const</span> std::string&amp; sql,std::initializer_list&lt;Param&gt; params)</span></span>&#123;</span><br><span class="line">    std::string new_sql=<span class="built_in">BuildSQL</span>(sql,params);</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql_, new_sql.<span class="built_in">c_str</span>()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> err_code = <span class="built_in">mysql_errno</span>(mysql_);</span><br><span class="line">        std::string err_msg = <span class="built_in">mysql_error</span>(mysql_);</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Query failed [&#123;&#125;]: &#123;&#125; | SQL: &#123;&#125;&quot;</span>, err_code, err_msg, new_sql);</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MySQLException</span>(err_code, err_msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_affected_rows</span>(mysql_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Insert后的id</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">MySQLConnection::LastInsertId</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_insert_id</span>(mysql_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySQLConnection::InitAndSetOptions</span><span class="params">(<span class="type">const</span> MySQLConfig&amp; config)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化连接句柄</span></span><br><span class="line">    mysql_=<span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(!mysql_)&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;mysql_init failed&quot;</span>);</span><br><span class="line">        <span class="comment">//注意：不可以throw MySQLException(mysql_errno(mysql_),mysql_error(mysql_));</span></span><br><span class="line">        <span class="comment">//因为mysql_ 是 nullptr，mysql_errno(nullptr) 行为未定义</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MySQLException</span>(<span class="number">0</span>, <span class="string">&quot;mysql_init failed: out of memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置参数</span></span><br><span class="line">    <span class="keyword">if</span>(config.connection_timeout_ms.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="type">int</span> connection_timeout=config.connection_timeout_ms.<span class="built_in">value</span>()/<span class="number">1000</span>; <span class="comment">//ms—&gt;s</span></span><br><span class="line">        <span class="built_in">mysql_options</span>(mysql_,MYSQL_OPT_CONNECT_TIMEOUT,&amp;connection_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(config.read_timeout_ms.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="type">int</span> read_timeout=config.read_timeout_ms.<span class="built_in">value</span>()/<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">mysql_options</span>(mysql_,MYSQL_OPT_READ_TIMEOUT,&amp;read_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(config.write_timeout_ms.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="type">int</span> write_timeout=config.write_timeout_ms.<span class="built_in">value</span>()/<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">mysql_options</span>(mysql_,MYSQL_OPT_WRITE_TIMEOUT,&amp;write_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(config.auto_reconnect.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="comment">/*MySQL C API 底层不直接支持 bool 类型，而是用 unsigned int（无符号整数）来表示布尔值，</span></span><br><span class="line"><span class="comment">          0 代表 false，非 0 代表 true。*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> mybool=config.auto_reconnect.<span class="built_in">value</span>()?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">mysql_options</span>(mysql_,MYSQL_OPT_RECONNECT,&amp;mybool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mysql_options</span>(mysql_,MYSQL_SET_CHARSET_NAME,config.charset.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断错误是否值得重试</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MySQLConnection::IsRetryableError</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> err_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (err_code) &#123;</span><br><span class="line">        <span class="comment">// 可重试的错误（网络/临时性问题）</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2002</span>:  <span class="comment">// CR_CONNECTION_ERROR - socket 错误</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2003</span>:  <span class="comment">// CR_CONN_HOST_ERROR - 无法连接主机</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2006</span>:  <span class="comment">// CR_SERVER_GONE_ERROR - 服务器断开</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2013</span>:  <span class="comment">// CR_SERVER_LOST - 连接丢失</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不可重试的错误（配置/认证问题）</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1045</span>:  <span class="comment">// ER_ACCESS_DENIED_ERROR - 认证失败</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1044</span>:  <span class="comment">// ER_DBACCESS_DENIED_ERROR - 无权限</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1049</span>:  <span class="comment">// ER_BAD_DB_ERROR - 数据库不存在</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2005</span>:  <span class="comment">// CR_UNKNOWN_HOST - 未知主机</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySQLConnection::ConnectWithRetry</span><span class="params">(<span class="type">const</span> MySQLConfig&amp; config)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> err_code=<span class="number">0</span>;</span><br><span class="line">    std::string err_msg;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> attempt=<span class="number">1</span>;attempt&lt;=config.max_retries;++attempt)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">InitAndSetOptions</span>(config);</span><br><span class="line">            <span class="comment">//尝试连接</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">mysql_real_connect</span>(mysql_,</span><br><span class="line">                                  config.host.<span class="built_in">c_str</span>(),</span><br><span class="line">                                  config.username.<span class="built_in">c_str</span>(),</span><br><span class="line">                                  config.password.<span class="built_in">c_str</span>(),</span><br><span class="line">                                  config.database.<span class="built_in">c_str</span>(),</span><br><span class="line">                                  config.port,</span><br><span class="line">                                  <span class="literal">nullptr</span>,</span><br><span class="line">                                  <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="comment">// 连接成功</span></span><br><span class="line">                <span class="built_in">LOG_INFO</span>(<span class="string">&quot;MySQL connected to &#123;&#125;:&#123;&#125;/&#123;&#125; (attempt &#123;&#125;/&#123;&#125;)&quot;</span>,</span><br><span class="line">                        config.host, config.port, config.database,</span><br><span class="line">                        attempt,config.max_retries);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//连接失败</span></span><br><span class="line">            err_code=<span class="built_in">mysql_errno</span>(mysql_);</span><br><span class="line">            err_msg=<span class="built_in">mysql_error</span>(mysql_);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放当前句柄</span></span><br><span class="line">            <span class="built_in">mysql_close</span>(mysql_);</span><br><span class="line">            mysql_=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;MySQL connect attempt &#123;&#125;/&#123;&#125; failed [&#123;&#125;]: &#123;&#125;&quot;</span>,</span><br><span class="line">                attempt, config.max_retries, err_code, err_msg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">IsRetryableError</span>(err_code))&#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Non-retryable error, giving up&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试重连（等待一段时间）</span></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Retrying in &#123;&#125; ms...&quot;</span>, config.retry_interval_ms);</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(config.retry_interval_ms));</span><br><span class="line">        &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">            <span class="comment">//捕捉InitAndSetOptions等抛出的异常</span></span><br><span class="line">            <span class="keyword">if</span>(mysql_)&#123;</span><br><span class="line">                <span class="built_in">mysql_close</span>(mysql_);</span><br><span class="line">                mysql_=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">//继续向上传递</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有重试都失败</span></span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;all Retry are failed. mysql connect failed&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MySQLException</span>(err_code, </span><br><span class="line">        <span class="string">&quot;Failed to connect after &quot;</span> + std::<span class="built_in">to_string</span>(config.max_retries) + </span><br><span class="line">        <span class="string">&quot; attempts: &quot;</span> + err_msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转义方法（防SQL注入的简单处理）</span></span><br><span class="line"><span class="function">std::string <span class="title">MySQLConnection::Escape</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mysql_)&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Connection not established&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MySQLException</span>(<span class="number">0</span>, <span class="string">&quot;Connection not established&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最坏情况“都需要转移”：所以将空间设置为 2*str.size()+1（官方推荐长度）</span></span><br><span class="line">    <span class="comment">//使用vector更安全，也避免手动管理空间</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(str.size()*<span class="number">2</span><span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len=<span class="built_in">mysql_real_escape_string</span>(mysql_,buffer.<span class="built_in">data</span>(),str.<span class="built_in">c_str</span>(),</span><br><span class="line">                                                <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;(str.<span class="built_in">size</span>()));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>(buffer.<span class="built_in">data</span>(),len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SQL语句包装器</span></span><br><span class="line"><span class="function">std::string <span class="title">MySQLConnection::BuildSQL</span><span class="params">(<span class="type">const</span> std::string&amp; sql, std::initializer_list&lt;Param&gt; params)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 预分配内存：初始容量为SQL长度 + 参数平均长度*参数数量（减少内存重分配）</span></span><br><span class="line">    std::string result;</span><br><span class="line">    result.<span class="built_in">reserve</span>(sql.<span class="built_in">size</span>() + params.<span class="built_in">size</span>() * <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> param=params.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//解析sql中的&#x27;?&#x27;占位符，并用params中的参数填入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c:sql)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(param==params.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">//参数不足</span></span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;参数不足&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;param is not enough&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span>&amp;&amp; val)&#123;</span><br><span class="line">                <span class="keyword">using</span> T=std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(val)&gt;;</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T,<span class="type">nullptr_t</span>&gt;)&#123;</span><br><span class="line">                    result+=<span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T,std::string&gt;)&#123;</span><br><span class="line">                    <span class="comment">//字符串要加“转义单引号”</span></span><br><span class="line">                    result+=<span class="string">&quot;\&#x27;&quot;</span>;</span><br><span class="line">                    result+=<span class="built_in">Escape</span>(val);  <span class="comment">//进行转义：方sql注入</span></span><br><span class="line">                    result+=<span class="string">&quot;\&#x27;&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    result+=std::<span class="built_in">to_string</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,*param);</span><br><span class="line"></span><br><span class="line">            param++;  <span class="comment">//参数后移</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//普通字符</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(param!=params.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;参数过多&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;too many param&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-结果集封装"><a href="#2-结果集封装" class="headerlink" title="2.结果集封装"></a>2.结果集封装</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mysql_result.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> user&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理结果集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLResult</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySQLResult</span><span class="params">(MYSQL_RES* res)</span></span>;</span><br><span class="line">    ~<span class="built_in">MySQLResult</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝，允许移动</span></span><br><span class="line">    <span class="built_in">MySQLResult</span>(<span class="type">const</span> MySQLResult&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MySQLResult&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MySQLResult&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//移动操作加 noexcept 可以让 STL 容器更好地优化。</span></span><br><span class="line">    <span class="built_in">MySQLResult</span>(MySQLResult&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line">    MySQLResult&amp; <span class="keyword">operator</span>=(MySQLResult&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历：获取下一行存储在current_row_中，无数据则返回false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元信息</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">RowCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">FieldCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取值（列索引从 0 开始）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsNull</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::optional&lt;std::string&gt; <span class="title">GetString</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::optional&lt;<span class="type">int64_t</span>&gt; <span class="title">GetInt</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::optional&lt;<span class="type">double</span>&gt; <span class="title">GetDouble</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空结果集判断</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> result_ == <span class="literal">nullptr</span> || <span class="built_in">RowCount</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//检查访问的列是否合法，不合法抛出异常</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CheckColumn</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    MYSQL_RES* result_ = <span class="literal">nullptr</span>;       <span class="comment">//结果集</span></span><br><span class="line">    MYSQL_ROW current_row_ = <span class="literal">nullptr</span>;   <span class="comment">//当前行</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* lengths_ = <span class="literal">nullptr</span>;  <span class="comment">//当前行各列字段值的实际长度数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field_count_ = <span class="number">0</span>;      <span class="comment">//结果集的列数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mysql_result.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysql_result.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server/exception.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> user&#123;</span><br><span class="line">    </span><br><span class="line">MySQLResult::<span class="built_in">MySQLResult</span>(MYSQL_RES* res)</span><br><span class="line">:<span class="built_in">result_</span>(res),</span><br><span class="line">    <span class="built_in">field_count_</span>(res?<span class="built_in">mysql_num_fields</span>(res):<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">MySQLResult::~<span class="built_in">MySQLResult</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(result_)&#123;</span><br><span class="line">        <span class="built_in">mysql_free_result</span>(result_);</span><br><span class="line">        result_=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySQLResult::<span class="built_in">MySQLResult</span>(MySQLResult&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">result_</span>(other.result_),</span><br><span class="line">        <span class="built_in">current_row_</span>(other.current_row_),</span><br><span class="line">        <span class="built_in">lengths_</span>(other.lengths_),</span><br><span class="line">        <span class="built_in">field_count_</span>(other.field_count_)&#123;</span><br><span class="line">    other.result_=<span class="literal">nullptr</span>;</span><br><span class="line">    other.current_row_=<span class="literal">nullptr</span>;</span><br><span class="line">    other.lengths_=<span class="literal">nullptr</span>;</span><br><span class="line">    other.field_count_=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySQLResult&amp; MySQLResult::<span class="keyword">operator</span>=(MySQLResult&amp;&amp; other) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">    <span class="comment">//注意检查&amp;other!=this</span></span><br><span class="line">    <span class="keyword">if</span>(&amp;other!=<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result_)&#123;</span><br><span class="line">            <span class="comment">//释放自己的资源</span></span><br><span class="line">            <span class="built_in">mysql_free_result</span>(result_);</span><br><span class="line">        &#125;</span><br><span class="line">        result_=other.result_;</span><br><span class="line">        current_row_=other.current_row_;</span><br><span class="line">        lengths_=other.lengths_;</span><br><span class="line">        field_count_=other.field_count_;</span><br><span class="line"></span><br><span class="line">        other.result_=<span class="literal">nullptr</span>;</span><br><span class="line">        other.current_row_=<span class="literal">nullptr</span>;</span><br><span class="line">        other.lengths_=<span class="literal">nullptr</span>;</span><br><span class="line">        other.field_count_=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MySQLResult::Next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!result_) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//获取一行数据（游标自动后移）</span></span><br><span class="line">    current_row_=<span class="built_in">mysql_fetch_row</span>(result_);</span><br><span class="line">    <span class="keyword">if</span>(current_row_)&#123;</span><br><span class="line">        <span class="comment">//获取各字段长度</span></span><br><span class="line">        lengths_=<span class="built_in">mysql_fetch_lengths</span>(result_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">MySQLResult::RowCount</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result_?<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="built_in">mysql_num_rows</span>(result_)):<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">MySQLResult::FieldCount</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> field_count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySQLResult::CheckColumn</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!current_row_)&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;No current row, call Next() first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(col&gt;=field_count_)&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Column index &quot;</span> + std::<span class="built_in">to_string</span>(col) + </span><br><span class="line">                            <span class="string">&quot; out of range, max is &quot;</span> + std::<span class="built_in">to_string</span>(field_count_ - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MySQLResult::IsNull</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">CheckColumn</span>(col);</span><br><span class="line">    <span class="keyword">return</span> current_row_[col]==<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">MySQLResult::GetString</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">CheckColumn</span>(col);</span><br><span class="line">    <span class="comment">//mysql中，可能存的是NULL</span></span><br><span class="line">    <span class="keyword">if</span>(current_row_[col]==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//current_row_可能包含的是二进制，不可以直接返回，避免被“截断”</span></span><br><span class="line">    <span class="keyword">if</span>(lengths_)&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">string</span>(current_row_[col],lengths_[col]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_row_[col];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int64_t</span>&gt; <span class="title">MySQLResult::GetInt</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">CheckColumn</span>(col);</span><br><span class="line">    <span class="comment">//mysql中，可能存的是NULL</span></span><br><span class="line">    <span class="keyword">if</span>(current_row_[col]==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">strtoll</span>(current_row_[col],<span class="literal">nullptr</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">double</span>&gt; <span class="title">MySQLResult::GetDouble</span><span class="params">(<span class="type">size_t</span> col)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">CheckColumn</span>(col);</span><br><span class="line">    <span class="comment">//mysql中，可能存的是NULL</span></span><br><span class="line">    <span class="keyword">if</span>(current_row_[col]==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">strtod</span>(current_row_[col],<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>mysql</category>
        <category>MySQL_C的使用</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf的使用</title>
    <url>/2026/01/19/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/protobuf%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul>
<li>Protobuf 是 Google 开发的一种轻量级、高效的结构化数据序列化协议，比 JSON、XML 更紧凑、更快，广泛用于网络通信和数据存储。</li>
</ul>
<h2 id="1-核心优势"><a href="#1-核心优势" class="headerlink" title="1.核心优势"></a>1.核心优势</h2><ul>
<li><p><strong>高效性</strong>：</p>
<ul>
<li><strong>二进制格式</strong>，序列化后体积小，解析速度快（比 JSON 快 3-5 倍）</li>
</ul>
</li>
<li><p><strong>跨语言</strong>：</p>
<ul>
<li>支持 C++、Java、Python、Go、JavaScrip 等几乎所有主流语言</li>
</ul>
</li>
<li><p><strong>向后兼容</strong>：</p>
<ul>
<li>字段可以新增&#x2F;废弃，旧版本程序能兼容新版本数据</li>
</ul>
</li>
<li><p><strong>强类型</strong>：</p>
<ul>
<li>通过 .proto 文件定义数据结构，编译后生成强类型代码，减少类型错误</li>
</ul>
</li>
</ul>
<h2 id="2-核心术语"><a href="#2-核心术语" class="headerlink" title="2.核心术语"></a>2.核心术语</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119221513229.png"></p>
<h2 id="3-Proto文件"><a href="#3-Proto文件" class="headerlink" title="3.Proto文件"></a>3.Proto文件</h2><p>正常来说，应该先讲Proto文件，但感觉这部分很枯燥，就放在了<a href="#Proto">附录：Proto文件</a>中，感兴趣的可以先去看一下。</p>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><p>Protobuf 的类型分为两大类：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119222351058.png"></p>
<h2 id="1-标量类型"><a href="#1-标量类型" class="headerlink" title="1.标量类型"></a>1.标量类型</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119222225945.png"></p>
<h3 id="（1）int32-vs-sint32（负数问题）"><a href="#（1）int32-vs-sint32（负数问题）" class="headerlink" title="（1）int32 vs sint32（负数问题）"></a>（1）int32 vs sint32（负数问题）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119222446609.png"></p>
<h3 id="（2）fixed32-vs-int32（大数值）"><a href="#（2）fixed32-vs-int32（大数值）" class="headerlink" title="（2）fixed32 vs int32（大数值）"></a>（2）fixed32 vs int32（大数值）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119222513321.png"></p>
<h3 id="（3）string-vs-bytes"><a href="#（3）string-vs-bytes" class="headerlink" title="（3）string vs bytes"></a>（3）string vs bytes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string: 会做 UTF-8 校验（某些语言）</span></span><br><span class="line"><span class="comment">// bytes: 纯二进制，无校验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景区分</span></span><br><span class="line">message File &#123;</span><br><span class="line">    string filename = <span class="number">1</span>;    <span class="comment">// 文件名是文本</span></span><br><span class="line">    bytes content = <span class="number">2</span>;      <span class="comment">// 文件内容是二进制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）选型决策树"><a href="#（4）选型决策树" class="headerlink" title="（4）选型决策树"></a>（4）选型决策树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">需要存整数？</span><br><span class="line">├─ 纯正数 → uint32 / uint64</span><br><span class="line">├─ 可能有负数？</span><br><span class="line">│   ├─ 是 → sint32 / sint64 ✅</span><br><span class="line">│   └─ 否 → int32 / int64</span><br><span class="line">└─ 值经常很大（&gt;<span class="number">2</span>^<span class="number">28</span>）？</span><br><span class="line">    └─ 是 → fixed32 / fixed64</span><br><span class="line"></span><br><span class="line">需要存字符串？</span><br><span class="line">├─ UTF<span class="number">-8</span> 文本 → string</span><br><span class="line">└─ 二进制数据 → bytes</span><br><span class="line"></span><br><span class="line">需要存小数？</span><br><span class="line">├─ 高精度（金额/坐标）→ <span class="type">double</span></span><br><span class="line">└─ 一般精度 → <span class="type">float</span></span><br></pre></td></tr></table></figure>

<h2 id="2-复合类型-字段规则"><a href="#2-复合类型-字段规则" class="headerlink" title="2.复合类型 &amp; 字段规则"></a>2.复合类型 &amp; 字段规则</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119223758714.png"></p>
<p><a id="message"></a></p>
<h3 id="（1）message（消息）"><a href="#（1）message（消息）" class="headerlink" title="（1）message（消息）"></a>（1）message（消息）</h3><h4 id="Proto-定义"><a href="#Proto-定义" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message Address &#123;</span><br><span class="line">    string city = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message User &#123;</span><br><span class="line">    int32 id = <span class="number">1</span>;</span><br><span class="line">    string name = <span class="number">2</span>;</span><br><span class="line">    Address address = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码"><a href="#C-生成类型伪代码" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    std::string city_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">city</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_city</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_city</span><span class="params">(std::string&amp;&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_city</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_city</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    <span class="type">int32_t</span> id_;</span><br><span class="line">    std::string name_;</span><br><span class="line">    Address* address_;              <span class="comment">// 指针，延迟分配</span></span><br><span class="line">    <span class="type">uint32_t</span> _has_bits_[<span class="number">1</span>];         <span class="comment">// 位图，跟踪 message 字段是否设置</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> Address&amp; <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">int32_t</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable（获取可修改指针）==========</span></span><br><span class="line">    <span class="function">std::string* <span class="title">mutable_name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Address* <span class="title">mutable_address</span><span class="params">()</span></span>;        <span class="comment">// 不存在则自动创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Has（存在性检查）==========</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_address</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 检查 _has_bits_</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear（重置为默认值） ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_address</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：嵌套 message 都是指针存储</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并设置</span></span><br><span class="line">User user;</span><br><span class="line">user.<span class="built_in">set_id</span>(<span class="number">1001</span>);</span><br><span class="line">user.<span class="built_in">set_name</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">user.<span class="built_in">mutable_address</span>()-&gt;<span class="built_in">set_city</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">id</span>() &lt;&lt; std::endl;              <span class="comment">// 1001</span></span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">name</span>() &lt;&lt; std::endl;            <span class="comment">// Alice</span></span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">address</span>().<span class="built_in">city</span>() &lt;&lt; std::endl;  <span class="comment">// Beijing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查嵌套消息</span></span><br><span class="line"><span class="keyword">if</span> (user.<span class="built_in">has_address</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;地址已设置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化 &amp; 反序列化</span></span><br><span class="line">std::string data = user.<span class="built_in">SerializeAsString</span>();</span><br><span class="line">User user2;</span><br><span class="line">user<span class="number">2.</span><span class="built_in">ParseFromString</span>(data);</span><br></pre></td></tr></table></figure>

<h3 id="（2）enum（枚举）"><a href="#（2）enum（枚举）" class="headerlink" title="（2）enum（枚举）"></a>（2）enum（枚举）</h3><h4 id="Proto-定义-1"><a href="#Proto-定义-1" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    STATUS_UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    STATUS_ACTIVE = <span class="number">1</span>;</span><br><span class="line">    STATUS_DELETED = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Order &#123;</span><br><span class="line">    Status status = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-1"><a href="#C-生成类型伪代码-1" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========== 枚举定义 ==========</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> : <span class="type">int</span> &#123;</span><br><span class="line">    STATUS_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">    STATUS_ACTIVE = <span class="number">1</span>,</span><br><span class="line">    STATUS_DELETED = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 枚举辅助函数 ==========</span></span><br><span class="line"><span class="comment">// 1.把枚举值转换为可读的字符串名称</span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">Status_Name</span><span class="params">(Status value)</span></span>;</span><br><span class="line"><span class="comment">// 2.把字符串解析为枚举值（反向转换）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Status_Parse</span><span class="params">(<span class="type">const</span> std::string&amp; name, Status* value)</span></span>;</span><br><span class="line"><span class="comment">// 3.检查整数值是否是合法的枚举值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Status_IsValid</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    <span class="type">int</span> status_;                       <span class="comment">// 枚举存储为 int</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_status</span><span class="params">(Status value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_status</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;order.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置枚举</span></span><br><span class="line">Order order;</span><br><span class="line">order.<span class="built_in">set_status</span>(Status::STATUS_ACTIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取并判断</span></span><br><span class="line"><span class="keyword">if</span> (order.<span class="built_in">status</span>() == Status::STATUS_ACTIVE) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;订单激活中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举 → 字符串</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Status_Name</span>(order.<span class="built_in">status</span>()) &lt;&lt; std::endl;  <span class="comment">// STATUS_ACTIVE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串 → 枚举</span></span><br><span class="line">Status s;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Status_Parse</span>(<span class="string">&quot;STATUS_DELETED&quot;</span>, &amp;s)) &#123;</span><br><span class="line">    order.<span class="built_in">set_status</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证值是否有效</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Status_IsValid</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1 是有效的 Status 值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map（映射）"><a href="#map（映射）" class="headerlink" title="&lt;3&gt;map&lt;K, V&gt;（映射）"></a>&lt;3&gt;map&lt;K, V&gt;（映射）</h3><h4 id="Proto-定义-2"><a href="#Proto-定义-2" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message Address &#123;</span><br><span class="line">    string city = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Student &#123;</span><br><span class="line">    map&lt;string, int32&gt; scores = <span class="number">1</span>;</span><br><span class="line">    map&lt;int32, Address&gt; addresses = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-2"><a href="#C-生成类型伪代码-2" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    std::string city_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">city</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_city</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_city</span><span class="params">(std::string&amp;&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_city</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_city</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    google::protobuf::Map&lt;std::string, <span class="type">int32_t</span>&gt; scores_;</span><br><span class="line">    google::protobuf::Map&lt;<span class="type">int32_t</span>, Address&gt; addresses_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter（只读引用）==========</span></span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::Map&lt;std::string, <span class="type">int32_t</span>&gt;&amp; <span class="title">scores</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::Map&lt;<span class="type">int32_t</span>, Address&gt;&amp; <span class="title">addresses</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable（可修改指针）==========</span></span><br><span class="line">    google::<span class="function">protobuf::Map&lt;std::string, <span class="type">int32_t</span>&gt;* <span class="title">mutable_scores</span><span class="params">()</span></span>;</span><br><span class="line">    google::<span class="function">protobuf::Map&lt;<span class="type">int32_t</span>, Address&gt;* <span class="title">mutable_addresses</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_scores</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_addresses</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== Map 容器类 ==========</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 内部存储 ==========</span></span><br><span class="line">    std::unordered_map&lt;K, V&gt; elements_;  <span class="comment">// 类似 unordered_map 实现</span></span><br><span class="line">    Arena* arena_;                        <span class="comment">// 可选的内存池</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ----- Access（访问）-----</span></span><br><span class="line">    V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key);</span><br><span class="line">    <span class="function"><span class="type">const</span> V&amp; <span class="title">at</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Lookup（查找）-----</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Modify（修改）-----</span></span><br><span class="line">    <span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Capacity（容量）-----</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Iterate（遍历）-----</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Student stu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入标量 map</span></span><br><span class="line">(*stu.<span class="built_in">mutable_scores</span>())[<span class="string">&quot;math&quot;</span>] = <span class="number">95</span>;</span><br><span class="line">(*stu.<span class="built_in">mutable_scores</span>())[<span class="string">&quot;english&quot;</span>] = <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入消息 map</span></span><br><span class="line">(*stu.<span class="built_in">mutable_addresses</span>())[<span class="number">1</span>].<span class="built_in">set_city</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">(*stu.<span class="built_in">mutable_addresses</span>())[<span class="number">2</span>].<span class="built_in">set_city</span>(<span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">std::cout &lt;&lt; stu.<span class="built_in">scores</span>().<span class="built_in">at</span>(<span class="string">&quot;math&quot;</span>) &lt;&lt; std::endl;       <span class="comment">// 95</span></span><br><span class="line">std::cout &lt;&lt; stu.<span class="built_in">addresses</span>().<span class="built_in">at</span>(<span class="number">1</span>).<span class="built_in">city</span>() &lt;&lt; std::endl;  <span class="comment">// Beijing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [subject, score] : stu.<span class="built_in">scores</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; subject &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; score &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">auto</span> it = stu.<span class="built_in">scores</span>().<span class="built_in">find</span>(<span class="string">&quot;math&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != stu.<span class="built_in">scores</span>().<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;找到: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">stu.<span class="built_in">mutable_scores</span>()-&gt;<span class="built_in">erase</span>(<span class="string">&quot;english&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小 &amp; 清空</span></span><br><span class="line">std::cout &lt;&lt; stu.<span class="built_in">scores</span>().<span class="built_in">size</span>() &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line">stu.<span class="built_in">clear_scores</span>();</span><br></pre></td></tr></table></figure>

<h3 id="（4）oneof（互斥字段）"><a href="#（4）oneof（互斥字段）" class="headerlink" title="（4）oneof（互斥字段）"></a>（4）oneof（互斥字段）</h3><h4 id="Proto-定义-3"><a href="#Proto-定义-3" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message Contact &#123;</span><br><span class="line">    string id = <span class="number">1</span>;</span><br><span class="line">    oneof method &#123;</span><br><span class="line">        string email = <span class="number">2</span>;</span><br><span class="line">        string phone = <span class="number">3</span>;</span><br><span class="line">        string wechat = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-3"><a href="#C-生成类型伪代码-3" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Contact</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    std::string id_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// oneof 使用 union 存储（节省内存）</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">MethodUnion</span> &#123;</span><br><span class="line">        std::string* email_;</span><br><span class="line">        std::string* phone_;</span><br><span class="line">        std::string* wechat_;</span><br><span class="line">    &#125; method_;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> _oneof_case_[<span class="number">1</span>];          <span class="comment">// 记录当前设置的是哪个字段</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Oneof Case 枚举 ==========</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">MethodCase</span> &#123;</span><br><span class="line">        kEmail = <span class="number">2</span>,</span><br><span class="line">        kPhone = <span class="number">3</span>,</span><br><span class="line">        kWechat = <span class="number">4</span>,</span><br><span class="line">        METHOD_NOT_SET = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Case 判断 ==========</span></span><br><span class="line">    <span class="function">MethodCase <span class="title">method_case</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">email</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">phone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">wechat</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter（设置一个会清除其他）==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_email</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_phone</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_wechat</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable ==========</span></span><br><span class="line">    <span class="function">std::string* <span class="title">mutable_id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string* <span class="title">mutable_email</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string* <span class="title">mutable_phone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string* <span class="title">mutable_wechat</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Has ==========</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_email</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_phone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_wechat</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;contact.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Contact c;</span><br><span class="line">c.<span class="built_in">set_id</span>(<span class="string">&quot;user_001&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 email</span></span><br><span class="line">c.<span class="built_in">set_email</span>(<span class="string">&quot;alice@example.com&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; c.<span class="built_in">email</span>() &lt;&lt; std::endl;  <span class="comment">// alice@example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 phone → 自动清除 email！</span></span><br><span class="line">c.<span class="built_in">set_phone</span>(<span class="string">&quot;13800138000&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; c.<span class="built_in">has_email</span>() &lt;&lt; std::endl;  <span class="comment">// false</span></span><br><span class="line">std::cout &lt;&lt; c.<span class="built_in">phone</span>() &lt;&lt; std::endl;      <span class="comment">// 13800138000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前设置的是哪个</span></span><br><span class="line"><span class="keyword">switch</span> (c.<span class="built_in">method_case</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Contact::kEmail:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Email: &quot;</span> &lt;&lt; c.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Contact::kPhone:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Phone: &quot;</span> &lt;&lt; c.<span class="built_in">phone</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Contact::kWechat:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WeChat: &quot;</span> &lt;&lt; c.<span class="built_in">wechat</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Contact::METHOD_NOT_SET:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未设置联系方式&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除整个 oneof</span></span><br><span class="line">c.<span class="built_in">clear_method</span>();</span><br><span class="line">std::cout &lt;&lt; (c.<span class="built_in">method_case</span>() == Contact::METHOD_NOT_SET) &lt;&lt; std::endl;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）Any（动态类型）"><a href="#（5）Any（动态类型）" class="headerlink" title="（5）Any（动态类型）"></a>（5）Any（动态类型）</h3><h4 id="Proto-定义-4"><a href="#Proto-定义-4" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    google.protobuf.Any data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-4"><a href="#C-生成类型伪代码-4" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> google::protobuf &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Any</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    std::string type_url_;    <span class="comment">// 类型标识，如 &quot;type.googleapis.com/User&quot;</span></span><br><span class="line">    std::string value_;       <span class="comment">// 序列化后的二进制数据</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Pack（打包）==========</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">PackFrom</span><span class="params">(<span class="type">const</span> T&amp; message)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">PackFrom</span><span class="params">(<span class="type">const</span> T&amp; message, <span class="type">const</span> std::string&amp; type_url_prefix)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Unpack（解包）==========</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">UnpackTo</span><span class="params">(T* message)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Type Check（类型检查）==========</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">Is</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">type_url</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_type_url</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace google::protobuf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    google::protobuf::Any* data_;     <span class="comment">// 指针，延迟分配</span></span><br><span class="line">    <span class="type">uint32_t</span> _has_bits_[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::Any&amp; <span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable ==========</span></span><br><span class="line">    google::<span class="function">protobuf::Any* <span class="title">mutable_data</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Has ==========</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_data</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/any.pb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;response.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包 User 到 Any</span></span><br><span class="line">User user;</span><br><span class="line">user.<span class="built_in">set_id</span>(<span class="number">1</span>);</span><br><span class="line">user.<span class="built_in">set_name</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">Response resp;</span><br><span class="line">resp.<span class="built_in">mutable_data</span>()-&gt;<span class="built_in">PackFrom</span>(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类型 URL</span></span><br><span class="line">std::cout &lt;&lt; resp.<span class="built_in">data</span>().<span class="built_in">type_url</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 输出: type.googleapis.com/User</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型检查 &amp; 解包</span></span><br><span class="line"><span class="keyword">if</span> (resp.<span class="built_in">data</span>().<span class="built_in">Is</span>&lt;User&gt;()) &#123;</span><br><span class="line">    User u;</span><br><span class="line">    <span class="keyword">if</span> (resp.<span class="built_in">data</span>().<span class="built_in">UnpackTo</span>(&amp;u)) &#123;</span><br><span class="line">        std::cout &lt;&lt; u.<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// Alice</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以打包其他类型</span></span><br><span class="line">Order order;</span><br><span class="line">order.<span class="built_in">set_status</span>(Status::STATUS_ACTIVE);</span><br><span class="line">resp.<span class="built_in">mutable_data</span>()-&gt;<span class="built_in">PackFrom</span>(order);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在是 Order 类型</span></span><br><span class="line">std::cout &lt;&lt; resp.<span class="built_in">data</span>().<span class="built_in">Is</span>&lt;User&gt;() &lt;&lt; std::endl;   <span class="comment">// false</span></span><br><span class="line">std::cout &lt;&lt; resp.<span class="built_in">data</span>().<span class="built_in">Is</span>&lt;Order&gt;() &lt;&lt; std::endl;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="Protobuf-Any-的”动态类型”解析"><a href="#Protobuf-Any-的”动态类型”解析" class="headerlink" title="&lt;4&gt;Protobuf Any 的”动态类型”解析"></a>&lt;4&gt;Protobuf Any 的”动态类型”解析</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119230729435.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119230756739.png"></p>
<h3 id="（6）Timestamp（时间点）"><a href="#（6）Timestamp（时间点）" class="headerlink" title="（6）Timestamp（时间点）"></a>（6）Timestamp（时间点）</h3><h4 id="Proto-定义-5"><a href="#Proto-定义-5" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message Event &#123;</span><br><span class="line">    google.protobuf.Timestamp created_at = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-5"><a href="#C-生成类型伪代码-5" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> google::protobuf &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timestamp</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    <span class="type">int64_t</span> seconds_;    <span class="comment">// Unix 时间戳（秒）</span></span><br><span class="line">    <span class="type">int32_t</span> nanos_;      <span class="comment">// 纳秒部分 [0, 999999999]</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">seconds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">nanos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_seconds</span><span class="params">(<span class="type">int64_t</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_nanos</span><span class="params">(<span class="type">int32_t</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> util &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeUtil</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Create（创建）==========</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Timestamp <span class="title">GetCurrentTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Timestamp <span class="title">SecondsToTimestamp</span><span class="params">(<span class="type">int64_t</span> seconds)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Timestamp <span class="title">MillisecondsToTimestamp</span><span class="params">(<span class="type">int64_t</span> millis)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Convert（转换）==========</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">TimestampToSeconds</span><span class="params">(<span class="type">const</span> Timestamp&amp; ts)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">TimestampToMilliseconds</span><span class="params">(<span class="type">const</span> Timestamp&amp; ts)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">TimestampToMicroseconds</span><span class="params">(<span class="type">const</span> Timestamp&amp; ts)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">TimestampToNanoseconds</span><span class="params">(<span class="type">const</span> Timestamp&amp; ts)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== String（字符串）==========</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">ToString</span><span class="params">(<span class="type">const</span> Timestamp&amp; ts)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">FromString</span><span class="params">(<span class="type">const</span> std::string&amp; str, Timestamp* ts)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace util</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace google::protobuf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    google::protobuf::Timestamp* created_at_;</span><br><span class="line">    <span class="type">uint32_t</span> _has_bits_[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::Timestamp&amp; <span class="title">created_at</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable ==========</span></span><br><span class="line">    google::<span class="function">protobuf::Timestamp* <span class="title">mutable_created_at</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Has ==========</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_created_at</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_created_at</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/timestamp.pb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/util/time_util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;event.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> google::protobuf::util::TimeUtil;</span><br><span class="line"></span><br><span class="line">Event event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1: 设置当前时间</span></span><br><span class="line">*event.<span class="built_in">mutable_created_at</span>() = TimeUtil::<span class="built_in">GetCurrentTime</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 手动设置秒和纳秒</span></span><br><span class="line">event.<span class="built_in">mutable_created_at</span>()-&gt;<span class="built_in">set_seconds</span>(<span class="number">1705312200</span>);</span><br><span class="line">event.<span class="built_in">mutable_created_at</span>()-&gt;<span class="built_in">set_nanos</span>(<span class="number">500000000</span>);  <span class="comment">// 0.5秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3: 从毫秒创建</span></span><br><span class="line">*event.<span class="built_in">mutable_created_at</span>() = TimeUtil::<span class="built_in">MillisecondsToTimestamp</span>(<span class="number">1705312200500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">std::cout &lt;&lt; event.<span class="built_in">created_at</span>().<span class="built_in">seconds</span>() &lt;&lt; std::endl;  <span class="comment">// 1705312200</span></span><br><span class="line">std::cout &lt;&lt; event.<span class="built_in">created_at</span>().<span class="built_in">nanos</span>() &lt;&lt; std::endl;    <span class="comment">// 500000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为毫秒</span></span><br><span class="line"><span class="type">int64_t</span> ms = TimeUtil::<span class="built_in">TimestampToMilliseconds</span>(event.<span class="built_in">created_at</span>());</span><br><span class="line">std::cout &lt;&lt; ms &lt;&lt; std::endl;  <span class="comment">// 1705312200500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为 RFC 3339 字符串</span></span><br><span class="line">std::string time_str = TimeUtil::<span class="built_in">ToString</span>(event.<span class="built_in">created_at</span>());</span><br><span class="line">std::cout &lt;&lt; time_str &lt;&lt; std::endl;  <span class="comment">// 2024-01-15T10:30:00.500Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串解析</span></span><br><span class="line">google::protobuf::Timestamp ts;</span><br><span class="line">TimeUtil::<span class="built_in">FromString</span>(<span class="string">&quot;2024-01-15T10:30:00Z&quot;</span>, &amp;ts);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（7）Duration（时间段）"><a href="#（7）Duration（时间段）" class="headerlink" title="（7）Duration（时间段）"></a>（7）Duration（时间段）</h3><h4 id="Proto-定义-6"><a href="#Proto-定义-6" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/duration.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message Task &#123;</span><br><span class="line">    google.protobuf.Duration timeout = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-6"><a href="#C-生成类型伪代码-6" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> google::protobuf &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duration</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    <span class="type">int64_t</span> seconds_;    <span class="comment">// 秒（可为负）</span></span><br><span class="line">    <span class="type">int32_t</span> nanos_;      <span class="comment">// 纳秒 [-999999999, 999999999]，与 seconds 同号</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">seconds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">nanos</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_seconds</span><span class="params">(<span class="type">int64_t</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_nanos</span><span class="params">(<span class="type">int32_t</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> util &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeUtil</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Create（创建）==========</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Duration <span class="title">SecondsToDuration</span><span class="params">(<span class="type">int64_t</span> seconds)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Duration <span class="title">MillisecondsToDuration</span><span class="params">(<span class="type">int64_t</span> millis)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Duration <span class="title">MicrosecondsToDuration</span><span class="params">(<span class="type">int64_t</span> micros)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Duration <span class="title">NanosecondsToDuration</span><span class="params">(<span class="type">int64_t</span> nanos)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Convert（转换）==========</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">DurationToSeconds</span><span class="params">(<span class="type">const</span> Duration&amp; d)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">DurationToMilliseconds</span><span class="params">(<span class="type">const</span> Duration&amp; d)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">DurationToMicroseconds</span><span class="params">(<span class="type">const</span> Duration&amp; d)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">DurationToNanoseconds</span><span class="params">(<span class="type">const</span> Duration&amp; d)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== String（字符串）==========</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">ToString</span><span class="params">(<span class="type">const</span> Duration&amp; d)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">FromString</span><span class="params">(<span class="type">const</span> std::string&amp; str, Duration* d)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace util</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace google::protobuf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    google::protobuf::Duration* timeout_;</span><br><span class="line">    <span class="type">uint32_t</span> _has_bits_[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::Duration&amp; <span class="title">timeout</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable ==========</span></span><br><span class="line">    google::<span class="function">protobuf::Duration* <span class="title">mutable_timeout</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Has ==========</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_timeout</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_timeout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/duration.pb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/util/time_util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> google::protobuf::util::TimeUtil;</span><br><span class="line"></span><br><span class="line">Task task;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1: 从秒创建</span></span><br><span class="line">*task.<span class="built_in">mutable_timeout</span>() = TimeUtil::<span class="built_in">SecondsToDuration</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 从毫秒创建（5.5秒）</span></span><br><span class="line">*task.<span class="built_in">mutable_timeout</span>() = TimeUtil::<span class="built_in">MillisecondsToDuration</span>(<span class="number">5500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3: 手动设置</span></span><br><span class="line">task.<span class="built_in">mutable_timeout</span>()-&gt;<span class="built_in">set_seconds</span>(<span class="number">10</span>);</span><br><span class="line">task.<span class="built_in">mutable_timeout</span>()-&gt;<span class="built_in">set_nanos</span>(<span class="number">500000000</span>);  <span class="comment">// 10.5秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">std::cout &lt;&lt; task.<span class="built_in">timeout</span>().<span class="built_in">seconds</span>() &lt;&lt; std::endl;  <span class="comment">// 10</span></span><br><span class="line">std::cout &lt;&lt; task.<span class="built_in">timeout</span>().<span class="built_in">nanos</span>() &lt;&lt; std::endl;    <span class="comment">// 500000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为毫秒</span></span><br><span class="line"><span class="type">int64_t</span> ms = TimeUtil::<span class="built_in">DurationToMilliseconds</span>(task.<span class="built_in">timeout</span>());</span><br><span class="line">std::cout &lt;&lt; ms &lt;&lt; std::endl;  <span class="comment">// 10500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为字符串</span></span><br><span class="line">std::string dur_str = TimeUtil::<span class="built_in">ToString</span>(task.<span class="built_in">timeout</span>());</span><br><span class="line">std::cout &lt;&lt; dur_str &lt;&lt; std::endl;  <span class="comment">// 10.500s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负数时间段（表示过去）</span></span><br><span class="line">*task.<span class="built_in">mutable_timeout</span>() = TimeUtil::<span class="built_in">SecondsToDuration</span>(<span class="number">-60</span>);</span><br><span class="line">std::cout &lt;&lt; task.<span class="built_in">timeout</span>().<span class="built_in">seconds</span>() &lt;&lt; std::endl;  <span class="comment">// -60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（8）optional-T（可选字段）"><a href="#（8）optional-T（可选字段）" class="headerlink" title="（8）optional T（可选字段）"></a>（8）optional T（可选字段）</h3><h4 id="Proto-定义-7"><a href="#Proto-定义-7" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message Profile &#123;</span><br><span class="line">    optional string nickname = <span class="number">1</span>;</span><br><span class="line">    optional int32 age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-7"><a href="#C-生成类型伪代码-7" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Profile</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    std::string nickname_;</span><br><span class="line">    <span class="type">int32_t</span> age_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// optional 字段使用位图跟踪是否设置</span></span><br><span class="line">    <span class="type">uint32_t</span> _has_bits_[<span class="number">1</span>];           <span class="comment">// 位图</span></span><br><span class="line">    <span class="comment">// bit 0 → has_nickname</span></span><br><span class="line">    <span class="comment">// bit 1 → has_age</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">nickname</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_nickname</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_nickname</span><span class="params">(std::string&amp;&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_nickname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int32_t</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable ==========</span></span><br><span class="line">    <span class="function">std::string* <span class="title">mutable_nickname</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Has（✅ optional 核心特性）==========</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_nickname</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 检查 _has_bits_[0] &amp; 0x01</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_age</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">// 检查 _has_bits_[0] &amp; 0x02</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_nickname</span><span class="params">()</span></span>;        <span class="comment">// 清除值 + 清除 has 位</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-7"><a href="#使用示例-7" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;profile.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Profile p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 核心区别：区分 &quot;未设置&quot; vs &quot;设置为默认值&quot; =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态：未设置</span></span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">has_nickname</span>() &lt;&lt; std::endl;  <span class="comment">// false</span></span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">has_age</span>() &lt;&lt; std::endl;       <span class="comment">// false</span></span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">nickname</span>() &lt;&lt; std::endl;      <span class="comment">// &quot;&quot;（默认值）</span></span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">age</span>() &lt;&lt; std::endl;           <span class="comment">// 0（默认值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">p.<span class="built_in">set_nickname</span>(<span class="string">&quot;Ali&quot;</span>);</span><br><span class="line">p.<span class="built_in">set_age</span>(<span class="number">25</span>);</span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">has_nickname</span>() &lt;&lt; std::endl;  <span class="comment">// true</span></span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">has_age</span>() &lt;&lt; std::endl;       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 关键：设置为空/零 ≠ 未设置 =====</span></span><br><span class="line">p.<span class="built_in">set_nickname</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">p.<span class="built_in">set_age</span>(<span class="number">0</span>);</span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">has_nickname</span>() &lt;&lt; std::endl;  <span class="comment">// true!（已设置，只是值为空）</span></span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">has_age</span>() &lt;&lt; std::endl;       <span class="comment">// true!（已设置，只是值为0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除后才是&quot;未设置&quot;</span></span><br><span class="line">p.<span class="built_in">clear_nickname</span>();</span><br><span class="line">p.<span class="built_in">clear_age</span>();</span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">has_nickname</span>() &lt;&lt; std::endl;  <span class="comment">// false</span></span><br><span class="line">std::cout &lt;&lt; p.<span class="built_in">has_age</span>() &lt;&lt; std::endl;       <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 实际应用：可选参数处理 =====</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateProfile</span><span class="params">(<span class="type">const</span> Profile&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">has_nickname</span>()) &#123;</span><br><span class="line">        <span class="comment">// 用户明确提供了昵称（即使是空字符串）</span></span><br><span class="line">        db.<span class="built_in">update</span>(<span class="string">&quot;nickname&quot;</span>, p.<span class="built_in">nickname</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未设置则不更新</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">has_age</span>()) &#123;</span><br><span class="line">        db.<span class="built_in">update</span>(<span class="string">&quot;age&quot;</span>, p.<span class="built_in">age</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（9）repeated-T（数组）"><a href="#（9）repeated-T（数组）" class="headerlink" title="（9）repeated T（数组）"></a>（9）repeated T（数组）</h3><h4 id="Proto-定义-8"><a href="#Proto-定义-8" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message Cart &#123;</span><br><span class="line">    repeated string tags = <span class="number">1</span>;</span><br><span class="line">    repeated int32 counts = <span class="number">2</span>;</span><br><span class="line">    repeated Item items = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Item &#123;</span><br><span class="line">    string name = <span class="number">1</span>;</span><br><span class="line">    int32 price = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-8"><a href="#C-生成类型伪代码-8" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cart</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 存储字段 ==========</span></span><br><span class="line">    google::protobuf::RepeatedPtrField&lt;std::string&gt; tags_;   <span class="comment">// 字符串数组</span></span><br><span class="line">    google::protobuf::RepeatedField&lt;<span class="type">int32_t</span>&gt; counts_;        <span class="comment">// 标量数组</span></span><br><span class="line">    google::protobuf::RepeatedPtrField&lt;Item&gt; items_;         <span class="comment">// 消息数组</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ==================== repeated string ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Size（大小）-----</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tags_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Getter（只读访问）-----</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">tags</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::RepeatedPtrField&lt;std::string&gt;&amp; <span class="title">tags</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Setter（修改指定位置）-----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_tags</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Add（追加）-----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_tags</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function">std::string* <span class="title">add_tags</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Mutable（可修改访问）-----</span></span><br><span class="line">    <span class="function">std::string* <span class="title">mutable_tags</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">    google::<span class="function">protobuf::RepeatedPtrField&lt;std::string&gt;* <span class="title">mutable_tags</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Clear（清空）-----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_tags</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== repeated int32 ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Size -----</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">counts_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Getter -----</span></span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">counts</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::RepeatedField&lt;<span class="type">int32_t</span>&gt;&amp; <span class="title">counts</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Setter -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_counts</span><span class="params">(<span class="type">int</span> index, <span class="type">int32_t</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Add -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_counts</span><span class="params">(<span class="type">int32_t</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Mutable -----</span></span><br><span class="line">    google::<span class="function">protobuf::RepeatedField&lt;<span class="type">int32_t</span>&gt;* <span class="title">mutable_counts</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Clear -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_counts</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== repeated message ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Size -----</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">items_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Getter -----</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Item&amp; <span class="title">items</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::RepeatedPtrField&lt;Item&gt;&amp; <span class="title">items</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Add（返回新元素指针）-----</span></span><br><span class="line">    <span class="function">Item* <span class="title">add_items</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Mutable -----</span></span><br><span class="line">    <span class="function">Item* <span class="title">mutable_items</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">    google::<span class="function">protobuf::RepeatedPtrField&lt;Item&gt;* <span class="title">mutable_items</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Clear -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_items</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== RepeatedField（标量数组）====================</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RepeatedField</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 内部存储 ==========</span></span><br><span class="line">    T* elements_;           <span class="comment">// 动态数组</span></span><br><span class="line">    <span class="type">int</span> current_size_;      <span class="comment">// 当前元素数</span></span><br><span class="line">    <span class="type">int</span> total_size_;        <span class="comment">// 已分配容量</span></span><br><span class="line">    Arena* arena_;          <span class="comment">// 可选内存池</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ----- Size -----</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Access -----</span></span><br><span class="line">    <span class="function">T <span class="title">Get</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    T <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;</span><br><span class="line">    <span class="function">T <span class="title">at</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Modify -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> index, T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">Add</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Remove -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExtractSubrange</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> num, T* elements)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Truncate</span><span class="params">(<span class="type">int</span> new_size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Iterate -----</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Raw Data -----</span></span><br><span class="line">    <span class="function">T* <span class="title">mutable_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T* <span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== RepeatedPtrField（消息/字符串数组）====================</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RepeatedPtrField</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ========== 内部存储 ==========</span></span><br><span class="line">    T** elements_;          <span class="comment">// 指针数组</span></span><br><span class="line">    <span class="type">int</span> current_size_;</span><br><span class="line">    <span class="type">int</span> total_size_;</span><br><span class="line">    Arena* arena_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ----- Size -----</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Access -----</span></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Get</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Mutable Access -----</span></span><br><span class="line">    <span class="function">T* <span class="title">Mutable</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Add -----</span></span><br><span class="line">    <span class="function">T* <span class="title">Add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(T&amp;&amp; value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Remove -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DeleteSubrange</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Swap -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SwapElements</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Iterate -----</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-8"><a href="#使用示例-8" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cart.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Cart cart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== repeated string ====================</span></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">cart.<span class="built_in">add_tags</span>(<span class="string">&quot;electronics&quot;</span>);</span><br><span class="line">cart.<span class="built_in">add_tags</span>(<span class="string">&quot;sale&quot;</span>);</span><br><span class="line">cart.<span class="built_in">add_tags</span>(<span class="string">&quot;hot&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">std::cout &lt;&lt; cart.<span class="built_in">tags_size</span>() &lt;&lt; std::endl;  <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; cart.<span class="built_in">tags</span>(<span class="number">0</span>) &lt;&lt; std::endl;      <span class="comment">// electronics</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tag : cart.<span class="built_in">tags</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; tag &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">cart.<span class="built_in">set_tags</span>(<span class="number">0</span>, <span class="string">&quot;digital&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">cart.<span class="built_in">clear_tags</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== repeated int32 ====================</span></span><br><span class="line">cart.<span class="built_in">add_counts</span>(<span class="number">10</span>);</span><br><span class="line">cart.<span class="built_in">add_counts</span>(<span class="number">20</span>);</span><br><span class="line">cart.<span class="built_in">add_counts</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; cart.<span class="built_in">counts</span>(<span class="number">1</span>) &lt;&lt; std::endl;  <span class="comment">// 20</span></span><br><span class="line">cart.<span class="built_in">set_counts</span>(<span class="number">1</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cart.<span class="built_in">counts_size</span>(); i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; cart.<span class="built_in">counts</span>(i) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== repeated message ====================</span></span><br><span class="line"><span class="comment">// 添加并设置（返回指针）</span></span><br><span class="line">Item* item1 = cart.<span class="built_in">add_items</span>();</span><br><span class="line">item1-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;iPhone&quot;</span>);</span><br><span class="line">item1-&gt;<span class="built_in">set_price</span>(<span class="number">999</span>);</span><br><span class="line"></span><br><span class="line">Item* item2 = cart.<span class="built_in">add_items</span>();</span><br><span class="line">item2-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;AirPods&quot;</span>);</span><br><span class="line">item2-&gt;<span class="built_in">set_price</span>(<span class="number">199</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">std::cout &lt;&lt; cart.<span class="built_in">items_size</span>() &lt;&lt; std::endl;        <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; cart.<span class="built_in">items</span>(<span class="number">0</span>).<span class="built_in">name</span>() &lt;&lt; std::endl;     <span class="comment">// iPhone</span></span><br><span class="line">std::cout &lt;&lt; cart.<span class="built_in">items</span>(<span class="number">0</span>).<span class="built_in">price</span>() &lt;&lt; std::endl;    <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : cart.<span class="built_in">items</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; item.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;: $&quot;</span> &lt;&lt; item.<span class="built_in">price</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改已存在的元素</span></span><br><span class="line">cart.<span class="built_in">mutable_items</span>(<span class="number">0</span>)-&gt;<span class="built_in">set_price</span>(<span class="number">899</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">cart.<span class="built_in">mutable_items</span>()-&gt;<span class="built_in">DeleteSubrange</span>(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 删除索引0，删1个</span></span><br><span class="line">std::cout &lt;&lt; cart.<span class="built_in">items_size</span>() &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换元素位置</span></span><br><span class="line">cart.<span class="built_in">add_items</span>()-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;iPad&quot;</span>);</span><br><span class="line">cart.<span class="built_in">mutable_items</span>()-&gt;<span class="built_in">SwapElements</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最后一个</span></span><br><span class="line">cart.<span class="built_in">mutable_items</span>()-&gt;<span class="built_in">RemoveLast</span>();</span><br></pre></td></tr></table></figure>

<h2 id="3-通用-Message-基类方法"><a href="#3-通用-Message-基类方法" class="headerlink" title="3.通用 Message 基类方法"></a>3.通用 Message 基类方法</h2><h3 id="（1）C-生成伪代码"><a href="#（1）C-生成伪代码" class="headerlink" title="（1）C++ 生成伪代码"></a>（1）C++ 生成伪代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> _cached_size_;  <span class="comment">// 缓存序列化后的字节大小，避免重复计算</span></span><br><span class="line">    Arena* _arena_;             <span class="comment">// 内存池指针，用于高效内存管理</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ==================== 序列化（对象 → 二进制）====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SerializeToString</span><span class="params">(std::string* output)</span> <span class="type">const</span></span>;  <span class="comment">// 序列化到 string，成功返回 true</span></span><br><span class="line">    <span class="function">std::string <span class="title">SerializeAsString</span><span class="params">()</span> <span class="type">const</span></span>;              <span class="comment">// 序列化并返回 string（失败返回空）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SerializeToArray</span><span class="params">(<span class="type">void</span>* data, <span class="type">int</span> size)</span> <span class="type">const</span></span>;  <span class="comment">// 序列化到预分配的 buffer</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ByteSizeLong</span><span class="params">()</span> <span class="type">const</span></span>;                        <span class="comment">// 计算序列化后的字节数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== 反序列化（二进制 → 对象）====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ParseFromString</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span></span>;      <span class="comment">// 从 string 解析，成功返回 true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ParseFromArray</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">int</span> size)</span></span>;    <span class="comment">// 从 buffer 解析</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== 复制 ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyFrom</span><span class="params">(<span class="type">const</span> Message&amp; from)</span></span>;   <span class="comment">// 完全覆盖：先 Clear()，再复制</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MergeFrom</span><span class="params">(<span class="type">const</span> Message&amp; from)</span></span>;  <span class="comment">// 合并：只覆盖 from 中已设置的字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== 清空 ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;  <span class="comment">// 重置所有字段为默认值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== 调试 ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 格式化输出（多行，带缩进）</span></span><br><span class="line">    <span class="function">std::string <span class="title">ShortDebugString</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 紧凑输出（单行）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（2）序列化-反序列化"><a href="#（2）序列化-反序列化" class="headerlink" title="（2）序列化&#x2F;反序列化"></a>（2）序列化&#x2F;反序列化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">User user;</span><br><span class="line">user.<span class="built_in">set_id</span>(<span class="number">42</span>);</span><br><span class="line">user.<span class="built_in">set_name</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">std::string data = user.<span class="built_in">SerializeAsString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">User user2;</span><br><span class="line">user<span class="number">2.</span><span class="built_in">ParseFromString</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试输出</span></span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">DebugString</span>();</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// id: 42</span></span><br><span class="line"><span class="comment">// name: &quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">ShortDebugString</span>();</span><br><span class="line"><span class="comment">// 输出: id: 42 name: &quot;Alice&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="补充：Well-Known-Types"><a href="#补充：Well-Known-Types" class="headerlink" title="补充：Well-Known Types"></a>补充：Well-Known Types</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120090503033.png"></p>
<h3 id="（1）Wrapper-Types（包装类型）"><a href="#（1）Wrapper-Types（包装类型）" class="headerlink" title="（1）Wrapper Types（包装类型）"></a>（1）Wrapper Types（包装类型）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120091029916.png"><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120091111812.png"></p>
<h4 id="Proto-定义-9"><a href="#Proto-定义-9" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/wrappers.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message User &#123;</span><br><span class="line">    google.protobuf.Int32Value age = <span class="number">1</span>;        <span class="comment">// 可判断是否设置</span></span><br><span class="line">    google.protobuf.StringValue nickname = <span class="number">2</span>;</span><br><span class="line">    google.protobuf.BoolValue is_vip = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-9"><a href="#C-生成类型伪代码-9" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> google::protobuf &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 Int32Value 为例，其他类似</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Int32Value</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int32_t</span> value_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int32_t</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace google::protobuf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    google::protobuf::Int32Value* age_;           <span class="comment">// 指针存储</span></span><br><span class="line">    google::protobuf::StringValue* nickname_;</span><br><span class="line">    google::protobuf::BoolValue* is_vip_;</span><br><span class="line">    <span class="type">uint32_t</span> _has_bits_[<span class="number">1</span>];                       <span class="comment">// 位图跟踪</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Has（核心特性）==========</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_age</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_nickname</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_is_vip</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="type">const</span> google::<span class="function">protobuf::Int32Value&amp; <span class="title">age</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable ==========</span></span><br><span class="line">    google::<span class="function">protobuf::Int32Value* <span class="title">mutable_age</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Clear ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-9"><a href="#使用示例-9" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/wrappers.pb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 核心用法：区分&quot;未设置&quot; vs &quot;设置为0/空&quot; =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态：未设置</span></span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">has_age</span>() &lt;&lt; std::endl;  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">user.<span class="built_in">mutable_age</span>()-&gt;<span class="built_in">set_value</span>(<span class="number">25</span>);</span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">has_age</span>() &lt;&lt; std::endl;      <span class="comment">// true</span></span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">age</span>().<span class="built_in">value</span>() &lt;&lt; std::endl;  <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 关键：设置为 0 也能检测到 =====</span></span><br><span class="line">user.<span class="built_in">mutable_age</span>()-&gt;<span class="built_in">set_value</span>(<span class="number">0</span>);</span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">has_age</span>() &lt;&lt; std::endl;      <span class="comment">// true! ✅</span></span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">age</span>().<span class="built_in">value</span>() &lt;&lt; std::endl;  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除后才是&quot;未设置&quot;</span></span><br><span class="line">user.<span class="built_in">clear_age</span>();</span><br><span class="line">std::cout &lt;&lt; user.<span class="built_in">has_age</span>() &lt;&lt; std::endl;  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 实际应用：API 更新接口 =====</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateUser</span><span class="params">(<span class="type">const</span> User&amp; req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="built_in">has_age</span>()) &#123;</span><br><span class="line">        <span class="comment">// 用户明确传了 age（即使是 0）</span></span><br><span class="line">        db.<span class="built_in">update</span>(<span class="string">&quot;age&quot;</span>, req.<span class="built_in">age</span>().<span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未设置则不更新该字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (req.<span class="built_in">has_nickname</span>()) &#123;</span><br><span class="line">        db.<span class="built_in">update</span>(<span class="string">&quot;nickname&quot;</span>, req.<span class="built_in">nickname</span>().<span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Wrapper-vs-optional-对比"><a href="#Wrapper-vs-optional-对比" class="headerlink" title="&lt;4&gt;Wrapper vs optional 对比"></a>&lt;4&gt;Wrapper vs optional 对比</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120091236245.png"></p>
<h3 id="（2）Struct-Value-ListValue（动态-JSON-结构）"><a href="#（2）Struct-Value-ListValue（动态-JSON-结构）" class="headerlink" title="（2）Struct &#x2F; Value &#x2F; ListValue（动态 JSON 结构）"></a>（2）Struct &#x2F; Value &#x2F; ListValue（动态 JSON 结构）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120091314284.png"><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120091430492.png"></p>
<h4 id="Proto-定义-10"><a href="#Proto-定义-10" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/struct.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message Config &#123;</span><br><span class="line">    google.protobuf.Struct settings = <span class="number">1</span>;   <span class="comment">// 任意 JSON 对象</span></span><br><span class="line">    google.protobuf.Value metadata = <span class="number">2</span>;    <span class="comment">// 任意 JSON 值</span></span><br><span class="line">    google.protobuf.ListValue items = <span class="number">3</span>;   <span class="comment">// JSON 数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-10"><a href="#C-生成类型伪代码-10" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> google::protobuf &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== Value（任意 JSON 值）====================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">KindCase</span> &#123;</span><br><span class="line">        kNullValue = <span class="number">1</span>,</span><br><span class="line">        kNumberValue = <span class="number">2</span>,</span><br><span class="line">        kStringValue = <span class="number">3</span>,</span><br><span class="line">        kBoolValue = <span class="number">4</span>,</span><br><span class="line">        kStructValue = <span class="number">5</span>,</span><br><span class="line">        kListValue = <span class="number">6</span>,</span><br><span class="line">        KIND_NOT_SET = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// oneof 存储</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        NullValue null_value_;</span><br><span class="line">        <span class="type">double</span> number_value_;</span><br><span class="line">        std::string* string_value_;</span><br><span class="line">        <span class="type">bool</span> bool_value_;</span><br><span class="line">        Struct* struct_value_;</span><br><span class="line">        ListValue* list_value_;</span><br><span class="line">    &#125;;</span><br><span class="line">    KindCase kind_case_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== Kind 判断 ==========</span></span><br><span class="line">    <span class="function">KindCase <span class="title">kind_case</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Getter ==========</span></span><br><span class="line">    <span class="function">NullValue <span class="title">null_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">number_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">string_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bool_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> Struct&amp; <span class="title">struct_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> ListValue&amp; <span class="title">list_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Setter ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_null_value</span><span class="params">(NullValue value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_number_value</span><span class="params">(<span class="type">double</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_string_value</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_bool_value</span><span class="params">(<span class="type">bool</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Mutable ==========</span></span><br><span class="line">    <span class="function">Struct* <span class="title">mutable_struct_value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ListValue* <span class="title">mutable_list_value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== Struct（JSON 对象）====================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Struct</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    google::protobuf::Map&lt;std::string, Value&gt; fields_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== 字段访问 ==========</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Map&lt;std::string, Value&gt;&amp; <span class="title">fields</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Map&lt;std::string, Value&gt;* <span class="title">mutable_fields</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== ListValue（JSON 数组）====================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListValue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    google::protobuf::RepeatedPtrField&lt;Value&gt; values_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ========== 元素访问 ==========</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">values_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> Value&amp; <span class="title">values</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Value* <span class="title">add_values</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Value* <span class="title">mutable_values</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> RepeatedPtrField&lt;Value&gt;&amp; <span class="title">values</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">RepeatedPtrField&lt;Value&gt;* <span class="title">mutable_values</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace google::protobuf</span></span><br></pre></td></tr></table></figure>

<h4 id="使用示例-10"><a href="#使用示例-10" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/struct.pb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> google::protobuf::Struct;</span><br><span class="line"><span class="keyword">using</span> google::protobuf::Value;</span><br><span class="line"><span class="keyword">using</span> google::protobuf::ListValue;</span><br><span class="line"></span><br><span class="line">Config config;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 构建 Struct（JSON 对象）====================</span></span><br><span class="line"><span class="comment">// 目标: &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;active&quot;: true &#125;</span></span><br><span class="line"></span><br><span class="line">Struct* settings = config.<span class="built_in">mutable_settings</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 string</span></span><br><span class="line">(*settings-&gt;<span class="built_in">mutable_fields</span>())[<span class="string">&quot;name&quot;</span>].<span class="built_in">set_string_value</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 number</span></span><br><span class="line">(*settings-&gt;<span class="built_in">mutable_fields</span>())[<span class="string">&quot;age&quot;</span>].<span class="built_in">set_number_value</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 bool</span></span><br><span class="line">(*settings-&gt;<span class="built_in">mutable_fields</span>())[<span class="string">&quot;active&quot;</span>].<span class="built_in">set_bool_value</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 null</span></span><br><span class="line">(*settings-&gt;<span class="built_in">mutable_fields</span>())[<span class="string">&quot;deleted_at&quot;</span>].<span class="built_in">set_null_value</span>(</span><br><span class="line">    google::protobuf::NULL_VALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 嵌套对象 ====================</span></span><br><span class="line"><span class="comment">// 目标: &#123; &quot;address&quot;: &#123; &quot;city&quot;: &quot;Beijing&quot;, &quot;zip&quot;: &quot;100000&quot; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">Struct* address = (*settings-&gt;<span class="built_in">mutable_fields</span>())[<span class="string">&quot;address&quot;</span>].<span class="built_in">mutable_struct_value</span>();</span><br><span class="line">(*address-&gt;<span class="built_in">mutable_fields</span>())[<span class="string">&quot;city&quot;</span>].<span class="built_in">set_string_value</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">(*address-&gt;<span class="built_in">mutable_fields</span>())[<span class="string">&quot;zip&quot;</span>].<span class="built_in">set_string_value</span>(<span class="string">&quot;100000&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 数组 ====================</span></span><br><span class="line"><span class="comment">// 目标: &#123; &quot;tags&quot;: [&quot;vip&quot;, &quot;new&quot;, 123] &#125;</span></span><br><span class="line"></span><br><span class="line">ListValue* tags = (*settings-&gt;<span class="built_in">mutable_fields</span>())[<span class="string">&quot;tags&quot;</span>].<span class="built_in">mutable_list_value</span>();</span><br><span class="line">tags-&gt;<span class="built_in">add_values</span>()-&gt;<span class="built_in">set_string_value</span>(<span class="string">&quot;vip&quot;</span>);</span><br><span class="line">tags-&gt;<span class="built_in">add_values</span>()-&gt;<span class="built_in">set_string_value</span>(<span class="string">&quot;new&quot;</span>);</span><br><span class="line">tags-&gt;<span class="built_in">add_values</span>()-&gt;<span class="built_in">set_number_value</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 读取 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 string</span></span><br><span class="line"><span class="keyword">if</span> (settings-&gt;<span class="built_in">fields</span>().<span class="built_in">contains</span>(<span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">const</span> Value&amp; v = settings-&gt;<span class="built_in">fields</span>().<span class="built_in">at</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">kind_case</span>() == Value::kStringValue) &#123;</span><br><span class="line">        std::cout &lt;&lt; v.<span class="built_in">string_value</span>() &lt;&lt; std::endl;  <span class="comment">// Alice</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 number</span></span><br><span class="line"><span class="type">double</span> age = settings-&gt;<span class="built_in">fields</span>().<span class="built_in">at</span>(<span class="string">&quot;age&quot;</span>).<span class="built_in">number_value</span>();</span><br><span class="line">std::cout &lt;&lt; age &lt;&lt; std::endl;  <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有字段</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : settings-&gt;<span class="built_in">fields</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (value.<span class="built_in">kind_case</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> Value::kStringValue:</span><br><span class="line">            std::cout &lt;&lt; value.<span class="built_in">string_value</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Value::kNumberValue:</span><br><span class="line">            std::cout &lt;&lt; value.<span class="built_in">number_value</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Value::kBoolValue:</span><br><span class="line">            std::cout &lt;&lt; (value.<span class="built_in">bool_value</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Value::kNullValue:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;null&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Value::kStructValue:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;&#123;...&#125;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Value::kListValue:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[...]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数组</span></span><br><span class="line"><span class="type">const</span> ListValue&amp; tag_list = settings-&gt;<span class="built_in">fields</span>().<span class="built_in">at</span>(<span class="string">&quot;tags&quot;</span>).<span class="built_in">list_value</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tag_list.<span class="built_in">values_size</span>(); i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tag[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]: &quot;</span>;</span><br><span class="line">    <span class="type">const</span> Value&amp; v = tag_list.<span class="built_in">values</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">kind_case</span>() == Value::kStringValue) &#123;</span><br><span class="line">        std::cout &lt;&lt; v.<span class="built_in">string_value</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.<span class="built_in">kind_case</span>() == Value::kNumberValue) &#123;</span><br><span class="line">        std::cout &lt;&lt; v.<span class="built_in">number_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Struct-与-JSON-互转"><a href="#Struct-与-JSON-互转" class="headerlink" title="&lt;4&gt;Struct 与 JSON 互转"></a>&lt;4&gt;Struct 与 JSON 互转</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/util/json_util.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> google::protobuf::util::JsonStringToMessage;</span><br><span class="line"><span class="keyword">using</span> google::protobuf::util::MessageToJsonString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON → Struct</span></span><br><span class="line">std::string json = <span class="string">R&quot;(&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class="line"><span class="string">    &quot;age&quot;: 25,</span></span><br><span class="line"><span class="string">    &quot;tags&quot;: [&quot;vip&quot;, &quot;new&quot;]</span></span><br><span class="line"><span class="string">&#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">Struct s;</span><br><span class="line"><span class="keyword">auto</span> status = <span class="built_in">JsonStringToMessage</span>(json, &amp;s);</span><br><span class="line"><span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;解析成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct → JSON</span></span><br><span class="line">std::string output;</span><br><span class="line"><span class="built_in">MessageToJsonString</span>(s, &amp;output);</span><br><span class="line">std::cout &lt;&lt; output &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25,&quot;tags&quot;:[&quot;vip&quot;,&quot;new&quot;]&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）Empty（空消息）"><a href="#（3）Empty（空消息）" class="headerlink" title="（3）Empty（空消息）"></a>（3）Empty（空消息）</h3><h4 id="Proto-定义-11"><a href="#Proto-定义-11" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/empty.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">service HealthService &#123;</span><br><span class="line">    <span class="function">rpc <span class="title">Ping</span><span class="params">(google.protobuf.Empty)</span> <span class="title">returns</span> <span class="params">(google.protobuf.Empty)</span></span>;</span><br><span class="line">    <span class="function">rpc <span class="title">DeleteUser</span><span class="params">(DeleteUserRequest)</span> <span class="title">returns</span> <span class="params">(google.protobuf.Empty)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DeleteUserRequest &#123;</span><br><span class="line">    int32 user_id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-11"><a href="#C-生成类型伪代码-11" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> google::protobuf &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 几乎没有方法，就是一个空消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsInitialized</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ByteSizeLong</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 始终返回 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace google::protobuf</span></span><br></pre></td></tr></table></figure>

<h4 id="使用示例-11"><a href="#使用示例-11" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/empty.pb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;health_service.grpc.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> google::protobuf::Empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== gRPC 客户端调用 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ping：无参数，无返回</span></span><br><span class="line">Empty req, resp;</span><br><span class="line">grpc::ClientContext context;</span><br><span class="line">grpc::Status status = stub-&gt;<span class="built_in">Ping</span>(&amp;context, req, &amp;resp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Ping 成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeleteUser：有参数，无返回</span></span><br><span class="line">DeleteUserRequest del_req;</span><br><span class="line">del_req.<span class="built_in">set_user_id</span>(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">Empty del_resp;</span><br><span class="line">status = stub-&gt;<span class="built_in">DeleteUser</span>(&amp;context, del_req, &amp;del_resp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== gRPC 服务端实现 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthServiceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> HealthService::Service &#123;</span><br><span class="line">    <span class="function">grpc::Status <span class="title">Ping</span><span class="params">(grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> Empty* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Empty* response)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 什么都不用做，直接返回 OK</span></span><br><span class="line">        <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">grpc::Status <span class="title">DeleteUser</span><span class="params">(grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> DeleteUserRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Empty* response)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">int32_t</span> user_id = request-&gt;<span class="built_in">user_id</span>();</span><br><span class="line">        db.<span class="built_in">deleteUser</span>(user_id);</span><br><span class="line">        <span class="comment">// 不需要填充 response</span></span><br><span class="line">        <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（4）FieldMask（字段掩码）"><a href="#（4）FieldMask（字段掩码）" class="headerlink" title="（4）FieldMask（字段掩码）"></a>（4）FieldMask（字段掩码）</h3><h4 id="Proto-定义-12"><a href="#Proto-定义-12" class="headerlink" title="&lt;1&gt;Proto 定义"></a>&lt;1&gt;Proto 定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/field_mask.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message User &#123;</span><br><span class="line">    int32 id = <span class="number">1</span>;</span><br><span class="line">    string name = <span class="number">2</span>;</span><br><span class="line">    string email = <span class="number">3</span>;</span><br><span class="line">    string phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UpdateUserRequest &#123;</span><br><span class="line">    User user = <span class="number">1</span>;</span><br><span class="line">    google.protobuf.FieldMask update_mask = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-生成类型伪代码-12"><a href="#C-生成类型伪代码-12" class="headerlink" title="&lt;2&gt;C++ 生成类型伪代码"></a>&lt;2&gt;C++ 生成类型伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> google::protobuf &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FieldMask</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    google::protobuf::RepeatedPtrField&lt;std::string&gt; paths_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ----- Size -----</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">paths_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Getter -----</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">paths</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> RepeatedPtrField&lt;std::string&gt;&amp; <span class="title">paths</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Add -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_paths</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    <span class="function">std::string* <span class="title">add_paths</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Mutable -----</span></span><br><span class="line">    <span class="function">std::string* <span class="title">mutable_paths</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">RepeatedPtrField&lt;std::string&gt;* <span class="title">mutable_paths</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----- Clear -----</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_paths</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace google::protobuf</span></span><br></pre></td></tr></table></figure>

<h4 id="使用示例-12"><a href="#使用示例-12" class="headerlink" title="&lt;3&gt;使用示例"></a>&lt;3&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/field_mask.pb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/util/field_mask_util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> google::protobuf::FieldMask;</span><br><span class="line"><span class="keyword">using</span> google::protobuf::util::FieldMaskUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 客户端：构建部分更新请求 ====================</span></span><br><span class="line"></span><br><span class="line">UpdateUserRequest req;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只更新 name 和 email</span></span><br><span class="line">req.<span class="built_in">mutable_user</span>()-&gt;<span class="built_in">set_id</span>(<span class="number">12345</span>);</span><br><span class="line">req.<span class="built_in">mutable_user</span>()-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">req.<span class="built_in">mutable_user</span>()-&gt;<span class="built_in">set_email</span>(<span class="string">&quot;alice@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定要更新的字段</span></span><br><span class="line">req.<span class="built_in">mutable_update_mask</span>()-&gt;<span class="built_in">add_paths</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">req.<span class="built_in">mutable_update_mask</span>()-&gt;<span class="built_in">add_paths</span>(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 服务端：根据 FieldMask 处理 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleUpdateUser</span><span class="params">(<span class="type">const</span> UpdateUserRequest&amp; req)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> User&amp; user = req.<span class="built_in">user</span>();</span><br><span class="line">    <span class="type">const</span> FieldMask&amp; mask = req.<span class="built_in">update_mask</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式1：手动遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; path : mask.<span class="built_in">paths</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">            db.<span class="built_in">update</span>(user.<span class="built_in">id</span>(), <span class="string">&quot;name&quot;</span>, user.<span class="built_in">name</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path == <span class="string">&quot;email&quot;</span>) &#123;</span><br><span class="line">            db.<span class="built_in">update</span>(user.<span class="built_in">id</span>(), <span class="string">&quot;email&quot;</span>, user.<span class="built_in">email</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path == <span class="string">&quot;phone&quot;</span>) &#123;</span><br><span class="line">            db.<span class="built_in">update</span>(user.<span class="built_in">id</span>(), <span class="string">&quot;phone&quot;</span>, user.<span class="built_in">phone</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2：使用 FieldMaskUtil 合并</span></span><br><span class="line">    User existing_user = db.<span class="built_in">getUser</span>(user.<span class="built_in">id</span>());</span><br><span class="line">    FieldMaskUtil::<span class="built_in">MergeMessageTo</span>(user, mask, &amp;existing_user);</span><br><span class="line">    db.<span class="built_in">saveUser</span>(existing_user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== FieldMaskUtil 工具函数 ====================</span></span><br><span class="line"></span><br><span class="line">User src, dst;</span><br><span class="line">src.<span class="built_in">set_name</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">src.<span class="built_in">set_email</span>(<span class="string">&quot;alice@example.com&quot;</span>);</span><br><span class="line">src.<span class="built_in">set_phone</span>(<span class="string">&quot;13800138000&quot;</span>);</span><br><span class="line"></span><br><span class="line">dst.<span class="built_in">set_id</span>(<span class="number">1</span>);</span><br><span class="line">dst.<span class="built_in">set_name</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">dst.<span class="built_in">set_email</span>(<span class="string">&quot;bob@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">FieldMask mask;</span><br><span class="line">mask.<span class="built_in">add_paths</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">mask.<span class="built_in">add_paths</span>(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只合并 mask 指定的字段</span></span><br><span class="line">FieldMaskUtil::<span class="built_in">MergeMessageTo</span>(src, mask, &amp;dst);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; dst.<span class="built_in">id</span>() &lt;&lt; std::endl;     <span class="comment">// 1（未被覆盖）</span></span><br><span class="line">std::cout &lt;&lt; dst.<span class="built_in">name</span>() &lt;&lt; std::endl;   <span class="comment">// Alice（被覆盖）</span></span><br><span class="line">std::cout &lt;&lt; dst.<span class="built_in">email</span>() &lt;&lt; std::endl;  <span class="comment">// alice@example.com（被覆盖）</span></span><br><span class="line">std::cout &lt;&lt; dst.<span class="built_in">phone</span>() &lt;&lt; std::endl;  <span class="comment">// &quot;&quot;（未被覆盖，dst 原本没有）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 其他工具函数 ====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 path 是否在 mask 中</span></span><br><span class="line"><span class="type">bool</span> has_name = FieldMaskUtil::<span class="built_in">IsPathInFieldMask</span>(<span class="string">&quot;name&quot;</span>, mask);  <span class="comment">// true</span></span><br><span class="line"><span class="type">bool</span> has_phone = FieldMaskUtil::<span class="built_in">IsPathInFieldMask</span>(<span class="string">&quot;phone&quot;</span>, mask); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为字符串</span></span><br><span class="line">std::string mask_str = FieldMaskUtil::<span class="built_in">ToString</span>(mask);  <span class="comment">// &quot;name,email&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串解析</span></span><br><span class="line">FieldMask mask2;</span><br><span class="line">FieldMaskUtil::<span class="built_in">FromString</span>(<span class="string">&quot;name,phone&quot;</span>, &amp;mask2);</span><br></pre></td></tr></table></figure>

<h1 id="三、RPC（远程过程调用）"><a href="#三、RPC（远程过程调用）" class="headerlink" title="三、RPC（远程过程调用）"></a>三、RPC（远程过程调用）</h1><h2 id="1-RPC的功能"><a href="#1-RPC的功能" class="headerlink" title="1.RPC的功能"></a>1.RPC的功能</h2><ul>
<li><strong>远程过程调用（Remote Procedure Call）</strong> 的核心目标是：<ul>
<li>让使用者在<strong>一台服务器上调用另一台服务器上的函数</strong>时，感觉<strong>就像调用本地函数</strong>一样简单。</li>
</ul>
</li>
<li>举个例子，假设你在服务器 A 上写代码，想获取服务器 B 上的用户信息：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用者视角：看起来就像调用本地函数</span></span><br><span class="line">UserResponse resp = userService.<span class="built_in">GetUser</span>(request);</span><br><span class="line"><span class="comment">// 实际上，这个请求通过网络发送到了服务器 B，服务器 B 执行后把结果返回</span></span><br></pre></td></tr></table></figure>
<p>从代码层面看，你完全 <strong>“感知不到”中间经历了网络传输、序列化、反序列化等复杂过程</strong>，这就是 RPC 的魅力所在。</p>
<p><a id="RPC（2）"></a></p>
<h2 id="2-RPC底层原理（重点！！）"><a href="#2-RPC底层原理（重点！！）" class="headerlink" title="2.RPC底层原理（重点！！）"></a>2.RPC底层原理（重点！！）</h2><h3 id="（1）RPC核心步骤（概述）"><a href="#（1）RPC核心步骤（概述）" class="headerlink" title="（1）RPC核心步骤（概述）"></a>（1）RPC核心步骤（概述）</h3><ul>
<li><strong>“双方定义一模一样的API”</strong> + <strong>“服务端注册方法”</strong> + <strong>“序列化”（序列化客户端发送的请求）</strong> + <strong>“网络通信”</strong> + <strong>“反序列化”（反序列化客户端发送的请求）</strong>+ <strong>“路由”（获取具体的方法进行执行）</strong></li>
</ul>
<h3 id="（2）RPC过程详解"><a href="#（2）RPC过程详解" class="headerlink" title="（2）RPC过程详解"></a>（2）RPC过程详解</h3><p>RPC 是如何实现”像调用本地函数一样”的效果呢？我们以客户端、服务端为例，服务端不同服务可能有同名的方法，所以我们以 <strong>（服务名,方法名）二元组</strong> 来定位一个“具体方法”</p>
<ul>
<li><strong>第一步：在客户端与服务端上定义好“一模一样”的API</strong><ul>
<li>客户端和服务端必须事先约定好接口的定义——<strong>服务名</strong>是什么、<strong>方法名</strong>叫什么、<strong>参数</strong>是什么类型、<strong>返回值</strong>是什么类型 ——&gt; 只有双方的”契约”一致，才能正确地互相理解。</li>
</ul>
</li>
<li><strong>第二步：服务端“注册方法”</strong><ul>
<li>如通过 <strong>std::map&lt;服务名:方法名,具体方法&gt;</strong> 来进行映射存储    ——&gt;这样就可以通过（服务名，方法名）来定位“具体方法”（<strong>具体方法&#x3D;map[服务名:方法名]</strong>）</li>
</ul>
</li>
<li><strong>第三步：客户端调用时，将”服务名+方法名 + 参数”进行“序列化”，再通过“网络发送”到目标服务端</strong><ul>
<li>当客户端执行User服务的GetUser(request)方法 时，RPC 框架会在背后做这些事情：<ul>
<li>1.把服务名（如 “User”）、方法名（如 “GetUser”）、参数（如 request 对象）<strong>序列化</strong>成二进制数据</li>
<li>2.通过网络把这些数据发送到服务端</li>
</ul>
</li>
</ul>
</li>
<li><strong>第四步：到达服务端后，进行“路由”后得到“具体方法”，进而执行对应方法</strong><ul>
<li>服务端收到数据后：<ul>
<li>1.<strong>反序列化</strong>得到“服务名”、“方法名”、“参数”</li>
<li>2.<strong>具体方法 &#x3D; map[服务名:方法名]</strong>，再用反序列化出的参数调用它</li>
<li>3.得到返回值后，再将返回值<strong>序列化</strong>，通过网络传回给客户端</li>
<li><strong>路由</strong>：就是指找到对应的“具体方法”进行执行</li>
</ul>
</li>
</ul>
</li>
<li><strong>第五步：客户端收到返回值，继续执行</strong><ul>
<li>客户端收到返回的二进制数据后，反序列化得到返回值，然后就像普通函数调用一样继续往下执行。</li>
</ul>
</li>
</ul>
<p><strong>关键点总结</strong>：</p>
<ul>
<li>RPC 的核心就是<strong>封装了中间网络通信的全部细节</strong>（序列化、网络传输、反序列化、路由），让开发者只需要关注”调用什么函数、传什么参数、拿什么返回值”，从而达到”像调用本地 API 一样”的使用体验。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                           RPC 调用完整流程                               │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   调用端服务器 (A)                              目标服务器 (B)            │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌──────────────┐                            ┌──────────────┐          │</span><br><span class="line">│   │  业务代码     │                            │  相同的 API   │          │</span><br><span class="line">│   │              │                            │              │          │</span><br><span class="line">│   │ <span class="built_in">GetUser</span>(req) │                            │ <span class="built_in">GetUser</span>(req) │          │</span><br><span class="line">│   └──────┬───────┘                            └──────▲───────┘          │</span><br><span class="line">│          │ ①调用                                     │ ④执行            │</span><br><span class="line">│          ▼                                           │                  │</span><br><span class="line">│   ┌──────────────┐                            ┌──────┴───────┐          │</span><br><span class="line">│   │  RPC 框架     │                            │  RPC 框架     │          │</span><br><span class="line">│   │              │                            │              │          │</span><br><span class="line">│   │ ②序列化       │     ═══════════════════    │ ③反序列化     │          │</span><br><span class="line">│   │ 方法名+参数   │────►   网络传输请求   ────►│ 方法名+参数   │          │</span><br><span class="line">│   │              │                            │              │          │</span><br><span class="line">│   │ ⑥反序列化    │◄────   网络传输响应   ◄────│ ⑤序列化      │          │</span><br><span class="line">│   │ 返回值       │     ═══════════════════    │ 返回值       │          │</span><br><span class="line">│   └──────┬───────┘                            └──────────────┘          │</span><br><span class="line">│          │ ⑦返回                                                        │</span><br><span class="line">│          ▼                                                              │</span><br><span class="line">│   ┌──────────────┐                                                      │</span><br><span class="line">│   │  业务代码     │                                                      │</span><br><span class="line">│   │ 拿到返回值    │                                                      │</span><br><span class="line">│   │ 继续执行...   │                                                      │</span><br><span class="line">│   └──────────────┘                                                      │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="3-RPC-的性能与价值"><a href="#3-RPC-的性能与价值" class="headerlink" title="3.RPC 的性能与价值"></a>3.RPC 的性能与价值</h2><ul>
<li><strong>性能方面</strong>：<ul>
<li>由于 RPC 调用中间<strong>增加了序列化、网络传输、反序列化等步骤</strong>，其<strong>性能必然“低于”直接调用本地函数</strong>。</li>
<li>一次本地函数调用可能只需要几纳秒，而一次 RPC 调用即使在同一局域网内，也至少需要几百微秒到几毫秒。</li>
</ul>
</li>
<li><strong>那为什么还要用 RPC？</strong><ul>
<li>因为在现代软件系统中，<strong>单台服务器的能力是有限的</strong>：<ul>
<li><strong>资源有限</strong>：一台机器的 CPU、内存、磁盘都是有上限的</li>
<li><strong>负载能力有限</strong>：单机能承受的并发请求量有限</li>
<li><strong>容错能力差</strong>：单机故障会导致整个服务不可用</li>
<li><strong>扩展困难</strong>：业务增长时，单机很难快速扩容</li>
</ul>
</li>
<li>要解决这些问题，必须采用<strong>分布式架构</strong>——把服务拆分到多台机器上运行。而<strong>机器之间的通信，就需要 RPC 来完成</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                     为什么需要 RPC？                             │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│   单机困境                              分布式解决方案            │</span><br><span class="line">│   ──────────                            ──────────────          │</span><br><span class="line">│                                                                 │</span><br><span class="line">│   资源有限                    ──────►   多机水平扩展             │</span><br><span class="line">│   (CPU/内存/磁盘)                       (加机器就能加资源)        │</span><br><span class="line">│                                                                 │</span><br><span class="line">│   负载能力差                  ──────►   负载均衡                 │</span><br><span class="line">│   (单机扛不住高并发)                    (请求分散到多台机器)      │</span><br><span class="line">│                                                                 │</span><br><span class="line">│   单点故障                    ──────►   容错冗余                 │</span><br><span class="line">│   (一台挂了全挂)                        (一台挂了其他顶上)        │</span><br><span class="line">│                                                                 │</span><br><span class="line">│   扩展困难                    ──────►   弹性伸缩                 │</span><br><span class="line">│   (业务增长难应对)                      (按需增减机器)           │</span><br><span class="line">│                                                                 │</span><br><span class="line">│                                                                 │</span><br><span class="line">│            ┌─────────────────────────────────────┐              │</span><br><span class="line">│            │  RPC 是分布式系统的<span class="string">&quot;神经网络&quot;</span>        │              │</span><br><span class="line">│            │  让多台机器能像一台机器一样协同工作   │              │</span><br><span class="line">│            └─────────────────────────────────────┘              │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>


<h1 id="四、Proto-Service（纯-Protobuf-层面）"><a href="#四、Proto-Service（纯-Protobuf-层面）" class="headerlink" title="四、Proto Service（纯 Protobuf 层面）"></a>四、Proto Service（纯 Protobuf 层面）</h1><ul>
<li>前面提到，RPC 要求调用端和被调用端有”<strong>一模一样的 API</strong>“。那这个 API 谁来定义？手写容易出错、跨语言还得写多份，非常麻烦 ——&gt; <strong>Proto Service 就是来解决这个问题的</strong></li>
<li>通过protoc编译后，Proto中的Service就会<strong>自动生成</strong> C++ 对应的抽象类和 Stub（客户端桩），也就不用我们自己去定义“<strong>一模一样的API</strong>”</li>
<li>除了自动生成代码，Proto Service 还<strong>自带了 Protobuf 的序列化、反序列化能力</strong> ——&gt; 消息的序列化和反序列化都由生成的代码自动处理，你不需要关心数据在网络上是怎么传输的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    Proto Service 的价值                           │</span><br><span class="line">├───────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                   │</span><br><span class="line">│   传统方式（手写）                  Proto Service 方式             │</span><br><span class="line">│                                                                   │</span><br><span class="line">│   ┌─────────────────┐              ┌─────────────────┐            │</span><br><span class="line">│   │ 服务端手写 API   │              │  .proto 文件     │            │</span><br><span class="line">│   │ (C++ 版本)      │              │  定义一次        │            │</span><br><span class="line">│   └─────────────────┘              └────────┬────────┘            │</span><br><span class="line">│            +                                │                     │</span><br><span class="line">│   ┌─────────────────┐                       │ protoc 编译         │</span><br><span class="line">│   │ 客户端手写 API   │                       ▼                     │</span><br><span class="line">│   │ (C++ 版本)      │              ┌────────┴────────┐            │</span><br><span class="line">│   └─────────────────┘              │                 │            │</span><br><span class="line">│            +                       ▼                 ▼            │</span><br><span class="line">│   ┌─────────────────┐      ┌─────────────┐   ┌─────────────┐     │</span><br><span class="line">│   │ 其他语言再写一遍  │      │ 服务端基类   │   │ 客户端 Stub │     │</span><br><span class="line">│   │ (Java/Go/...)   │      │ (自动生成)   │   │ (自动生成)  │     │</span><br><span class="line">│   └─────────────────┘      └─────────────┘   └─────────────┘     │</span><br><span class="line">│                                                                   │</span><br><span class="line">│   ❌ 繁琐、易出错、难维护    ✅ 一次定义、多端生成、“序列化、反序列化”   │</span><br><span class="line">│                                                                   │</span><br><span class="line">└───────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>注意</strong>：本节聚焦于 <strong>Protobuf 原生 Service 机制</strong>，与 gRPC 框架无关。Protobuf 的 Service 只是一个「接口描述层」，<strong>需要自己实现 RPC 通信层</strong>。</p>
<ul>
<li>在Protobuf中，message描述 <strong>数据结构</strong>，service描述 <strong>RPC接口</strong></li>
<li>在 .proto 文件里 <strong>“定义服务的方法名、参数、返回值”</strong> ，通过 protoc 编译后，会<strong>自动生成</strong> C++ 对应的 <strong>抽象基类（服务端实现）</strong> 和 <strong>Stub 类（客户端桩）</strong></li>
<li>需要注意的是：原生的Proto Service <strong>本身不包含网络传输逻辑</strong>，它只是<strong>定义”接口长什么样”</strong>。<ul>
<li>要实现真正的远程调用，通常需要搭配 <strong>RPC 框架</strong>（如 <strong>gRPC</strong>，这是目前最主流的选择）来处理底层的网络通信。（或者<strong>自己实现网络层</strong>）<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120103057891.png"></li>
</ul>
</li>
</ul>
<p><a id="proto_service"></a></p>
<h2 id="2-Service的使用"><a href="#2-Service的使用" class="headerlink" title="2.Service的使用"></a>2.Service的使用</h2><h3 id="（1）基本语法"><a href="#（1）基本语法" class="headerlink" title="（1）基本语法"></a>（1）基本语法</h3><p><strong>以EchoService为例</strong>：客户端发送消息给服务端，服务端原封不动</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">package myservice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于 C++ 代码生成优化</span></span><br><span class="line">option cc_generic_services = <span class="literal">true</span>;  <span class="comment">// 【关键】必须开启才会生成 Service 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求消息</span></span><br><span class="line">message EchoRequest &#123;</span><br><span class="line">  string message = <span class="number">1</span>;    <span class="comment">//客户端消息</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义响应消息</span></span><br><span class="line">message EchoResponse &#123;</span><br><span class="line">  string reply = <span class="number">1</span>;        <span class="comment">//服务端回复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line">service EchoService &#123;</span><br><span class="line">  <span class="comment">// RPC 方法定义</span></span><br><span class="line">  <span class="function">rpc <span class="title">Echo</span><span class="params">(EchoRequest)</span> <span class="title">returns</span> <span class="params">(EchoResponse)</span></span>;</span><br><span class="line">  <span class="function">rpc <span class="title">Ping</span><span class="params">(EchoRequest)</span> <span class="title">returns</span> <span class="params">(EchoResponse)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 补充：支持流式 RPC（Protobuf 原生支持，无需额外扩展）</span></span><br><span class="line">  <span class="comment">// rpc ListUsers(GetUserRequest) returns (stream GetUserResponse);  // 服务端流式</span></span><br><span class="line">  <span class="comment">// rpc BatchUpdateUser(stream GetUserRequest) returns (GetUserResponse);  // 客户端流式</span></span><br><span class="line">  <span class="comment">// rpc BidirectionalTalk(stream GetUserRequest) returns (stream GetUserResponse);  // 双向流式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⚠️ 重要</strong>：cc_generic_services &#x3D; true 是使用 Protobuf 原生 Service 的前提！</p>
<h3 id="（2）编译命令"><a href="#（2）编译命令" class="headerlink" title="（2）编译命令"></a>（2）编译命令</h3><ol>
<li><strong>基本编译</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只生成消息类和 Service 类</span></span><br><span class="line">protoc --cpp_out=./generated echo.proto</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>生成文件</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── echo.pb.h      <span class="comment"># 头文件（消息类 + Service 类）</span></span><br><span class="line">└── echo.pb.cc     <span class="comment"># 实现文件</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>编译参数详解</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc \</span><br><span class="line">  --cpp_out=OUT_DIR \          <span class="comment"># 指定输出目录</span></span><br><span class="line">  --proto_path=IMPORT_PATH \   <span class="comment"># 指定 .proto 文件搜索路径（可多次使用）</span></span><br><span class="line">  echo.proto                    <span class="comment"># 输入文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：多路径</span></span><br><span class="line">protoc \</span><br><span class="line">  --cpp_out=./generated \</span><br><span class="line">  --proto_path=./protos \</span><br><span class="line">  --proto_path=./third_party \</span><br><span class="line">  echo.proto</span><br></pre></td></tr></table></figure>

<h3 id="（3）生成的-C-伪代码"><a href="#（3）生成的-C-伪代码" class="headerlink" title="（3）生成的 C++ 伪代码"></a>（3）生成的 C++ 伪代码</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120234637423.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"><span class="comment">// echo.pb.h - 生成的头文件</span></span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/stubs/callback.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myservice &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"><span class="comment">// 消息类（略，与普通 message 相同）</span></span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoRequest</span> : <span class="keyword">public</span> ::google::protobuf::Message &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoResponse</span> : <span class="keyword">public</span> ::google::protobuf::Message &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"><span class="comment">// Service 抽象基类 - 服务端需要继承实现</span></span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoService</span> : <span class="keyword">public</span> ::google::protobuf::Service &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 禁止直接构造，必须继承</span></span><br><span class="line">    <span class="built_in">EchoService</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EchoService</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">EchoService</span>(<span class="type">const</span> EchoService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    EchoService&amp; <span class="keyword">operator</span>=(<span class="type">const</span> EchoService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型别名（方便使用）</span></span><br><span class="line">    <span class="keyword">typedef</span> EchoService_Stub Stub;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===================== 【核心】纯虚方法 - 需要子类实现的业务逻辑 =====================</span></span><br><span class="line">    <span class="comment">// 由 rpc Echo(EchoRequest) returns (EchoResponse) 生成</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Echo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::RpcController* controller,    <span class="comment">//RPC 控制器（用于设置/获取错误信息、取消等）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> EchoRequest* request,                        <span class="comment">//请求消息类（由框架反序列化后传入）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        EchoResponse* response,                            <span class="comment">//响应消息类（子类填充后由框架序列化）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::Closure* done                 <span class="comment">//完成回调（异步场景使用，调用 done-&gt;Run() 表示完成）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由 rpc Ping(EchoRequest) returns (EchoResponse) 生成</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Ping</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> EchoRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">        EchoResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::Closure* done</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【核心】通用调用入口 - 根据方法描述符分发到具体方法</span></span><br><span class="line">    <span class="comment">// 框架层调用此方法，由它路由到 Echo() 或 Ping()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CallMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::google::protobuf::MethodDescriptor* method, <span class="comment">// 方法描述符（包含服务名、方法名、索引等元信息）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::RpcController* controller,        <span class="comment">// 控制器（用于取消、超时、错误处理）	</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::google::protobuf::Message* request,            <span class="comment">// 请求消息（已序列化或待序列化）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::Message* response,                <span class="comment">// 响应消息（调用完成后由框架填充）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::Closure* done                    <span class="comment">//完成回调 :</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>&#123;                                                        <span class="comment">// - 异步调用：传回调对象，CallMethod 立即返回</span></span><br><span class="line">                                                            <span class="comment">// - 同步调用：传 nullptr，CallMethod 阻塞直到完成</span></span><br><span class="line">        <span class="comment">// 1. 断言：确保传入的方法确实属于本服务</span></span><br><span class="line">        <span class="built_in">GOOGLE_DCHECK_EQ</span>(method-&gt;<span class="built_in">service</span>(), EchoService::<span class="built_in">descriptor</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 根据方法索引进行路由分发</span></span><br><span class="line">        <span class="keyword">switch</span> (method-&gt;<span class="built_in">index</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">// 索引 0 对应 Echo 方法（proto 文件中定义的第一个 rpc）</span></span><br><span class="line">                <span class="built_in">Echo</span>(</span><br><span class="line">                    controller,</span><br><span class="line">                    <span class="comment">// 向下转型：从通用 Message* 转为具体的 EchoRequest*</span></span><br><span class="line">                    ::google::protobuf::<span class="built_in">down_cast</span>&lt;<span class="type">const</span> EchoRequest*&gt;(request),</span><br><span class="line">                    <span class="comment">// 向下转型：从通用 Message* 转为具体的 EchoResponse*</span></span><br><span class="line">                    ::google::protobuf::<span class="built_in">down_cast</span>&lt;EchoResponse*&gt;(response),</span><br><span class="line">                    done</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">// 索引 1 对应 Ping 方法（proto 文件中定义的第二个 rpc）</span></span><br><span class="line">                <span class="built_in">Ping</span>(</span><br><span class="line">                    controller,</span><br><span class="line">                    ::google::protobuf::<span class="built_in">down_cast</span>&lt;<span class="type">const</span> EchoRequest*&gt;(request),</span><br><span class="line">                    ::google::protobuf::<span class="built_in">down_cast</span>&lt;EchoResponse*&gt;(response),</span><br><span class="line">                    done</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 非法索引，致命错误</span></span><br><span class="line">                <span class="built_in">GOOGLE_LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Bad method index: &quot;</span> &lt;&lt; method-&gt;<span class="built_in">index</span>() </span><br><span class="line">                                  &lt;&lt; <span class="string">&quot;. This method doesn&#x27;t belong to this service.&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; 		</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 静态方法：获取服务描述符</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> ::google::<span class="function">protobuf::ServiceDescriptor* <span class="title">descriptor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务描述符（实例方法）</span></span><br><span class="line">    <span class="type">const</span> ::google::<span class="function">protobuf::ServiceDescriptor* <span class="title">GetDescriptor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求/响应消息的原型（用于创建消息实例）</span></span><br><span class="line">    <span class="type">const</span> ::google::<span class="function">protobuf::Message&amp; <span class="title">GetRequestPrototype</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::google::protobuf::MethodDescriptor* method</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> ::google::<span class="function">protobuf::Message&amp; <span class="title">GetResponsePrototype</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::google::protobuf::MethodDescriptor* method</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"><span class="comment">// Stub 类 - 客户端桩，用于发起 RPC 调用</span></span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoService_Stub</span> : <span class="keyword">public</span> EchoService &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    EchoService_Stub::<span class="built_in">EchoService_Stub</span>(::google::protobuf::RpcChannel* channel)</span><br><span class="line">        : <span class="built_in">channel_</span>(channel), <span class="built_in">owns_channel_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EchoService_Stub::<span class="built_in">EchoService_Stub</span>(</span><br><span class="line">        ::google::protobuf::RpcChannel* channel,</span><br><span class="line">        ::google::protobuf::Service::ChannelOwnership ownership)</span><br><span class="line">        : <span class="built_in">channel_</span>(channel),</span><br><span class="line">          <span class="built_in">owns_channel_</span>(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EchoService_Stub::~<span class="built_in">EchoService_Stub</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (owns_channel_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> channel_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 Channel</span></span><br><span class="line">    <span class="keyword">inline</span> ::google::<span class="function">protobuf::RpcChannel* <span class="title">channel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> channel_; &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Echo 方法： rpc Echo(EchoRequest) returns (EchoResponse)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EchoService_Stub::Echo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> EchoRequest* request,						<span class="comment">// 请求：EchoRequest</span></span></span></span><br><span class="line"><span class="params"><span class="function">        EchoResponse* response,							<span class="comment">// 响应：EchoResponse</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::Closure* done</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取方法描述符</span></span><br><span class="line">        <span class="type">const</span> ::google::protobuf::MethodDescriptor* method =</span><br><span class="line">            EchoService::<span class="built_in">descriptor</span>()-&gt;<span class="built_in">method</span>(<span class="number">0</span>);	<span class="comment">// 获取索引为 0 的方法（即 Echo）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 直接委托给 channel 的 CallMethod</span></span><br><span class="line">        <span class="comment">//    所有序列化、网络传输、反序列化都由 channel 负责</span></span><br><span class="line">        channel_-&gt;<span class="built_in">CallMethod</span>(</span><br><span class="line">            method,      <span class="comment">// 方法描述符（携带服务名、方法名等元信息）</span></span><br><span class="line">            controller,  <span class="comment">// 控制器（透传）</span></span><br><span class="line">            request,     <span class="comment">// 请求消息（透传）</span></span><br><span class="line">            response,    <span class="comment">// 响应消息（透传）</span></span><br><span class="line">            done         <span class="comment">// 完成回调（透传）</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ping 方法： rpc Ping(EchoRequest) returns (EchoResponse);</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Ping</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> EchoRequest* request,                        <span class="comment">// 请求：EchoRequest</span></span></span></span><br><span class="line"><span class="params"><span class="function">        EchoResponse* response,                            <span class="comment">// 响应：EchoResponse</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::Closure* done</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取方法描述符（索引 1 = Ping）</span></span><br><span class="line">        <span class="type">const</span> ::google::protobuf::MethodDescriptor* method =</span><br><span class="line">            EchoService::<span class="built_in">descriptor</span>()-&gt;<span class="built_in">method</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 委托给 channel</span></span><br><span class="line">        channel_-&gt;<span class="built_in">CallMethod</span>(</span><br><span class="line">            method,</span><br><span class="line">            controller,</span><br><span class="line">            request,</span><br><span class="line">            response,</span><br><span class="line">            done</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ::google::protobuf::RpcChannel* channel_;      <span class="comment">// RPC 通道</span></span><br><span class="line">    <span class="type">bool</span> owns_channel_;                             <span class="comment">// 是否拥有所有权</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 通道抽象基类 ——&gt; 客户端通过它发送请求到服务端（网络传输层抽象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcChannel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RpcChannel</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【核心】发起 RPC 调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CallMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 方法描述符（包含服务名、方法名、索引等元信息）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::google::protobuf::MethodDescriptor* method,        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 控制器（用于取消、超时、错误处理）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::RpcController* controller,        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 请求消息（已序列化或待序列化）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::google::protobuf::Message* request,        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 响应消息（调用完成后由框架填充）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::Message* response,            </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">/*完成回调</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">            - 同步调用：传 nullptr，CallMethod 阻塞直到完成	</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">            - 异步调用：传回调对象，CallMethod 立即返回</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">        */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ::google::protobuf::Closure* done                    </span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>= <span class="number">0</span>;                                    </span><br><span class="line">&#125;;     </span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace myservice</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/stubs/callback.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> google &#123;</span><br><span class="line"><span class="keyword">namespace</span> protobuf &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 控制器抽象基类 ——&gt; 用于控制单次 RPC 调用的行为（取消、超时、错误处理等）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcController</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RpcController</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================== 客户端侧方法 ==============================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置控制器状态（复用控制器时调用）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查调用是否失败</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Failed</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取错误信息（Failed() 为 true 时有效）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">ErrorText</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发起取消请求（通知服务端停止处理）</span></span><br><span class="line">    <span class="comment">// 注意：服务端可能忽略，调用后 done 回调仍会被执行</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartCancel</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ============================== 服务端侧方法 ==============================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置失败状态和错误信息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetFailed</span><span class="params">(<span class="type">const</span> std::string&amp; reason)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查客户端是否已请求取消</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsCanceled</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册取消回调（当客户端取消时被调用）</span></span><br><span class="line">    <span class="comment">// @param callback: 取消时执行的回调，传 nullptr 取消注册</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyOnCancel</span><span class="params">(Closure* callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC 回调函数抽象基类 ——&gt; 用于“异步操作”完成时的通知机制</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Closure</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行回调（调用后对象可能被删除，取决于实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================== Closure 工厂函数 ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一次性 Closure（Run() 后自动 delete this）</span></span><br><span class="line"><span class="comment">// @param function: 无参函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Closure* <span class="title">NewCallback</span><span class="params">(<span class="type">void</span> (*function)())</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部实现：返回一个调用 function() 后自删除的 Closure</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* 实现细节 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一次性 Closure（带对象方法）</span></span><br><span class="line"><span class="comment">// @param object: 对象指针</span></span><br><span class="line"><span class="comment">// @param method: 成员函数指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Closure* <span class="title">NewCallback</span><span class="params">(Class* object, <span class="type">void</span> (Class::*method)())</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部实现：返回一个调用 object-&gt;method() 后自删除的 Closure</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* 实现细节 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一次性 Closure（带参数）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Closure* <span class="title">NewCallback</span><span class="params">(Class* object, <span class="type">void</span> (Class::*method)(Arg1), Arg1 arg1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* 实现细节 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建永久 Closure（Run() 后不自动删除，可重复使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Closure* <span class="title">NewPermanentCallback</span><span class="params">(<span class="type">void</span> (*function)())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* 实现细节 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Closure* <span class="title">NewPermanentCallback</span><span class="params">(Class* object, <span class="type">void</span> (Class::*method)())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* 实现细节 */</span>;</span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace protobuf</span></span><br><span class="line">&#125; <span class="comment">// namespace google</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）Stub类-与-RpcChannel类-解析"><a href="#（4）Stub类-与-RpcChannel类-解析" class="headerlink" title="（4）Stub类 与 RpcChannel类 解析"></a>（4）Stub类 与 RpcChannel类 解析</h3><h4 id="使用伪代码"><a href="#使用伪代码" class="headerlink" title="&lt;1&gt;使用伪代码"></a>&lt;1&gt;使用伪代码</h4><p><a href="#channel">自定义RpcChannel示例</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== 客户端使用 ====================</span></span><br><span class="line">   <span class="comment">// 1. 创建 Channel（注入网络实现）</span></span><br><span class="line">   <span class="function">MyRpcChannel <span class="title">channel</span><span class="params">(<span class="string">&quot;127.0.0.1:8080&quot;</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 2. 创建 Stub（绑定 Channel）</span></span><br><span class="line">   <span class="function">UserService_Stub <span class="title">stub</span><span class="params">(&amp;channel)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3. 创建 Controller</span></span><br><span class="line">   MyRpcController controller;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 4. 准备请求和响应参数</span></span><br><span class="line">   GetUserRequest request;</span><br><span class="line">   request.<span class="built_in">set_user_id</span>(<span class="number">12345</span>);</span><br><span class="line">   </span><br><span class="line">   GetUserResponse response;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 5. 调用！</span></span><br><span class="line">   stub.<span class="built_in">GetUser</span>(&amp;controller, &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 6. 检查结果</span></span><br><span class="line">   <span class="keyword">if</span> (controller.<span class="built_in">Failed</span>()) &#123;</span><br><span class="line">       std::cerr &lt;&lt; <span class="string">&quot;RPC failed: &quot;</span> &lt;&lt; controller.<span class="built_in">ErrorText</span>() &lt;&lt; std::endl;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;User name: &quot;</span> &lt;&lt; response.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Stub类-与-RpcChannel类-的关系"><a href="#Stub类-与-RpcChannel类-的关系" class="headerlink" title="&lt;2&gt;Stub类 与 RpcChannel类 的关系"></a>&lt;2&gt;Stub类 与 RpcChannel类 的关系</h4><ul>
<li>在上一节”<strong>生成的C++伪代码</strong>“中可以看到，每一个定义在 proto 中的服务（如：service UserService）都会生成对应的 XXX_Stub 类，这正是”<strong>服务在客户端的句柄</strong>“，客户端用它来发起 RPC 调用<ul>
<li>如：<strong>stub.GetUser(&amp;controller, &amp;request, &amp;response, nullptr);</strong></li>
</ul>
</li>
<li>Stub类：<ul>
<li>作为服务在客户端的句柄，内部包含该服务的<strong>所有 RPC 方法调用接口</strong></li>
<li>持有一个 RpcChannel* 数据成员，在构造时注入<ul>
<li>如： <strong>UserService_Stub stub(&amp;channel);</strong></li>
</ul>
</li>
<li>内部的 RPC 方法实现非常简单：<strong>封装并调用 channel_-&gt;CallMethod(…)</strong></li>
</ul>
</li>
<li>RpcChannel类：<ul>
<li>理解它需要“<a href="#reflect">反射机制</a>”的基础</li>
<li><strong>核心作用</strong>：网络连接、序列化、反序列化</li>
<li><strong>工作流程</strong>：<ul>
<li>1.通过 Stub 传入的 MethodDescriptor* 提取”服务名、方法名”</li>
<li>2.将”服务名、方法名、request”序列化后通过网络发送到服务端</li>
<li>3.接收响应并反序列化为 response</li>
</ul>
</li>
<li>这正好对应”RPC 底层原理”中所说：客户端通过 <strong>（服务名, 方法）二元名组</strong> 定位具体方法</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                      客户端 RPC 调用完整流程                                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                             │</span><br><span class="line">│   用户代码                                                                   │</span><br><span class="line">│   ┌─────────────────────────────────────────┐                               │</span><br><span class="line">│   │ stub.<span class="built_in">GetUser</span>(&amp;ctrl, &amp;req, &amp;resp, done)  │                               │</span><br><span class="line">│   └─────────────────┬───────────────────────┘                               │</span><br><span class="line">│                     │                                                       │</span><br><span class="line">│                     ▼                                                       │</span><br><span class="line">│   Stub 类（Proto 生成）                                                      │</span><br><span class="line">│   ┌─────────────────────────────────────────┐                               │</span><br><span class="line">│   │ <span class="number">1.</span> 获取 MethodDescriptor（方法元信息）   │                               │</span><br><span class="line">│   │ <span class="number">2.</span> 调用 channel_-&gt;<span class="built_in">CallMethod</span>(...)       │                               │</span><br><span class="line">│   └─────────────────┬───────────────────────┘                               │</span><br><span class="line">│                     │                                                       │</span><br><span class="line">│                     ▼                                                       │</span><br><span class="line">│   RpcChannel（用户实现）                                                     │</span><br><span class="line">│   ┌─────────────────────────────────────────┐                               │</span><br><span class="line">│   │ <span class="number">1.</span> 从 MethodDescriptor 提取服务名、方法名│                               │</span><br><span class="line">│   │ <span class="number">2.</span> 序列化 request                       │                               │</span><br><span class="line">│   │ <span class="number">3.</span> 构建协议包 [服务名][方法名][数据]      │                               │</span><br><span class="line">│   │ <span class="number">4.</span> 通过 socket 发送到服务端              │                               │</span><br><span class="line">│   │ <span class="number">5.</span> 接收响应数据                          │                               │</span><br><span class="line">│   │ <span class="number">6.</span> 反序列化到 response                  │                               │</span><br><span class="line">│   └─────────────────────────────────────────┘                               │</span><br><span class="line">│                     │                                                       │</span><br><span class="line">│                     ▼                                                       │</span><br><span class="line">│   ┌─────────────────────────────────────────┐                               │</span><br><span class="line">│   │ 用户拿到 response，继续业务逻辑          │                               │</span><br><span class="line">│   └─────────────────────────────────────────┘                               │</span><br><span class="line">│                                                                             │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌──────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                          工厂类比                                         │</span><br><span class="line">├──────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                          │</span><br><span class="line">│   你（用户）                                                              │</span><br><span class="line">│     │                                                                    │</span><br><span class="line">│     │ 带着原材料（request）                                               │</span><br><span class="line">│     │ 指定产品交付处（response）                                          │</span><br><span class="line">│     ▼                                                                    │</span><br><span class="line">│   ┌────────────────┐                                                     │</span><br><span class="line">│   │   门  户        │  ◄─── Stub 类                                      │</span><br><span class="line">│   │   (Stub)       │       • 接收原材料                                  │</span><br><span class="line">│   │                │       • 登记加工需求（获取 MethodDescriptor）         │</span><br><span class="line">│   └───────┬────────┘       • 转交给内部员工                              │</span><br><span class="line">│           │                                                              │</span><br><span class="line">│           ▼                                                              │</span><br><span class="line">│   ┌────────────────┐                                                     │</span><br><span class="line">│   │  内部员工       │  ◄─── RpcChannel                                   │</span><br><span class="line">│   │  (RpcChannel)  │       • 打包原材料（序列化）                         │</span><br><span class="line">│   │                │       • 运送到加工车间（网络传输）                    │</span><br><span class="line">│   │                │       • 带回成品（接收响应）                         │</span><br><span class="line">│   │                │       • 拆包（反序列化）                             │</span><br><span class="line">│   └───────┬────────┘                                                     │</span><br><span class="line">│           │                                                              │</span><br><span class="line">│           │  ════════════════════════════════                            │</span><br><span class="line">│           │        网络（运输通道）                                        │</span><br><span class="line">│           │  ════════════════════════════════                            │</span><br><span class="line">│           ▼                                                              │</span><br><span class="line">│   ┌────────────────┐                                                     │</span><br><span class="line">│   │  加工车间       │  ◄─── 服务端                                        │</span><br><span class="line">│   │  (Server)      │       • 根据订单（服务名+方法名）找到机器             │</span><br><span class="line">│   │                │       • 加工原材料                                   │</span><br><span class="line">│   │                │       • 产出成品                                     │</span><br><span class="line">│   └────────────────┘                                                     │</span><br><span class="line">│                                                                          │</span><br><span class="line">└──────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（5）RpcController类-与-Closure类"><a href="#（5）RpcController类-与-Closure类" class="headerlink" title="（5）RpcController类 与 Closure类"></a>（5）RpcController类 与 Closure类</h3><h4 id="RpcController-类"><a href="#RpcController-类" class="headerlink" title="&lt;1&gt; RpcController 类"></a>&lt;1&gt; RpcController 类</h4><p><strong>核心功能</strong>：<br>	- 控制单次 RPC 调用的行为（取消、超时、错误处理等）<br><strong>设计原因</strong>：<br>	- CallMethod 方法的返回值是 void，调用结果（成功&#x2F;失败&#x2F;错误信息）无法通过返回值告知用户<br>	- 因此通过”<strong>出参</strong>“的形式将 RpcController 传入，<strong>内部信息填充后，用户即可获取调用状态</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">MyRpcController controller;</span><br><span class="line">stub.<span class="built_in">GetUser</span>(&amp;controller, &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 controller 获取调用状态</span></span><br><span class="line"><span class="keyword">if</span> (controller.<span class="built_in">Failed</span>()) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; controller.<span class="built_in">ErrorText</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Closure-类"><a href="#Closure-类" class="headerlink" title="&lt;2&gt; Closure 类"></a>&lt;2&gt; Closure 类</h4><p><a href="#Closure">Closure 常用构造方法</a><br><strong>核心功能</strong>：决定是”同步操作”还是”异步操作”</p>
<ul>
<li><strong>同步</strong>：即阻塞，用户在通过Stub调用函数时，会一直阻塞，直到函数处理结束后将响应填入“reponse出参”，用户再处理reponse</li>
<li><strong>异步</strong>：即非阻塞，用户事先将reponse的处理逻辑封装到Clouser中（回调函数），并在通过Stub调用函数时一同传入，然后函数就直接返回，用户可以直接去做其它业务，因为响应到来时，直接交给Clouser中封装好的处理逻辑去处理即可<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122100053975.png"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========== 统一的 response 处理函数 ==========</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleResponse</span><span class="params">(GetUserResponse* response)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;User name: &quot;</span> &lt;&lt; response-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;User age: &quot;</span> &lt;&lt; response-&gt;<span class="built_in">age</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// ... 其他业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 同步调用 ==========</span></span><br><span class="line">stub.<span class="built_in">GetUser</span>(&amp;controller, &amp;request, &amp;response, <span class="literal">nullptr</span>);  <span class="comment">// 阻塞等待</span></span><br><span class="line"><span class="built_in">HandleResponse</span>(&amp;response);  <span class="comment">// 响应就绪后，手动调用处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 异步调用 ==========</span></span><br><span class="line"><span class="keyword">auto</span>* done = <span class="built_in">NewCallback</span>(&amp;HandleResponse, &amp;response);     <span class="comment">// 将处理函数封装为 Closure</span></span><br><span class="line">stub.<span class="built_in">GetUser</span>(&amp;controller, &amp;request, &amp;response, done);     <span class="comment">// 立即返回</span></span><br><span class="line"><span class="comment">// 继续做其他事情...</span></span><br><span class="line"><span class="comment">// 响应到来时，框架自动执行 HandleResponse(&amp;response)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122100154823.png"></p>
<h3 id="（6）服务端的使用"><a href="#（6）服务端的使用" class="headerlink" title="（6）服务端的使用"></a>（6）服务端的使用</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122103313708.png"></p>
<ul>
<li>从“生成的C++伪代码”中我们可以看到，proto中定义的service，会生成一个同名的Service类（如：service EchoService ——&gt;class EchoService）</li>
<li>Service类中的方法（如Echo、Ping）都是纯虚函数，需要服务端自己继承并实现（毕竟要实现的是自己的业务嘛）</li>
<li>服务端会对每一个服务进行注册，如：<strong>std::map(服务名，Service)</strong><ul>
<li>为什么不注册方法？因为Protobuf的“<strong>反射机制</strong>”在获取去Service后，可以通过“方法名”获取“<strong>方法描述符MethodDescriptor</strong>” ——&gt; 结合起来，正好对应（服务名，方法名）二元组定位具体方法</li>
</ul>
</li>
<li><strong>CallMethod方法</strong>：<ul>
<li>会传入“方法描述符MethodDescriptor”，在内部根据“<strong>方法索引</strong>”找到具体方法进行执行</li>
</ul>
</li>
</ul>
<p><strong>用户实现服务</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========== 用户继承并实现业务逻辑 ==========</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServiceImpl</span> : <span class="keyword">public</span> EchoService::Service &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Status <span class="title">Echo</span><span class="params">(ServerContext* ctx, <span class="type">const</span> EchoRequest* req, EchoResponse* resp)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        resp-&gt;<span class="built_in">set_message</span>(<span class="string">&quot;Echo: &quot;</span> + req-&gt;<span class="built_in">message</span>());  <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Status <span class="title">Ping</span><span class="params">(ServerContext* ctx, <span class="type">const</span> PingRequest* req, PingResponse* resp)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        resp-&gt;<span class="built_in">set_pong</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>服务注册（服务端框架）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========== gRPC 服务端内部注册表 ==========</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 只注册服务，不注册方法！</span></span><br><span class="line">    std::map&lt;std::string, google::protobuf::Service*&gt; services_;</span><br><span class="line">    <span class="comment">//        服务名（如 &quot;EchoService&quot;）    服务实例</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RegisterService</span><span class="params">(google::protobuf::Service* service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射获取服务名</span></span><br><span class="line">        <span class="type">const</span> std::string&amp; name = service-&gt;<span class="built_in">GetDescriptor</span>()-&gt;<span class="built_in">name</span>();</span><br><span class="line">        services_[name] = service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    google::<span class="function">protobuf::Service* <span class="title">FindService</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> services_[name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>请求分发流程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========== 收到 RPC 请求时的处理 ==========</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleRpcRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; service_name,   <span class="comment">// 如 &quot;EchoService&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; method_name,    <span class="comment">// 如 &quot;Echo&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; request_data    <span class="comment">// 序列化的请求</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Step 1: 根据服务名找到服务实例</span></span><br><span class="line">    <span class="keyword">auto</span>* service = registry_.<span class="built_in">FindService</span>(service_name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 2: 通过反射，根据方法名获取方法描述符</span></span><br><span class="line">    <span class="type">const</span> ServiceDescriptor* service_desc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="type">const</span> MethodDescriptor* method_desc = service_desc-&gt;<span class="built_in">FindMethodByName</span>(method_name);</span><br><span class="line">    <span class="comment">//                                    ↑ 【反射机制】方法名 → 方法描述符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3: 通过反射创建请求/响应对象</span></span><br><span class="line">    Message* request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method_desc).<span class="built_in">New</span>();</span><br><span class="line">    Message* response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method_desc).<span class="built_in">New</span>();</span><br><span class="line">    request-&gt;<span class="built_in">ParseFromString</span>(request_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 4: 调用 CallMethod，内部根据方法索引分发到具体实现</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method_desc, controller, request, response, done);</span><br><span class="line">    <span class="comment">//                  ↑ 传入方法描述符，CallMethod 内部用 method-&gt;index() 分发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>流程图</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">客户端请求: &#123; service: <span class="string">&quot;EchoService&quot;</span>, method: <span class="string">&quot;Echo&quot;</span>, data: ... &#125;</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│  Step <span class="number">1</span>: 服务名 → 服务实例                                    │</span><br><span class="line">│          registry_[<span class="string">&quot;EchoService&quot;</span>] → EchoServiceImpl*         │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│  Step <span class="number">2</span>: 方法名 → 方法描述符（反射）                           │</span><br><span class="line">│          service_desc-&gt;<span class="built_in">FindMethodByName</span>(<span class="string">&quot;Echo&quot;</span>)              │</span><br><span class="line">│          → MethodDescriptor &#123; index=<span class="number">0</span>, name=<span class="string">&quot;Echo&quot;</span>, ... &#125;    │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│  Step <span class="number">3</span>: CallMethod 根据 method-&gt;<span class="built_in">index</span>() 分发                │</span><br><span class="line">│          <span class="keyword">switch</span>(<span class="number">0</span>) → <span class="built_in">Echo</span>(ctx, req, resp)                    │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            ▼</span><br><span class="line">                    EchoServiceImpl::<span class="built_in">Echo</span>() 执行</span><br></pre></td></tr></table></figure>


<p><a id="channel"></a></p>
<h3 id="附录1：自定义RpcChannel示例"><a href="#附录1：自定义RpcChannel示例" class="headerlink" title="附录1：自定义RpcChannel示例"></a>附录1：自定义RpcChannel示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义 RpcChannel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRpcChannel</span> : <span class="keyword">public</span> ::google::protobuf::RpcChannel &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyRpcChannel</span>(<span class="type">const</span> std::string&amp; addr) : <span class="built_in">server_addr_</span>(addr) &#123;</span><br><span class="line">       socket_fd_ = <span class="built_in">connectToServer</span>(addr);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ~<span class="built_in">MyRpcChannel</span>() &#123;</span><br><span class="line">       <span class="built_in">close</span>(socket_fd_);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">CallMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> ::google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">       ::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> ::google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">       ::google::protobuf::Message* response,</span></span></span><br><span class="line"><span class="params"><span class="function">       ::google::protobuf::Closure* done)</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// ========== 1. 序列化请求 ==========</span></span><br><span class="line">       std::string request_data = request-&gt;<span class="built_in">SerializeAsString</span>();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// ========== 2. 构建协议包 ==========</span></span><br><span class="line">       <span class="comment">// 协议：[服务名长度][服务名][方法名长度][方法名][数据长度][数据]</span></span><br><span class="line">       std::string service_name = method-&gt;<span class="built_in">service</span>()-&gt;<span class="built_in">full_name</span>();  <span class="comment">// &quot;package.UserService&quot;</span></span><br><span class="line">       std::string method_name = method-&gt;<span class="built_in">name</span>();                    <span class="comment">// &quot;GetUser&quot;</span></span><br><span class="line">       </span><br><span class="line">       <span class="type">uint32_t</span> service_len = service_name.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">uint32_t</span> method_len = method_name.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">uint32_t</span> data_len = request_data.<span class="built_in">size</span>();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// ========== 3. 发送请求 ==========</span></span><br><span class="line">       <span class="comment">// 服务名</span></span><br><span class="line">       <span class="built_in">send</span>(socket_fd_, &amp;service_len, <span class="built_in">sizeof</span>(service_len), <span class="number">0</span>);</span><br><span class="line">       <span class="built_in">send</span>(socket_fd_, service_name.<span class="built_in">data</span>(), service_len, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 方法名</span></span><br><span class="line">       <span class="built_in">send</span>(socket_fd_, &amp;method_len, <span class="built_in">sizeof</span>(method_len), <span class="number">0</span>);</span><br><span class="line">       <span class="built_in">send</span>(socket_fd_, method_name.<span class="built_in">data</span>(), method_len, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 数据</span></span><br><span class="line">       <span class="built_in">send</span>(socket_fd_, &amp;data_len, <span class="built_in">sizeof</span>(data_len), <span class="number">0</span>);</span><br><span class="line">       <span class="built_in">send</span>(socket_fd_, request_data.<span class="built_in">data</span>(), data_len, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// ========== 4. 接收响应 ==========</span></span><br><span class="line">       <span class="type">uint32_t</span> resp_len;</span><br><span class="line">       <span class="built_in">recv</span>(socket_fd_, &amp;resp_len, <span class="built_in">sizeof</span>(resp_len), <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">resp_data</span><span class="params">(resp_len)</span></span>;</span><br><span class="line">       <span class="built_in">recv</span>(socket_fd_, resp_data.<span class="built_in">data</span>(), resp_len, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// ========== 5. 反序列化响应 ==========</span></span><br><span class="line">       <span class="keyword">if</span> (!response-&gt;<span class="built_in">ParseFromArray</span>(resp_data.<span class="built_in">data</span>(), resp_len)) &#123;</span><br><span class="line">           controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;Failed to parse response&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// ========== 6. 回调 ==========</span></span><br><span class="line">       <span class="keyword">if</span> (done != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">           done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ==================== 辅助函数：建立连接 ====================</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">connectToServer</span><span class="params">(<span class="type">const</span> std::string&amp; addr)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 解析地址 &quot;127.0.0.1:8080&quot;</span></span><br><span class="line">       <span class="type">size_t</span> pos = addr.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">       std::string ip = addr.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">       <span class="type">int</span> port = std::<span class="built_in">stoi</span>(addr.<span class="built_in">substr</span>(pos + <span class="number">1</span>));</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 创建 socket</span></span><br><span class="line">       <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create socket&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 设置服务器地址</span></span><br><span class="line">       <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">       <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">       server_addr.sin_family = AF_INET;</span><br><span class="line">       server_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">       <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;server_addr.sin_addr);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 连接</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">close</span>(fd);</span><br><span class="line">           <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to connect to server&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string server_addr_;</span><br><span class="line">   <span class="type">int</span> socket_fd_;</span><br></pre></td></tr></table></figure>

<p><strong>协议格式图示</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                          自定义 RPC 协议包格式                          │</span><br><span class="line">├────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                        │</span><br><span class="line">│   字节偏移:  <span class="number">0</span>        <span class="number">4</span>        <span class="number">4</span>+S      <span class="number">8</span>+S      <span class="number">8</span>+S+M    <span class="number">12</span>+S+M       │</span><br><span class="line">│            ┌────────┬────────┬────────┬────────┬────────┬────────────┐ │</span><br><span class="line">│            │服务名   │ 服务名  │方法名   │ 方法名  │数据     │   数据     │ │</span><br><span class="line">│            │长度(<span class="number">4</span>B)│ (S字节) │长度(<span class="number">4</span>B)│ (M字节) │长度(<span class="number">4</span>B)│  (D字节)   │ │</span><br><span class="line">│            └────────┴────────┴────────┴────────┴────────┴────────────┘ │</span><br><span class="line">│                                                                        │</span><br><span class="line">│   示例：                                                                │</span><br><span class="line">│   ┌────┬─────────────────────┬────┬─────────┬────┬──────────────────┐  │</span><br><span class="line">│   │ <span class="number">19</span> │ <span class="string">&quot;package.UserService&quot;</span>│  <span class="number">7</span> │<span class="string">&quot;GetUser&quot;</span>│ <span class="number">12</span> │ &lt;protobuf数据&gt;   │  │</span><br><span class="line">│   └────┴─────────────────────┴────┴─────────┴────┴──────────────────┘  │</span><br><span class="line">│                                                                        │</span><br><span class="line">└────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p><a id="Closure"></a></p>
<h3 id="附录2：Closure-常用构造方法"><a href="#附录2：Closure-常用构造方法" class="headerlink" title="附录2：Closure 常用构造方法"></a>附录2：Closure 常用构造方法</h3><p>Google Protobuf 提供了 NewCallback 系列<strong>工厂函数</strong>来创建 Closure：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========== 1. 普通函数 ==========</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleResponse</span><span class="params">(GetUserResponse* response)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>* done = <span class="built_in">NewCallback</span>(&amp;HandleResponse, &amp;response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 2. 成员函数（需要对象指针）==========</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnDone</span><span class="params">(GetUserResponse* response)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHandler handler;</span><br><span class="line"><span class="keyword">auto</span>* done = <span class="built_in">NewCallback</span>(&amp;handler, &amp;MyHandler::OnDone, &amp;response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 3. 无参回调 ==========</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnComplete</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>* done = <span class="built_in">NewCallback</span>(&amp;OnComplete);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 4. 多参数回调 ==========</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessResult</span><span class="params">(<span class="type">int</span> code, GetUserResponse* response)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>* done = <span class="built_in">NewCallback</span>(&amp;ProcessResult, <span class="number">200</span>, &amp;response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 5. 永久回调（可重复执行，不会自动删除）==========</span></span><br><span class="line"><span class="keyword">auto</span>* done = <span class="built_in">NewPermanentCallback</span>(&amp;HandleResponse, &amp;response);</span><br><span class="line"><span class="comment">// 注意：需要手动 delete</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122100447091.png"></p>
<h2 id="3-Service在RPC中的作用"><a href="#3-Service在RPC中的作用" class="headerlink" title="3.Service在RPC中的作用"></a>3.Service在RPC中的作用</h2><p><a href="#RPC%EF%BC%882%EF%BC%89">RPC底层原理</a><br>通过proto的service生成的C++伪代码，已经满足了RPC的如下条件</p>
<ul>
<li>1.双方定义一模一样的API<ul>
<li>通过上述C++伪代码可以看到，服务端（EchoService）与客户端（EchoService_Stub）拥有相同的“核心API”<ul>
<li>如：Echo、Ping、CallMethod（其中客户端通过RpcChannel间接拥有CallMethod）</li>
</ul>
</li>
</ul>
</li>
<li>2.“序列化”、“反序列化”能力<ul>
<li>proto中的message自带“序列化”、“反序列化”能力</li>
</ul>
</li>
<li><strong>欠缺</strong>：<ul>
<li><strong>服务端注册方法</strong>：<ul>
<li>这需要服务端借助 “<strong>反射机制</strong>” 获取 “服务名、方法名”</li>
</ul>
</li>
<li><strong>网络通信</strong>：<ul>
<li>这需要自己实现（或使用已有框架）</li>
</ul>
</li>
<li><strong>路由</strong>：<ul>
<li>这也需要服务端借助 “<strong>反射机制</strong>” 获取 “服务名、方法名”</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>PRC在proto中的调用链路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                            完整 RPC 调用链路                                     │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                                 │</span><br><span class="line">│  客户端                                              服务端                      │</span><br><span class="line">│  ──────                                              ──────                      │</span><br><span class="line">│                                                                                 │</span><br><span class="line">│  ① 业务代码调用                                                                  │</span><br><span class="line">│     stub-&gt;<span class="built_in">Echo</span>(controller, &amp;req, &amp;resp, done)                                   │</span><br><span class="line">│         │                                                                       │</span><br><span class="line">│         ▼                                                                       │</span><br><span class="line">│  ② Stub::<span class="built_in">Echo</span>() 转发给 Channel                                                  │</span><br><span class="line">│     channel_-&gt;<span class="built_in">CallMethod</span>(<span class="built_in">descriptor</span>()-&gt;<span class="built_in">method</span>(<span class="number">0</span>), ...)                          │</span><br><span class="line">│         │                                                                       │</span><br><span class="line">│         ▼                                                                       │</span><br><span class="line">│  ③ RpcChannel::<span class="built_in">CallMethod</span>() 序列化 + 发送                                       │</span><br><span class="line">│     • 序列化 request → bytes                                                    │</span><br><span class="line">│     • 构造包头：service=<span class="string">&quot;EchoService&quot;</span>, method=<span class="string">&quot;Echo&quot;</span>, index=<span class="number">0</span>                   │</span><br><span class="line">│     • 发送到网络                                                                │</span><br><span class="line">│         │                                                                       │</span><br><span class="line">│         │ ═══════════════════ 网络传输 ═══════════════════                      │</span><br><span class="line">│         ▼                                                                       │</span><br><span class="line">│  ④ 服务端框架接收                                              ┌──────────────┐ │</span><br><span class="line">│     • 解析包头，找到 ServiceDescriptor                          │  RPC Server  │ │</span><br><span class="line">│     • 根据 method_index 获取 MethodDescriptor                  │              │ │</span><br><span class="line">│     • 创建 request/response 实例（通过反射）                     │  接收数据    │ │</span><br><span class="line">│     • 反序列化 request                                          │  解析路由    │ │</span><br><span class="line">│         │                                                      └──────┬───────┘ │</span><br><span class="line">│         ▼                                                             │         │</span><br><span class="line">│  ⑤ 调用 Service::<span class="built_in">CallMethod</span>()                                         │         │</span><br><span class="line">│     service-&gt;<span class="built_in">CallMethod</span>(method, controller, request, response, done)  │         │</span><br><span class="line">│         │                                                             │         │</span><br><span class="line">│         ▼                                                             │         │</span><br><span class="line">│  ⑥ CallMethod 路由到具体方法                                                     │</span><br><span class="line">│     <span class="keyword">switch</span> (method-&gt;<span class="built_in">index</span>())                                                    │</span><br><span class="line">│         <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">Echo</span>(...)  ←── 你实现的业务逻辑                                  │</span><br><span class="line">│         │                                                                       │</span><br><span class="line">│         ▼                                                                       │</span><br><span class="line">│  ⑦ 业务处理完成，response 已填充                                                 │</span><br><span class="line">│     done-&gt;<span class="built_in">Run</span>()  <span class="comment">// 触发响应发送                                                │</span></span><br><span class="line">│         │                                                                       │</span><br><span class="line">│         │ ═══════════════════ 网络传输 ═══════════════════                      │</span><br><span class="line">│         ▼                                                                       │</span><br><span class="line">│  ⑧ 客户端接收响应                                                                │</span><br><span class="line">│     • 反序列化 response                                                         │</span><br><span class="line">│     • 调用 done-&gt;<span class="built_in">Run</span>()（异步）或直接返回（同步）                                  │</span><br><span class="line">│                                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p><a id="reflect"></a></p>
<h2 id="4-Protobuf的反射机制"><a href="#4-Protobuf的反射机制" class="headerlink" title="4.Protobuf的反射机制"></a>4.Protobuf的反射机制</h2><p><a href="#RPC%EF%BC%882%EF%BC%89">RPC底层原理</a></p>
<ul>
<li>什么是“反射机制”？说实话，我自己现在也不是很明白，但我们只需要知道以下几点即可<ul>
<li>通过反射机制，我们可以获取 <strong>ServiceDescriptor、MethodDescriptor</strong>，进而可以获取“服务名”、“方法名”、“请求消息类型描述符”、“响应消息类型描述符”等</li>
<li>获得“服务名”、“方法名”等，客户端就可以封装到“请求中”，二服务端就可以实现“服务的注册”、“路由”等功能。</li>
</ul>
</li>
</ul>
<h3 id="（1）Protobuf的反射层次结构"><a href="#（1）Protobuf的反射层次结构" class="headerlink" title="（1）Protobuf的反射层次结构"></a>（1）Protobuf的反射层次结构</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        Protobuf 反射层次结构                                      │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                                 │</span><br><span class="line">│  DescriptorPool（描述符池）                                                       │</span><br><span class="line">│       │   • 全局唯一的描述符管理器                                                 │</span><br><span class="line">│       │   • 存储所有已加载的 .proto 文件描述信息                                    │</span><br><span class="line">│       │   • 提供按名称查找描述符的能力                                             │</span><br><span class="line">│       │   • <span class="built_in">generated_pool</span>() 获取编译期生成的描述符池                              │</span><br><span class="line">│       │                                                                         │</span><br><span class="line">│       ▼                                                                         │</span><br><span class="line">│  FileDescriptor（文件描述符）                                                     │</span><br><span class="line">│       │   • 对应一个 .proto 文件                                                  │</span><br><span class="line">│       │   • 包含文件名、包名、依赖关系等元信息                                       │</span><br><span class="line">│       │   • <span class="built_in">name</span>()        → <span class="string">&quot;echo.proto&quot;</span>                                        │</span><br><span class="line">│       │   • <span class="built_in">package</span>()     → <span class="string">&quot;myservice&quot;</span>                                         │</span><br><span class="line">│       │   • <span class="built_in">dependency</span>()  → 导入的其他 .proto 文件                                │</span><br><span class="line">│       │                                                                         │</span><br><span class="line">│       │                                                                         │</span><br><span class="line">│       ├──▶ MessageDescriptor[]（消息描述符数组）                                  │</span><br><span class="line">│       │         │   • 对应一个 message 定义                                       │</span><br><span class="line">│       │         │   • <span class="built_in">name</span>()         → <span class="string">&quot;EchoRequest&quot;</span>                            │</span><br><span class="line">│       │         │   • <span class="built_in">full_name</span>()    → <span class="string">&quot;myservice.EchoRequest&quot;</span>                  │</span><br><span class="line">│       │         │   • <span class="built_in">field_count</span>()  → 字段数量                                  │</span><br><span class="line">│       │         │   • <span class="built_in">nested_type</span>()  → 嵌套的 message                            │</span><br><span class="line">│       │         │                                                               │</span><br><span class="line">│       │         ├──▶ FieldDescriptor[]（字段描述符数组）                          │</span><br><span class="line">│       │         │         • 对应 message 中的每个字段                             │</span><br><span class="line">│       │         │         • <span class="built_in">name</span>()         → <span class="string">&quot;message&quot;</span>                          │</span><br><span class="line">│       │         │         • <span class="built_in">number</span>()       → <span class="number">1</span>（字段编号）                        │</span><br><span class="line">│       │         │         • <span class="built_in">type</span>()         → TYPE_STRING / TYPE_INT32 / ...     │</span><br><span class="line">│       │         │         • <span class="built_in">is_repeated</span>()  → 是否为 repeated                     │</span><br><span class="line">│       │         │         • <span class="built_in">is_optional</span>()  → 是否为 optional                     │</span><br><span class="line">│       │         │         • <span class="built_in">default_value_string</span>() → 默认值                      │</span><br><span class="line">│       │         │         • <span class="built_in">message_type</span>() → 如果是嵌套消息，返回其描述符          │</span><br><span class="line">│       │         │                                                               │</span><br><span class="line">│       │         └──▶ EnumDescriptor[]（枚举描述符数组）                           │</span><br><span class="line">│       │                   • 对应 <span class="keyword">enum</span> 定义                                       │</span><br><span class="line">│       │                   • <span class="built_in">name</span>()         → <span class="string">&quot;Status&quot;</span>                           │</span><br><span class="line">│       │                   • <span class="built_in">value_count</span>()  → 枚举值数量                          │</span><br><span class="line">│       │                   └──▶ EnumValueDescriptor[]                            │</span><br><span class="line">│       │                             • <span class="built_in">name</span>()   → <span class="string">&quot;OK&quot;</span>                           │</span><br><span class="line">│       │                             • <span class="built_in">number</span>() → <span class="number">0</span>                              │</span><br><span class="line">│       │                                                                         │</span><br><span class="line">│       │                                                                         │</span><br><span class="line">│       └──▶ ServiceDescriptor[]（服务描述符数组）                                  │</span><br><span class="line">│                 │   • 对应一个 service 定义                                       │</span><br><span class="line">│                 │   • <span class="built_in">name</span>()         → <span class="string">&quot;EchoService&quot;</span>                            │</span><br><span class="line">│                 │   • <span class="built_in">full_name</span>()    → <span class="string">&quot;myservice.EchoService&quot;</span>                  │</span><br><span class="line">│                 │   • <span class="built_in">method_count</span>() → RPC 方法数量                              │</span><br><span class="line">│                 │                                                               │</span><br><span class="line">│                 └──▶ MethodDescriptor[]（方法描述符数组）                         │</span><br><span class="line">│                           • 对应 service 中的每个 rpc 方法                        │</span><br><span class="line">│                           • <span class="built_in">name</span>()          → <span class="string">&quot;Echo&quot;</span>                            │</span><br><span class="line">│                           • <span class="built_in">full_name</span>()     → <span class="string">&quot;myservice.EchoService.Echo&quot;</span>      │</span><br><span class="line">│                           • <span class="built_in">index</span>()         → 方法在 service 中的索引             │</span><br><span class="line">│                           • <span class="built_in">input_type</span>()    → 请求消息的 MessageDescriptor       │</span><br><span class="line">│                           • <span class="built_in">output_type</span>()   → 响应消息的 MessageDescriptor       │</span><br><span class="line">│                           • <span class="built_in">client_streaming</span>() → 客户端是否流式                   │</span><br><span class="line">│                           • <span class="built_in">server_streaming</span>() → 服务端是否流式                   │</span><br><span class="line">│                                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（2）ServiceDescriptor（服务描述符）"><a href="#（2）ServiceDescriptor（服务描述符）" class="headerlink" title="（2）ServiceDescriptor（服务描述符）"></a>（2）ServiceDescriptor（服务描述符）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceDescriptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;            		<span class="comment">// 服务名称（如 &quot;EchoService&quot;）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">full_name</span><span class="params">()</span> <span class="type">const</span></span>;        		<span class="comment">// 完整名称（如 &quot;myservice.EchoService&quot;）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> <span class="type">const</span></span>;                            		<span class="comment">// 在文件中的索引</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">file</span><span class="params">()</span> <span class="type">const</span></span>;            		<span class="comment">// 所属文件</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">method_count</span><span class="params">()</span> <span class="type">const</span></span>;                    		<span class="comment">// 方法数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按索引获取方法描述符：O(log n)</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MethodDescriptor* <span class="title">method</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 边界检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(methods_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methods_[index];</span><br><span class="line">    &#125;        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按名称查找方法描述符O()</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MethodDescriptor* <span class="title">FindMethodByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = methods_by_name_.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (it == methods_by_name_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> ServiceOptions&amp; <span class="title">options</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 选项</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;                    <span class="comment">// 调试</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;                                    <span class="comment">// 服务名</span></span><br><span class="line">    std::vector&lt;<span class="type">const</span> MethodDescriptor*&gt; methods_;        <span class="comment">// 方法列表（按定义顺序）</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">const</span> MethodDescriptor*&gt; methods_by_name_;  <span class="comment">// 名称索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）MethodDescriptor-（方法描述符）"><a href="#（3）MethodDescriptor-（方法描述符）" class="headerlink" title="（3）MethodDescriptor （方法描述符）"></a>（3）MethodDescriptor （方法描述符）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MethodDescriptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 方法名称（如 &quot;Echo&quot;）</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">full_name</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 完整名称（如 &quot;myservice.EchoService.Echo&quot;）</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> <span class="type">const</span></span>;                            <span class="comment">// 方法在服务中的索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> ServiceDescriptor* <span class="title">service</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// 所属服务描述符</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">file</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 所属文件描述符</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">input_type</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 请求消息类型描述符</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">output_type</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 响应消息类型描述符</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流式标记（Proto3 支持）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">client_streaming</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 客户端是否为流式</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">server_streaming</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 服务端是否为流式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选项</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MethodOptions&amp; <span class="title">options</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调试</span></span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="（4）DescriptorPool（描述符池）"><a href="#（4）DescriptorPool（描述符池）" class="headerlink" title="（4）DescriptorPool（描述符池）"></a>（4）DescriptorPool（描述符池）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DescriptorPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 单例访问</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取编译期生成的全局描述符池（包含所有 .pb.cc 注册的类型）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> DescriptorPool* <span class="title">generated_pool</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 构造/析构</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建空的描述符池</span></span><br><span class="line">    <span class="built_in">DescriptorPool</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建带回退池的描述符池（找不到时从 fallback_pool 查找）</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DescriptorPool</span><span class="params">(<span class="type">const</span> DescriptorPool* fallback_pool)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">DescriptorPool</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找方法（如 &quot;myservice.EchoService.Echo&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MethodDescriptor* <span class="title">FindMethodByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找服务（如 &quot;myservice.EchoService&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> ServiceDescriptor* <span class="title">FindServiceByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找文件描述符（如 &quot;echo.proto&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">FindFileByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找消息类型（如 &quot;myservice.EchoRequest&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">FindMessageTypeByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找字段（全局扩展字段）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindFieldByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找扩展字段（按编号）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindExtensionByNumber</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> Descriptor* extendee, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> number</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找枚举类型（如 &quot;myservice.Status&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumDescriptor* <span class="title">FindEnumTypeByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找枚举值（如 &quot;myservice.Status.OK&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumValueDescriptor* <span class="title">FindEnumValueByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 动态构建（运行时加载 .proto）</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 FileDescriptorProto 构建（proto 的自描述格式）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">BuildFile</span><span class="params">(<span class="type">const</span> FileDescriptorProto&amp; proto)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带错误收集器的构建</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">BuildFileCollectingErrors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> FileDescriptorProto&amp; proto,</span></span></span><br><span class="line"><span class="params"><span class="function">        ErrorCollector* error_collector</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">DescriptorPool</span>(<span class="type">const</span> DescriptorPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    DescriptorPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> DescriptorPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（5）FileDescriptor（文件描述符）"><a href="#（5）FileDescriptor（文件描述符）" class="headerlink" title="（5）FileDescriptor（文件描述符）"></a>（5）FileDescriptor（文件描述符）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 文件名（如 &quot;echo.proto&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">package</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 包名（如 &quot;myservice&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> DescriptorPool* <span class="title">pool</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 所属的描述符池</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Syntax</span> &#123;                            <span class="comment">// 语法版本</span></span><br><span class="line">        SYNTAX_UNKNOWN = <span class="number">0</span>,</span><br><span class="line">        SYNTAX_PROTO2 = <span class="number">2</span>,</span><br><span class="line">        SYNTAX_PROTO3 = <span class="number">3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Syntax <span class="title">syntax</span><span class="params">()</span> <span class="type">const</span></span>;                    <span class="comment">// 获取语法版本</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dependency_count</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 直接依赖的文件数量</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========================================= 文件描述符相关 =========================================</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">dependency</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;            <span class="comment">// 获取第 i 个依赖文件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">public_dependency_count</span><span class="params">()</span> <span class="type">const</span></span>;                        <span class="comment">// public import 的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">public_dependency</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;   <span class="comment">// 获取第 i 个 public 依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">weak_dependency_count</span><span class="params">()</span> <span class="type">const</span></span>;                            <span class="comment">// weak import 的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">weak_dependency</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;        <span class="comment">// 获取第 i 个 weak 依赖</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========================================= message相关 =========================================</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">message_type_count</span><span class="params">()</span> <span class="type">const</span></span>;                                <span class="comment">// 顶层 message 数量</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">message_type</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;            <span class="comment">// 获取第 i 个 message 描述符</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">FindMessageTypeByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;    <span class="comment">// 按名称查找 message（只在当前文件查找）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========================================= enum相关 =========================================</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">enum_type_count</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 顶层 enum 数量</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumDescriptor* <span class="title">enum_type</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;        <span class="comment">// 获取第 i 个 enum 描述符</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumDescriptor* <span class="title">FindEnumTypeByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;    <span class="comment">// 按名称查找 enum</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumValueDescriptor* <span class="title">FindEnumValueByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;    <span class="comment">// 按名称查找 enum 值</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========================================= service相关 =========================================</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">service_count</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// service 数量</span></span><br><span class="line">    <span class="function"><span class="type">const</span> ServiceDescriptor* <span class="title">service</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;    <span class="comment">// 获取第 i 个 service 描述符</span></span><br><span class="line">    <span class="function"><span class="type">const</span> ServiceDescriptor* <span class="title">FindServiceByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;    <span class="comment">// 按名称查找 service</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========================================= 扩展相关 =========================================    </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extension_count</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 顶层扩展字段数量</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">extension</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;    <span class="comment">// 获取第 i 个扩展字段</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindExtensionByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;    <span class="comment">// 按名称查找扩展</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindExtensionByLowercaseName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;    <span class="comment">// 按被扩展类型和编号查找</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选项</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FileOptions&amp; <span class="title">options</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========================================= 调试 =========================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 .proto 格式的字符串表示</span></span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 输出带源码位置信息的字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">DebugStringWithOptions</span><span class="params">(<span class="type">const</span> DebugStringOptions&amp; options)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（6）MessageDescriptor（消息描述符）"><a href="#（6）MessageDescriptor（消息描述符）" class="headerlink" title="（6）MessageDescriptor（消息描述符）"></a>（6）MessageDescriptor（消息描述符）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Descriptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;                	<span class="comment">// 消息名称（如 &quot;EchoRequest&quot;）</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">full_name</span><span class="params">()</span> <span class="type">const</span></span>;            	<span class="comment">// 完整名称（如 &quot;myservice.EchoRequest&quot;）    </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> <span class="type">const</span></span>;                                	<span class="comment">// 在父容器中的索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">file</span><span class="params">()</span> <span class="type">const</span></span>;               	 	<span class="comment">// 所属文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">containing_type</span><span class="params">()</span> <span class="type">const</span></span>;        	<span class="comment">// 父消息（如果是嵌套定义） </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ===================================== 字段 =====================================</span></span><br><span class="line">    <span class="comment">// 字段数量（不含扩展）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">field_count</span><span class="params">()</span> <span class="type">const</span></span>;                            </span><br><span class="line">    <span class="comment">// 获取第 i 个字段</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">field</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 按名称查找字段</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindFieldByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 按字段编号查找</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindFieldByNumber</span><span class="params">(<span class="type">int</span> number)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 按小写名称查找（用于 JSON 映射）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindFieldByLowercaseName</span><span class="params">(<span class="type">const</span> std::string&amp; lowercase_name)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 按驼峰名称查找</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindFieldByCamelcaseName</span><span class="params">(<span class="type">const</span> std::string&amp; camelcase_name)</span> <span class="type">const</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ===================================== oneof（联合字段） =====================================</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">oneof_decl_count</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// oneof 数量</span></span><br><span class="line">    <span class="function"><span class="type">const</span> OneofDescriptor* <span class="title">oneof_decl</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;    <span class="comment">// 获取第 i 个 oneof</span></span><br><span class="line">    <span class="function"><span class="type">const</span> OneofDescriptor* <span class="title">FindOneofByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;    <span class="comment">// 按名称查找 oneof</span></span><br><span class="line">    <span class="comment">// 真实 oneof 数量（不含 synthetic oneof，即 optional 的内部实现）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">real_oneof_decl_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ===================================== 嵌套类型 =====================================</span></span><br><span class="line">    <span class="comment">// 嵌套 message 数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nested_type_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 获取第 i 个嵌套 message</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">nested_type</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 按名称查找嵌套 message</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">FindNestedTypeByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===================================== 嵌套枚举 =====================================</span></span><br><span class="line">    <span class="comment">// 嵌套 enum 数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">enum_type_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 获取第 i 个嵌套 enum</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumDescriptor* <span class="title">enum_type</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 按名称查找嵌套 enum</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumDescriptor* <span class="title">FindEnumTypeByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 按值名称查找 enum value</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumValueDescriptor* <span class="title">FindEnumValueByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ===================================== 扩展范围=====================================</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ExtensionRange</span> &#123;</span><br><span class="line">        <span class="type">int</span> start;  <span class="comment">// 起始编号（含）</span></span><br><span class="line">        <span class="type">int</span> end;    <span class="comment">// 结束编号（不含）</span></span><br><span class="line">        <span class="type">const</span> ExtensionRangeOptions* options;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 扩展范围数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extension_range_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 获取第 i 个扩展范围</span></span><br><span class="line">    <span class="function"><span class="type">const</span> ExtensionRange* <span class="title">extension_range</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 检查编号是否在扩展范围内</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsExtensionNumber</span><span class="params">(<span class="type">int</span> number)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===================================== 扩展字段=====================================</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extension_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">extension</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">FindExtensionByName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===================================== 保留字段（reserved）=====================================</span></span><br><span class="line">    <span class="comment">// 保留的编号范围数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reserved_range_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ReservedRange</span> &#123;</span><br><span class="line">        <span class="type">int</span> start;  <span class="comment">// 起始编号（含）</span></span><br><span class="line">        <span class="type">int</span> end;    <span class="comment">// 结束编号（含）</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">const</span> ReservedRange* <span class="title">reserved_range</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 保留的名称数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reserved_name_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 获取第 i 个保留名称</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">reserved_name</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===================================== 特性检查 =====================================   </span></span><br><span class="line">    <span class="comment">// 是否是 map entry（map&lt;K,V&gt; 内部生成的消息）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">map_key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">map_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 获取 map 的 key/value 字段描述符</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">map_key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> FieldDescriptor* <span class="title">map_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选项</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MessageOptions&amp; <span class="title">options</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试</span></span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（7）FieldDescriptor（字段描述符）"><a href="#（7）FieldDescriptor（字段描述符）" class="headerlink" title="（7）FieldDescriptor（字段描述符）"></a>（7）FieldDescriptor（字段描述符）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FieldDescriptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 字段类型枚举</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">        TYPE_DOUBLE         = <span class="number">1</span>,</span><br><span class="line">        TYPE_FLOAT          = <span class="number">2</span>,</span><br><span class="line">        TYPE_INT64          = <span class="number">3</span>,</span><br><span class="line">        TYPE_UINT64         = <span class="number">4</span>,</span><br><span class="line">        TYPE_INT32          = <span class="number">5</span>,</span><br><span class="line">        TYPE_FIXED64        = <span class="number">6</span>,</span><br><span class="line">        TYPE_FIXED32        = <span class="number">7</span>,</span><br><span class="line">        TYPE_BOOL           = <span class="number">8</span>,</span><br><span class="line">        TYPE_STRING         = <span class="number">9</span>,</span><br><span class="line">        TYPE_GROUP          = <span class="number">10</span>,  <span class="comment">// 已废弃</span></span><br><span class="line">        TYPE_MESSAGE        = <span class="number">11</span>,  <span class="comment">// 嵌套消息</span></span><br><span class="line">        TYPE_BYTES          = <span class="number">12</span>,</span><br><span class="line">        TYPE_UINT32         = <span class="number">13</span>,</span><br><span class="line">        TYPE_ENUM           = <span class="number">14</span>,</span><br><span class="line">        TYPE_SFIXED32       = <span class="number">15</span>,</span><br><span class="line">        TYPE_SFIXED64       = <span class="number">16</span>,</span><br><span class="line">        TYPE_SINT32         = <span class="number">17</span>,</span><br><span class="line">        TYPE_SINT64         = <span class="number">18</span>,</span><br><span class="line">        MAX_TYPE            = <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++ 类型枚举（用于代码生成）</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CppType</span> &#123;</span><br><span class="line">        CPPTYPE_INT32       = <span class="number">1</span>,</span><br><span class="line">        CPPTYPE_INT64       = <span class="number">2</span>,</span><br><span class="line">        CPPTYPE_UINT32      = <span class="number">3</span>,</span><br><span class="line">        CPPTYPE_UINT64      = <span class="number">4</span>,</span><br><span class="line">        CPPTYPE_DOUBLE      = <span class="number">5</span>,</span><br><span class="line">        CPPTYPE_FLOAT       = <span class="number">6</span>,</span><br><span class="line">        CPPTYPE_BOOL        = <span class="number">7</span>,</span><br><span class="line">        CPPTYPE_ENUM        = <span class="number">8</span>,</span><br><span class="line">        CPPTYPE_STRING      = <span class="number">9</span>,</span><br><span class="line">        CPPTYPE_MESSAGE     = <span class="number">10</span>,</span><br><span class="line">        MAX_CPPTYPE         = <span class="number">10</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标签（proto2）</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Label</span> &#123;</span><br><span class="line">        LABEL_OPTIONAL      = <span class="number">1</span>,</span><br><span class="line">        LABEL_REQUIRED      = <span class="number">2</span>,  <span class="comment">// proto2 only</span></span><br><span class="line">        LABEL_REPEATED      = <span class="number">3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 基本信息</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字段名称（如 &quot;message&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完整名称（如 &quot;myservice.EchoRequest.message&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">full_name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字段编号</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">number</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在消息中的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 类型信息</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Proto 类型</span></span><br><span class="line">    <span class="function">Type <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型名称字符串（如 &quot;string&quot;, &quot;int32&quot;）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">type_name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++ 类型</span></span><br><span class="line">    <span class="function">CppType <span class="title">cpp_type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++ 类型名称字符串</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">CppTypeName</span><span class="params">(CppType cpp_type)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    <span class="function">Label <span class="title">label</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 类型判断</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为 repeated</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_repeated</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为 optional（proto3 显式 optional 或 proto2 optional）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_optional</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为 required（proto2）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_required</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为 map 类型</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_map</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为 packed 编码</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_packed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为扩展字段</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_extension</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 所属关系</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所属文件</span></span><br><span class="line">    <span class="function"><span class="type">const</span> FileDescriptor* <span class="title">file</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所属消息（普通字段）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">containing_type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 被扩展的消息（扩展字段）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">extension_scope</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所属 oneof（如果有）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> OneofDescriptor* <span class="title">containing_oneof</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真实 oneof 索引（-1 表示不属于 oneof）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index_in_oneof</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 嵌套类型信息</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是 TYPE_MESSAGE 或 TYPE_GROUP，返回消息描述符</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Descriptor* <span class="title">message_type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是 TYPE_ENUM，返回枚举描述符</span></span><br><span class="line">    <span class="function"><span class="type">const</span> EnumDescriptor* <span class="title">enum_type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 默认值</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否有显式设置默认值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_default_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 各类型的默认值获取</span></span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">default_value_int32</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">default_value_int64</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">default_value_uint32</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">default_value_uint64</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">default_value_float</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">default_value_double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">default_value_bool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">default_value_string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> EnumValueDescriptor* <span class="title">default_value_enum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// JSON 相关</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// JSON 字段名（默认用驼峰命名）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">json_name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小写名称（下划线）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">lowercase_name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 驼峰名称</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">camelcase_name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 选项</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> FieldOptions&amp; <span class="title">options</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 调试</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="五、gRPC-的使用"><a href="#五、gRPC-的使用" class="headerlink" title="五、gRPC 的使用"></a>五、gRPC 的使用</h1><h2 id="1-gRPC-编译命令"><a href="#1-gRPC-编译命令" class="headerlink" title="1.gRPC 编译命令"></a>1.gRPC 编译命令</h2><h3 id="（1）基本编译命令"><a href="#（1）基本编译命令" class="headerlink" title="（1）基本编译命令"></a>（1）基本编译命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 C++ 代码（同时生成 protobuf 和 grpc 代码）</span></span><br><span class="line">protoc --cpp_out=. --grpc_out=. --plugin=protoc-gen-grpc=`<span class="built_in">which</span> grpc_cpp_plugin` your_service.proto</span><br></pre></td></tr></table></figure>
<p>生成文件：</p>
<ul>
<li>your_service.pb.h &#x2F; your_service.pb.cc — Protobuf 消息类</li>
<li>your_service.grpc.pb.h &#x2F; your_service.grpc.pb.cc — gRPC 服务类（Stub 等）</li>
</ul>
<h3 id="（2）指定输出目录"><a href="#（2）指定输出目录" class="headerlink" title="（2）指定输出目录"></a>（2）指定输出目录</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">protoc -I=./proto \</span><br><span class="line">       --cpp_out=./generated \</span><br><span class="line">       --grpc_out=./generated \</span><br><span class="line">       --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` \</span><br><span class="line">       ./proto/your_service.proto</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122101152562.png"></p>
<h2 id="2-四种-RPC-模式"><a href="#2-四种-RPC-模式" class="headerlink" title="2.四种 RPC 模式"></a>2.四种 RPC 模式</h2><p>Proto 定义了 4 种标准 RPC 模式，核心区别是「<strong>请求&#x2F;响应是否为流式</strong>」，每种模式对应 C++ 编译后不同的函数签名和调用方式<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260120111458667.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        四种 RPC 模式                             │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  Unary:            Client ──Req──▶ Server ──Resp──▶ Client     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  Server Stream:    Client ──Req──▶ Server ══Resp══▶            │</span><br><span class="line">│                                           ══Resp══▶            │</span><br><span class="line">│                                           ══Resp══▶ Client     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  Client Stream:    Client ══Req══▶                              │</span><br><span class="line">│                           ══Req══▶                              │</span><br><span class="line">│                           ══Req══▶ Server ──Resp──▶ Client     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  Bidirectional:    Client ══Req══▶ Server                       │</span><br><span class="line">│                           ◀══Resp══                             │</span><br><span class="line">│                           ══Req══▶                              │</span><br><span class="line">│                           ◀══Resp══  (实时双向)                  │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">图例: ── 单条消息   ══ 流式消息</span><br></pre></td></tr></table></figure>

<h2 id="3-使用示例（综合）"><a href="#3-使用示例（综合）" class="headerlink" title="3.使用示例（综合）"></a>3.使用示例（综合）</h2><h3 id="（1）Proto定义"><a href="#（1）Proto定义" class="headerlink" title="（1）Proto定义"></a>（1）Proto定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求和响应消息定义</span></span><br><span class="line">message Request &#123;</span><br><span class="line">    string data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    string result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义四种RPC模式的服务</span></span><br><span class="line">service DemoService &#123;</span><br><span class="line">    <span class="comment">// 1. Unary（一元RPC）：单请求-单响应</span></span><br><span class="line">    <span class="function">rpc <span class="title">UnaryCall</span><span class="params">(Request)</span> <span class="title">returns</span> <span class="params">(Response)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. Server Streaming（服务端流）：单请求-多响应流</span></span><br><span class="line">    <span class="function">rpc <span class="title">ServerStreamingCall</span><span class="params">(Request)</span> <span class="title">returns</span> <span class="params">(stream Response)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. Client Streaming（客户端流）：多请求流-单响应</span></span><br><span class="line">    <span class="function">rpc <span class="title">ClientStreamingCall</span><span class="params">(stream Request)</span> <span class="title">returns</span> <span class="params">(Response)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. Bidirectional Streaming（双向流）：多请求流-多响应流</span></span><br><span class="line">    <span class="function">rpc <span class="title">BidirectionalStreamingCall</span><span class="params">(stream Request)</span> <span class="title">returns</span> <span class="params">(stream Response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）生成的C-伪代码"><a href="#（2）生成的C-伪代码" class="headerlink" title="（2）生成的C++伪代码"></a>（2）生成的C++伪代码</h3><p>运行 protoc –grpc_out&#x3D;. –cpp_out&#x3D;. demo.proto 后生成</p>
<h4 id="服务端基类（demo-grpc-pb-h）"><a href="#服务端基类（demo-grpc-pb-h）" class="headerlink" title="&lt;1&gt;服务端基类（demo.grpc.pb.h）"></a>&lt;1&gt;服务端基类（demo.grpc.pb.h）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> demo &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatService</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> <span class="type">const</span>* <span class="title">service_full_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;im.ChatService&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 同步 Service 基类 ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Service</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Service</span>();</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Service</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> grpc::Status <span class="title">Chat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerReaderWriter&lt;ChatMessage, ChatMessage&gt;* stream</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 【关键】异步 Service 基类 ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncService</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AsyncService</span>();</span><br><span class="line">        ~<span class="built_in">AsyncService</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 请求处理一个 Chat 调用</span></span><br><span class="line">        <span class="comment">// 当有新的 Chat 请求到达时，通过 cq 通知</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">RequestChat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerAsyncReaderWriter&lt;ChatMessage, ChatMessage&gt;* stream,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//                            ↑ 写出          ↑ 读入</span></span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::CompletionQueue* new_call_cq,  <span class="comment">// 用于新调用通知</span></span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerCompletionQueue* notification_cq,  <span class="comment">// 用于完成通知</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span>* tag  <span class="comment">// 完成时的标识</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Stub 类（完整版） ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">final</span> : <span class="keyword">public</span> StubInterface &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Stub</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;grpc::ChannelInterface&gt;&amp; channel)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ---------- 同步接口 ----------</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientReaderWriter&lt;ChatMessage, ChatMessage&gt;&gt; </span><br><span class="line">        <span class="built_in">Chat</span>(grpc::ClientContext* context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ---------- 异步接口 ----------</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncReaderWriter&lt;ChatMessage, ChatMessage&gt;&gt; </span><br><span class="line">        <span class="built_in">AsyncChat</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            grpc::CompletionQueue* cq,</span><br><span class="line">            <span class="type">void</span>* tag</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// PrepareAsync 版本（延迟启动）</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncReaderWriter&lt;ChatMessage, ChatMessage&gt;&gt; </span><br><span class="line">        <span class="built_in">PrepareAsyncChat</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            grpc::CompletionQueue* cq</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::shared_ptr&lt;grpc::ChannelInterface&gt; channel_;</span><br><span class="line">        <span class="type">const</span> grpc::internal::RpcMethod rpcmethod_Chat_;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;Stub&gt; <span class="title">NewStub</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;grpc::Channel&gt;&amp; channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> grpc::StubOptions&amp; options = grpc::StubOptions()</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace demo</span></span><br></pre></td></tr></table></figure>
<h4 id="核心流操作类（gRPC-库提供）"><a href="#核心流操作类（gRPC-库提供）" class="headerlink" title="&lt;2&gt;核心流操作类（gRPC 库提供）"></a>&lt;2&gt;核心流操作类（gRPC 库提供）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 服务端使用 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端写入流（Server Streaming 用）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg)</span></span>;                    <span class="comment">// 发送一个响应</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, WriteOptions opts)</span></span>; <span class="comment">// 带选项写入</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端读取流（Client Streaming 用）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(R* msg)</span></span>;  <span class="comment">// 读取一个请求，返回 false 表示流结束</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端双向流（Bidirectional 用）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>, <span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerReaderWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(R* msg)</span></span>;         <span class="comment">// 读取客户端请求</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg)</span></span>;  <span class="comment">// 发送响应给客户端</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 客户端使用 ==========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端读取流（Server Streaming 用）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(R* msg)</span></span>;        <span class="comment">// 读取服务端响应</span></span><br><span class="line">    <span class="function">grpc::Status <span class="title">Finish</span><span class="params">()</span></span>;    <span class="comment">// 结束并获取状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端写入流（Client Streaming 用）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg)</span></span>;  <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">WritesDone</span><span class="params">()</span></span>;         <span class="comment">// 标记发送完成</span></span><br><span class="line">    <span class="function">grpc::Status <span class="title">Finish</span><span class="params">()</span></span>;     <span class="comment">// 等待服务端响应并获取状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端双向流（Bidirectional 用）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>, <span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientReaderWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg)</span></span>;  <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(R* msg)</span></span>;         <span class="comment">// 读取响应</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">WritesDone</span><span class="params">()</span></span>;         <span class="comment">// 标记发送完成</span></span><br><span class="line">    <span class="function">grpc::Status <span class="title">Finish</span><span class="params">()</span></span>;     <span class="comment">// 获取最终状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）gRPC-新增的关键类型（C-伪代码）"><a href="#（3）gRPC-新增的关键类型（C-伪代码）" class="headerlink" title="（3）gRPC 新增的关键类型（C++ 伪代码）"></a>（3）gRPC 新增的关键类型（C++ 伪代码）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122105626627.png"></p>
<h4 id="grpc-Status"><a href="#grpc-Status" class="headerlink" title="&lt;1&gt;grpc::Status"></a>&lt;1&gt;grpc::Status</h4><ul>
<li>在原生Proto的Service中，是通过Context返回“执行状态”（成功&#x2F;失败&#x2F;错误码&#x2F;错误信息），grpc框架直接将其抽取出来实现了grpc::Status专门存储“执行状态”。</li>
</ul>
<h5 id="1-内部伪代码"><a href="#1-内部伪代码" class="headerlink" title="1)内部伪代码"></a>1)内部伪代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="built_in">Status</span>();  <span class="comment">// 默认 OK</span></span><br><span class="line">    <span class="built_in">Status</span>(StatusCode code, <span class="type">const</span> std::string&amp; error_message);</span><br><span class="line">    <span class="built_in">Status</span>(StatusCode code, <span class="type">const</span> std::string&amp; error_message, <span class="type">const</span> std::string&amp; error_details);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态判断</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="type">const</span></span>;                      <span class="comment">// 是否成功</span></span><br><span class="line">    <span class="function">StatusCode <span class="title">error_code</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 错误码</span></span><br><span class="line">    <span class="function">std::string <span class="title">error_message</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 错误信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">error_details</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 详细信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预定义状态</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> Status&amp; OK;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> Status&amp; CANCELLED;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态码枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">StatusCode</span> &#123;</span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    CANCELLED = <span class="number">1</span>,</span><br><span class="line">    UNKNOWN = <span class="number">2</span>,</span><br><span class="line">    INVALID_ARGUMENT = <span class="number">3</span>,</span><br><span class="line">    DEADLINE_EXCEEDED = <span class="number">4</span>,</span><br><span class="line">    NOT_FOUND = <span class="number">5</span>,</span><br><span class="line">    ALREADY_EXISTS = <span class="number">6</span>,</span><br><span class="line">    PERMISSION_DENIED = <span class="number">7</span>,</span><br><span class="line">    RESOURCE_EXHAUSTED = <span class="number">8</span>,</span><br><span class="line">    FAILED_PRECONDITION = <span class="number">9</span>,</span><br><span class="line">    ABORTED = <span class="number">10</span>,</span><br><span class="line">    OUT_OF_RANGE = <span class="number">11</span>,</span><br><span class="line">    UNIMPLEMENTED = <span class="number">12</span>,</span><br><span class="line">    INTERNAL = <span class="number">13</span>,</span><br><span class="line">    UNAVAILABLE = <span class="number">14</span>,</span><br><span class="line">    DATA_LOSS = <span class="number">15</span>,</span><br><span class="line">    UNAUTHENTICATED = <span class="number">16</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h5 id="2）使用示例"><a href="#2）使用示例" class="headerlink" title="2）使用示例"></a>2）使用示例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 作用：告诉调用者&quot;这次 RPC 成功了吗？失败原因是什么？&quot;</span></span><br><span class="line"></span><br><span class="line">grpc::Status status = stub-&gt;<span class="built_in">Echo</span>(&amp;context, request, &amp;response);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 成功，使用 response</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;错误码: &quot;</span> &lt;&lt; status.<span class="built_in">error_code</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;错误信息: &quot;</span> &lt;&lt; status.<span class="built_in">error_message</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grpc-ClientContext-—-客户端调用上下文"><a href="#grpc-ClientContext-—-客户端调用上下文" class="headerlink" title="&lt;2&gt;grpc::ClientContext — 客户端调用上下文"></a>&lt;2&gt;grpc::ClientContext — 客户端调用上下文</h4><ul>
<li>在原生Proto的Service中，是通过Context在设置“超时、取消”，这部分功能现在也被抽取出来封装在grpc::ClinetContext中，方便客户端使用</li>
<li>相比与原生Proto的Context，<strong>新增了“元数据、认证”等功能</strong><ul>
<li><strong>元数据</strong>：元数据是附加在 RPC 调用上的<strong>键值对信息</strong>，类似于 HTTP Headers，用于传递额外的键值对信息</li>
<li><strong>认证功能</strong>：用于身份验证，如 Token、证书等</li>
</ul>
</li>
</ul>
<h5 id="1）内部伪代码"><a href="#1）内部伪代码" class="headerlink" title="1）内部伪代码"></a>1）内部伪代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientContext</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClientContext</span>();</span><br><span class="line">    ~<span class="built_in">ClientContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 元数据 (Metadata) ==========</span></span><br><span class="line">    <span class="comment">// 发送给服务端的元数据（调用前设置）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMetadata</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取服务端返回的初始元数据</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::multimap&lt;grpc::string_ref, grpc::string_ref&gt;&amp; <span class="title">GetServerInitialMetadata</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取服务端返回的尾部元数据</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::multimap&lt;grpc::string_ref, grpc::string_ref&gt;&amp; <span class="title">GetServerTrailingMetadata</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 超时控制 ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_deadline</span><span class="params">(<span class="type">const</span> std::chrono::system_clock::time_point&amp; deadline)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_deadline</span><span class="params">(<span class="type">const</span> gpr_timespec&amp; deadline)</span></span>;</span><br><span class="line">    std::chrono::<span class="function">system_clock::time_point <span class="title">deadline</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 取消调用 ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TryCancel</span><span class="params">()</span></span>;               <span class="comment">// 尝试取消本次 RPC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 认证 ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_credentials</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;CallCredentials&gt;&amp; creds)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">const</span> AuthContext&gt; <span class="title">auth_context</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 压缩 ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_compression_algorithm</span><span class="params">(grpc_compression_algorithm algorithm)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 其他 ==========</span></span><br><span class="line">    <span class="function">std::string <span class="title">peer</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 获取对端地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_wait_for_ready</span><span class="params">(<span class="type">bool</span> wait)</span></span>;  <span class="comment">// 等待 channel ready</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️ 不可复制，每次调用需要新建</span></span><br><span class="line">    <span class="built_in">ClientContext</span>(<span class="type">const</span> ClientContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ClientContext&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ClientContext&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h5 id="2）使用示例-1"><a href="#2）使用示例-1" class="headerlink" title="2）使用示例"></a>2）使用示例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：配置本次 RPC 调用的超时、元数据、认证等参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 每次 RPC 调用都必须新建 ClientContext，不可复用！</span></span><br><span class="line">grpc::ClientContext context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 设置超时 ==========</span></span><br><span class="line"><span class="comment">// 5秒后超时</span></span><br><span class="line">context.<span class="built_in">set_deadline</span>(std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 添加元数据（类似 HTTP Header） ==========</span></span><br><span class="line">context.<span class="built_in">AddMetadata</span>(<span class="string">&quot;x-request-id&quot;</span>, <span class="string">&quot;uuid-12345&quot;</span>);      <span class="comment">// 请求追踪</span></span><br><span class="line">context.<span class="built_in">AddMetadata</span>(<span class="string">&quot;authorization&quot;</span>, <span class="string">&quot;Bearer my-token&quot;</span>); <span class="comment">// 自定义认证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 设置认证凭证 ==========</span></span><br><span class="line"><span class="keyword">auto</span> call_creds = grpc::<span class="built_in">AccessTokenCredentials</span>(<span class="string">&quot;jwt-token&quot;</span>);</span><br><span class="line">context.<span class="built_in">set_credentials</span>(call_creds);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 发起调用 ==========</span></span><br><span class="line">grpc::Status status = stub-&gt;<span class="built_in">Echo</span>(&amp;context, request, &amp;response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 获取服务端返回的元数据 ==========</span></span><br><span class="line"><span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; metadata = context.<span class="built_in">GetServerTrailingMetadata</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = metadata.<span class="built_in">find</span>(<span class="string">&quot;x-server-time&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != metadata.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;服务端时间: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 取消调用（通常在另一个线程） ==========</span></span><br><span class="line"><span class="comment">// context.TryCancel();</span></span><br></pre></td></tr></table></figure>

<h4 id="grpc-ServerContext-—-服务端处理上下文"><a href="#grpc-ServerContext-—-服务端处理上下文" class="headerlink" title="&lt;3&gt;grpc::ServerContext — 服务端处理上下文"></a>&lt;3&gt;grpc::ServerContext — 服务端处理上下文</h4><ul>
<li>与 ClientContext 对应，服务端用于获取客户端信息和设置响应元数据</li>
<li>可以检测客户端是否取消了请求、获取客户端设置的超时时间</li>
<li>可以获取客户端的认证信息和地址</li>
</ul>
<h5 id="1-内部伪代码-1"><a href="#1-内部伪代码-1" class="headerlink" title="1)内部伪代码"></a>1)内部伪代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerContext</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ServerContext</span>();</span><br><span class="line">    ~<span class="built_in">ServerContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 元数据 (Metadata) ==========</span></span><br><span class="line">    <span class="comment">// 获取客户端发来的元数据</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::multimap&lt;grpc::string_ref, grpc::string_ref&gt;&amp; <span class="title">client_metadata</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送初始元数据给客户端（在第一个响应之前）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddInitialMetadata</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送尾部元数据给客户端（在 RPC 结束时）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTrailingMetadata</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 取消/超时检测 ==========</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsCancelled</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 客户端是否取消了请求</span></span><br><span class="line">    std::chrono::<span class="function">system_clock::time_point <span class="title">deadline</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 客户端设置的 deadline</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 认证信息 ==========</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">const</span> AuthContext&gt; <span class="title">auth_context</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">peer</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 客户端地址（如 &quot;ipv4:127.0.0.1:12345&quot;）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 压缩 ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_compression_level</span><span class="params">(grpc_compression_level level)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_compression_algorithm</span><span class="params">(grpc_compression_algorithm algorithm)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 异步通知 ==========</span></span><br><span class="line">    <span class="comment">// 当 RPC 被取消时触发回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AsyncNotifyWhenDone</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h5 id="2）使用示例-2"><a href="#2）使用示例-2" class="headerlink" title="2）使用示例"></a>2）使用示例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：在服务端处理方法中，获取客户端信息、设置响应元数据</span></span><br><span class="line"></span><br><span class="line"><span class="function">grpc::Status <span class="title">MyServiceImpl::Echo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    grpc::ServerContext* context,    <span class="comment">// 框架自动传入，无需手动创建</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> EchoRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">    EchoResponse* response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ========== 获取客户端元数据 ==========</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; metadata = context-&gt;<span class="built_in">client_metadata</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = metadata.<span class="built_in">find</span>(<span class="string">&quot;x-request-id&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != metadata.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="function">std::string <span class="title">request_id</span><span class="params">(it-&gt;second.data(), it-&gt;second.size())</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请求ID: &quot;</span> &lt;&lt; request_id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 获取客户端地址 ==========</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;客户端地址: &quot;</span> &lt;&lt; context-&gt;<span class="built_in">peer</span>() &lt;&lt; std::endl;  <span class="comment">// 如 &quot;ipv4:192.168.1.100:54321&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 检测是否超时/取消 ==========</span></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;<span class="built_in">IsCancelled</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::CANCELLED, <span class="string">&quot;客户端已取消请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 长时间处理时定期检查 ==========</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context-&gt;<span class="built_in">IsCancelled</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::CANCELLED, <span class="string">&quot;处理中被取消&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 设置响应元数据 ==========</span></span><br><span class="line">    context-&gt;<span class="built_in">AddInitialMetadata</span>(<span class="string">&quot;x-server-version&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>);   <span class="comment">// 初始元数据</span></span><br><span class="line">    context-&gt;<span class="built_in">AddTrailingMetadata</span>(<span class="string">&quot;x-process-time-ms&quot;</span>, <span class="string">&quot;42&quot;</span>);    <span class="comment">// 尾部元数据</span></span><br><span class="line"></span><br><span class="line">    response-&gt;<span class="built_in">set_message</span>(request-&gt;<span class="built_in">message</span>());</span><br><span class="line">    <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="grpc-Channel"><a href="#grpc-Channel" class="headerlink" title="&lt;4&gt;grpc::Channel"></a>&lt;4&gt;grpc::Channel</h4><ul>
<li>原生 Proto 中需要自己实现 RpcChannel（纯虚类），gRPC 直接提供了<strong>内置 HTTP&#x2F;2 实现</strong></li>
<li>Channel 代表客户端到服务端的逻辑连接，<strong>可被多个 Stub 共享</strong></li>
<li>内置<strong>连接池、重连、负载均衡</strong>等功能</li>
</ul>
<h5 id="1）内部伪代码-1"><a href="#1）内部伪代码-1" class="headerlink" title="1）内部伪代码"></a>1）内部伪代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> : <span class="keyword">public</span> ChannelInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取连接状态</span></span><br><span class="line">    <span class="function">grpc_connectivity_state <span class="title">GetState</span><span class="params">(<span class="type">bool</span> try_to_connect)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待状态变化</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">WaitForStateChange</span><span class="params">(grpc_connectivity_state last_observed,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::chrono::system_clock::time_point deadline)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待连接就绪</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">WaitForConnected</span><span class="params">(std::chrono::system_clock::time_point deadline)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接状态枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">grpc_connectivity_state</span> &#123;</span><br><span class="line">    GRPC_CHANNEL_IDLE,              <span class="comment">// 空闲</span></span><br><span class="line">    GRPC_CHANNEL_CONNECTING,        <span class="comment">// 连接中</span></span><br><span class="line">    GRPC_CHANNEL_READY,             <span class="comment">// 就绪</span></span><br><span class="line">    GRPC_CHANNEL_TRANSIENT_FAILURE, <span class="comment">// 暂时失败（会重试）</span></span><br><span class="line">    GRPC_CHANNEL_SHUTDOWN,          <span class="comment">// 已关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== Channel 创建函数 ==========</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Channel&gt; <span class="title">CreateChannel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; target,                      <span class="comment">// 地址，如 &quot;localhost:50051&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt;ChannelCredentials&gt;&amp; creds</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建凭证</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ChannelCredentials&gt; <span class="title">InsecureChannelCredentials</span><span class="params">()</span></span>;  <span class="comment">// 不加密</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ChannelCredentials&gt; <span class="title">SslCredentials</span><span class="params">(<span class="type">const</span> SslCredentialsOptions&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h5 id="2）使用示例-3"><a href="#2）使用示例-3" class="headerlink" title="2）使用示例"></a>2）使用示例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：建立到服务端的连接，创建 Stub 时使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 创建不加密的 Channel（开发测试用） ==========</span></span><br><span class="line"><span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(</span><br><span class="line">    <span class="string">&quot;localhost:50051&quot;</span>, </span><br><span class="line">    grpc::<span class="built_in">InsecureChannelCredentials</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 创建 TLS 加密的 Channel（生产环境） ==========</span></span><br><span class="line">grpc::SslCredentialsOptions ssl_opts;</span><br><span class="line">ssl_opts.pem_root_certs = <span class="built_in">ReadFile</span>(<span class="string">&quot;ca.crt&quot;</span>);  <span class="comment">// CA 证书</span></span><br><span class="line"><span class="keyword">auto</span> secure_channel = grpc::<span class="built_in">CreateChannel</span>(</span><br><span class="line">    <span class="string">&quot;server.example.com:443&quot;</span>,</span><br><span class="line">    grpc::<span class="built_in">SslCredentials</span>(ssl_opts)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 使用 Channel 创建 Stub ==========</span></span><br><span class="line"><span class="keyword">auto</span> stub = MyService::<span class="built_in">NewStub</span>(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 检查连接状态 ==========</span></span><br><span class="line"><span class="keyword">auto</span> state = channel-&gt;<span class="built_in">GetState</span>(<span class="literal">true</span>);  <span class="comment">// true = 尝试连接</span></span><br><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> GRPC_CHANNEL_IDLE:       std::cout &lt;&lt; <span class="string">&quot;空闲&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GRPC_CHANNEL_CONNECTING: std::cout &lt;&lt; <span class="string">&quot;连接中&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GRPC_CHANNEL_READY:      std::cout &lt;&lt; <span class="string">&quot;已就绪&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GRPC_CHANNEL_TRANSIENT_FAILURE: std::cout &lt;&lt; <span class="string">&quot;暂时失败&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GRPC_CHANNEL_SHUTDOWN:   std::cout &lt;&lt; <span class="string">&quot;已关闭&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 等待连接就绪（带超时） ==========</span></span><br><span class="line"><span class="type">bool</span> connected = channel-&gt;<span class="built_in">WaitForConnected</span>(</span><br><span class="line">    std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;连接超时！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 多个 Stub 共享同一个 Channel（推荐） ==========</span></span><br><span class="line"><span class="keyword">auto</span> stub1 = MyService::<span class="built_in">NewStub</span>(channel);</span><br><span class="line"><span class="keyword">auto</span> stub2 = MyService::<span class="built_in">NewStub</span>(channel);  <span class="comment">// 复用连接</span></span><br></pre></td></tr></table></figure>

<h4 id="grpc-Server-grpc-ServerBuilder"><a href="#grpc-Server-grpc-ServerBuilder" class="headerlink" title="&lt;5&gt;grpc::Server &amp; grpc::ServerBuilder"></a>&lt;5&gt;grpc::Server &amp; grpc::ServerBuilder</h4><ul>
<li>原生 Proto 没有提供服务端框架，需要自己处理网络监听、线程管理等</li>
<li>gRPC 通过 ServerBuilder（建造者模式） 简化服务器配置和启动、<strong>服务注册</strong>等</li>
<li>Server 提供阻塞等待和优雅关闭功能</li>
</ul>
<h5 id="1）内部伪代码-2"><a href="#1）内部伪代码-2" class="headerlink" title="1）内部伪代码"></a>1）内部伪代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== ServerBuilder - 构建服务器 ==========</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ServerBuilder</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加监听地址</span></span><br><span class="line">    <span class="function">ServerBuilder&amp; <span class="title">AddListeningPort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string&amp; addr,                    <span class="comment">// 如 &quot;0.0.0.0:50051&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::shared_ptr&lt;ServerCredentials&gt; creds,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span>* selected_port = <span class="literal">nullptr</span>                <span class="comment">// 输出实际端口</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册服务实现</span></span><br><span class="line">    <span class="function">ServerBuilder&amp; <span class="title">RegisterService</span><span class="params">(Service* service)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程池</span></span><br><span class="line">    <span class="function">ServerBuilder&amp; <span class="title">SetSyncServerOption</span><span class="params">(SyncServerOption option, <span class="type">int</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置最大消息大小</span></span><br><span class="line">    <span class="function">ServerBuilder&amp; <span class="title">SetMaxReceiveMessageSize</span><span class="params">(<span class="type">int</span> max_size)</span></span>;</span><br><span class="line">    <span class="function">ServerBuilder&amp; <span class="title">SetMaxSendMessageSize</span><span class="params">(<span class="type">int</span> max_size)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建并启动</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Server&gt; <span class="title">BuildAndStart</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== Server - 服务器实例 ==========</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 阻塞等待服务关闭</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Wait</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Shutdown</span><span class="params">(<span class="type">const</span> std::chrono::system_clock::time_point&amp; deadline)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端凭证</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;ServerCredentials&gt; <span class="title">InsecureServerCredentials</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;ServerCredentials&gt; <span class="title">SslServerCredentials</span><span class="params">(<span class="type">const</span> SslServerCredentialsOptions&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>
<h5 id="2）使用示例-4"><a href="#2）使用示例-4" class="headerlink" title="2）使用示例"></a>2）使用示例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：配置、启动、管理 gRPC 服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 1. 创建服务实现 ==========</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyServiceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> MyService::Service &#123;</span><br><span class="line">    <span class="function">grpc::Status <span class="title">Echo</span><span class="params">(grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> EchoRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                      EchoResponse* response)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        response-&gt;<span class="built_in">set_message</span>(<span class="string">&quot;Echo: &quot;</span> + request-&gt;<span class="built_in">message</span>());</span><br><span class="line">        <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 2. 使用 ServerBuilder 构建服务器 ==========</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;</span><br><span class="line">    MyServiceImpl service;</span><br><span class="line"></span><br><span class="line">    grpc::ServerBuilder builder;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加监听端口（不加密）</span></span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加监听端口（TLS 加密）</span></span><br><span class="line">    <span class="comment">// grpc::SslServerCredentialsOptions ssl_opts;</span></span><br><span class="line">    <span class="comment">// ssl_opts.pem_key_cert_pairs.push_back(&#123;ReadFile(&quot;server.key&quot;), ReadFile(&quot;server.crt&quot;)&#125;);</span></span><br><span class="line">    <span class="comment">// builder.AddListeningPort(&quot;0.0.0.0:443&quot;, grpc::SslServerCredentials(ssl_opts));</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册服务</span></span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    builder.<span class="built_in">SetMaxReceiveMessageSize</span>(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);  <span class="comment">// 10MB</span></span><br><span class="line">    builder.<span class="built_in">SetMaxSendMessageSize</span>(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建并启动</span></span><br><span class="line">    std::unique_ptr&lt;grpc::Server&gt; server = builder.<span class="built_in">BuildAndStart</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;服务器启动: &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 阻塞等待 ==========</span></span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>();  <span class="comment">// 阻塞直到 Shutdown 被调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 4. 优雅关闭（通常在信号处理中） ==========</span></span><br><span class="line">std::unique_ptr&lt;grpc::Server&gt; g_server;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SignalHandler</span><span class="params">(<span class="type">int</span> signal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_server) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;正在关闭服务器...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 优雅关闭：等待现有请求完成</span></span><br><span class="line">        g_server-&gt;<span class="built_in">Shutdown</span>(std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流操作类"><a href="#流操作类" class="headerlink" title="&lt;6&gt;流操作类"></a>&lt;6&gt;流操作类</h4><ul>
<li>原生 Proto 不支持流式传输，gRPC 新增了<strong>四种流模式</strong>的支持</li>
<li>服务端使用 ServerWriter&#x2F;Reader&#x2F;ReaderWriter</li>
<li>客户端使用 ClientWriter&#x2F;Reader&#x2F;ReaderWriter</li>
</ul>
<h5 id="1）内部伪代码-3"><a href="#1）内部伪代码-3" class="headerlink" title="1）内部伪代码"></a>1）内部伪代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 服务端流类 ==========</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerWriter</span> &#123;                    <span class="comment">// Server Streaming 用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, WriteOptions options)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerReader</span> &#123;                    <span class="comment">// Client Streaming 用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(R* msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">W</span>, <span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerReaderWriter</span> &#123;              <span class="comment">// Bidirectional 用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(R* msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 客户端流类 ==========</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientReader</span> &#123;                    <span class="comment">// Server Streaming 用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(R* msg)</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientWriter</span> &#123;                    <span class="comment">// Client Streaming 用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">WritesDone</span><span class="params">()</span></span>;                  <span class="comment">// 标记写入完成</span></span><br><span class="line">    <span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">W</span>, <span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientReaderWriter</span> &#123;              <span class="comment">// Bidirectional 用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Read</span><span class="params">(R* msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">WritesDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 写入选项 ==========</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteOptions</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">WriteOptions&amp; <span class="title">set_buffer_hint</span><span class="params">()</span></span>;    <span class="comment">// 提示可缓冲</span></span><br><span class="line">    <span class="function">WriteOptions&amp; <span class="title">set_last_message</span><span class="params">()</span></span>;   <span class="comment">// 标记最后一条</span></span><br><span class="line">    <span class="function">WriteOptions&amp; <span class="title">clear_buffer_hint</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h5 id="2）使用示例-5"><a href="#2）使用示例-5" class="headerlink" title="2）使用示例"></a>2）使用示例</h5><p><strong>Server Streaming（服务端流）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景：客户端发一个请求，服务端返回多个响应（如分页数据、实时推送）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 服务端实现 =====</span></span><br><span class="line"><span class="function">grpc::Status <span class="title">ListItems</span><span class="params">(grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ListRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       grpc::ServerWriter&lt;Item&gt;* writer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context-&gt;<span class="built_in">IsCancelled</span>()) <span class="keyword">break</span>;  <span class="comment">// 检查取消</span></span><br><span class="line">        </span><br><span class="line">        Item item;</span><br><span class="line">        item.<span class="built_in">set_id</span>(i);</span><br><span class="line">        item.<span class="built_in">set_name</span>(<span class="string">&quot;Item &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!writer-&gt;<span class="built_in">Write</span>(item)) <span class="keyword">break</span>;  <span class="comment">// 写入失败则退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 客户端调用 =====</span></span><br><span class="line">grpc::ClientContext context;</span><br><span class="line">ListRequest request;</span><br><span class="line"><span class="keyword">auto</span> reader = stub-&gt;<span class="built_in">ListItems</span>(&amp;context, request);</span><br><span class="line"></span><br><span class="line">Item item;</span><br><span class="line"><span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>(&amp;item)) &#123;  <span class="comment">// 循环读取</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;收到: &quot;</span> &lt;&lt; item.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grpc::Status status = reader-&gt;<span class="built_in">Finish</span>();  <span class="comment">// 获取最终状态</span></span><br></pre></td></tr></table></figure>

<p><strong>Client Streaming（客户端流）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景：客户端发多个请求，服务端返回一个响应（如上传文件、批量提交）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 服务端实现 =====</span></span><br><span class="line"><span class="function">grpc::Status <span class="title">UploadFile</span><span class="params">(grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">                        grpc::ServerReader&lt;FileChunk&gt;* reader,</span></span></span><br><span class="line"><span class="params"><span class="function">                        UploadResult* result)</span> </span>&#123;</span><br><span class="line">    FileChunk chunk;</span><br><span class="line">    <span class="type">int</span> total_bytes = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>(&amp;chunk)) &#123;  <span class="comment">// 循环读取客户端发来的数据块</span></span><br><span class="line">        total_bytes += chunk.<span class="built_in">data</span>().<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 处理数据块...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result-&gt;<span class="built_in">set_total_bytes</span>(total_bytes);</span><br><span class="line">    result-&gt;<span class="built_in">set_success</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 客户端调用 =====</span></span><br><span class="line">grpc::ClientContext context;</span><br><span class="line">UploadResult result;</span><br><span class="line"><span class="keyword">auto</span> writer = stub-&gt;<span class="built_in">UploadFile</span>(&amp;context, &amp;result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    FileChunk chunk;</span><br><span class="line">    chunk.<span class="built_in">set_data</span>(<span class="string">&quot;chunk data &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!writer-&gt;<span class="built_in">Write</span>(chunk)) <span class="keyword">break</span>;  <span class="comment">// 写入失败则退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writer-&gt;<span class="built_in">WritesDone</span>();  <span class="comment">// ⚠️ 必须调用！告诉服务端发送完毕</span></span><br><span class="line">grpc::Status status = writer-&gt;<span class="built_in">Finish</span>();  <span class="comment">// 等待服务端响应</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;上传完成，共 &quot;</span> &lt;&lt; result.<span class="built_in">total_bytes</span>() &lt;&lt; <span class="string">&quot; 字节&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>Bidirectional Streaming（双向流）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景：客户端和服务端同时发送多个消息（如聊天、实时协作）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 服务端实现 =====</span></span><br><span class="line"><span class="function">grpc::Status <span class="title">Chat</span><span class="params">(grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">                  grpc::ServerReaderWriter&lt;ChatMessage, ChatMessage&gt;* stream)</span> </span>&#123;</span><br><span class="line">    ChatMessage msg;</span><br><span class="line">    <span class="keyword">while</span> (stream-&gt;<span class="built_in">Read</span>(&amp;msg)) &#123;  <span class="comment">// 读取客户端消息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;收到: &quot;</span> &lt;&lt; msg.<span class="built_in">content</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回复</span></span><br><span class="line">        ChatMessage reply;</span><br><span class="line">        reply.<span class="built_in">set_content</span>(<span class="string">&quot;服务端回复: &quot;</span> + msg.<span class="built_in">content</span>());</span><br><span class="line">        stream-&gt;<span class="built_in">Write</span>(reply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 客户端调用 =====</span></span><br><span class="line">grpc::ClientContext context;</span><br><span class="line"><span class="keyword">auto</span> stream = stub-&gt;<span class="built_in">Chat</span>(&amp;context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动读取线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">reader_thread</span><span class="params">([&amp;stream]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    ChatMessage msg;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span> (stream-&gt;Read(&amp;msg)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;收到: &quot;</span> &lt;&lt; msg.content() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程发送</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    ChatMessage msg;</span><br><span class="line">    msg.<span class="built_in">set_content</span>(<span class="string">&quot;消息 &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">    stream-&gt;<span class="built_in">Write</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stream-&gt;<span class="built_in">WritesDone</span>();  <span class="comment">// 发送完毕</span></span><br><span class="line">reader_thread.<span class="built_in">join</span>();  <span class="comment">// 等待读取完成</span></span><br><span class="line"></span><br><span class="line">grpc::Status status = stream-&gt;<span class="built_in">Finish</span>();</span><br></pre></td></tr></table></figure>

<h2 id="4-Unary（一元）"><a href="#4-Unary（一元）" class="headerlink" title="4.Unary（一元）"></a>4.Unary（一元）</h2><h3 id="（1）功能设计"><a href="#（1）功能设计" class="headerlink" title="（1）功能设计"></a>（1）功能设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">场景：用户登录验证</span><br><span class="line"></span><br><span class="line">┌─────────────┐         LoginRequest          ┌─────────────┐</span><br><span class="line">│   客户端     │ ──────────────────────────→   │   服务端     │</span><br><span class="line">│             │      (username, password)     │             │</span><br><span class="line">│             │                               │             │</span><br><span class="line">│             │ ←──────────────────────────   │             │</span><br><span class="line">└─────────────┘        LoginResponse          └─────────────┘</span><br><span class="line">                  (success, token, message)</span><br><span class="line"></span><br><span class="line">特点：一问一答，最简单的 RPC 模式</span><br></pre></td></tr></table></figure>
<h3 id="（2）Proto定义"><a href="#（2）Proto定义" class="headerlink" title="（2）Proto定义"></a>（2）Proto定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// login.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package auth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录请求</span></span><br><span class="line">message LoginRequest &#123;</span><br><span class="line">    string username = <span class="number">1</span>;</span><br><span class="line">    string password = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录响应</span></span><br><span class="line">message LoginResponse &#123;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">1</span>;</span><br><span class="line">    string token = <span class="number">2</span>;</span><br><span class="line">    string message = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录服务</span></span><br><span class="line">service AuthService &#123;</span><br><span class="line">    <span class="comment">// Unary：无 stream 关键字</span></span><br><span class="line">    <span class="function">rpc <span class="title">Login</span><span class="params">(LoginRequest)</span> <span class="title">returns</span> <span class="params">(LoginResponse)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）生成的-C-关键伪代码"><a href="#（3）生成的-C-关键伪代码" class="headerlink" title="（3）生成的 C++ 关键伪代码"></a>（3）生成的 C++ 关键伪代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== auth.grpc.pb.h ====================</span></span><br><span class="line"><span class="keyword">namespace</span> auth &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthService</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> <span class="type">const</span>* <span class="title">service_full_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;auth.AuthService&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 同步 Service 基类 ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Service</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Service</span>();</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Service</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> grpc::Status <span class="title">Login</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">            LoginResponse* response</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 异步 Service 基类 ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncService</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AsyncService</span>();</span><br><span class="line">        ~<span class="built_in">AsyncService</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 请求处理一个 Login 调用</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">RequestLogin</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            LoginRequest* request,                        <span class="comment">// 请求会被填充到这里</span></span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerAsyncResponseWriter&lt;LoginResponse&gt;* writer,  <span class="comment">// 异步响应写入器</span></span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::CompletionQueue* new_call_cq,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerCompletionQueue* notification_cq,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span>* tag</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Stub 类（完整版） ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">final</span> : <span class="keyword">public</span> StubInterface &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Stub</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;grpc::ChannelInterface&gt;&amp; channel)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ---------- 同步接口 ----------</span></span><br><span class="line">        <span class="function">grpc::Status <span class="title">Login</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ClientContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> LoginRequest&amp; request,</span></span></span><br><span class="line"><span class="params"><span class="function">            LoginResponse* response</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ---------- 异步接口 ----------</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncResponseReader&lt;LoginResponse&gt;&gt; </span><br><span class="line">        <span class="built_in">AsyncLogin</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            <span class="type">const</span> LoginRequest&amp; request,</span><br><span class="line">            grpc::CompletionQueue* cq</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// PrepareAsync 版本（延迟启动，需手动调用 StartCall）</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncResponseReader&lt;LoginResponse&gt;&gt; </span><br><span class="line">        <span class="built_in">PrepareAsyncLogin</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            <span class="type">const</span> LoginRequest&amp; request,</span><br><span class="line">            grpc::CompletionQueue* cq</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::shared_ptr&lt;grpc::ChannelInterface&gt; channel_;</span><br><span class="line">        <span class="type">const</span> grpc::internal::RpcMethod rpcmethod_Login_;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;Stub&gt; <span class="title">NewStub</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;grpc::Channel&gt;&amp; channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> grpc::StubOptions&amp; options = grpc::StubOptions()</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace auth</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== auth.grpc.pb.cc（实现伪代码） ====================</span></span><br><span class="line"><span class="keyword">namespace</span> auth &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stub 同步调用实现</span></span><br><span class="line">grpc::Status AuthService::Stub::<span class="built_in">Login</span>(</span><br><span class="line">    grpc::ClientContext* context,</span><br><span class="line">    <span class="type">const</span> LoginRequest&amp; request,</span><br><span class="line">    LoginResponse* response) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 序列化请求</span></span><br><span class="line">    grpc::ByteBuffer request_buf;</span><br><span class="line">    SerializationTraits&lt;LoginRequest&gt;::<span class="built_in">Serialize</span>(request, &amp;request_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 通过 Channel 发送请求并等待响应</span></span><br><span class="line">    grpc::ByteBuffer response_buf;</span><br><span class="line">    grpc::Status status = channel_-&gt;<span class="built_in">SyncUnaryCall</span>(</span><br><span class="line">        <span class="string">&quot;/auth.AuthService/Login&quot;</span>,  <span class="comment">// 方法路径</span></span><br><span class="line">        context,</span><br><span class="line">        request_buf,</span><br><span class="line">        &amp;response_buf</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 反序列化响应</span></span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        SerializationTraits&lt;LoginResponse&gt;::<span class="built_in">Deserialize</span>(response_buf, response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service 默认实现（返回未实现）</span></span><br><span class="line">grpc::Status AuthService::Service::<span class="built_in">Login</span>(</span><br><span class="line">    grpc::ServerContext* context,</span><br><span class="line">    <span class="type">const</span> LoginRequest* request,</span><br><span class="line">    LoginResponse* response) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::UNIMPLEMENTED, <span class="string">&quot;Method not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace auth</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）使用示例"><a href="#（4）使用示例" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><p><strong>服务端实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== server.cpp ====================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;auth.grpc.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承生成的 Service 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthServiceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> auth::AuthService::Service &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">grpc::Status <span class="title">Login</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> auth::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">        auth::LoginResponse* response)</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取客户端信息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;客户端地址: &quot;</span> &lt;&lt; context-&gt;<span class="built_in">peer</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否被取消</span></span><br><span class="line">        <span class="keyword">if</span> (context-&gt;<span class="built_in">IsCancelled</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::CANCELLED, <span class="string">&quot;请求被取消&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 业务逻辑：验证用户</span></span><br><span class="line">        <span class="keyword">if</span> (request-&gt;<span class="built_in">username</span>() == <span class="string">&quot;admin&quot;</span> &amp;&amp; request-&gt;<span class="built_in">password</span>() == <span class="string">&quot;123456&quot;</span>) &#123;</span><br><span class="line">            response-&gt;<span class="built_in">set_success</span>(<span class="literal">true</span>);</span><br><span class="line">            response-&gt;<span class="built_in">set_token</span>(<span class="string">&quot;jwt-token-xxxxx&quot;</span>);</span><br><span class="line">            response-&gt;<span class="built_in">set_message</span>(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response-&gt;<span class="built_in">set_success</span>(<span class="literal">false</span>);</span><br><span class="line">            response-&gt;<span class="built_in">set_message</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;</span><br><span class="line">    AuthServiceImpl service;</span><br><span class="line">    </span><br><span class="line">    grpc::ServerBuilder builder;</span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>());</span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service);</span><br><span class="line">    </span><br><span class="line">    std::unique_ptr&lt;grpc::Server&gt; server = builder.<span class="built_in">BuildAndStart</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;服务器启动: &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== client.cpp ====================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;auth.grpc.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Channel</span></span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(</span><br><span class="line">        <span class="string">&quot;localhost:50051&quot;</span>,</span><br><span class="line">        grpc::<span class="built_in">InsecureChannelCredentials</span>()</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 创建 Stub</span></span><br><span class="line">    <span class="keyword">auto</span> stub = auth::AuthService::<span class="built_in">NewStub</span>(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 准备请求</span></span><br><span class="line">    auth::LoginRequest request;</span><br><span class="line">    request.<span class="built_in">set_username</span>(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    request.<span class="built_in">set_password</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 创建 Context（每次调用必须新建！）</span></span><br><span class="line">    grpc::ClientContext context;</span><br><span class="line">    context.<span class="built_in">set_deadline</span>(</span><br><span class="line">        std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    context.<span class="built_in">AddMetadata</span>(<span class="string">&quot;client-version&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 调用 RPC</span></span><br><span class="line">    auth::LoginResponse response;</span><br><span class="line">    grpc::Status status = stub-&gt;<span class="built_in">Login</span>(&amp;context, request, &amp;response);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 处理结果</span></span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.<span class="built_in">success</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;✓ 登录成功！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  Token: &quot;</span> &lt;&lt; response.<span class="built_in">token</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;✗ 登录失败: &quot;</span> &lt;&lt; response.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✗ RPC 错误: &quot;</span> &lt;&lt; status.<span class="built_in">error_message</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  错误码: &quot;</span> &lt;&lt; status.<span class="built_in">error_code</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）数据流图"><a href="#（5）数据流图" class="headerlink" title="（5）数据流图"></a>（5）数据流图</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        Unary 调用流程                                    │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   客户端                                              服务端             │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   LoginRequest req;                                                     │</span><br><span class="line">│   req.<span class="built_in">set_username</span>(<span class="string">&quot;admin&quot;</span>);                                           │</span><br><span class="line">│   req.<span class="built_in">set_password</span>(<span class="string">&quot;123456&quot;</span>);                                          │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   stub-&gt;<span class="built_in">Login</span>(&amp;ctx, req, &amp;resp);                                       │</span><br><span class="line">│         │                                                               │</span><br><span class="line">│         │  ┌──────────────────┐                                        │</span><br><span class="line">│         └─→│  HTTP/<span class="number">2</span> POST     │                                        │</span><br><span class="line">│            │  /auth.AuthService/Login                                   │</span><br><span class="line">│            │  Body: [序列化的 LoginRequest]                             │</span><br><span class="line">│            └────────────────────────────────────────→ 收到请求          │</span><br><span class="line">│                                                      │                  │</span><br><span class="line">│                                                      ▼                  │</span><br><span class="line">│                                              <span class="built_in">Login</span>(ctx, req, resp)     │</span><br><span class="line">│                                              验证用户名密码              │</span><br><span class="line">│                                              填充 resp                  │</span><br><span class="line">│                                              <span class="keyword">return</span> Status::OK         │</span><br><span class="line">│                                                      │                  │</span><br><span class="line">│            ┌────────────────────────────────────────←┘                  │</span><br><span class="line">│            │  HTTP/<span class="number">2</span> Response                                          │</span><br><span class="line">│            │  Body: [序列化的 LoginResponse]                            │</span><br><span class="line">│            │  Trailers: grpc-status=<span class="number">0</span>                                   │</span><br><span class="line">│         ←──┘                                                            │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   status.<span class="built_in">ok</span>() == <span class="literal">true</span>                                                   │</span><br><span class="line">│   resp.<span class="built_in">success</span>() == <span class="literal">true</span>                                               │</span><br><span class="line">│   resp.<span class="built_in">token</span>() == <span class="string">&quot;jwt-token-xxxxx&quot;</span>                                    │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（6）Unary模式总结"><a href="#（6）Unary模式总结" class="headerlink" title="（6）Unary模式总结"></a>（6）Unary模式总结</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122153138053.png"></p>
<h2 id="5-Server-Streaming（服务端流）"><a href="#5-Server-Streaming（服务端流）" class="headerlink" title="5.Server Streaming（服务端流）"></a>5.Server Streaming（服务端流）</h2><h3 id="（1）功能设计-1"><a href="#（1）功能设计-1" class="headerlink" title="（1）功能设计"></a>（1）功能设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">场景：查询订单列表（分批返回）</span><br><span class="line"></span><br><span class="line">┌─────────────┐       OrderQuery              ┌─────────────┐</span><br><span class="line">│   客户端     │ ──────────────────────────→   │   服务端     │</span><br><span class="line">│             │      (user_id, status)        │             │</span><br><span class="line">│             │                               │             │</span><br><span class="line">│             │ ←─────── Order <span class="number">1</span> ─────────    │             │</span><br><span class="line">│             │ ←─────── Order <span class="number">2</span> ─────────    │             │</span><br><span class="line">│             │ ←─────── Order <span class="number">3</span> ─────────    │             │</span><br><span class="line">│             │ ←─────── ...     ─────────    │             │</span><br><span class="line">└─────────────┘                               └─────────────┘</span><br><span class="line"></span><br><span class="line">特点：一个请求，多个响应（服务端推送）</span><br></pre></td></tr></table></figure>

<h3 id="（2）Proto定义-1"><a href="#（2）Proto定义-1" class="headerlink" title="（2）Proto定义"></a>（2）Proto定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// order.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package shop;</span><br><span class="line"></span><br><span class="line">message OrderQuery &#123;</span><br><span class="line">    string user_id = <span class="number">1</span>;</span><br><span class="line">    string status = <span class="number">2</span>;  <span class="comment">// &quot;pending&quot;, &quot;completed&quot;, &quot;all&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Order &#123;</span><br><span class="line">    string order_id = <span class="number">1</span>;</span><br><span class="line">    string product_name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">3</span>;</span><br><span class="line">    string status = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service OrderService &#123;</span><br><span class="line">    <span class="comment">// Server Streaming：返回值加 stream</span></span><br><span class="line">    <span class="function">rpc <span class="title">ListOrders</span><span class="params">(OrderQuery)</span> <span class="title">returns</span> <span class="params">(stream Order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）生成的-C-关键伪代码-1"><a href="#（3）生成的-C-关键伪代码-1" class="headerlink" title="（3）生成的 C++ 关键伪代码"></a>（3）生成的 C++ 关键伪代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== order.grpc.pb.h ====================</span></span><br><span class="line"><span class="keyword">namespace</span> shop &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> <span class="type">const</span>* <span class="title">service_full_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;shop.OrderService&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 同步 Service 基类 ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Service</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Service</span>();</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Service</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> grpc::Status <span class="title">ListOrders</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> OrderQuery* request,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerWriter&lt;Order&gt;* writer</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 异步 Service 基类 ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncService</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AsyncService</span>();</span><br><span class="line">        ~<span class="built_in">AsyncService</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 请求处理一个 ListOrders 调用</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">RequestListOrders</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            OrderQuery* request,                    <span class="comment">// 请求会被填充到这里</span></span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerAsyncWriter&lt;Order&gt;* writer, <span class="comment">// 异步写入器</span></span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::CompletionQueue* new_call_cq,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerCompletionQueue* notification_cq,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span>* tag</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Stub 类（完整版） ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">final</span> : <span class="keyword">public</span> StubInterface &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Stub</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;grpc::ChannelInterface&gt;&amp; channel)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ---------- 同步接口 ----------</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientReader&lt;Order&gt;&gt; <span class="built_in">ListOrders</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            <span class="type">const</span> OrderQuery&amp; request</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ---------- 异步接口 ----------</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncReader&lt;Order&gt;&gt; <span class="built_in">AsyncListOrders</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            <span class="type">const</span> OrderQuery&amp; request,</span><br><span class="line">            grpc::CompletionQueue* cq,</span><br><span class="line">            <span class="type">void</span>* tag</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// PrepareAsync 版本（延迟启动，需手动调用 StartCall）</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncReader&lt;Order&gt;&gt; <span class="built_in">PrepareAsyncListOrders</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            <span class="type">const</span> OrderQuery&amp; request,</span><br><span class="line">            grpc::CompletionQueue* cq</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::shared_ptr&lt;grpc::ChannelInterface&gt; channel_;</span><br><span class="line">        <span class="type">const</span> grpc::internal::RpcMethod rpcmethod_ListOrders_;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;Stub&gt; <span class="title">NewStub</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;grpc::Channel&gt;&amp; channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> grpc::StubOptions&amp; options = grpc::StubOptions()</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace shop</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== order.grpc.pb.cc（实现伪代码） ====================</span></span><br><span class="line"><span class="keyword">namespace</span> shop &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stub 实现</span></span><br><span class="line">std::unique_ptr&lt;grpc::ClientReader&lt;Order&gt;&gt; OrderService::Stub::<span class="built_in">ListOrders</span>(</span><br><span class="line">    grpc::ClientContext* context,</span><br><span class="line">    <span class="type">const</span> OrderQuery&amp; request) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建调用</span></span><br><span class="line">    <span class="keyword">auto</span> call = channel_-&gt;<span class="built_in">CreateCall</span>(<span class="string">&quot;/shop.OrderService/ListOrders&quot;</span>, context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 发送请求（只发一次）</span></span><br><span class="line">    grpc::ByteBuffer request_buf;</span><br><span class="line">    SerializationTraits&lt;OrderQuery&gt;::<span class="built_in">Serialize</span>(request, &amp;request_buf);</span><br><span class="line">    call.<span class="built_in">Write</span>(request_buf);</span><br><span class="line">    call.<span class="built_in">WritesDone</span>();  <span class="comment">// 客户端发送完成</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 返回 Reader，让调用者循环读取</span></span><br><span class="line">    <span class="keyword">return</span> std::make_unique&lt;grpc::ClientReader&lt;Order&gt;&gt;(std::<span class="built_in">move</span>(call), context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service 默认实现</span></span><br><span class="line">grpc::Status OrderService::Service::<span class="built_in">ListOrders</span>(</span><br><span class="line">    grpc::ServerContext* context,</span><br><span class="line">    <span class="type">const</span> OrderQuery* request,</span><br><span class="line">    grpc::ServerWriter&lt;Order&gt;* writer) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::UNIMPLEMENTED, <span class="string">&quot;Method not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace shop</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）使用示例-1"><a href="#（4）使用示例-1" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><p><strong>服务端实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== server.cpp ====================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;order.grpc.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> shop::OrderService::Service &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">grpc::Status <span class="title">ListOrders</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> shop::OrderQuery* request,</span></span></span><br><span class="line"><span class="params"><span class="function">        grpc::ServerWriter&lt;shop::Order&gt;* writer)</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;查询用户订单: &quot;</span> &lt;&lt; request-&gt;<span class="built_in">user_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模拟从数据库查询订单</span></span><br><span class="line">        std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; orders = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;iPhone 15&quot;</span>, <span class="number">7999.0</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;MacBook Pro&quot;</span>, <span class="number">14999.0</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;AirPods Pro&quot;</span>, <span class="number">1899.0</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; orders.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 检查客户端是否取消</span></span><br><span class="line">            <span class="keyword">if</span> (context-&gt;<span class="built_in">IsCancelled</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::CANCELLED, <span class="string">&quot;客户端取消请求&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构造响应</span></span><br><span class="line">            shop::Order order;</span><br><span class="line">            order.<span class="built_in">set_order_id</span>(<span class="string">&quot;ORD-&quot;</span> + std::<span class="built_in">to_string</span>(i + <span class="number">1</span>));</span><br><span class="line">            order.<span class="built_in">set_product_name</span>(orders[i].first);</span><br><span class="line">            order.<span class="built_in">set_price</span>(orders[i].second);</span><br><span class="line">            order.<span class="built_in">set_status</span>(<span class="string">&quot;completed&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 写入流</span></span><br><span class="line">            <span class="keyword">if</span> (!writer-&gt;<span class="built_in">Write</span>(order)) &#123;</span><br><span class="line">                <span class="comment">// 写入失败（可能客户端断开）</span></span><br><span class="line">                <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::UNKNOWN, <span class="string">&quot;写入失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟延迟</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;</span><br><span class="line">    OrderServiceImpl service;</span><br><span class="line">    </span><br><span class="line">    grpc::ServerBuilder builder;</span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>());</span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> server = builder.<span class="built_in">BuildAndStart</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;服务器启动: &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;</span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== client.cpp ====================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;order.grpc.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;localhost:50051&quot;</span>, </span><br><span class="line">                                       grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="keyword">auto</span> stub = shop::OrderService::<span class="built_in">NewStub</span>(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备请求</span></span><br><span class="line">    shop::OrderQuery query;</span><br><span class="line">    query.<span class="built_in">set_user_id</span>(<span class="string">&quot;user-123&quot;</span>);</span><br><span class="line">    query.<span class="built_in">set_status</span>(<span class="string">&quot;all&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 Context</span></span><br><span class="line">    grpc::ClientContext context;</span><br><span class="line">    context.<span class="built_in">set_deadline</span>(</span><br><span class="line">        std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">30</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 RPC，获取 Reader</span></span><br><span class="line">    <span class="keyword">auto</span> reader = stub-&gt;<span class="built_in">ListOrders</span>(&amp;context, query);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环读取响应</span></span><br><span class="line">    shop::Order order;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>(&amp;order)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;订单 &quot;</span> &lt;&lt; ++count &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  ID: &quot;</span> &lt;&lt; order.<span class="built_in">order_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  商品: &quot;</span> &lt;&lt; order.<span class="built_in">product_name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  价格: ¥&quot;</span> &lt;&lt; order.<span class="built_in">price</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最终状态</span></span><br><span class="line">    grpc::Status status = reader-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✓ 共收到 &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; 个订单&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✗ 错误: &quot;</span> &lt;&lt; status.<span class="built_in">error_message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）数据流图-1"><a href="#（5）数据流图-1" class="headerlink" title="（5）数据流图"></a>（5）数据流图</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    Server Streaming 调用流程                             │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   客户端                                              服务端             │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   <span class="keyword">auto</span> reader = stub-&gt;<span class="built_in">ListOrders</span>(&amp;ctx, query);                         │</span><br><span class="line">│         │                                                               │</span><br><span class="line">│         │  ┌──────────────────┐                                        │</span><br><span class="line">│         └─→│  POST /shop.OrderService/ListOrders                       │</span><br><span class="line">│            │  Body: [OrderQuery]                                       │</span><br><span class="line">│            └────────────────────────────────────────→ 收到请求          │</span><br><span class="line">│                                                      │                  │</span><br><span class="line">│                                                      ▼                  │</span><br><span class="line">│                                             <span class="keyword">for</span> each order:            │</span><br><span class="line">│                                               writer-&gt;<span class="built_in">Write</span>(order)     │</span><br><span class="line">│            ┌────────────────────────────────────────←┐                  │</span><br><span class="line">│            │  DATA frame: [Order <span class="number">1</span>]                  │                  │</span><br><span class="line">│   reader-&gt;<span class="built_in">Read</span>(&amp;order) ←─┘                           │                  │</span><br><span class="line">│   处理 Order <span class="number">1</span>                                       │                  │</span><br><span class="line">│                                                      │                  │</span><br><span class="line">│            ┌────────────────────────────────────────←┤                  │</span><br><span class="line">│            │  DATA frame: [Order <span class="number">2</span>]                  │                  │</span><br><span class="line">│   reader-&gt;<span class="built_in">Read</span>(&amp;order) ←─┘                           │                  │</span><br><span class="line">│   处理 Order <span class="number">2</span>                                       │                  │</span><br><span class="line">│                                                      │                  │</span><br><span class="line">│            ┌────────────────────────────────────────←┤                  │</span><br><span class="line">│            │  DATA frame: [Order <span class="number">3</span>]                  │                  │</span><br><span class="line">│   reader-&gt;<span class="built_in">Read</span>(&amp;order) ←─┘                           │                  │</span><br><span class="line">│   处理 Order <span class="number">3</span>                                       │                  │</span><br><span class="line">│                                                      │                  │</span><br><span class="line">│                                             <span class="keyword">return</span> Status::OK          │</span><br><span class="line">│            ┌────────────────────────────────────────←┘                  │</span><br><span class="line">│            │  HEADERS: grpc-status=<span class="number">0</span> (Trailers)                        │</span><br><span class="line">│   reader-&gt;<span class="built_in">Read</span>() 返回 <span class="literal">false</span> ←─┘                                        │</span><br><span class="line">│   status = reader-&gt;<span class="built_in">Finish</span>()                                            │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（6）Server-Streaming-模式总结"><a href="#（6）Server-Streaming-模式总结" class="headerlink" title="（6）Server Streaming 模式总结"></a>（6）Server Streaming 模式总结</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122153119547.png"></p>
<h2 id="6-Client-Streaming（客户端流）"><a href="#6-Client-Streaming（客户端流）" class="headerlink" title="6.Client Streaming（客户端流）"></a>6.Client Streaming（客户端流）</h2><h3 id="（1）功能设计-2"><a href="#（1）功能设计-2" class="headerlink" title="（1）功能设计"></a>（1）功能设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">场景：上传文件（分块传输）</span><br><span class="line"></span><br><span class="line">┌─────────────┐       FileChunk <span class="number">1</span>             ┌─────────────┐</span><br><span class="line">│   客户端     │ ──────────────────────────→   │   服务端     │</span><br><span class="line">│             │       FileChunk <span class="number">2</span>             │             │</span><br><span class="line">│             │ ──────────────────────────→   │             │</span><br><span class="line">│             │       FileChunk <span class="number">3</span>             │             │</span><br><span class="line">│             │ ──────────────────────────→   │             │</span><br><span class="line">│             │       ...                     │             │</span><br><span class="line">│             │                               │             │</span><br><span class="line">│             │ ←──────────────────────────   │             │</span><br><span class="line">└─────────────┘      UploadResult             └─────────────┘</span><br><span class="line"></span><br><span class="line">特点：多个请求，一个响应（批量提交）</span><br></pre></td></tr></table></figure>

<h3 id="（2）Proto-定义"><a href="#（2）Proto-定义" class="headerlink" title="（2）Proto 定义"></a>（2）Proto 定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package storage;</span><br><span class="line"></span><br><span class="line">message FileChunk &#123;</span><br><span class="line">    string filename = <span class="number">1</span>;</span><br><span class="line">    bytes data = <span class="number">2</span>;</span><br><span class="line">    int32 chunk_index = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> is_last = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UploadResult &#123;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">1</span>;</span><br><span class="line">    string file_id = <span class="number">2</span>;</span><br><span class="line">    int64 total_bytes = <span class="number">3</span>;</span><br><span class="line">    string message = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service FileService &#123;</span><br><span class="line">    <span class="comment">// Client Streaming：请求加 stream</span></span><br><span class="line">    <span class="function">rpc <span class="title">UploadFile</span><span class="params">(stream FileChunk)</span> <span class="title">returns</span> <span class="params">(UploadResult)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）生成的-C-关键伪代码-2"><a href="#（3）生成的-C-关键伪代码-2" class="headerlink" title="（3）生成的 C++ 关键伪代码"></a>（3）生成的 C++ 关键伪代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== file.grpc.pb.h ====================</span></span><br><span class="line"><span class="keyword">namespace</span> storage &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileService</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">char</span> <span class="type">const</span>* <span class="title">service_full_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;storage.FileService&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 同步 Service 基类 ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Service</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Service</span>();</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Service</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> grpc::Status <span class="title">UploadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerReader&lt;FileChunk&gt;* reader,</span></span></span><br><span class="line"><span class="params"><span class="function">            UploadResult* response</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 异步 Service 基类 ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncService</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AsyncService</span>();</span><br><span class="line">        ~<span class="built_in">AsyncService</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 请求处理一个 UploadFile 调用</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">RequestUploadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerAsyncReader&lt;UploadResult, FileChunk&gt;* reader,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//                      ↑ 响应类型      ↑ 请求类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::CompletionQueue* new_call_cq,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerCompletionQueue* notification_cq,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span>* tag</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Stub 类（完整版） ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">final</span> : <span class="keyword">public</span> StubInterface &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Stub</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;grpc::ChannelInterface&gt;&amp; channel)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ---------- 同步接口 ----------</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientWriter&lt;FileChunk&gt;&gt; <span class="built_in">UploadFile</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            UploadResult* response</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ---------- 异步接口 ----------</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncWriter&lt;FileChunk&gt;&gt; <span class="built_in">AsyncUploadFile</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            UploadResult* response,</span><br><span class="line">            grpc::CompletionQueue* cq,</span><br><span class="line">            <span class="type">void</span>* tag</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// PrepareAsync 版本（延迟启动，需手动调用 StartCall）</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncWriter&lt;FileChunk&gt;&gt; <span class="built_in">PrepareAsyncUploadFile</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            UploadResult* response,</span><br><span class="line">            grpc::CompletionQueue* cq</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::shared_ptr&lt;grpc::ChannelInterface&gt; channel_;</span><br><span class="line">        <span class="type">const</span> grpc::internal::RpcMethod rpcmethod_UploadFile_;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;Stub&gt; <span class="title">NewStub</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;grpc::Channel&gt;&amp; channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> grpc::StubOptions&amp; options = grpc::StubOptions()</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace storage</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== file.grpc.pb.cc（实现伪代码） ====================</span></span><br><span class="line"><span class="keyword">namespace</span> storage &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stub 实现</span></span><br><span class="line">std::unique_ptr&lt;grpc::ClientWriter&lt;FileChunk&gt;&gt; FileService::Stub::<span class="built_in">UploadFile</span>(</span><br><span class="line">    grpc::ClientContext* context,</span><br><span class="line">    UploadResult* response) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建调用</span></span><br><span class="line">    <span class="keyword">auto</span> call = channel_-&gt;<span class="built_in">CreateCall</span>(<span class="string">&quot;/storage.FileService/UploadFile&quot;</span>, context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 返回 Writer，让调用者循环写入</span></span><br><span class="line">    <span class="comment">// 响应指针保存，在 Finish() 时填充</span></span><br><span class="line">    <span class="keyword">return</span> std::make_unique&lt;grpc::ClientWriter&lt;FileChunk&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">move</span>(call), context, response</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service 默认实现</span></span><br><span class="line">grpc::Status FileService::Service::<span class="built_in">UploadFile</span>(</span><br><span class="line">    grpc::ServerContext* context,</span><br><span class="line">    grpc::ServerReader&lt;FileChunk&gt;* reader,</span><br><span class="line">    UploadResult* response) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::UNIMPLEMENTED, <span class="string">&quot;Method not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace storage</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）使用示例-2"><a href="#（4）使用示例-2" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><p><strong>服务端实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== server.cpp ====================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file.grpc.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileServiceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> storage::FileService::Service &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">grpc::Status <span class="title">UploadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">        grpc::ServerReader&lt;storage::FileChunk&gt;* reader,</span></span></span><br><span class="line"><span class="params"><span class="function">        storage::UploadResult* response)</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        storage::FileChunk chunk;</span><br><span class="line">        std::string filename;</span><br><span class="line">        std::ofstream file;</span><br><span class="line">        <span class="type">int64_t</span> total_bytes = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环读取客户端发来的数据块</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>(&amp;chunk)) &#123;</span><br><span class="line">            <span class="comment">// 检查取消</span></span><br><span class="line">            <span class="keyword">if</span> (context-&gt;<span class="built_in">IsCancelled</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::CANCELLED, <span class="string">&quot;上传被取消&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第一个块时创建文件</span></span><br><span class="line">            <span class="keyword">if</span> (filename.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                filename = <span class="string">&quot;/tmp/&quot;</span> + chunk.<span class="built_in">filename</span>();</span><br><span class="line">                file.<span class="built_in">open</span>(filename, std::ios::binary);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;开始接收文件: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 写入数据</span></span><br><span class="line">            file.<span class="built_in">write</span>(chunk.<span class="built_in">data</span>().<span class="built_in">data</span>(), chunk.<span class="built_in">data</span>().<span class="built_in">size</span>());</span><br><span class="line">            total_bytes += chunk.<span class="built_in">data</span>().<span class="built_in">size</span>();</span><br><span class="line">            </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  收到块 &quot;</span> &lt;&lt; chunk.<span class="built_in">chunk_index</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; chunk.<span class="built_in">data</span>().<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; 字节&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 填充响应</span></span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(<span class="literal">true</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_file_id</span>(<span class="string">&quot;FILE-&quot;</span> + std::<span class="built_in">to_string</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>)));</span><br><span class="line">        response-&gt;<span class="built_in">set_total_bytes</span>(total_bytes);</span><br><span class="line">        response-&gt;<span class="built_in">set_message</span>(<span class="string">&quot;上传完成: &quot;</span> + filename);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;</span><br><span class="line">    FileServiceImpl service;</span><br><span class="line">    </span><br><span class="line">    grpc::ServerBuilder builder;</span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>());</span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service);</span><br><span class="line">    builder.<span class="built_in">SetMaxReceiveMessageSize</span>(<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>);  <span class="comment">// 100MB</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> server = builder.<span class="built_in">BuildAndStart</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;服务器启动: &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;</span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== client.cpp ====================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file.grpc.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;localhost:50051&quot;</span>, </span><br><span class="line">                                       grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="keyword">auto</span> stub = storage::FileService::<span class="built_in">NewStub</span>(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 Context</span></span><br><span class="line">    grpc::ClientContext context;</span><br><span class="line">    context.<span class="built_in">set_deadline</span>(</span><br><span class="line">        std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">minutes</span>(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备响应对象（Finish 后填充）</span></span><br><span class="line">    storage::UploadResult result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 Writer</span></span><br><span class="line">    <span class="keyword">auto</span> writer = stub-&gt;<span class="built_in">UploadFile</span>(&amp;context, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取本地文件并分块上传</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> CHUNK_SIZE = <span class="number">64</span> * <span class="number">1024</span>;  <span class="comment">// 64KB 每块</span></span><br><span class="line">    <span class="type">char</span> buffer[CHUNK_SIZE];</span><br><span class="line">    <span class="type">int</span> chunk_index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (file.<span class="built_in">read</span>(buffer, CHUNK_SIZE) || file.<span class="built_in">gcount</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        storage::FileChunk chunk;</span><br><span class="line">        chunk.<span class="built_in">set_filename</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        chunk.<span class="built_in">set_data</span>(buffer, file.<span class="built_in">gcount</span>());</span><br><span class="line">        chunk.<span class="built_in">set_chunk_index</span>(chunk_index++);</span><br><span class="line">        chunk.<span class="built_in">set_is_last</span>(file.<span class="built_in">eof</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!writer-&gt;<span class="built_in">Write</span>(chunk)) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;写入失败！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发送块 &quot;</span> &lt;&lt; chunk_index &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️ 必须调用！告诉服务端发送完毕</span></span><br><span class="line">    writer-&gt;<span class="built_in">WritesDone</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待响应并获取状态</span></span><br><span class="line">    grpc::Status status = writer-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✓ 上传成功！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  文件ID: &quot;</span> &lt;&lt; result.<span class="built_in">file_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  总大小: &quot;</span> &lt;&lt; result.<span class="built_in">total_bytes</span>() &lt;&lt; <span class="string">&quot; 字节&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✗ 上传失败: &quot;</span> &lt;&lt; status.<span class="built_in">error_message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）数据流图-2"><a href="#（5）数据流图-2" class="headerlink" title="（5）数据流图"></a>（5）数据流图</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    Client Streaming 调用流程                             │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   客户端                                              服务端             │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   <span class="keyword">auto</span> writer = stub-&gt;<span class="built_in">UploadFile</span>(&amp;ctx, &amp;result);                       │</span><br><span class="line">│         │                                                               │</span><br><span class="line">│         │  ┌──────────────────┐                                        │</span><br><span class="line">│         └─→│  POST /storage.FileService/UploadFile                     │</span><br><span class="line">│            └────────────────────────────────────────→ 开始接收          │</span><br><span class="line">│                                                      │                  │</span><br><span class="line">│   writer-&gt;<span class="built_in">Write</span>(chunk1);                             │                  │</span><br><span class="line">│         │  ┌──────────────────┐                      │                  │</span><br><span class="line">│         └─→│  DATA: [FileChunk <span class="number">1</span>]                    │                  │</span><br><span class="line">│            └───────────────────────────────────────→ reader-&gt;<span class="built_in">Read</span>()    │</span><br><span class="line">│                                                      保存数据            │</span><br><span class="line">│   writer-&gt;<span class="built_in">Write</span>(chunk2);                             │                  │</span><br><span class="line">│         │  ┌──────────────────┐                      │                  │</span><br><span class="line">│         └─→│  DATA: [FileChunk <span class="number">2</span>]                    │                  │</span><br><span class="line">│            └───────────────────────────────────────→ reader-&gt;<span class="built_in">Read</span>()    │</span><br><span class="line">│                                                      保存数据            │</span><br><span class="line">│   writer-&gt;<span class="built_in">Write</span>(chunk3);                             │                  │</span><br><span class="line">│         │  ┌──────────────────┐                      │                  │</span><br><span class="line">│         └─→│  DATA: [FileChunk <span class="number">3</span>]                    │                  │</span><br><span class="line">│            └───────────────────────────────────────→ reader-&gt;<span class="built_in">Read</span>()    │</span><br><span class="line">│                                                      保存数据            │</span><br><span class="line">│   writer-&gt;<span class="built_in">WritesDone</span>();                              │                  │</span><br><span class="line">│         │  ┌──────────────────┐                      │                  │</span><br><span class="line">│         └─→│  END_STREAM flag                        │                  │</span><br><span class="line">│            └───────────────────────────────────────→ <span class="built_in">Read</span>() 返回 <span class="literal">false</span> │</span><br><span class="line">│                                                      填充 response      │</span><br><span class="line">│                                                      <span class="keyword">return</span> Status::OK │</span><br><span class="line">│            ┌────────────────────────────────────────←┘                  │</span><br><span class="line">│            │  DATA: [UploadResult]                                     │</span><br><span class="line">│            │  HEADERS: grpc-status=<span class="number">0</span>                                   │</span><br><span class="line">│   writer-&gt;<span class="built_in">Finish</span>() ←─┘                                                 │</span><br><span class="line">│   result 已填充                                                         │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（6）Client-Streaming-模式总结"><a href="#（6）Client-Streaming-模式总结" class="headerlink" title="（6）Client Streaming 模式总结"></a>（6）Client Streaming 模式总结</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122153548149.png"></p>
<h2 id="7-Bidirectional-Streaming（双向流）"><a href="#7-Bidirectional-Streaming（双向流）" class="headerlink" title="7.Bidirectional Streaming（双向流）"></a>7.Bidirectional Streaming（双向流）</h2><h3 id="（1）功能设计-3"><a href="#（1）功能设计-3" class="headerlink" title="（1）功能设计"></a>（1）功能设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">场景：实时聊天室</span><br><span class="line"></span><br><span class="line">┌─────────────┐       ChatMessage             ┌─────────────┐</span><br><span class="line">│   客户端     │ ←──────────────────────────→  │   服务端     │</span><br><span class="line">│             │       ChatMessage             │             │</span><br><span class="line">│             │ ←──────────────────────────→  │             │</span><br><span class="line">│             │       ChatMessage             │             │</span><br><span class="line">│             │ ←──────────────────────────→  │             │</span><br><span class="line">│             │       ...                     │             │</span><br><span class="line">└─────────────┘   （双向独立，可同时读写）      └─────────────┘</span><br><span class="line"></span><br><span class="line">特点：多个请求，多个响应，全双工通信</span><br></pre></td></tr></table></figure>

<h3 id="（2）Proto-定义-1"><a href="#（2）Proto-定义-1" class="headerlink" title="（2）Proto 定义"></a>（2）Proto 定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chat.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package im;</span><br><span class="line"></span><br><span class="line">message ChatMessage &#123;</span><br><span class="line">    string sender = <span class="number">1</span>;</span><br><span class="line">    string content = <span class="number">2</span>;</span><br><span class="line">    int64 timestamp = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service ChatService &#123;</span><br><span class="line">    <span class="comment">// Bidirectional Streaming：请求和响应都加 stream</span></span><br><span class="line">    <span class="function">rpc <span class="title">Chat</span><span class="params">(stream ChatMessage)</span> <span class="title">returns</span> <span class="params">(stream ChatMessage)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）生成的-C-关键伪代码-3"><a href="#（3）生成的-C-关键伪代码-3" class="headerlink" title="（3）生成的 C++ 关键伪代码"></a>（3）生成的 C++ 关键伪代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== chat.grpc.pb.h ====================</span></span><br><span class="line"><span class="keyword">namespace</span> im &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatService</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Service 基类（服务端继承） ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Service</span> : <span class="keyword">public</span> grpc::Service &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 服务端用 ServerReaderWriter 同时读写</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> grpc::Status <span class="title">Chat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">            grpc::ServerReaderWriter&lt;ChatMessage, ChatMessage&gt;* stream</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//                       ↑ 写出类型    ↑ 读入类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== Stub 类（客户端使用） ==========</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">final</span> : <span class="keyword">public</span> StubInterface &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Stub</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;grpc::ChannelInterface&gt;&amp; channel)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回 ClientReaderWriter，可同时读写</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientReaderWriter&lt;ChatMessage, ChatMessage&gt;&gt; <span class="built_in">Chat</span>(</span><br><span class="line">            grpc::ClientContext* context</span><br><span class="line">            <span class="comment">//                    ↑ 写出类型       ↑ 读入类型</span></span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 异步版本</span></span><br><span class="line">        std::unique_ptr&lt;grpc::ClientAsyncReaderWriter&lt;ChatMessage, ChatMessage&gt;&gt; </span><br><span class="line">        <span class="built_in">AsyncChat</span>(</span><br><span class="line">            grpc::ClientContext* context,</span><br><span class="line">            grpc::CompletionQueue* cq,</span><br><span class="line">            <span class="type">void</span>* tag</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::shared_ptr&lt;grpc::ChannelInterface&gt; channel_;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;Stub&gt; <span class="title">NewStub</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;grpc::Channel&gt;&amp; channel</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace im</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== chat.grpc.pb.cc（实现伪代码） ====================</span></span><br><span class="line"><span class="keyword">namespace</span> im &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stub 实现</span></span><br><span class="line">std::unique_ptr&lt;grpc::ClientReaderWriter&lt;ChatMessage, ChatMessage&gt;&gt; </span><br><span class="line">ChatService::Stub::<span class="built_in">Chat</span>(grpc::ClientContext* context) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建调用并返回双向流对象</span></span><br><span class="line">    <span class="keyword">auto</span> call = channel_-&gt;<span class="built_in">CreateCall</span>(<span class="string">&quot;/im.ChatService/Chat&quot;</span>, context);</span><br><span class="line">    <span class="keyword">return</span> std::make_unique&lt;grpc::ClientReaderWriter&lt;ChatMessage, ChatMessage&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">move</span>(call), context</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service 默认实现</span></span><br><span class="line">grpc::Status ChatService::Service::<span class="built_in">Chat</span>(</span><br><span class="line">    grpc::ServerContext* context,</span><br><span class="line">    grpc::ServerReaderWriter&lt;ChatMessage, ChatMessage&gt;* stream) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> grpc::<span class="built_in">Status</span>(grpc::UNIMPLEMENTED, <span class="string">&quot;Method not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace im</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）使用示例-3"><a href="#（4）使用示例-3" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><p><strong>服务端实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== server.cpp ====================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chat.grpc.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatServiceImpl</span> <span class="keyword">final</span> : <span class="keyword">public</span> im::ChatService::Service &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储所有活跃的流（简化版，实际需要更复杂的管理）</span></span><br><span class="line">    std::mutex streams_mutex_;</span><br><span class="line">    std::vector&lt;grpc::ServerReaderWriter&lt;im::ChatMessage, im::ChatMessage&gt;*&gt; streams_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">grpc::Status <span class="title">Chat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        grpc::ServerContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">        grpc::ServerReaderWriter&lt;im::ChatMessage, im::ChatMessage&gt;* stream)</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注册这个流</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(streams_mutex_)</span></span>;</span><br><span class="line">            streams_.<span class="built_in">push_back</span>(stream);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;新用户连接: &quot;</span> &lt;&lt; context-&gt;<span class="built_in">peer</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        im::ChatMessage msg;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环读取客户端消息</span></span><br><span class="line">        <span class="keyword">while</span> (stream-&gt;<span class="built_in">Read</span>(&amp;msg)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context-&gt;<span class="built_in">IsCancelled</span>()) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; msg.<span class="built_in">sender</span>() &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; msg.<span class="built_in">content</span>() &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 广播给所有客户端（包括发送者）</span></span><br><span class="line">            im::ChatMessage broadcast;</span><br><span class="line">            broadcast.<span class="built_in">set_sender</span>(msg.<span class="built_in">sender</span>());</span><br><span class="line">            broadcast.<span class="built_in">set_content</span>(msg.<span class="built_in">content</span>());</span><br><span class="line">            broadcast.<span class="built_in">set_timestamp</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(streams_mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>* s : streams_) &#123;</span><br><span class="line">                s-&gt;<span class="built_in">Write</span>(broadcast);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移除这个流</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(streams_mutex_)</span></span>;</span><br><span class="line">            streams_.<span class="built_in">erase</span>(</span><br><span class="line">                std::<span class="built_in">remove</span>(streams_.<span class="built_in">begin</span>(), streams_.<span class="built_in">end</span>(), stream),</span><br><span class="line">                streams_.<span class="built_in">end</span>()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;用户断开: &quot;</span> &lt;&lt; context-&gt;<span class="built_in">peer</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> grpc::Status::OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;</span><br><span class="line">    ChatServiceImpl service;</span><br><span class="line">    </span><br><span class="line">    grpc::ServerBuilder builder;</span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>());</span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> server = builder.<span class="built_in">BuildAndStart</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;聊天服务器启动: &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;</span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== client.cpp ====================</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chat.grpc.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;localhost:50051&quot;</span>, </span><br><span class="line">                                       grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="keyword">auto</span> stub = im::ChatService::<span class="built_in">NewStub</span>(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 Context</span></span><br><span class="line">    grpc::ClientContext context;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取双向流</span></span><br><span class="line">    <span class="keyword">auto</span> stream = stub-&gt;<span class="built_in">Chat</span>(&amp;context);</span><br><span class="line">    </span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; running&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ===== 读取线程：接收服务端消息 =====</span></span><br><span class="line">    <span class="function">std::thread <span class="title">reader_thread</span><span class="params">([&amp;stream, &amp;running]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        im::ChatMessage msg;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (stream-&gt;Read(&amp;msg)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;\r[&quot;</span> &lt;&lt; msg.sender() &lt;&lt; <span class="string">&quot;]: &quot;</span> </span></span></span><br><span class="line"><span class="params"><span class="function">                      &lt;&lt; msg.content() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;&gt; &quot;</span> &lt;&lt; std::flush;  <span class="comment">// 重新显示输入提示</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        running = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;连接已断开&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ===== 主线程：发送用户输入 =====</span></span><br><span class="line">    std::string username;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入用户名: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">getline</span>(std::cin, username);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始聊天（输入 &#x27;quit&#x27; 退出）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&gt; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (running &amp;&amp; std::<span class="built_in">getline</span>(std::cin, line)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line == <span class="string">&quot;quit&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;&gt; &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        im::ChatMessage msg;</span><br><span class="line">        msg.<span class="built_in">set_sender</span>(username);</span><br><span class="line">        msg.<span class="built_in">set_content</span>(line);</span><br><span class="line">        msg.<span class="built_in">set_timestamp</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!stream-&gt;<span class="built_in">Write</span>(msg)) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;发送失败！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&gt; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记写入完成</span></span><br><span class="line">    stream-&gt;<span class="built_in">WritesDone</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待读取线程结束</span></span><br><span class="line">    reader_thread.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最终状态</span></span><br><span class="line">    grpc::Status status = stream-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;正常退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; status.<span class="built_in">error_message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）数据流图-3"><a href="#（5）数据流图-3" class="headerlink" title="（5）数据流图"></a>（5）数据流图</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                  Bidirectional Streaming 调用流程                        │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   客户端                                              服务端             │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   <span class="keyword">auto</span> stream = stub-&gt;<span class="built_in">Chat</span>(&amp;ctx);                                      │</span><br><span class="line">│         │                                                               │</span><br><span class="line">│         │  ┌──────────────────┐                                        │</span><br><span class="line">│         └─→│  POST /im.ChatService/Chat                                │</span><br><span class="line">│            └────────────────────────────────────────→ 连接建立          │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│   │         双向独立通信（全双工）                                     │   │</span><br><span class="line">│   │                                                                  │   │</span><br><span class="line">│   │   stream-&gt;<span class="built_in">Write</span>(msg1);                                          │   │</span><br><span class="line">│   │         ─────────── [ChatMessage] ───────────→ stream-&gt;<span class="built_in">Read</span>()   │   │</span><br><span class="line">│   │                                                                  │   │</span><br><span class="line">│   │                                                 stream-&gt;<span class="built_in">Write</span>()  │   │</span><br><span class="line">│   │   stream-&gt;<span class="built_in">Read</span>() ←─────────── [ChatMessage] ───────────          │   │</span><br><span class="line">│   │                                                                  │   │</span><br><span class="line">│   │   stream-&gt;<span class="built_in">Write</span>(msg2);                                          │   │</span><br><span class="line">│   │         ─────────── [ChatMessage] ───────────→ stream-&gt;<span class="built_in">Read</span>()   │   │</span><br><span class="line">│   │                                                                  │   │</span><br><span class="line">│   │                                                 stream-&gt;<span class="built_in">Write</span>()  │   │</span><br><span class="line">│   │   stream-&gt;<span class="built_in">Read</span>() ←─────────── [ChatMessage] ───────────          │   │</span><br><span class="line">│   │                                                                  │   │</span><br><span class="line">│   │   （读和写可以同时进行，互不阻塞）                                  │   │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   stream-&gt;<span class="built_in">WritesDone</span>();                                                 │</span><br><span class="line">│         ─────────── END_STREAM ───────────→ <span class="built_in">Read</span>() 返回 <span class="literal">false</span>          │</span><br><span class="line">│                                            <span class="keyword">return</span> Status::OK           │</span><br><span class="line">│         ←─────────── grpc-status=<span class="number">0</span> ───────────                         │</span><br><span class="line">│   stream-&gt;<span class="built_in">Finish</span>();                                                    │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（6）Bidirectional-Streaming-模式总结"><a href="#（6）Bidirectional-Streaming-模式总结" class="headerlink" title="（6）Bidirectional Streaming 模式总结"></a>（6）Bidirectional Streaming 模式总结</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260122153842158.png"></p>
<h2 id="8-gRPC的异步调用"><a href="#8-gRPC的异步调用" class="headerlink" title="8.gRPC的异步调用"></a>8.gRPC的异步调用</h2><h3 id="（0）概述"><a href="#（0）概述" class="headerlink" title="（0）概述"></a>（0）概述</h3><p>gRPC C++的异步调用主要涉及：</p>
<ul>
<li><p>CompletionQueue - 核心事件队列</p>
</li>
<li><p>ClientAsyncResponseReader - 异步Unary客户端</p>
</li>
<li><p>ClientAsyncReader - 异步Server Streaming客户端</p>
</li>
<li><p>ClientAsyncWriter - 异步Client Streaming客户端</p>
</li>
<li><p>ClientAsyncReaderWriter - 异步双向流客户端</p>
</li>
<li><p>ServerAsyncResponseWriter - 异步Unary服务端</p>
</li>
<li><p>ServerAsyncReader - 异步Client Streaming服务端</p>
</li>
<li><p>ServerAsyncWriter - 异步Server Streaming服务端</p>
</li>
<li><p>ServerAsyncReaderWriter - 异步双向流服务端</p>
</li>
<li><p>Alarm - 定时</p>
</li>
</ul>
<p><strong>异步 vs 同步</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        同步 vs 异步                                      │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   同步调用（阻塞）                                                        │</span><br><span class="line">│   ┌─────────┐                                                           │</span><br><span class="line">│   │ Thread  │──<span class="built_in">Call</span>()──→ [等待...等待...等待...] ──→ 返回结果           │</span><br><span class="line">│   └─────────┘            （线程被阻塞）                                   │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   异步调用（非阻塞）                                                      │</span><br><span class="line">│   ┌─────────┐                                                           │</span><br><span class="line">│   │ Thread  │──<span class="built_in">AsyncCall</span>()──→ 立即返回，继续做其他事                     │</span><br><span class="line">│   └─────────┘                    │                                      │</span><br><span class="line">│        │                         ▼                                      │</span><br><span class="line">│        │              ┌──────────────────┐                              │</span><br><span class="line">│        └──轮询────────→│ CompletionQueue │←── 结果就绪时通知             │</span><br><span class="line">│                       └──────────────────┘                              │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p><strong>核心类总览</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                     gRPC 异步核心类                                      │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│   │                    CompletionQueue                               │   │</span><br><span class="line">│   │                   （核心事件队列）                                 │   │</span><br><span class="line">│   │                                                                  │   │</span><br><span class="line">│   │   所有异步操作完成后，都会向 CQ 投递事件                           │   │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                          ▲                                              │</span><br><span class="line">│          ┌───────────────┼───────────────┐                              │</span><br><span class="line">│          │               │               │                              │</span><br><span class="line">│   ┌──────┴──────┐ ┌──────┴──────┐ ┌──────┴──────┐                       │</span><br><span class="line">│   │   客户端     │ │   服务端     │ │   工具类    │                       │</span><br><span class="line">│   ├─────────────┤ ├─────────────┤ ├─────────────┤                       │</span><br><span class="line">│   │AsyncResp..  │ │AsyncResp..  │ │   Alarm     │                       │</span><br><span class="line">│   │AsyncReader  │ │AsyncReader  │ │  (定时器)   │                       │</span><br><span class="line">│   │AsyncWriter  │ │AsyncWriter  │ │             │                       │</span><br><span class="line">│   │AsyncRW      │ │AsyncRW      │ │             │                       │</span><br><span class="line">│   └─────────────┘ └─────────────┘ └─────────────┘                       │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（1）CompletionQueue-—-核心事件队列"><a href="#（1）CompletionQueue-—-核心事件队列" class="headerlink" title="（1）CompletionQueue — 核心事件队列"></a>（1）CompletionQueue — 核心事件队列</h3><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="&lt;1&gt;伪代码"></a>&lt;1&gt;伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompletionQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CompletionQueue</span>();</span><br><span class="line">    ~<span class="built_in">CompletionQueue</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 事件获取 ==========</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻塞等待，直到有事件或队列关闭</span></span><br><span class="line">    <span class="comment">// 返回值：GOT_EVENT / SHUTDOWN / TIMEOUT</span></span><br><span class="line">    <span class="function">NextStatus <span class="title">Next</span><span class="params">(<span class="type">void</span>** tag, <span class="type">bool</span>* ok)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带超时的等待</span></span><br><span class="line">    <span class="function">NextStatus <span class="title">AsyncNext</span><span class="params">(<span class="type">void</span>** tag, <span class="type">bool</span>* ok, </span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::chrono::system_clock::time_point&amp; deadline)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 关闭队列 ==========</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;  <span class="comment">// 关闭后，Next() 返回 SHUTDOWN</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 返回状态枚举 ==========</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">NextStatus</span> &#123;</span><br><span class="line">        GOT_EVENT,   <span class="comment">// 成功获取到事件</span></span><br><span class="line">        SHUTDOWN,    <span class="comment">// 队列已关闭</span></span><br><span class="line">        TIMEOUT      <span class="comment">// 超时（仅 AsyncNext）</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端专用（支持请求注册）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerCompletionQueue</span> : <span class="keyword">public</span> CompletionQueue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 服务端专用功能...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>
<h4 id="使用示例-13"><a href="#使用示例-13" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">grpc::CompletionQueue cq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="type">void</span>* tag;</span><br><span class="line"><span class="type">bool</span> ok;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞等待事件</span></span><br><span class="line">    grpc::CompletionQueue::NextStatus status = cq.<span class="built_in">Next</span>(&amp;tag, &amp;ok);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status == grpc::CompletionQueue::SHUTDOWN) &#123;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 队列关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status == grpc::CompletionQueue::GOT_EVENT) &#123;</span><br><span class="line">        <span class="comment">// tag: 用户自定义指针，用于识别是哪个操作完成</span></span><br><span class="line">        <span class="comment">// ok:  操作是否成功</span></span><br><span class="line">        <span class="comment">//      - true: 操作成功完成</span></span><br><span class="line">        <span class="comment">//      - false: 操作失败（如连接断开、取消等）</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">ProcessEvent</span>(tag, ok);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）Alarm-—-定时器"><a href="#（2）Alarm-—-定时器" class="headerlink" title="（2）Alarm — 定时器"></a>（2）Alarm — 定时器</h3><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="&lt;1&gt;伪代码"></a>&lt;1&gt;伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Alarm</span>();</span><br><span class="line">    ~<span class="built_in">Alarm</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置定时器：到期后 tag 被投递到 cq</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(CompletionQueue* cq, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> std::chrono::system_clock::time_point&amp; deadline,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消定时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h4 id="使用示例-14"><a href="#使用示例-14" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">grpc::Alarm alarm;</span><br><span class="line">grpc::CompletionQueue cq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5秒后触发</span></span><br><span class="line">alarm.<span class="built_in">Set</span>(&amp;cq, </span><br><span class="line">          std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>),</span><br><span class="line">          (<span class="type">void</span>*)<span class="string">&quot;timer_tag&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* tag;</span><br><span class="line"><span class="type">bool</span> ok;</span><br><span class="line">cq.<span class="built_in">Next</span>(&amp;tag, &amp;ok);  <span class="comment">// 5秒后返回</span></span><br><span class="line"><span class="comment">// tag == &quot;timer_tag&quot;</span></span><br><span class="line"><span class="comment">// ok == true (正常触发) 或 false (被取消)</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）客户端异步类"><a href="#（3）客户端异步类" class="headerlink" title="（3）客户端异步类"></a>（3）客户端异步类</h3><h4 id="ClientAsyncResponseReader-—-异步-Unary"><a href="#ClientAsyncResponseReader-—-异步-Unary" class="headerlink" title="&lt;1&gt;ClientAsyncResponseReader — 异步 Unary"></a>&lt;1&gt;ClientAsyncResponseReader — 异步 Unary</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&gt;  <span class="comment">// R = 响应类型 (LoginResponse)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientAsyncResponseReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 启动调用（PrepareAsync 版本需要手动调用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartCall</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取服务端发送的初始元数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadInitialMetadata</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完成调用，获取响应和状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">(R* msg, grpc::Status* status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h4 id="ClientAsyncReader-—-异步-Server-Streaming"><a href="#ClientAsyncReader-—-异步-Server-Streaming" class="headerlink" title="&lt;2&gt;ClientAsyncReader — 异步 Server Streaming"></a>&lt;2&gt;ClientAsyncReader — 异步 Server Streaming</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 客户端异步读取器 ====================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&gt;  <span class="comment">// R = 读取类型 (Order)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientAsyncReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 启动调用（PrepareAsync 版本需要手动调用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartCall</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取服务端发送的初始元数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadInitialMetadata</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步读取一条消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">(R* msg, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完成调用，获取最终状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">(grpc::Status* status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h4 id="ClientAsyncWriter-—-异步-Client-Streaming"><a href="#ClientAsyncWriter-—-异步-Client-Streaming" class="headerlink" title="&lt;3&gt;ClientAsyncWriter — 异步 Client Streaming"></a>&lt;3&gt;ClientAsyncWriter — 异步 Client Streaming</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;  <span class="comment">// W = 写入类型 (FileChunk)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientAsyncWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 启动调用（PrepareAsync 版本需要手动调用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartCall</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步写入一条消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带选项的写入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, grpc::WriteOptions options, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写完所有消息后调用（告诉服务器不再写了）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WritesDone</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完成调用，获取响应和状态</span></span><br><span class="line">    <span class="comment">// response 在创建 Writer 时已经传入，Finish 后会被填充</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">(grpc::Status* status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取服务端发送的初始元数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadInitialMetadata</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h4 id="ClientAsyncReaderWriter-—-异步双向流"><a href="#ClientAsyncReaderWriter-—-异步双向流" class="headerlink" title="&lt;4&gt;ClientAsyncReaderWriter — 异步双向流"></a>&lt;4&gt;ClientAsyncReaderWriter — 异步双向流</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>, <span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientAsyncReaderWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 异步读取一条消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">(R* msg, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步写入一条消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带 WriteOptions 的写入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, grpc::WriteOptions options, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写完所有消息后调用（半关闭）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WritesDone</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完成调用，获取最终状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">(grpc::Status* status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读写同时进行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadInitialMetadata</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）服务端异步类"><a href="#（4）服务端异步类" class="headerlink" title="（4）服务端异步类"></a>（4）服务端异步类</h3><h4 id="ServerAsyncResponseWriter-—-异步-Unary"><a href="#ServerAsyncResponseWriter-—-异步-Unary" class="headerlink" title="&lt;1&gt;ServerAsyncResponseWriter — 异步 Unary"></a>&lt;1&gt;ServerAsyncResponseWriter — 异步 Unary</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 服务端异步响应写入器 ====================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;  <span class="comment">// W = 响应类型 (LoginResponse)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerAsyncResponseWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 发送初始元数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendInitialMetadata</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送响应并结束调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">(<span class="type">const</span> W&amp; msg, <span class="type">const</span> grpc::Status&amp; status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束调用但不发送响应（出错时使用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FinishWithError</span><span class="params">(<span class="type">const</span> grpc::Status&amp; status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h4 id="ServerAsyncReader-—-异步-Client-Streaming"><a href="#ServerAsyncReader-—-异步-Client-Streaming" class="headerlink" title="&lt;2&gt;ServerAsyncReader — 异步 Client Streaming"></a>&lt;2&gt;ServerAsyncReader — 异步 Client Streaming</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 服务端异步读取器 ====================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>, <span class="keyword">class</span> <span class="title class_">R</span>&gt;  <span class="comment">// W = 响应类型, R = 请求类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerAsyncReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 发送初始元数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendInitialMetadata</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步读取一条消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">(R* msg, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束调用并发送响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">(<span class="type">const</span> W&amp; msg, <span class="type">const</span> grpc::Status&amp; status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束调用但不发送响应（出错时使用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FinishWithError</span><span class="params">(<span class="type">const</span> grpc::Status&amp; status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h4 id="ServerAsyncWriter-—-异步-Server-Streaming"><a href="#ServerAsyncWriter-—-异步-Server-Streaming" class="headerlink" title="&lt;3&gt;ServerAsyncWriter — 异步 Server Streaming"></a>&lt;3&gt;ServerAsyncWriter — 异步 Server Streaming</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 服务端异步写入器 ====================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>&gt;  <span class="comment">// W = 写入类型 (Order)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerAsyncWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 发送初始元数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendInitialMetadata</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步写入一条消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带选项的写入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, grpc::WriteOptions options, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束调用（发送状态码）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">(<span class="type">const</span> grpc::Status&amp; status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入最后一条消息并结束（合并操作，更高效）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteAndFinish</span><span class="params">(<span class="type">const</span> W&amp; msg, grpc::WriteOptions options,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> grpc::Status&amp; status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h4 id="ServerAsyncReaderWriter-—-异步双向流"><a href="#ServerAsyncReaderWriter-—-异步双向流" class="headerlink" title="&lt;4&gt;ServerAsyncReaderWriter — 异步双向流"></a>&lt;4&gt;ServerAsyncReaderWriter — 异步双向流</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> grpc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">W</span>, <span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerAsyncReaderWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 异步读取</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">(R* msg, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步写入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> W&amp; msg, grpc::WriteOptions options, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">(<span class="type">const</span> grpc::Status&amp; status, <span class="type">void</span>* tag)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送初始元数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendInitialMetadata</span><span class="params">(<span class="type">void</span>* tag)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace grpc</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）异步调用过程详解"><a href="#（5）异步调用过程详解" class="headerlink" title="（5）异步调用过程详解"></a>（5）异步调用过程详解</h3><h4 id="示例：异步登录"><a href="#示例：异步登录" class="headerlink" title="&lt;1&gt;示例：异步登录"></a>&lt;1&gt;示例：异步登录</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;auth.grpc.pb.h&quot;</span>  <span class="comment">// protoc 生成的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// CallData 结构体：封装一次 RPC 调用的所有状态</span></span><br><span class="line"><span class="comment">// 每个异步请求都需要独立的状态，因为多个请求可能同时进行</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CallData</span> &#123;</span><br><span class="line">    auth::LoginRequest request;     <span class="comment">// 请求消息</span></span><br><span class="line">    auth::LoginResponse response;   <span class="comment">// 响应消息（Finish 后被填充）</span></span><br><span class="line">    grpc::ClientContext context;    <span class="comment">// 调用上下文（超时、元数据等）</span></span><br><span class="line">    grpc::Status status;            <span class="comment">// RPC 状态（Finish 后被填充）</span></span><br><span class="line">    std::unique_ptr&lt;grpc::ClientAsyncResponseReader&lt;auth::LoginResponse&gt;&gt; reader;  <span class="comment">// 异步读取器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 1. 创建 Channel 和 Stub</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// Channel：到服务端的连接（可复用）</span></span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;localhost:50051&quot;</span>, </span><br><span class="line">                                       grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="comment">// Stub：RPC 调用的代理对象</span></span><br><span class="line">    <span class="keyword">auto</span> stub = auth::AuthService::<span class="built_in">NewStub</span>(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CompletionQueue：异步操作完成通知的队列</span></span><br><span class="line">    <span class="comment">// 所有异步操作完成后都会往这里投递事件</span></span><br><span class="line">    grpc::CompletionQueue cq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 2. 发起多个异步请求（非阻塞，立即返回）</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 为每个请求分配独立的状态（堆上分配，生命周期跨越异步操作）</span></span><br><span class="line">        CallData* call = <span class="keyword">new</span> <span class="built_in">CallData</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 填充请求数据</span></span><br><span class="line">        call-&gt;request.<span class="built_in">set_username</span>(<span class="string">&quot;user&quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        call-&gt;request.<span class="built_in">set_password</span>(<span class="string">&quot;pass&quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AsyncLogin()：发起异步 RPC，立即返回</span></span><br><span class="line">        <span class="comment">// - 请求已发送到服务端</span></span><br><span class="line">        <span class="comment">// - 返回 ClientAsyncResponseReader 用于后续操作</span></span><br><span class="line">        call-&gt;reader = stub-&gt;<span class="built_in">AsyncLogin</span>(&amp;call-&gt;context, call-&gt;request, &amp;cq);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Finish()：注册&quot;完成回调&quot;</span></span><br><span class="line">        <span class="comment">// - 告诉 gRPC：当响应到达时，把结果填入 response 和 status</span></span><br><span class="line">        <span class="comment">// - tag 参数：完成时用于识别是哪个请求（这里传 call 指针）</span></span><br><span class="line">        <span class="comment">// - 此时请求还没完成，只是注册了回调</span></span><br><span class="line">        call-&gt;reader-&gt;<span class="built_in">Finish</span>(&amp;call-&gt;response, &amp;call-&gt;status, (<span class="type">void</span>*)call);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：循环立即继续，不等待响应</span></span><br><span class="line">        <span class="comment">// 3 个请求几乎同时发出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 3. 事件循环：等待并处理完成事件</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="type">void</span>* tag;   <span class="comment">// 完成事件的标识（就是 Finish 时传入的 call 指针）</span></span><br><span class="line">    <span class="type">bool</span> ok;     <span class="comment">// 操作是否成功</span></span><br><span class="line">    <span class="type">int</span> completed = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cq.Next()：阻塞等待下一个完成事件</span></span><br><span class="line">    <span class="comment">// 返回 false 表示队列已关闭</span></span><br><span class="line">    <span class="keyword">while</span> (completed &lt; <span class="number">3</span> &amp;&amp; cq.<span class="built_in">Next</span>(&amp;tag, &amp;ok)) &#123;</span><br><span class="line">        <span class="comment">// 从 tag 恢复出 CallData 指针</span></span><br><span class="line">        CallData* call = <span class="built_in">static_cast</span>&lt;CallData*&gt;(tag);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查结果</span></span><br><span class="line">        <span class="keyword">if</span> (ok &amp;&amp; call-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="comment">// ok=true：gRPC 层面操作成功</span></span><br><span class="line">            <span class="comment">// status.ok()：业务层面 RPC 成功</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;成功: &quot;</span> &lt;&lt; call-&gt;response.<span class="built_in">token</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败原因可能：网络错误、服务端错误等</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;失败: &quot;</span> &lt;&lt; call-&gt;status.<span class="built_in">error_message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放堆内存</span></span><br><span class="line">        <span class="keyword">delete</span> call;</span><br><span class="line">        completed++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行流程图</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间线 ─────────────────────────────────────────────────────────────────►</span><br><span class="line"></span><br><span class="line">主线程:</span><br><span class="line">    │</span><br><span class="line">    ├─ <span class="built_in">AsyncLogin</span>(user0) ──► 请求<span class="number">0</span>发出 ─────────────┐</span><br><span class="line">    ├─ <span class="built_in">AsyncLogin</span>(user1) ──► 请求<span class="number">1</span>发出 ────────┐    │</span><br><span class="line">    ├─ <span class="built_in">AsyncLogin</span>(user2) ──► 请求<span class="number">2</span>发出 ───┐    │    │</span><br><span class="line">    │                                     │    │    │</span><br><span class="line">    ├─ cq.<span class="built_in">Next</span>() [阻塞等待]               │    │    │</span><br><span class="line">    │      ◄────────────────────────────────────────┘ 响应<span class="number">0</span>到达</span><br><span class="line">    ├─ 处理 user0 结果                    │    │</span><br><span class="line">    │                                     │    │</span><br><span class="line">    ├─ cq.<span class="built_in">Next</span>() [阻塞等待]               │    │</span><br><span class="line">    │      ◄─────────────────────────────────────┘ 响应<span class="number">1</span>到达  </span><br><span class="line">    ├─ 处理 user1 结果                    │</span><br><span class="line">    │                                     │</span><br><span class="line">    ├─ cq.<span class="built_in">Next</span>() [阻塞等待]               │</span><br><span class="line">    │      ◄──────────────────────────────┘ 响应<span class="number">2</span>到达</span><br><span class="line">    ├─ 处理 user2 结果</span><br><span class="line">    │</span><br><span class="line">    └─ 退出</span><br><span class="line"></span><br><span class="line">注意：响应到达顺序可能与发送顺序不同！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="gRPC-异步调用关键过程"><a href="#gRPC-异步调用关键过程" class="headerlink" title="&lt;2&gt;gRPC 异步调用关键过程"></a>&lt;2&gt;gRPC 异步调用关键过程</h4><ul>
<li><strong>调用 AsyncLogin() 时</strong>：<ul>
<li>传入事件队列 cq，内部通过 Channel 的网络连接将序列化后的请求发送到服务端，并返回一个 ClientAsyncResponseReader 对象。此时请求已发出，但还没注册”完成通知”。</li>
</ul>
</li>
<li><strong>调用 Finish(response, status, tag) 时</strong>：<br>  告诉框架”当响应回来时，把结果写入 response 和 status，然后把 tag 放入事件队列通知我”。此时 tag 被绑定到这次调用。</li>
<li><strong>网络层收到响应时（由 gRPC 内部的 I&#x2F;O 线程处理）</strong>：<ul>
<li>框架将响应反序列化后写入用户提供的 response，将状态写入 status，然后把 (tag, ok) 放入事件队列。</li>
</ul>
</li>
<li><strong>如果网络层响应先到达（Finish 还没调用）</strong>：<ul>
<li>gRPC 内部的 I&#x2F;O 线程会把响应数据暂存在内部缓冲区（绑定在 grpc_call 结构中），不会入队，也不会丢弃，只是静静等待。</li>
<li><strong>调用 Finish(response, status, tag) 时</strong>：框架检查内部缓冲区，发现响应已经到了，于是立即将数据写入 response 和 status，然后把 (tag, ok) 放入事件队列。（如果响应还没到，则注册回调等待）</li>
</ul>
</li>
<li><strong>用户调用 cq.Next(&amp;tag, &amp;ok) 时</strong>：<ul>
<li>从事件队列中取出完成的事件，<strong>通过 tag 找到对应的调用上下文</strong>，处理结果。</li>
</ul>
</li>
</ul>
<h4 id="tag-的作用"><a href="#tag-的作用" class="headerlink" title="&lt;3&gt;tag 的作用"></a>&lt;3&gt;tag 的作用</h4><p>响应确实已经写入 response 和 status 了。那 tag 的作用是什么？	<br><strong>🎯 核心问题</strong>：你怎么知道哪个调用完成了？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设你同时发起了 100 个异步调用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    CallData* call = <span class="keyword">new</span> <span class="built_in">CallData</span>();</span><br><span class="line">    call-&gt;id = i;</span><br><span class="line">    call-&gt;reader = stub-&gt;<span class="built_in">AsyncLogin</span>(&amp;call-&gt;context, call-&gt;request, &amp;cq);</span><br><span class="line">    call-&gt;reader-&gt;<span class="built_in">Finish</span>(&amp;call-&gt;response, &amp;call-&gt;status, (<span class="type">void</span>*)call);  <span class="comment">// tag = call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="type">void</span>* tag;</span><br><span class="line"><span class="type">bool</span> ok;</span><br><span class="line"><span class="keyword">while</span> (cq.<span class="built_in">Next</span>(&amp;tag, &amp;ok)) &#123;</span><br><span class="line">    <span class="comment">// 问题来了：这是哪个调用完成了？？</span></span><br><span class="line">    <span class="comment">// response 在哪？status 在哪？</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 答案：通过 tag 找回来！</span></span><br><span class="line">    CallData* call = <span class="built_in">static_cast</span>&lt;CallData*&gt;(tag);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在你知道了：</span></span><br><span class="line">    <span class="comment">// - 这是第 call-&gt;id 个调用</span></span><br><span class="line">    <span class="comment">// - 响应在 call-&gt;response 里</span></span><br><span class="line">    <span class="comment">// - 状态在 call-&gt;status 里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tag 不是用来传递数据的，而是用来”认领”的</strong>——当事件队列告诉你”有个调用完成了”，你需要通过 tag 知道”是哪个调用完成了”，从而找到对应的 response 和 status。</li>
<li>如果只有一个调用，tag 确实显得多余。但异步模型的意义就在于并发多个调用，tag 是区分它们的唯一标识。</li>
</ul>
<p><a id="Proto"></a></p>
<h1 id="附录：Proto文件"><a href="#附录：Proto文件" class="headerlink" title="附录：Proto文件"></a>附录：Proto文件</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><h3 id="简单演示"><a href="#简单演示" class="headerlink" title="&lt;1&gt;简单演示"></a>&lt;1&gt;简单演示</h3><p><strong>初学先了解以下几个部分即可，其它的遇到时再看</strong></p>
<figure class="highlight plaintext"><figcaption><span>Streaming（服务端流）</span></figcaption><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // 1. 语法版本声明（必须在第一行非注释处）</span><br><span class="line"></span><br><span class="line">// 2. 包名声明（可选，防止命名冲突）</span><br><span class="line">package user;</span><br><span class="line"></span><br><span class="line">// 3. 导入其他 proto 文件</span><br><span class="line">import &quot;google/protobuf/timestamp.proto&quot;;</span><br><span class="line">import &quot;other/message.proto&quot;;</span><br><span class="line">import public &quot;shared/common.proto&quot;;  // 传递导入</span><br><span class="line"></span><br><span class="line">// 4. 消息、枚举、服务定义</span><br><span class="line">message User &#123; ... &#125;</span><br><span class="line">enum Status &#123; ... &#125;</span><br><span class="line">service UserService &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="编译命令"><a href="#编译命令" class="headerlink" title="&lt;2&gt;编译命令"></a>&lt;2&gt;编译命令</h3><p>通过protoc命令进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本编译</span></span><br><span class="line">protoc --cpp_out=./output user.proto</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定搜索路径</span></span><br><span class="line">protoc -I=./protos --cpp_out=./output user.proto</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 gRPC 代码</span></span><br><span class="line">protoc --cpp_out=. --grpc_out=. --plugin=protoc-gen-grpc=`<span class="built_in">which</span> grpc_cpp_plugin` user.proto</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119235923782.png"></p>
<h2 id="1-Proto-文件核心语法详解：syntax、package、import、option"><a href="#1-Proto-文件核心语法详解：syntax、package、import、option" class="headerlink" title="1.Proto 文件核心语法详解：syntax、package、import、option"></a>1.Proto 文件核心语法详解：syntax、package、import、option</h2><h3 id="（1）syntax：指定语法版本"><a href="#（1）syntax：指定语法版本" class="headerlink" title="（1）syntax：指定语法版本"></a>（1）syntax：指定语法版本</h3><h4 id="核心作用"><a href="#核心作用" class="headerlink" title="&lt;1&gt;核心作用"></a>&lt;1&gt;核心作用</h4><p>声明 .proto 文件的语法版本，是文件<strong>第一行必须写</strong>的内容，直接决定编译器生成的 C++ 代码结构、字段访问方式和默认行为</p>
<h4 id="语法格式"><a href="#语法格式" class="headerlink" title="&lt;2&gt;语法格式"></a>&lt;2&gt;语法格式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 推荐使用 proto3</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>; <span class="comment">// 旧版，不推荐新项目使用</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）package：定义命名空间（C-命名空间映射）"><a href="#（2）package：定义命名空间（C-命名空间映射）" class="headerlink" title="（2）package：定义命名空间（C++ 命名空间映射）"></a>（2）package：定义命名空间（C++ 命名空间映射）</h3><h4 id="核心作用-1"><a href="#核心作用-1" class="headerlink" title="&lt;1&gt;核心作用"></a>&lt;1&gt;核心作用</h4><p>避免不同 .proto 文件的类型重名，<strong>直接映射为 C++ 的命名空间</strong>，是 C++ 中隔离类型的核心方式。</p>
<h4 id="语法格式-C-映射示例"><a href="#语法格式-C-映射示例" class="headerlink" title="&lt;2&gt;语法格式 + C++ 映射示例"></a>&lt;2&gt;语法格式 + C++ 映射示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .proto 文件</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">package com.example.chat; <span class="comment">// 多层级包名</span></span><br><span class="line"></span><br><span class="line">message ChatMsg &#123;</span><br><span class="line">  string content = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后生成的 C++ 代码结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动生成命名空间，与 package 完全一致</span></span><br><span class="line"><span class="keyword">namespace</span> com &#123;</span><br><span class="line"><span class="keyword">namespace</span> example &#123;</span><br><span class="line"><span class="keyword">namespace</span> chat &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ChatMsg</span> : <span class="keyword">public</span> ::google::protobuf::Message &#123;</span><br><span class="line">    <span class="comment">// ... 成员方法（get_content()、set_content() 等）</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace chat</span></span><br><span class="line">&#125; <span class="comment">// namespace example</span></span><br><span class="line">&#125; <span class="comment">// namespace com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 代码中使用</span></span><br><span class="line">com::example::chat::ChatMsg msg;</span><br><span class="line">msg.<span class="built_in">set_content</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="C-实战注意事项"><a href="#C-实战注意事项" class="headerlink" title="&lt;3&gt;C++ 实战注意事项"></a>&lt;3&gt;C++ 实战注意事项</h4><ul>
<li>package 命名建议与 C++ 项目的命名空间规范一致（如 company.module.feature），避免冲突；</li>
<li>若多个 .proto 文件使用同一 package，编译后会合并到同一个 C++ 命名空间下；</li>
<li>禁止在 package 中使用 C++ 关键字（如 class、namespace），否则生成代码会编译报错。</li>
</ul>
<h3 id="（3）import：导入其他-Proto-文件（C-类型复用）"><a href="#（3）import：导入其他-Proto-文件（C-类型复用）" class="headerlink" title="（3）import：导入其他 Proto 文件（C++ 类型复用）"></a>（3）import：导入其他 Proto 文件（C++ 类型复用）</h3><h4 id="核心作用-2"><a href="#核心作用-2" class="headerlink" title="&lt;1&gt;核心作用"></a>&lt;1&gt;核心作用</h4><p>复用其他 .proto 文件定义的 message&#x2F;enum&#x2F;service，C++ 中可直接使用导入的类型，无需重复定义。</p>
<h4 id="基础语法-C-示例"><a href="#基础语法-C-示例" class="headerlink" title="&lt;2&gt;基础语法 + C++ 示例"></a>&lt;2&gt;基础语法 + C++ 示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 基础导入（导入自定义 proto）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;common/error_code.proto&quot;</span>; </span><br><span class="line"><span class="comment">// 2. 导入官方 Well-Known Type（C++ 常用，如时间戳）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">package com.example.chat;</span><br><span class="line"></span><br><span class="line">message ChatMsg &#123;</span><br><span class="line">  string content = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 使用导入的枚举（来自 error_code.proto）</span></span><br><span class="line">  com.example.common.ErrorCode code = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 使用官方 Timestamp 类型（C++ 映射为 google::protobuf::Timestamp）</span></span><br><span class="line">  google::protobuf::Timestamp send_time = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-场景高级用法"><a href="#C-场景高级用法" class="headerlink" title="&lt;3&gt;C++ 场景高级用法"></a>&lt;3&gt;C++ 场景高级用法</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119234919030.png"></p>
<h4 id="C-编译关键"><a href="#C-编译关键" class="headerlink" title="&lt;4&gt;C++ 编译关键"></a>&lt;4&gt;C++ 编译关键</h4><p>编译时需通过 -I（或 –proto_path）指定 Proto 文件的搜索根目录，否则编译器找不到导入的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：指定根目录为 proto/，编译 chat.proto 生成 C++ 代码</span></span><br><span class="line">protoc -I=proto/ --cpp_out=src/ proto/com/example/chat.proto</span><br></pre></td></tr></table></figure>

<h3 id="（4）option：配置编译行为（C-专属配置）"><a href="#（4）option：配置编译行为（C-专属配置）" class="headerlink" title="（4）option：配置编译行为（C++ 专属配置）"></a>（4）option：配置编译行为（C++ 专属配置）</h3><h4 id="核心作用-3"><a href="#核心作用-3" class="headerlink" title="&lt;1&gt;核心作用"></a>&lt;1&gt;核心作用</h4><p>设置 Protobuf 编译器生成 C++ 代码的规则、命名、优化策略等，分为「文件级 option」（全局）和「局部 option」（字段&#x2F;枚举）。</p>
<h4 id="C-常用文件级-Option"><a href="#C-常用文件级-Option" class="headerlink" title="&lt;2&gt;C++ 常用文件级 Option"></a>&lt;2&gt;C++ 常用文件级 Option</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119235233461.png"></p>
<h4 id="C-常用局部-Option"><a href="#C-常用局部-Option" class="headerlink" title="&lt;3&gt;C++ 常用局部 Option"></a>&lt;3&gt;C++ 常用局部 Option</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119235355637.png"></p>
<h4 id="C-实战示例（完整-Option-配置）"><a href="#C-实战示例（完整-Option-配置）" class="headerlink" title="&lt;4&gt;C++ 实战示例（完整 Option 配置）"></a>&lt;4&gt;C++ 实战示例（完整 Option 配置）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">package com.example.chat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 专属全局配置</span></span><br><span class="line">option cc_namespace = <span class="string">&quot;chat::v1&quot;</span>; <span class="comment">// 覆盖默认命名空间</span></span><br><span class="line">option optimize_for = SPEED;      <span class="comment">// 优先执行速度</span></span><br><span class="line">option cc_enable_arenas = <span class="literal">true</span>;   <span class="comment">// 启用 Arena 内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MsgType</span> &#123;</span><br><span class="line">  option allow_alias = <span class="literal">true</span>; <span class="comment">// 允许枚举别名</span></span><br><span class="line">  TEXT = <span class="number">0</span>;</span><br><span class="line">  TEXT_MSG = <span class="number">0</span>; <span class="comment">// 别名（C++ 中可混用）</span></span><br><span class="line">  VOICE = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ChatMsg &#123;</span><br><span class="line">  string content = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 废弃字段（C++ 使用时会报警告）</span></span><br><span class="line">  string old_content = <span class="number">2</span> [deprecated = <span class="literal">true</span>];</span><br><span class="line">  <span class="comment">// 自定义 C++ 类型（默认 int32_t → 改为 uint32_t）</span></span><br><span class="line">  int32 msg_id = <span class="number">3</span> [cc_type = <span class="string">&quot;uint32_t&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="附录：Protobuf-学习路线（从基础到高级）"><a href="#附录：Protobuf-学习路线（从基础到高级）" class="headerlink" title="附录：Protobuf 学习路线（从基础到高级）"></a>附录：Protobuf 学习路线（从基础到高级）</h1><hr>
<h2 id="第一阶段：基础入门"><a href="#第一阶段：基础入门" class="headerlink" title="第一阶段：基础入门"></a>第一阶段：基础入门</h2><table>
<thead>
<tr>
<th>序号</th>
<th>知识点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Proto 文件语法</td>
<td><code>syntax</code>、<code>package</code>、<code>import</code>、<code>option</code></td>
</tr>
<tr>
<td>2</td>
<td>标量类型</td>
<td>int32&#x2F;sint32&#x2F;fixed32、string&#x2F;bytes、bool、float&#x2F;double</td>
</tr>
<tr>
<td>3</td>
<td>复合类型</td>
<td>message、enum、嵌套定义</td>
</tr>
<tr>
<td>4</td>
<td>字段规则</td>
<td>singular、<code>optional</code>、<code>repeated</code>、<code>map</code></td>
</tr>
<tr>
<td>5</td>
<td>字段编号</td>
<td>1-15 优化、reserved、编号不可复用</td>
</tr>
<tr>
<td>6</td>
<td>编译与生成</td>
<td><code>protoc</code> 命令、生成的 C++ 类结构</td>
</tr>
<tr>
<td>7</td>
<td>序列化&#x2F;反序列化</td>
<td><code>SerializeToString</code>、<code>ParseFromString</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="第二阶段：核心应用"><a href="#第二阶段：核心应用" class="headerlink" title="第二阶段：核心应用"></a>第二阶段：核心应用</h2><table>
<thead>
<tr>
<th>序号</th>
<th>知识点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>默认值机制</td>
<td>Proto3 默认值、optional 与 has_xxx()</td>
</tr>
<tr>
<td>9</td>
<td>oneof</td>
<td>互斥字段、union 存储原理</td>
</tr>
<tr>
<td>10</td>
<td>Well-Known Types</td>
<td><code>Any</code>、<code>Timestamp</code>、<code>Duration</code>、<code>Wrapper</code>、<code>Struct</code></td>
</tr>
<tr>
<td>11</td>
<td><strong>Service 定义</strong></td>
<td>RPC 接口定义、生成的 Stub 类</td>
</tr>
<tr>
<td>12</td>
<td><strong>gRPC 集成</strong></td>
<td>同步&#x2F;异步调用、四种 RPC 模式（Unary&#x2F;Stream）</td>
</tr>
<tr>
<td>13</td>
<td>错误处理</td>
<td>Status、错误码、metadata</td>
</tr>
</tbody></table>
<hr>
<h2 id="第三阶段：进阶优化"><a href="#第三阶段：进阶优化" class="headerlink" title="第三阶段：进阶优化"></a>第三阶段：进阶优化</h2><table>
<thead>
<tr>
<th>序号</th>
<th>知识点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>14</td>
<td><strong>编码原理</strong></td>
<td>Varint、ZigZag、Wire Type、Tag-Length-Value</td>
</tr>
<tr>
<td>15</td>
<td>性能优化</td>
<td>Arena 内存池、对象复用、预分配</td>
</tr>
<tr>
<td>16</td>
<td>大消息处理</td>
<td>分块传输、流式 RPC、CodedInputStream</td>
</tr>
<tr>
<td>17</td>
<td>Proto2 vs Proto3</td>
<td>差异对比、迁移注意事项</td>
</tr>
<tr>
<td>18</td>
<td>版本兼容</td>
<td>字段新增&#x2F;删除&#x2F;修改的兼容性规则</td>
</tr>
</tbody></table>
<hr>
<h2 id="第四阶段：高级特性"><a href="#第四阶段：高级特性" class="headerlink" title="第四阶段：高级特性"></a>第四阶段：高级特性</h2><table>
<thead>
<tr>
<th>序号</th>
<th>知识点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>19</td>
<td><strong>反射机制</strong></td>
<td>Descriptor、FieldDescriptor、Reflection</td>
</tr>
<tr>
<td>20</td>
<td><strong>动态消息</strong></td>
<td>DynamicMessage、运行时构造消息</td>
</tr>
<tr>
<td>21</td>
<td>自定义 Option</td>
<td>extend、自定义注解、代码生成器读取</td>
</tr>
<tr>
<td>22</td>
<td>插件开发</td>
<td><code>protoc</code> 插件机制、CodeGenerator 接口</td>
</tr>
<tr>
<td>23</td>
<td>JSON 互转</td>
<td><code>util::JsonStringToMessage</code>、JsonPrintOptions</td>
</tr>
</tbody></table>
<hr>
<h2 id="第五阶段：工程实践"><a href="#第五阶段：工程实践" class="headerlink" title="第五阶段：工程实践"></a>第五阶段：工程实践</h2><table>
<thead>
<tr>
<th>序号</th>
<th>知识点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>24</td>
<td>项目组织</td>
<td>proto 文件管理、包结构设计、CI&#x2F;CD 集成</td>
</tr>
<tr>
<td>25</td>
<td>API 设计规范</td>
<td>Google API 设计指南、命名规范、版本管理</td>
</tr>
<tr>
<td>26</td>
<td>安全考虑</td>
<td>大小限制、递归深度、未知字段处理</td>
</tr>
<tr>
<td>27</td>
<td>调试工具</td>
<td><code>protoc --decode</code>、grpcurl、Wireshark 插件</td>
</tr>
<tr>
<td>28</td>
<td>与其他序列化对比</td>
<td>vs JSON、vs FlatBuffers、vs MessagePack</td>
</tr>
</tbody></table>
<hr>
<h2 id="可视化路线图"><a href="#可视化路线图" class="headerlink" title="可视化路线图"></a>可视化路线图</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">基础 ──────────────────────────────────────────────► 高级</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[语法]</span> → <span class="selector-attr">[类型]</span> → <span class="selector-attr">[序列化]</span> → <span class="selector-attr">[Service/gRPC]</span> → <span class="selector-attr">[编码原理]</span></span><br><span class="line">                                    │</span><br><span class="line">                                    ▼</span><br><span class="line">                            <span class="selector-attr">[Arena 优化]</span></span><br><span class="line">                                    │</span><br><span class="line">                                    ▼</span><br><span class="line">                    <span class="selector-attr">[反射]</span> → <span class="selector-attr">[动态消息]</span> → <span class="selector-attr">[插件开发]</span></span><br><span class="line">                                    │</span><br><span class="line">                                    ▼</span><br><span class="line">                            <span class="selector-attr">[工程实践/规范]</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>protobuf的使用</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlpp11的安装</title>
    <url>/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/sqlpp11-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="提要（请看完再决定是否继续看）"><a href="#提要（请看完再决定是否继续看）" class="headerlink" title="提要（请看完再决定是否继续看）"></a>提要（请看完再决定是否继续看）</h1><ol>
<li>安装时间： 2026年1月12日 （注意：如果你安装时间较晚，下述方法可能已不再适用）</li>
<li>安装后版本： 0.65 + 11 commits（相较于0.65 有11 个额外的 commit ）——&gt;（可切换为0.65）</li>
</ol>
<ul>
<li><strong>注</strong>：也许你安装后并不是这个版本，已经升级</li>
</ul>
<ol start="3">
<li><strong>注意</strong>：也许由于版本不同等问题，安装后进行的“测试代码”不再适用，语法可能也不再适用，请自己斟酌！</li>
</ol>
<h2 id="个人抱怨"><a href="#个人抱怨" class="headerlink" title="个人抱怨"></a>个人抱怨</h2><h5 id="1-在网上没找到很完整的教程，中间尝试了不同的安装方式（vcpkg等），不同安装版本，总是出问题，安装都花了一天（也许是我个人能力太低😞），真的很无奈。"><a href="#1-在网上没找到很完整的教程，中间尝试了不同的安装方式（vcpkg等），不同安装版本，总是出问题，安装都花了一天（也许是我个人能力太低😞），真的很无奈。" class="headerlink" title="1.在网上没找到很完整的教程，中间尝试了不同的安装方式（vcpkg等），不同安装版本，总是出问题，安装都花了一天（也许是我个人能力太低😞），真的很无奈。"></a>1.在网上没找到很完整的教程，中间尝试了不同的安装方式（vcpkg等），不同安装版本，总是出问题，安装都花了一天（也许是我个人能力太低😞），真的很无奈。</h5><h5 id="2-如果在这个过程中，你遇到任何问题，请寻找其它参考教程以及AI的帮助"><a href="#2-如果在这个过程中，你遇到任何问题，请寻找其它参考教程以及AI的帮助" class="headerlink" title="2.如果在这个过程中，你遇到任何问题，请寻找其它参考教程以及AI的帮助"></a>2.如果在这个过程中，你遇到任何问题，请寻找其它参考教程以及AI的帮助</h5><h1 id="一、sqlpp11介绍与环境搭建"><a href="#一、sqlpp11介绍与环境搭建" class="headerlink" title="一、sqlpp11介绍与环境搭建"></a>一、sqlpp11介绍与环境搭建</h1><h2 id="1-sqlpp11介绍"><a href="#1-sqlpp11介绍" class="headerlink" title="1.sqlpp11介绍"></a>1.sqlpp11介绍</h2><ul>
<li>SQLPP11是一款基于C++11及以上标准的类型安全嵌入式SQL库，核心价值在于让开发者用原生C++语法编写SQL语句，通过编译期检查规避语法错误、类型不匹配及SQL注入风险</li>
<li>兼容MySQL、SQLite、PostgreSQL等主流数据库，零运行时开销且符合C++开发习惯</li>
</ul>
<p><strong>核心优势</strong>：</p>
<ul>
<li><strong>类型安全</strong>：编译期校验SQL语法、字段类型匹配性（如int字段赋值字符串直接编译失败）；</li>
<li><strong>原生C++集成</strong>：支持移动语义、lambda、类型推导等C++11+特性，无需手写SQL字符串；</li>
<li><strong>多库兼容</strong>：通过适配层对接主流数据库，核心代码无需修改即可切换数据库；</li>
<li><strong>轻量高效</strong>：模板元编程实现核心逻辑，编译期完成大部分计算，无额外运行时开销。</li>
</ul>
<h2 id="2-安装教程（Linux，sqlpp11-mysql为例）"><a href="#2-安装教程（Linux，sqlpp11-mysql为例）" class="headerlink" title="2.安装教程（Linux，sqlpp11+mysql为例）"></a>2.安装教程（Linux，sqlpp11+mysql为例）</h2><p><strong>注</strong>：如果你在下面任何步骤出现问题无法解决且不想继续，可以查看<a href="#clean">卸载&#x2F;清理教程</a>进行清除</p>
<p><strong>以下库都放置在 “~&#x2F;thirdparty” 目录下</strong></p>
<h3 id="（1）系统依赖"><a href="#（1）系统依赖" class="headerlink" title="（1）系统依赖"></a>（1）系统依赖</h3><p>确保你已经安装了：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">g++ (&gt;= 5.0) 或 clang++</span><br><span class="line">cmake (&gt;= 3.10)</span><br><span class="line">git</span><br><span class="line">make</span><br><span class="line">libmysqlclient-dev   # MySQL C API 库头文件和链接库</span><br></pre></td></tr></table></figure>
<p>以Ubuntu为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install g++ cmake git make libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<h3 id="（2）安装sqlpp11"><a href="#（2）安装sqlpp11" class="headerlink" title="（2）安装sqlpp11"></a>（2）安装sqlpp11</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/thirdparty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆 sqlpp11</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rbock/sqlpp11.git</span><br><span class="line"><span class="built_in">cd</span> sqlpp11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有可用的 CMake 选项（-L 列出缓存变量）</span></span><br><span class="line"><span class="comment"># grep -i mysql 过滤出与 MySQL 相关的选项</span></span><br><span class="line"><span class="comment"># 目的：确认启用 MySQL connector 的选项名称（不同版本可能不同）</span></span><br><span class="line">cmake .. -L | grep -i mysql </span><br><span class="line"><span class="comment"># 预期输出类似：BUILD_MYSQL_CONNECTOR:BOOL=OFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空构建目录，准备正式编译</span></span><br><span class="line"><span class="built_in">rm</span> -rf *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正式编译</span></span><br><span class="line"><span class="comment"># -DBUILD_MYSQL_CONNECTOR=ON  : 启用 MySQL connector（上一步查到的选项）</span></span><br><span class="line"><span class="comment"># -DCMAKE_INSTALL_PREFIX=/usr/local : 指定安装路径</span></span><br><span class="line">cmake .. \</span><br><span class="line">  -DBUILD_MYSQL_CONNECTOR=ON \</span><br><span class="line">  -DCMAKE_INSTALL_PREFIX=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行编译（-j$(nproc) 使用所有 CPU 核心加速）</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装到系统目录（需要 sudo 权限）</span></span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<p><strong>如果连接github失败，且你的宿主机上有VPN，可以看我另一篇笔记<a href="/categories/Linux/Linux%E7%9A%84%E4%BD%BF%E7%94%A8/Linux%E8%AE%BE%E7%BD%AEVPN%E4%BB%A3%E7%90%86%EF%BC%88%E8%A7%A3%E5%86%B3github%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%EF%BC%89/">Linux设置VPN代理（解决github连接问题）</a></strong></p>
<h3 id="（3）测试-sqlpp11-MySQL-连接"><a href="#（3）测试-sqlpp11-MySQL-连接" class="headerlink" title="（3）测试 sqlpp11 MySQL 连接"></a>（3）测试 sqlpp11 MySQL 连接</h3><p><strong>个人认为还是通过“代码测试”比较靠谱，毕竟能用才是“目标”</strong></p>
<h4 id="创建测试项目"><a href="#创建测试项目" class="headerlink" title="&lt;1&gt;创建测试项目"></a>&lt;1&gt;创建测试项目</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/test_sqlpp11</span><br><span class="line"><span class="built_in">cd</span> ~/test_sqlpp11</span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong>：</p>
<ul>
<li><strong>注意</strong>：<ul>
<li>mysql连接配置换成你自己的！！</li>
<li>test数据库需要先创建，或换为你已有的数据库</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlpp11/mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        sqlpp::mysql::<span class="built_in">global_library_init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 shared_ptr</span></span><br><span class="line">        <span class="keyword">auto</span> config = std::<span class="built_in">make_shared</span>&lt;sqlpp::mysql::connection_config&gt;();</span><br><span class="line">        config-&gt;host = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">        config-&gt;port = <span class="number">3306</span>;</span><br><span class="line">        config-&gt;user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        config-&gt;password = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">        config-&gt;database = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        config-&gt;debug = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接传 shared_ptr</span></span><br><span class="line">        sqlpp::mysql::connection db&#123;config&#125;;</span><br><span class="line"></span><br><span class="line">        db.<span class="built_in">execute</span>(<span class="string">&quot;SELECT 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✅ 连接成功！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;❌ 失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CMakeLists.txt</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(test_sqlpp11)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 pkg-config 找 MySQL</span></span><br><span class="line"><span class="keyword">find_package</span>(PkgConfig REQUIRED)</span><br><span class="line">pkg_check_modules(MYSQL REQUIRED IMPORTED_TARGET mysqlclient)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 MySQL::MySQL alias（sqlpp11 需要这个名字）</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">TARGET</span> MySQL::MySQL)</span><br><span class="line">    <span class="keyword">add_library</span>(MySQL::MySQL ALIAS PkgConfig::MYSQL)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Sqlpp11 REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(test_mysql main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(test_mysql </span><br><span class="line">    PRIVATE </span><br><span class="line">    sqlpp11::sqlpp11</span><br><span class="line">    sqlpp11::mysql</span><br><span class="line">    Threads::Threads</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="编译运行："><a href="#编译运行：" class="headerlink" title="&lt;2&gt;编译运行："></a>&lt;2&gt;编译运行：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/test_sqlpp11</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">cmake .. -DCMAKE_PREFIX_PATH=/usr/local</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">./test_mysql</span><br></pre></td></tr></table></figure>

<h4 id="查看安装版本的方法"><a href="#查看安装版本的方法" class="headerlink" title="&lt;3&gt;查看安装版本的方法"></a>&lt;3&gt;查看安装版本的方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/thirdparty/sqlpp11</span><br><span class="line">git describe --tags --always</span><br><span class="line"><span class="comment"># 输出类似: 0.65-11-gabcdef （0.65 版本 + 11 个 commit）</span></span><br></pre></td></tr></table></figure>


<h2 id="3-卸载-清理教程"><a href="#3-卸载-清理教程" class="headerlink" title="3.卸载&#x2F;清理教程 "></a>3.卸载&#x2F;清理教程 <a id="clean"></a></h2><h5 id="如果你在上面步骤中出现任何问题，不想继续，可按下面方式进行清除"><a href="#如果你在上面步骤中出现任何问题，不想继续，可按下面方式进行清除" class="headerlink" title="如果你在上面步骤中出现任何问题，不想继续，可按下面方式进行清除"></a>如果你在上面步骤中出现任何问题，不想继续，可按下面方式进行清除</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"><span class="comment"># sqlpp11 完整卸载脚本</span></span><br><span class="line"><span class="comment"># ==========================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 尝试官方卸载（如果 build 目录还在）</span></span><br><span class="line"><span class="built_in">cd</span> ~/thirdparty/sqlpp11/build 2&gt;/dev/null &amp;&amp; <span class="built_in">sudo</span> make uninstall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 删除头文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/include/sqlpp11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除 cmake 配置文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/lib/cmake/Sqlpp11</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/lib/cmake/sqlpp11</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/share/sqlpp11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除库文件（如果有编译出 .a 或 .so）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/libsqlpp11*</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/libsqlpp-mysql*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 删除 pkg-config 文件（如果有）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/pkgconfig/sqlpp11*.pc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 删除可能安装到 /usr 的文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/include/sqlpp11</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/lib/cmake/Sqlpp11</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/lib/cmake/sqlpp11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 删除源码目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/thirdparty/sqlpp11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 更新链接器缓存</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 验证是否清理干净</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== 检查残留文件 ===&quot;</span></span><br><span class="line">find /usr/local -name <span class="string">&quot;*sqlpp*&quot;</span> 2&gt;/dev/null</span><br><span class="line">find /usr -name <span class="string">&quot;*sqlpp*&quot;</span> 2&gt;/dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>sqlpp11（已不准备使用）</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-plus-plus使用教程</title>
    <url>/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="#use">附录1：Redis++ 核心场景</a><br><a href="#mechanism">附录2：Redis++ 重要机制</a><br><a href="#install">附录3：Redis++ 安装教程</a></p>
<h1 id="一、Redis-概述"><a href="#一、Redis-概述" class="headerlink" title="一、Redis++概述"></a>一、Redis++概述</h1><h2 id="1-Redis-适配模式介绍"><a href="#1-Redis-适配模式介绍" class="headerlink" title="1.Redis++ 适配模式介绍"></a>1.Redis++ 适配模式介绍</h2><p>Redis++ 支持多种部署模式的适配，不同模式对应不同的生产场景需求，核心模式如下：</p>
<ul>
<li><strong>单机模式</strong>：<ul>
<li>适配小型应用、开发&#x2F;测试环境，直接连接单个Redis节点，部署简单但无高可用保障。</li>
<li>生产环境仅推荐用于<strong>非核心业务</strong>，需配合数据备份策略使用。​</li>
</ul>
</li>
<li><strong>主从模式</strong>：<ul>
<li>适配<strong>读多写少</strong>的生产场景</li>
<li>包含一个主节点（写入）和多个从节点（读取）</li>
<li>Redis++可通过配置指定读请求路由到从节点，提升读吞吐量，主从故障切换需依赖哨兵或手动操作。​</li>
</ul>
</li>
<li><strong>哨兵模式</strong>：<ul>
<li>在<strong>主从模式基础上</strong>增加哨兵节点，负责监控主从节点健康状态</li>
<li>当主节点故障时自动完成故障切换，保障高可用性</li>
<li>Redis++通过连接哨兵节点获取主从信息，无需手动维护节点地址。​</li>
</ul>
</li>
<li><strong>集群模式（Cluster）</strong>：<ul>
<li>适配<strong>海量数据、高并发</strong>的核心生产场景，将数据分片存储在多个主节点，每个主节点对应多个从节点。</li>
<li>Redis++提供RedisCluster客户端，自动适配数据分片、节点发现和故障切换，API与单机模式兼容，生产可无缝切换。</li>
</ul>
</li>
</ul>
<p><strong>注意！！</strong>：</p>
<ul>
<li>主从复制、哨兵模式、集群模式都是<strong>由“Redis服务端”手动配置</strong></li>
<li>Redis++是Redis客户端库<ul>
<li><strong>不负责配置</strong>“主从复制”、“哨兵模式”、“集群模式”</li>
<li>只负责<strong>连接到Redis服务器</strong></li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113171238862.png"></li>
</ul>
<h2 id="2-Redis-核心配置介绍"><a href="#2-Redis-核心配置介绍" class="headerlink" title="2.Redis++核心配置介绍"></a>2.Redis++核心配置介绍</h2><p>Redis++的配置核心围绕<strong>连接参数</strong>和<strong>池化参数</strong>，不同模式的配置略有差异</p>
<h3 id="（1）基础连接配置"><a href="#（1）基础连接配置" class="headerlink" title="（1）基础连接配置"></a>（1）基础连接配置</h3><ul>
<li><p><strong>host&#x2F;port</strong>：</p>
<ul>
<li>Redis节点的<strong>ip地址 和 端口port</strong><ul>
<li>单机模式：填写单个节点信息</li>
<li>集群&#x2F;哨兵模式：填写任意一个节点（客户端自动发现其他节点）</li>
</ul>
</li>
<li>生产环境建议使用内网IP或域名，避免公网传输风险。</li>
</ul>
</li>
<li><p><strong>password</strong>：</p>
<ul>
<li><strong>Redis访问密码</strong>，防未授权访问</li>
<li><strong>生产环境必须强制设置</strong>：<ul>
<li>长度建议不小于8位</li>
<li>包含字母、数字和特殊字符</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>db</strong>：</p>
<ul>
<li><strong>Redis逻辑数据库编号</strong>（0-15默认）</li>
<li>生产环境建议按业务模块隔离数据库<ul>
<li>例如用户模块用db1、订单模块用db2，避免键名冲突和数据混乱。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>socket_timeout</strong>：</p>
<ul>
<li><strong>套接字读写超时时间</strong></li>
<li>生产环境建议设置500ms-1s，避免因网络阻塞导致应用线程挂起。</li>
</ul>
</li>
<li><p><strong>connect_timeout</strong>：</p>
<ul>
<li><strong>连接建立超时时间</strong></li>
<li>生产环境建议设置1s-2s，防止因Redis节点故障导致连接等待过久。</li>
</ul>
</li>
</ul>
<h3 id="（2）连接池配置"><a href="#（2）连接池配置" class="headerlink" title="（2）连接池配置"></a>（2）连接池配置</h3><ul>
<li><p><strong>size</strong>：</p>
<ul>
<li><strong>连接池大小</strong></li>
<li>需根据业务QPS调整，生产环境建议20-50个连接（高QPS场景可增至100）<ul>
<li>连接过多：导致Redis资源耗尽</li>
<li>连接过少：导致请求排队。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>wait_timeout</strong>：</p>
<ul>
<li><strong>获取连接的等待超时时间</strong></li>
<li>生产环境建议设置200-500ms，超时后抛出异常，避免应用线程无限等待连接。</li>
</ul>
</li>
<li><p><strong>connection_lifetime</strong>：</p>
<ul>
<li><strong>连接最大生存时间</strong></li>
<li>生产环境建议设置5-10分钟，自动关闭长时间空闲的连接，避免无效连接占用资源。</li>
</ul>
</li>
</ul>
<h2 id="3-核心依赖与编译规范"><a href="#3-核心依赖与编译规范" class="headerlink" title="3.核心依赖与编译规范"></a>3.核心依赖与编译规范</h2><h3 id="（1）核心依赖与编译规范"><a href="#（1）核心依赖与编译规范" class="headerlink" title="（1）核心依赖与编译规范"></a>（1）核心依赖与编译规范</h3><ul>
<li><strong>编译选项</strong>：<ul>
<li>必须指定 -std&#x3D;c++17</li>
<li>链接 -lredis++ -lhiredis -pthread（线程库）；</li>
</ul>
</li>
<li><strong>编译优化</strong>：<ul>
<li>添加 -O2 提升性能</li>
<li>-Wall -Werror 严格检查代码；</li>
</ul>
</li>
<li><strong>头文件</strong>：<ul>
<li>#include &lt;sw&#x2F;redis++&#x2F;redis++.h&gt;（核心）</li>
<li>#include &lt;sw&#x2F;redis++&#x2F;cluster.h&gt;（集群）。</li>
</ul>
</li>
</ul>
<h3 id="（2）CMake-项目集成"><a href="#（2）CMake-项目集成" class="headerlink" title="（2）CMake 项目集成"></a>（2）CMake 项目集成</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyRedisProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 1. 设置 C++ 标准（必须与 redis++ 编译时一致） ============</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 2. 查找 hiredis 库 ============</span></span><br><span class="line"><span class="keyword">find_path</span>(HIREDIS_HEADER hiredis)</span><br><span class="line"><span class="keyword">find_library</span>(HIREDIS_LIB hiredis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 3. 查找 redis++ 库 ============</span></span><br><span class="line"><span class="comment"># 注意：这里是 sw，不是 redis++</span></span><br><span class="line"><span class="keyword">find_path</span>(REDIS_PLUS_PLUS_HEADER sw)</span><br><span class="line"><span class="keyword">find_library</span>(REDIS_PLUS_PLUS_LIB redis++)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 4. 创建可执行文件 ============</span></span><br><span class="line"><span class="keyword">add_executable</span>(myapp main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 5. 添加头文件路径 ============</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(myapp PRIVATE </span><br><span class="line">    <span class="variable">$&#123;HIREDIS_HEADER&#125;</span></span><br><span class="line">    <span class="variable">$&#123;REDIS_PLUS_PLUS_HEADER&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 6. 链接库 ============</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp PRIVATE</span><br><span class="line">    <span class="variable">$&#123;REDIS_PLUS_PLUS_LIB&#125;</span></span><br><span class="line">    <span class="variable">$&#123;HIREDIS_LIB&#125;</span></span><br><span class="line">    pthread  <span class="comment"># 必须链接线程库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="（3）连接配置示例"><a href="#（3）连接配置示例" class="headerlink" title="（3）连接配置示例"></a>（3）连接配置示例</h3><ul>
<li>生产环境<strong>禁止使用单连接</strong>，必须用<strong>连接池</strong></li>
<li>同时添加超时、密码等生产必备配置</li>
<li><strong>注</strong>：<ul>
<li>如果业务需要，可在业务层添加“<strong>手动重试封装</strong>”</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="comment">// Redis 连接创建函数（带连接池）</span></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function">Redis <span class="title">create_prod_redis_conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 基础连接配置</span></span><br><span class="line">    ConnectionOptions opts;</span><br><span class="line">    opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    opts.port = <span class="number">6379</span>;</span><br><span class="line">    opts.password = <span class="string">&quot;your_redis_pwd&quot;</span>;  <span class="comment">// 无密码则注释掉</span></span><br><span class="line">    opts.db = <span class="number">0</span>;</span><br><span class="line">    opts.socket_timeout = chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">    opts.connect_timeout = chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 注意：redis++ 默认会自动重连，无需手动配置重连参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接池配置</span></span><br><span class="line">    ConnectionPoolOptions pool_opts;</span><br><span class="line">    pool_opts.size = <span class="number">20</span>;</span><br><span class="line">    pool_opts.wait_timeout = chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line">    pool_opts.connection_lifetime = chrono::<span class="built_in">minutes</span>(<span class="number">5</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Redis</span>(opts, pool_opts);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Redis 连接失败：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Redis 初始化失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="comment">// 带重试的执行封装（解决重连问题）</span></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">redis_exec_with_retry</span><span class="params">(Redis&amp; redis, Func&amp;&amp; func, <span class="type">int</span> max_retry = <span class="number">3</span>)</span> </span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(func(redis))</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_retry; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">func</span>(redis);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp; e) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Redis 超时，重试 &quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; max_retry &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (i == max_retry - <span class="number">1</span>) <span class="keyword">throw</span>;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> IoError&amp; e) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Redis IO 错误，重试 &quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; max_retry &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (i == max_retry - <span class="number">1</span>) <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span> * (i + <span class="number">1</span>)));  <span class="comment">// 退避</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Redis 重试耗尽&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_usage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> redis = <span class="built_in">create_prod_redis_conn</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通调用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;操作失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带重试的调用</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">redis_exec_with_retry</span>(redis, [](Redis&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> r.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、官方文档提示事项"><a href="#二、官方文档提示事项" class="headerlink" title="二、官方文档提示事项"></a>二、官方文档提示事项</h1><p><strong>建议先阅读之后的小节，这里放在前面是为了“强调它的重要性”</strong></p>
<h2 id="1-Connection连接"><a href="#1-Connection连接" class="headerlink" title="1.Connection连接"></a>1.Connection连接</h2><h3 id="（1）尽可能复用-Redis-对象"><a href="#（1）尽可能复用-Redis-对象" class="headerlink" title="（1）尽可能复用 Redis 对象"></a>（1）尽可能复用 Redis 对象</h3><ul>
<li><strong>你应该尽可能复用 Redis 对象</strong><ul>
<li>因为<strong>创建 Redis 对象的开销并不小</strong>，因为它会创建到 Redis 服务器的新连接。</li>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000730301.png"></li>
</ul>
</li>
<li><strong>Redis对象是多线程安全的</strong><ul>
<li>你可以在多个线程中共享同一个 Redis 对象。</li>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000814117.png"></li>
</ul>
</li>
</ul>
<h3 id="（2）自动重连机制"><a href="#（2）自动重连机制" class="headerlink" title="（2）自动重连机制"></a>（2）自动重连机制</h3><ul>
<li>Redis 类维护一个连接到 Redis 服务器的连接池。<ul>
<li>如果连接断开，Redis 会<strong>自动重新连接</strong>到 Redis 服务器。</li>
</ul>
</li>
<li><strong>不需要手动检查 Redis 对象是否成功连接到服务器</strong><ul>
<li>如果 Redis 无法创建到 Redis 服务器的连接，或者连接在某个时刻断开，当你尝试发送命令时，它会<strong>抛出 Error 类型的异常</strong></li>
<li><strong>即使你收到异常（即连接断开），你也不需要创建新的 Redis 对象！！</strong><ul>
<li>你可以复用同一个 Redis 对象继续发送命令，Redis 对象会自动尝试重连服务器。</li>
<li>如果重连成功，它会发送命令到服务器；</li>
<li>否则，它会再次抛出异常。</li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000348588.png"></li>
</ul>
</li>
</ul>
<h3 id="（3）“阻塞命令”的使用"><a href="#（3）“阻塞命令”的使用" class="headerlink" title="（3）“阻塞命令”的使用"></a>（3）“阻塞命令”的使用</h3><ul>
<li>当使用<strong>阻塞命令</strong>时，socket_timeout <strong>必须大于阻塞命令的超时时间</strong>，否则会导致误报超时和数据丢失。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113234947400.png"></li>
</ul>
</li>
</ul>
<h3 id="（4）连接池的懒加载机制"><a href="#（4）连接池的懒加载机制" class="headerlink" title="（4）连接池的懒加载机制"></a>（4）连接池的懒加载机制</h3><ul>
<li>连接池中的连接是**懒加载（延迟创建）**的<ul>
<li>当连接池初始化时（即 Redis 构造函数执行时），Redis 不会立即连接到服务器</li>
<li>只有在你尝试<strong>发送命令时才会建立连接</strong><ul>
<li>通过这种方式，我们可以<strong>避免不必要的连接</strong></li>
</ul>
</li>
<li>因此，如果连接池大小设置为 5，但实际最大并发连接数只有 3，那么连接池中实际只会有 3 个连接。</li>
</ul>
</li>
</ul>
<h3 id="（5）URI-参数区分大小写（要求全小写）"><a href="#（5）URI-参数区分大小写（要求全小写）" class="headerlink" title="（5）URI 参数区分大小写（要求全小写）"></a>（5）URI 参数区分大小写（要求全小写）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：全小写</span></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1:6379?socket_timeout=100ms&amp;keep_alive=true&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：大小写混用</span></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1:6379?Socket_Timeout=100ms&quot;</span>);  <span class="comment">// 无法识别</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）Pipeline-Transaction-注意事项"><a href="#（6）Pipeline-Transaction-注意事项" class="headerlink" title="（6）Pipeline &#x2F; Transaction 注意事项"></a>（6）Pipeline &#x2F; Transaction 注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084518210.png"></p>
<h3 id="（7）Subscriber-订阅者注意事项"><a href="#（7）Subscriber-订阅者注意事项" class="headerlink" title="（7）Subscriber 订阅者注意事项"></a>（7）Subscriber 订阅者注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084903240.png"></p>
<h3 id="（8）Redis-Cluster-集群注意事项"><a href="#（8）Redis-Cluster-集群注意事项" class="headerlink" title="（8）Redis Cluster 集群注意事项"></a>（8）Redis Cluster 集群注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084633220.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084947303.png"></p>
<h3 id="（9）异步接口注意事项"><a href="#（9）异步接口注意事项" class="headerlink" title="（9）异步接口注意事项"></a>（9）异步接口注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084713792.png"></p>
<h3 id="（10）异常处理"><a href="#（10）异常处理" class="headerlink" title="（10）异常处理"></a>（10）异常处理</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084746832.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114085208456.png"></p>
<h1 id="三、配置结构体"><a href="#三、配置结构体" class="headerlink" title="三、配置结构体"></a>三、配置结构体</h1><p><a id="ConnectionOptions"></a></p>
<h2 id="1-ConnectionOptions结构体"><a href="#1-ConnectionOptions结构体" class="headerlink" title="1.ConnectionOptions结构体"></a>1.ConnectionOptions结构体</h2><ul>
<li><strong>注</strong>：内部成员变量顺序我做了调整，其它都未改动</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnectionOptions</span> &#123;</span><br><span class="line">    <span class="comment">// ============ 默认构造/拷贝/移动/析构 ============</span></span><br><span class="line">    <span class="built_in">ConnectionOptions</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ConnectionOptions</span>(<span class="type">const</span> ConnectionOptions &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ConnectionOptions&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionOptions &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ConnectionOptions</span>(ConnectionOptions &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ConnectionOptions&amp; <span class="keyword">operator</span>=(ConnectionOptions &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConnectionOptions</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 连接目标 ============</span></span><br><span class="line">    ConnectionType type = ConnectionType::TCP;  <span class="comment">// 连接类型: TCP 或 UNIX</span></span><br><span class="line">    std::string host;                           <span class="comment">// Redis 服务器ip地址 (TCP模式)</span></span><br><span class="line">    <span class="type">int</span> port = <span class="number">6379</span>;                            <span class="comment">// 端口号 (TCP模式)</span></span><br><span class="line">    std::string path;                           <span class="comment">// Unix Socket 路径 (UNIX模式)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 认证相关 ============</span></span><br><span class="line">    std::string user = <span class="string">&quot;default&quot;</span>;               <span class="comment">// ACL 用户名 (Redis 6.0+ 支持)</span></span><br><span class="line">    std::string password;                       <span class="comment">// 认证密码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 数据库选择 ============</span></span><br><span class="line">    <span class="type">int</span> db = <span class="number">0</span>;                                 <span class="comment">// 数据库索引 (0-15)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 超时设置 ============</span></span><br><span class="line">    std::chrono::milliseconds connect_timeout&#123;<span class="number">0</span>&#125;;  <span class="comment">// 连接超时 (0=系统默认)</span></span><br><span class="line">    std::chrono::milliseconds socket_timeout&#123;<span class="number">0</span>&#125;;   <span class="comment">// 读写超时 (0=无限等待)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ TCP 保活 ============</span></span><br><span class="line">    <span class="type">bool</span> keep_alive = <span class="literal">false</span>;                    <span class="comment">// 是否启用 TCP KeepAlive（心跳机制）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> REDIS_PLUS_PLUS_HAS_redisEnableKeepAliveWithInterval</span></span><br><span class="line">    std::chrono::seconds keep_alive_s&#123;<span class="number">0</span>&#125;;       <span class="comment">// KeepAlive 探测（心跳）间隔 (需要 hiredis 支持)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ TLS/SSL ============</span></span><br><span class="line">    tls::TlsOptions tls;                        <span class="comment">// TLS 加密配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 协议版本 ============</span></span><br><span class="line">    <span class="type">int</span> resp = <span class="number">2</span>;                               <span class="comment">// RESP 协议版本 (2 或 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 连接名称 ============</span></span><br><span class="line">    std::string name;                           <span class="comment">// CLIENT SETNAME 设置的连接名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 集群专用（与我们无关，不用看） ============</span></span><br><span class="line">    <span class="comment">// 是否允许从 Redis Cluster 的从节点（slave/replica）读取数据。</span></span><br><span class="line">    <span class="comment">// 客户端不应手动设置，RedisCluster 类会自动管理这个标志（未来可能移除）</span></span><br><span class="line">    <span class="type">bool</span> readonly = <span class="literal">false</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部使用，返回服务器信息字符串</span></span><br><span class="line">    std::string _server_info() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>keep_alive 和 keep_alive_s 的关系</strong></p>
<ul>
<li>keep_alive &#x3D; true 但 keep_alive_s &#x3D; 0 时，使用系统默认的 KeepAlive 间隔（通常是 7200 秒）</li>
<li>若要自定义间隔，需要 hiredis 版本支持 redisEnableKeepAliveWithInterval</li>
</ul>
<p><a id="ConnectionPoolOptions"></a></p>
<h2 id="2-ConnectionPoolOptions结构体"><a href="#2-ConnectionPoolOptions结构体" class="headerlink" title="2.ConnectionPoolOptions结构体"></a>2.ConnectionPoolOptions结构体</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnectionPoolOptions</span> &#123;</span><br><span class="line">    <span class="comment">// 连接池最大连接数</span></span><br><span class="line">    std::<span class="type">size_t</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接时的最大等待时间</span></span><br><span class="line">    <span class="comment">// 当连接池耗尽时，调用者最多阻塞等待这么久</span></span><br><span class="line">    <span class="comment">// 0 = 无限等待（不推荐，可能导致线程死锁）</span></span><br><span class="line">    std::chrono::milliseconds wait_timeout&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接的最大存活时间</span></span><br><span class="line">    <span class="comment">// 超过此时间的连接会被销毁并重建</span></span><br><span class="line">    <span class="comment">// 用于防止长连接腐化、应对服务端重启等场景</span></span><br><span class="line">    <span class="comment">// 0 = 永不过期</span></span><br><span class="line">    std::chrono::milliseconds connection_lifetime&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接的最大空闲时间</span></span><br><span class="line">    <span class="comment">// 超过此时间未被使用的连接会被回收</span></span><br><span class="line">    <span class="comment">// 用于释放闲置资源、避免空闲连接被防火墙/代理断开</span></span><br><span class="line">    <span class="comment">// 0 = 不回收空闲连接</span></span><br><span class="line">    std::chrono::milliseconds connection_idle_time&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a id="SentinelOptions"></a></p>
<h2 id="3-SentinelOptions结构体"><a href="#3-SentinelOptions结构体" class="headerlink" title="3.SentinelOptions结构体"></a>3.SentinelOptions结构体</h2><ul>
<li><strong>注</strong>：内部成员变量顺序我做了调整，其它都未改动</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SentinelOptions</span> &#123;</span><br><span class="line">    <span class="comment">/// 哨兵节点列表：每个元素为&lt;哨兵节点IP/域名, 哨兵端口&gt;</span></span><br><span class="line">    <span class="comment">/// 示例：&#123;&#123;&quot;127.0.0.1&quot;, 26379&#125;, &#123;&quot;127.0.0.1&quot;, 26380&#125;&#125;</span></span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, <span class="type">int</span>&gt;&gt; nodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 连接哨兵节点的超时时间，默认100毫秒</span></span><br><span class="line">    <span class="comment">/// 超过该时间未建立连接则视为连接失败</span></span><br><span class="line">    std::chrono::milliseconds connect_timeout&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 与哨兵节点通信的Socket超时时间，默认100毫秒</span></span><br><span class="line">    <span class="comment">/// 超过该时间未收到哨兵响应则视为通信失败</span></span><br><span class="line">    std::chrono::milliseconds socket_timeout&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 连接哨兵失败后的重试间隔，默认100毫秒</span></span><br><span class="line">    std::chrono::milliseconds retry_interval&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 连接哨兵的最大重试次数，默认2次</span></span><br><span class="line">    <span class="comment">/// 达到该次数仍失败则整体连接流程终止</span></span><br><span class="line">    std::<span class="type">size_t</span> max_retry = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 哨兵认证的用户名，默认值为&quot;default&quot;（Redis 6.0+ 新增的ACL用户认证）</span></span><br><span class="line">    std::string user = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 哨兵认证的密码（如果哨兵节点配置了密码验证，需填写此项）</span></span><br><span class="line">    std::string password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 是否启用TCP Keep-Alive机制，默认true</span></span><br><span class="line">    <span class="comment">/// 作用：检测无效的连接，避免长时间空闲的连接被断开</span></span><br><span class="line">    <span class="type">bool</span> keep_alive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// TLS/SSL连接配置选项（如果哨兵节点启用了TLS加密，需配置此项）</span></span><br><span class="line">    tls::TlsOptions tls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 指定与哨兵通信使用的Redis RESP协议版本，默认2（RESP2）</span></span><br><span class="line">    <span class="comment">/// 可选值：2（RESP2）、3（RESP3），需与哨兵节点的协议版本匹配</span></span><br><span class="line">    <span class="type">int</span> resp = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、Redis-类（单机-主从-哨兵模式核心客户端）"><a href="#四、Redis-类（单机-主从-哨兵模式核心客户端）" class="headerlink" title="四、Redis 类（单机&#x2F;主从&#x2F;哨兵模式核心客户端）"></a>四、Redis 类（单机&#x2F;主从&#x2F;哨兵模式核心客户端）</h1><ul>
<li>作为 Redis++ 最基础且核心的“<strong>客户端类</strong>”，封装了所有 Redis 原生命令的调用接口</li>
<li>支持<strong>单机、主从、哨兵</strong>三种部署模式的连接与操作，是生产环境中最常用的类</li>
</ul>
<p><strong>注！！</strong>：单机、主从、哨兵等部署模式都是<strong>由“服务端”配置</strong>，Redis类只负责连接到已存在的部署模式</p>
<h2 id="1-Redis类介绍"><a href="#1-Redis类介绍" class="headerlink" title="1.Redis类介绍"></a>1.Redis类介绍</h2><h3 id="（1）Redis类的关键实现细节"><a href="#（1）Redis类的关键实现细节" class="headerlink" title="（1）Redis类的关键实现细节"></a>（1）Redis类的关键实现细节</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Redis</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 基础构造：通过连接选项 + 连接池选项初始化（最常用）</span></span><br><span class="line">    <span class="comment">/// @param connection_opts 连接选项</span></span><br><span class="line">    <span class="comment">/// @param pool_opts 连接池选项</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Redis</span><span class="params">(<span class="type">const</span> ConnectionOptions &amp;connection_opts,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> ConnectionPoolOptions &amp;pool_opts = &#123;&#125;)</span></span></span><br><span class="line"><span class="function">                	:_pool(std::make_shared&lt;ConnectionPool&gt;(pool_opts, connection_opts)) </span></span><br><span class="line"><span class="function">                	&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 简化构造：通过 URI 字符串直接初始化（快速配置场景）</span></span><br><span class="line">    <span class="comment">/// @brief 用 URI 字符串构造 Redis 实例（简化配置，无需手动组装 ConnectionOptions）</span></span><br><span class="line">    <span class="comment">/// @param uri URI 格式说明：</span></span><br><span class="line">    <span class="comment">///     - TCP 连接：tcp://[[username:]password@]host[:port][/db]</span></span><br><span class="line">    <span class="comment">///         - 示例：&quot;tcp://127.0.0.1&quot;、&quot;tcp://user:pass@127.0.0.1:6379/0&quot;（连接 0 号库）</span></span><br><span class="line">    <span class="comment">///     - Unix 套接字连接：unix://[[username:]password@]path-to-unix-domain-socket[/db]</span></span><br><span class="line">    <span class="comment">///         - 示例：&quot;unix:///tmp/redis.sock&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Redis</span><span class="params">(<span class="type">const</span> std::string &amp;uri)</span> : Redis(Uri(uri)) &#123;</span>&#125;  <span class="comment">// 内部转发给 Uri 解析后的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 哨兵模式构造：通过 Redis Sentinel 自动发现节点（高可用场景）</span></span><br><span class="line">    <span class="comment">/// @brief 基于 Redis 哨兵模式构造 Redis 实例（自动获取主从节点信息，支持故障自动切换）</span></span><br><span class="line">    <span class="comment">/// @param sentinel Sentinel 实例的智能指针（用于与哨兵集群通信）</span></span><br><span class="line">    <span class="comment">/// @param master_name 主节点名称（哨兵集群监控的主节点标识）</span></span><br><span class="line">    <span class="comment">/// @param role 连接角色：</span></span><br><span class="line">    <span class="comment">///     - Role::MASTER: 连接主节点（用于写操作）</span></span><br><span class="line">    <span class="comment">///     - Role::SLAVE: 连接从节点（用于读操作，实现读写分离）</span></span><br><span class="line">    <span class="comment">/// @param connection_opts 连接选项（同基础构造，可配置 KeepAlive 等）</span></span><br><span class="line">    <span class="comment">/// @param pool_opts 连接池选项（同基础构造，默认使用默认配置）</span></span><br><span class="line">    <span class="built_in">Redis</span>(<span class="type">const</span> std::shared_ptr&lt;Sentinel&gt; &amp;sentinel,</span><br><span class="line">          <span class="type">const</span> std::string &amp;master_name,</span><br><span class="line">          Role role,</span><br><span class="line">          <span class="type">const</span> ConnectionOptions &amp;connection_opts,</span><br><span class="line">          <span class="type">const</span> ConnectionPoolOptions &amp;pool_opts = &#123;&#125;)</span><br><span class="line">          : _pool(std::<span class="built_in">make_shared</span>&lt;ConnectionPool&gt;(<span class="built_in">SimpleSentinel</span>(sentinel, master_name, role),</span><br><span class="line">                                                   pool_opts,</span><br><span class="line">                                                   connection_opts)) </span><br><span class="line">          &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Redis</span>(<span class="type">const</span> Redis &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Redis&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Redis &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Redis</span>(Redis &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Redis&amp; <span class="keyword">operator</span>=(Redis &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;ConnectionPool&gt; _pool;  <span class="comment">// 核心成员：连接池智能指针（管理 Redis 连接）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（2）数据类型-操作对照表"><a href="#（2）数据类型-操作对照表" class="headerlink" title="（2）数据类型 &amp; 操作对照表"></a>（2）数据类型 &amp; 操作对照表</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113145948394.png"></p>
<h3 id="（3）key、管道、事务、发布订阅等功能"><a href="#（3）key、管道、事务、发布订阅等功能" class="headerlink" title="（3）key、管道、事务、发布订阅等功能"></a>（3）key、管道、事务、发布订阅等功能</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113150625783.png"></p>
<h2 id="2-Redis类-适配“单机模式”"><a href="#2-Redis类-适配“单机模式”" class="headerlink" title="2.Redis类 适配“单机模式”"></a>2.Redis类 适配“单机模式”</h2><h3 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li>Redis类直接连接单个Redis节点，部署简单但无高可用保障</li>
<li><strong>服务端部署！！</strong>：<ul>
<li>Linux上安装Redis后，直接启动即可</li>
</ul>
</li>
</ul>
<h3 id="（2）代码实现"><a href="#（2）代码实现" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h3><p><a href="#ConnectionOptions">ConnectionOptions结构体</a><br><a href="#ConnectionPoolOptions">ConnectionPoolOptions结构体</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(Redis &amp;redis, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            std::string key = <span class="string">&quot;key_&quot;</span> + std::<span class="built_in">to_string</span>(id) + <span class="string">&quot;_&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">            redis.<span class="built_in">set</span>(key, <span class="string">&quot;value_&quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (val) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error &amp;e) &#123;</span><br><span class="line">        <span class="comment">// ✅ 线程内部捕获异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;✗ 线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConnectionOptions conn_opts;</span><br><span class="line">    conn_opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    conn_opts.port = <span class="number">6379</span>;</span><br><span class="line">    conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    ConnectionPoolOptions pool_opts;</span><br><span class="line">    pool_opts.size = <span class="number">5</span>;</span><br><span class="line">    pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    pool_opts.connection_lifetime = std::chrono::<span class="built_in">minutes</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 Redis 对象（可能失败） </span></span><br><span class="line">    std::unique_ptr&lt;Redis&gt; redis;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redis = std::<span class="built_in">make_unique</span>&lt;Redis&gt;(conn_opts, pool_opts);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✓ Redis 连接成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;✗ Redis 连接失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 连接失败，直接退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(*redis), i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;✓ 所有线程完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Redis类-适配“主从复制模式”"><a href="#3-Redis类-适配“主从复制模式”" class="headerlink" title="3.Redis类 适配“主从复制模式”"></a>3.Redis类 适配“主从复制模式”</h2><h3 id="（1）介绍-1"><a href="#（1）介绍-1" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li>适配读多写少的生产场景，包含一个主节点（写入）和多个从节点（读取）</li>
<li>分别创建Redis类，按“单机模式“连接方式分别连接“主节点、从节点”即可（通过<strong>ip：port</strong>）</li>
<li><strong>服务端部署！！</strong>：<ul>
<li>服务端需<strong>手动“配置主从”</strong></li>
</ul>
</li>
</ul>
<h3 id="（2）代码实现-1"><a href="#（2）代码实现-1" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h3><p><a href="#ConnectionOptions">ConnectionOptions结构体</a><br><a href="#ConnectionPoolOptions">ConnectionPoolOptions结构体</a><br><strong>假设主从复制模式配置如下</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主节点</span><br><span class="line">127.0.0.1：6370</span><br><span class="line"></span><br><span class="line"># 从节点1</span><br><span class="line">127.0.0.1：6380</span><br><span class="line"></span><br><span class="line"># 从节点2</span><br><span class="line">127.0.0.1:6381</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ==================== 配置参数 ====================</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主节点配置</span></span><br><span class="line">        std::string master_host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> master_port = <span class="number">6379</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从节点配置</span></span><br><span class="line">        std::vector&lt;std::pair&lt;std::string, <span class="type">int</span>&gt;&gt; slaves = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>&#125;,  <span class="comment">// 从节点1</span></span><br><span class="line">            &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6381</span>&#125;   <span class="comment">// 从节点2</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        std::string password = <span class="string">&quot;&quot;</span>;  <span class="comment">// 如果有密码，填写在这里</span></span><br><span class="line">        <span class="type">size_t</span> pool_size = <span class="number">3</span>;       <span class="comment">// 连接池大小</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ==================== 1. 连接主节点 ====================</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;=== 连接主节点 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        ConnectionOptions master_opts;</span><br><span class="line">        master_opts.host = master_host;</span><br><span class="line">        master_opts.port = master_port;</span><br><span class="line">        master_opts.password = password;</span><br><span class="line">        master_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">        master_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        ConnectionPoolOptions pool_opts;</span><br><span class="line">        pool_opts.size = pool_size;</span><br><span class="line">        pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> master = <span class="built_in">Redis</span>(master_opts, pool_opts);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✓ 主节点连接成功：&quot;</span> &lt;&lt; master_host &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; master_port &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ==================== 2. 连接从节点 ====================</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n=== 连接从节点 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        std::vector&lt;Redis&gt; slave_clients;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [host, port] : slaves) &#123;</span><br><span class="line">            ConnectionOptions slave_opts;</span><br><span class="line">            slave_opts.host = host;</span><br><span class="line">            slave_opts.port = port;</span><br><span class="line">            slave_opts.password = password;</span><br><span class="line">            slave_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">            slave_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">            </span><br><span class="line">            slave_clients.<span class="built_in">emplace_back</span>(<span class="built_in">Redis</span>(slave_opts, pool_opts));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;✓ 从节点连接成功：&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Redis类-适配“哨兵模式”"><a href="#4-Redis类-适配“哨兵模式”" class="headerlink" title="4.Redis类 适配“哨兵模式”"></a>4.Redis类 适配“哨兵模式”</h2><h3 id="（1）介绍-2"><a href="#（1）介绍-2" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li>“哨兵模式”为Redis提供了高可用性，但相较于前两中模式，要复杂一点</li>
<li>“哨兵模式”需要用到“<strong>Sentinel类</strong>”（哨兵类）</li>
<li><strong>服务端部署！！</strong>：<ul>
<li>服务端需手动**“配置主从”**（<strong>哨兵模式的基础</strong>）</li>
<li>服务器序手动创建“<strong>哨兵节点</strong>”</li>
</ul>
</li>
</ul>
<h3 id="（2）代码实现-2"><a href="#（2）代码实现-2" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h3><p><a href="#ConnectionOptions">ConnectionOptions结构体</a><br><a href="#ConnectionPoolOptions">ConnectionPoolOptions结构体</a><br><strong>推荐先看</strong>：<a href="#Sentinel">Sentinel类</a><br><strong>假设哨兵模式配置如下</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主节点</span><br><span class="line">127.0.0.1：6370</span><br><span class="line"></span><br><span class="line"># 从节点</span><br><span class="line">127.0.0.1：6380</span><br><span class="line">127.0.0.1：6381</span><br><span class="line"></span><br><span class="line"># 哨兵节点</span><br><span class="line">127.0.0.1：9000</span><br><span class="line">127.0.0.1：9001</span><br><span class="line">127.0.0.1：9002</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 1. 哨兵配置 ============</span></span><br><span class="line">    SentinelOptions sentinel_opts;</span><br><span class="line">    sentinel_opts.nodes = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9001</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9002</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    sentinel_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    sentinel_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> sentinel = std::<span class="built_in">make_shared</span>&lt;Sentinel&gt;(sentinel_opts);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============ 2. 连接配置 ============</span></span><br><span class="line">    ConnectionOptions conn_opts;</span><br><span class="line">    conn_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    ConnectionPoolOptions pool_opts;</span><br><span class="line">    pool_opts.size = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============ 3. 创建主节点 ============</span></span><br><span class="line">    <span class="keyword">auto</span> master = <span class="built_in">Redis</span>(sentinel, </span><br><span class="line">                        <span class="string">&quot;mymaster&quot;</span>,  	<span class="comment">// 这是在哨兵配置文件中定义的主节点名称</span></span><br><span class="line">                        Role::MASTER,   <span class="comment">// 角色</span></span><br><span class="line">                        conn_opts, </span><br><span class="line">                        pool_opts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 4. 创建从节点 ============</span></span><br><span class="line">    <span class="keyword">auto</span> slave = <span class="built_in">Redis</span>(sentinel, </span><br><span class="line">                        <span class="string">&quot;mymaster&quot;</span>, 	<span class="comment">// 这是在哨兵配置文件中定义的主节点名称</span></span><br><span class="line">                        Role::SLAVE, 	<span class="comment">// 角色</span></span><br><span class="line">                        conn_opts, </span><br><span class="line">                        pool_opts);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;✅ 从节点连接成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>不需要手动指定“主节点”、“从节点”的ip:port</strong><ul>
<li>节点的分配都有“<strong>Sentinel类</strong>”（哨兵类）完成</li>
</ul>
</li>
</ul>
<h3 id="（3）为什么需要“哨兵模式”？"><a href="#（3）为什么需要“哨兵模式”？" class="headerlink" title="（3）为什么需要“哨兵模式”？"></a>（3）为什么需要“哨兵模式”？</h3><h4 id="核心问题"><a href="#核心问题" class="headerlink" title="&lt;1&gt;核心问题"></a>&lt;1&gt;核心问题</h4><p><strong>❌ 主从复制模式的致命缺陷</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">主从复制模式 = 手动管理 + 单点故障</span><br><span class="line"></span><br><span class="line">客户端连接：</span><br><span class="line">master_redis = <span class="built_in">Redis</span>(<span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">slave_redis  = <span class="built_in">Redis</span>(<span class="string">&quot;127.0.0.1:6380&quot;</span>)</span><br><span class="line"></span><br><span class="line">问题<span class="number">1</span>：主节点宕机</span><br><span class="line">→ master_redis 连接失效</span><br><span class="line">→ 抛出异常：Connection refused</span><br><span class="line">→ 写操作全部失败</span><br><span class="line">→ 需要人工介入：</span><br><span class="line">   <span class="number">1.</span> 手动提升从节点（SLAVEOF NO ONE）</span><br><span class="line">   <span class="number">2.</span> 修改代码中的主节点地址</span><br><span class="line">   <span class="number">3.</span> 重启应用程序</span><br><span class="line"></span><br><span class="line">问题<span class="number">2</span>：从节点宕机</span><br><span class="line">→ slave_redis 连接失效</span><br><span class="line">→ 抛出异常：Connection refused</span><br><span class="line">→ 读操作失败</span><br><span class="line">→ 需要人工切换到其他从节点</span><br></pre></td></tr></table></figure>

<p><strong>核心矛盾</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">客户端 <span class="code">`Redis`</span> 对象 = 静态连接（固定 <span class="code">`IP:Port`</span>）</span><br><span class="line">服务端节点状态   = 动态变化（宕机/切换/新增）</span><br><span class="line"></span><br><span class="line">→ 两者无法自动同步</span><br><span class="line">→ 需要人工干预</span><br><span class="line">→ 高可用性差</span><br></pre></td></tr></table></figure>

<h4 id="哨兵模式的解决方案"><a href="#哨兵模式的解决方案" class="headerlink" title="&lt;2&gt;哨兵模式的解决方案"></a>&lt;2&gt;哨兵模式的解决方案</h4><p><strong>核心思想</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引入中间层：Sentinel</span><br><span class="line">作用：动态感知节点变化，自动更新客户端连接</span><br></pre></td></tr></table></figure>
<p><strong>框架设计</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">传统模式（静态连接）：</span><br><span class="line">应用程序 → Redis 对象 → 固定节点 (<span class="code">`127.0.0.1:6379`</span>)</span><br><span class="line"><span class="code">              ↓ 节点宕机</span></span><br><span class="line"><span class="code">         连接失效，抛出异常</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">哨兵模式（动态连接）：</span><br><span class="line">应用程序 → Sentinel → 哨兵集群 (监控节点状态)</span><br><span class="line"><span class="code">              ↓                  ↓</span></span><br><span class="line"><span class="code">         Redis 对象 ←─── 动态获取可用节点</span></span><br><span class="line"><span class="code">              ↓</span></span><br><span class="line"><span class="code">         当前主节点 (`127.0.0.1:6379`)</span></span><br><span class="line"><span class="code">              ↓ 主节点宕机</span></span><br><span class="line"><span class="code">         哨兵检测 → 选举新主节点 (`127.0.0.1:6380`)</span></span><br><span class="line"><span class="code">              ↓</span></span><br><span class="line"><span class="code">         Sentinel 自动通知 Redis 对象</span></span><br><span class="line"><span class="code">              ↓</span></span><br><span class="line"><span class="code">         Redis 对象自动重连新主节点</span></span><br><span class="line"><span class="code">              ↓</span></span><br><span class="line"><span class="code">         应用程序无感知，继续正常工作</span></span><br></pre></td></tr></table></figure>
<h4 id="Redis-的实现细节（简要版）"><a href="#Redis-的实现细节（简要版）" class="headerlink" title="&lt;3&gt;Redis++ 的实现细节（简要版）"></a>&lt;3&gt;Redis++ 的实现细节（简要版）</h4><ol>
<li><strong>传统模式</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 静态连接</span></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主节点宕机</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">// → 抛出异常：Connection refused</span></span><br><span class="line"><span class="comment">// → 无法自动恢复</span></span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>Redis 对象只知道创建时的固定地址</li>
<li>节点变化时，无法自动更新连接</li>
<li>需要手动修改代码并重启</li>
</ul>
<ol start="2">
<li><strong>哨兵模式（Sentinel + Redis）</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 动态连接</span></span><br><span class="line">SentinelOptions sentinel_opts;</span><br><span class="line">sentinel_opts.nodes = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26379</span>&#125;,  <span class="comment">// 哨兵1</span></span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26380</span>&#125;,  <span class="comment">// 哨兵2</span></span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26381</span>&#125;   <span class="comment">// 哨兵3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> sentinel = std::<span class="built_in">make_shared</span>&lt;Sentinel&gt;(sentinel_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接配置</span></span><br><span class="line">ConnectionOptions conn_opts;</span><br><span class="line">conn_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Sentinel 创建 Redis 对象</span></span><br><span class="line">    <span class="keyword">auto</span> master = <span class="built_in">Redis</span>(sentinel, </span><br><span class="line">        <span class="string">&quot;mymaster&quot;</span>,      <span class="comment">// 这是在哨兵配置文件中定义的主节点名称</span></span><br><span class="line">        Role::MASTER,   <span class="comment">// 角色</span></span><br><span class="line">        conn_opts, </span><br><span class="line">        pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部机制：</span></span><br><span class="line"><span class="comment">// 1. Redis 对象持有 Sentinel 的引用</span></span><br><span class="line"><span class="comment">// 2. 发现连接失效时，调用 Sentinel 查询新主节点</span></span><br><span class="line"><span class="comment">// 3. 自动重连新主节点</span></span><br><span class="line"><span class="comment">// 4. 重试失败的操作</span></span><br></pre></td></tr></table></figure>
<p><strong>内部流程</strong>（伪代码）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Redis</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Sentinel&gt; sentinel_;  <span class="comment">// 持有 Sentinel 引用</span></span><br><span class="line">    std::string master_name_;</span><br><span class="line">    Connection* conn_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过 Sentinel 创建</span></span><br><span class="line">    <span class="built_in">Redis</span>(std::shared_ptr&lt;Sentinel&gt; sentinel, </span><br><span class="line">          <span class="type">const</span> std::string&amp; master_name) </span><br><span class="line">        : <span class="built_in">sentinel_</span>(sentinel), <span class="built_in">master_name_</span>(master_name) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始连接</span></span><br><span class="line">        <span class="keyword">auto</span> [host, port] = sentinel_-&gt;<span class="built_in">getMasterAddr</span>(master_name_);</span><br><span class="line">        conn_ = <span class="built_in">connect</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn_-&gt;<span class="built_in">send</span>(<span class="string">&quot;SET&quot;</span>, key, value);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> ConnectionError&amp; e) &#123;</span><br><span class="line">            <span class="comment">// 连接失效，自动重连</span></span><br><span class="line">            <span class="built_in">reconnect</span>();</span><br><span class="line">            <span class="comment">// 重试操作</span></span><br><span class="line">            conn_-&gt;<span class="built_in">send</span>(<span class="string">&quot;SET&quot;</span>, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动重连</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 Sentinel 查询新主节点</span></span><br><span class="line">        <span class="keyword">auto</span> [host, port] = sentinel_-&gt;<span class="built_in">getMasterAddr</span>(master_name_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 销毁旧连接</span></span><br><span class="line">        <span class="keyword">delete</span> conn_;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重连新主节点</span></span><br><span class="line">        conn_ = <span class="built_in">connect</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="“主从复制模式”-vs-“哨兵模式”"><a href="#“主从复制模式”-vs-“哨兵模式”" class="headerlink" title="&lt;4&gt;“主从复制模式” vs “哨兵模式”"></a>&lt;4&gt;“主从复制模式” vs “哨兵模式”</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113224050272.png"></p>
<h2 id="5-注意事项！！"><a href="#5-注意事项！！" class="headerlink" title="5.注意事项！！"></a>5.注意事项！！</h2><ul>
<li><p>Redis 类对象是<strong>线程安全</strong>的，生产环境可全局共享一个实例（基于连接池实现线程隔离），无需每个线程创建单独对象；</p>
</li>
<li><p>所有Redis命令调用可能会抛出sw::redis::Error异常，应当捕获并妥善处理（如重连、告警、日志记录等）；</p>
</li>
<li><p>哨兵模式下，只需在 conn_opts.host 填写任意一个哨兵节点地址，客户端会自动发现主从节点；</p>
</li>
<li><p>避免长时间持有 Redis 对象的引用，使用完毕后及时释放，让连接池回收连接。</p>
</li>
</ul>
<p><a id="Sentinel"></a></p>
<h1 id="五、Sentinel"><a href="#五、Sentinel" class="headerlink" title="五、Sentinel"></a>五、Sentinel</h1><p>Sentinel 类是 Redis++ 中专门用于与 <strong>Redis Sentinel 哨兵集群</strong> 通信的组件，功能：</p>
<ul>
<li>服务发现 <ul>
<li>从哨兵集群获取当前主库&#x2F;从库的地址</li>
</ul>
</li>
<li>故障透明 <ul>
<li>故障切换时<strong>自动获取新主库地址</strong></li>
</ul>
</li>
<li>连接中介 <ul>
<li>作为 Redis 对象和实际 Redis 实例之间的桥梁</li>
</ul>
</li>
</ul>
<h2 id="1-Sentinel类的职责"><a href="#1-Sentinel类的职责" class="headerlink" title="1.Sentinel类的职责"></a>1.Sentinel类的职责</h2><ul>
<li><strong>使用 Role::MASTER</strong>：<ul>
<li>redis-plus-plus <strong>总是连接到当前的master</strong>（即使发生故障切换）。</li>
<li>每次 redis-plus-plus 需要“为master创建一个新的连接”，或者“连接断开并且需要重新连接到master”时<ul>
<li>redis-plus-plus 会向 Redis Sentinel 询问master地址，并连接到当前的master。</li>
</ul>
</li>
<li><strong>发生故障切换</strong><ul>
<li>redis-plus-plus 可以自动获取新master的地址，并<strong>刷新底层连接池中的所有连地址接（连接到新的master）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用 Role::SLAVE</strong><ul>
<li>redis-plus-plus <strong>总是连接到slave</strong>。</li>
<li>一个主节点可能有多个slave，redis-plus-plus 会<strong>随机选一个并连接到它</strong><ul>
<li><strong>底层连接池中的所有连接都连接到同一个slave</strong></li>
</ul>
</li>
<li><strong>如果连接断开，且该slave仍为活体</strong><ul>
<li>redis-plus-plus 将重新连接该从属实例</li>
</ul>
</li>
<li><strong>如果该salve宕机，或者被提升为master</strong><ul>
<li>redis-plus-plus 会随机连接到另一个slave。</li>
<li>如果没有活着的slave，它会抛出例外。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-Sentinel类的关键实现细节"><a href="#2-Sentinel类的关键实现细节" class="headerlink" title="2.Sentinel类的关键实现细节"></a>2.Sentinel类的关键实现细节</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sentinel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sentinel</span><span class="params">(<span class="type">const</span> SentinelOptions &amp;sentinel_opts)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sentinel</span>(<span class="type">const</span> Sentinel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Sentinel&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sentinel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sentinel</span>(Sentinel &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Sentinel&amp; <span class="keyword">operator</span>=(Sentinel &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Sentinel</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h2 id="3-Sentinel-类的使用方式"><a href="#3-Sentinel-类的使用方式" class="headerlink" title="3.Sentinel 类的使用方式"></a>3.Sentinel 类的使用方式</h2><p><a href="#SentinelOptions">SentinelOptions结构体</a></p>
<h3 id="（1）创建-Sentinel-对象"><a href="#（1）创建-Sentinel-对象" class="headerlink" title="（1）创建 Sentinel 对象"></a>（1）创建 Sentinel 对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"><span class="comment">// 配置哨兵选项</span></span><br><span class="line">SentinelOptions sentinel_opts;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【必需】哨兵节点列表（至少配置一个，建议三个以上保证高可用）</span></span><br><span class="line">sentinel_opts.nodes = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26379</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26380</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26381</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【可选】连接哨兵的超时时间，默认 100ms ——&gt;注：不能为0</span></span><br><span class="line">sentinel_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【可选】请求/响应超时时间，默认 100ms  ——&gt;注：不能为0</span></span><br><span class="line">sentinel_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Sentinel 共享指针（必须用 shared_ptr）</span></span><br><span class="line"><span class="keyword">auto</span> sentinel = std::<span class="built_in">make_shared</span>&lt;Sentinel&gt;(sentinel_opts);</span><br></pre></td></tr></table></figure>

<h3 id="（2）通过-Sentinel-创建-Redis-连接"><a href="#（2）通过-Sentinel-创建-Redis-连接" class="headerlink" title="（2）通过 Sentinel 创建 Redis 连接"></a>（2）通过 Sentinel 创建 Redis 连接</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// =============== 1.创建哨兵 ===============</span></span><br><span class="line"><span class="comment">// 配置哨兵选项</span></span><br><span class="line">SentinelOptions sentinel_opts;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【必需】哨兵节点列表（至少配置一个，建议三个以上保证高可用）</span></span><br><span class="line">sentinel_opts.nodes = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26379</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26380</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26381</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【可选】连接哨兵的超时时间，默认 100ms ——&gt;注：不能为0</span></span><br><span class="line">sentinel_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【可选】请求/响应超时时间，默认 100ms  ——&gt;注：不能为0</span></span><br><span class="line">sentinel_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Sentinel 共享指针（必须用 shared_ptr）</span></span><br><span class="line"><span class="keyword">auto</span> sentinel = std::<span class="built_in">make_shared</span>&lt;Sentinel&gt;(sentinel_opts);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============== 2.创建Redis连接配置 ===============</span></span><br><span class="line"><span class="comment">// 连接配置</span></span><br><span class="line">ConnectionOptions conn_opts;</span><br><span class="line">conn_opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">conn_opts.port = <span class="number">6379</span>;</span><br><span class="line">conn_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);   <span class="comment">// 必须设置！不能为 0</span></span><br><span class="line">conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);    <span class="comment">// 必须设置！不能为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池配置</span></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">5</span>;  <span class="comment">// 连接池大小：5个连接</span></span><br><span class="line">pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);  <span class="comment">// 等待连接超时</span></span><br><span class="line">pool_opts.connection_lifetime = std::chrono::<span class="built_in">minutes</span>(<span class="number">10</span>); <span class="comment">// 连接生命周期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============== 3.创建Redis主节点 ===============</span></span><br><span class="line"><span class="comment">// 创建连接主库的 Redis 对象</span></span><br><span class="line"><span class="keyword">auto</span> master = <span class="built_in">Redis</span>(sentinel,</span><br><span class="line">                    <span class="string">&quot;mymaster&quot;</span>,	 	<span class="comment">// Name of master node</span></span><br><span class="line">                    Role::MASTER, 	<span class="comment">// 角色</span></span><br><span class="line">                    conn_opts, </span><br><span class="line">                    pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =============== 3.创建Redis从节点 ===============</span></span><br><span class="line"><span class="comment">// 创建连接从库的 Redis 对象</span></span><br><span class="line"><span class="keyword">auto</span> slave = <span class="built_in">Redis</span>(sentinel, </span><br><span class="line">                   <span class="string">&quot;mymaster&quot;</span>,		<span class="comment">// Name of master node </span></span><br><span class="line">                   Role::SLAVE, 	<span class="comment">// 角色</span></span><br><span class="line">                   conn_opts, </span><br><span class="line">                   pool_opts);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>不需要手动指定“主节点&#x2F;从节点”的ip：port</strong>，由Sentinel自动分配</li>
</ul>
<h1 id="六、RedisCluster（集群模式客户端）"><a href="#六、RedisCluster（集群模式客户端）" class="headerlink" title="六、RedisCluster（集群模式客户端）"></a>六、RedisCluster（集群模式客户端）</h1><ul>
<li>RedisCluster类是集群模式下“客户端”连接“服务端”的句柄，向服务端发送请求<ul>
<li>redis-plus-plus 客户端库<strong>不负责创建集群</strong>，它只负责<strong>连接到已存在的集群</strong>。</li>
</ul>
</li>
<li><strong>接口与 Redis 类类似！！</strong></li>
</ul>
<h2 id="1-RedisCluster类-的构造"><a href="#1-RedisCluster类-的构造" class="headerlink" title="1.RedisCluster类 的构造"></a>1.RedisCluster类 的构造</h2><h3 id="（1）构造函数"><a href="#（1）构造函数" class="headerlink" title="（1）构造函数"></a>（1）构造函数</h3><h4 id="基本构造函数"><a href="#基本构造函数" class="headerlink" title="&lt;1&gt;基本构造函数"></a>&lt;1&gt;基本构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RedisCluster</span>(<span class="type">const</span> ConnectionOptions &amp;connection_opts,</span><br><span class="line">             <span class="type">const</span> ConnectionPoolOptions &amp;pool_opts = &#123;&#125;,    <span class="comment">//默认为每个主节点维护单一连接</span></span><br><span class="line">             Role role = Role::MASTER,</span><br><span class="line">             <span class="type">const</span> ClusterOptions &amp;cluster_opts = &#123;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113163903839.png"></p>
<h4 id="URL构造函数"><a href="#URL构造函数" class="headerlink" title="&lt;2&gt;URL构造函数"></a>&lt;2&gt;URL构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如： &quot;tcp://127.0.0.1&quot; or &quot;tcp://127.0.0.1:6379&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">RedisCluster</span><span class="params">(<span class="type">const</span> std::string &amp;uri)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>限制</strong>：</p>
<ul>
<li>❌ 无法指定密码</li>
<li>❌ 只能使用默认连接池配置（size&#x3D;1）</li>
</ul>
<h3 id="（2）配置选项"><a href="#（2）配置选项" class="headerlink" title="（2）配置选项"></a>（2）配置选项</h3><h4 id="ConnectionOptions（连接配置）"><a href="#ConnectionOptions（连接配置）" class="headerlink" title="&lt;1&gt;ConnectionOptions（连接配置）"></a>&lt;1&gt;ConnectionOptions（连接配置）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">connection_options.host = <span class="string">&quot;127.0.0.1&quot;</span>;  <span class="comment">// 必需：任意一个主节点</span></span><br><span class="line">connection_options.port = <span class="number">7000</span>;         <span class="comment">// 可选：默认 6379</span></span><br><span class="line">connection_options.password = <span class="string">&quot;auth&quot;</span>;   <span class="comment">// 可选：集群密码（所有节点相同）</span></span><br><span class="line">connection_options.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">connection_options.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">connection_options.keep_alive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 集群模式下被忽略</span></span><br><span class="line">connection_options.db = <span class="number">0</span>;  <span class="comment">// Redis Cluster 不支持多数据库</span></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ul>
<li><p>⚠️ 只能使用 TCP 连接，<strong>不支持 Unix Domain Socket</strong></p>
</li>
<li><p>⚠️ 所有节点<strong>必须使用相同的密码</strong></p>
</li>
<li><p>⚠️ db 参数被忽略（集群不支持多数据库）</p>
</li>
</ul>
<p><strong>自动发现机制</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只需配置一个主节点</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">RedisCluster 发送 CLUSTER SLOTS 命令</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">自动获取所有节点信息并建立连接</span><br></pre></td></tr></table></figure>

<h4 id="ConnectionPoolOptions（连接池配置）"><a href="#ConnectionPoolOptions（连接池配置）" class="headerlink" title="&lt;2&gt;ConnectionPoolOptions（连接池配置）"></a>&lt;2&gt;ConnectionPoolOptions（连接池配置）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line">pool_options.size = <span class="number">3</span>;  <span class="comment">// 每个节点的连接数</span></span><br><span class="line">pool_options.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">pool_options.connection_lifetime = std::chrono::<span class="built_in">minutes</span>(<span class="number">10</span>);</span><br><span class="line">pool_options.connection_idle_time = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>工作原理</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设集群有 3 个主节点，且pool_options.size = 3</span><br><span class="line"></span><br><span class="line">节点1 (127.0.0.1:7000) → 连接池 [conn1, conn2, conn3]</span><br><span class="line">节点2 (127.0.0.1:7001) → 连接池 [conn1, conn2, conn3]</span><br><span class="line">节点3 (127.0.0.1:7002) → 连接池 [conn1, conn2, conn3]</span><br><span class="line"></span><br><span class="line">总连接数 = 3 节点 × 3 连接 = 9 个连接</span><br></pre></td></tr></table></figure>

<h4 id="ClusterOptions（集群配置）"><a href="#ClusterOptions（集群配置）" class="headerlink" title="&lt;3&gt;ClusterOptions（集群配置）"></a>&lt;3&gt;ClusterOptions（集群配置）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ClusterOptions</span> &#123;</span><br><span class="line">    <span class="comment">//刷新“槽位-节点”映射的时间</span></span><br><span class="line">    std::chrono::milliseconds slot_map_refresh_interval = std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：</p>
<ul>
<li><p>🔄 定期刷新槽位-节点映射（默认 10 秒）</p>
</li>
<li><p>🔄 同时刷新节点列表（自动发现新节点&#x2F;移除下线节点）</p>
</li>
</ul>
<p><strong>刷新触发条件</strong>：</p>
<ol>
<li><p>定时刷新：每 10 秒（可配置）</p>
</li>
<li><p>错误触发：收到 MOVED&#x2F;ASK 重定向时立即刷新</p>
</li>
</ol>
<h3 id="（3）创建实例的方式"><a href="#（3）创建实例的方式" class="headerlink" title="（3）创建实例的方式"></a>（3）创建实例的方式</h3><h4 id="使用-URI（最简单）"><a href="#使用-URI（最简单）" class="headerlink" title="&lt;1&gt;使用 URI（最简单）"></a>&lt;1&gt;使用 URI（最简单）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只指定一个节点，自动发现其他节点</span></span><br><span class="line"><span class="keyword">auto</span> redis = sw::redis::<span class="built_in">RedisCluster</span>(<span class="string">&quot;tcp://127.0.0.1:7000&quot;</span>);</span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：代码简洁<br><strong>缺点</strong>：无法配置密码、连接池大小</p>
<h4 id="标准配置（推荐）"><a href="#标准配置（推荐）" class="headerlink" title="&lt;2&gt;标准配置（推荐）"></a>&lt;2&gt;标准配置（推荐）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 连接配置（任意一个主节点）</span></span><br><span class="line">ConnectionOptions conn_opts;</span><br><span class="line">conn_opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">conn_opts.port = <span class="number">7000</span>;</span><br><span class="line">conn_opts.password = <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line">conn_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 连接池配置（每个节点 3 个连接）</span></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line">pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 RedisCluster</span></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">RedisCluster</span>(conn_opts, pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="完整配置"><a href="#完整配置" class="headerlink" title="&lt;3&gt;完整配置"></a>&lt;3&gt;完整配置</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions conn_opts;</span><br><span class="line">conn_opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">conn_opts.port = <span class="number">7000</span>;</span><br><span class="line">conn_opts.password = <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">ClusterOptions cluster_opts;</span><br><span class="line">cluster_opts.slot_map_refresh_interval = std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">RedisCluster</span>(</span><br><span class="line">    conn_opts, </span><br><span class="line">    pool_opts, </span><br><span class="line">    Role::MASTER,      <span class="comment">// 访问主节点</span></span><br><span class="line">    cluster_opts</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="2-RedisCluster的连接机制"><a href="#2-RedisCluster的连接机制" class="headerlink" title="2.RedisCluster的连接机制"></a>2.RedisCluster的连接机制</h2><h3 id="（1）Role-MASTER-模式（默认）"><a href="#（1）Role-MASTER-模式（默认）" class="headerlink" title="（1）Role::MASTER 模式（默认）"></a>（1）Role::MASTER 模式（默认）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">RedisCluster</span>(conn_opts, pool_opts, Role::MASTER);</span><br></pre></td></tr></table></figure>
<h4 id="连接拓扑（连接所有主节点）"><a href="#连接拓扑（连接所有主节点）" class="headerlink" title="&lt;1&gt;连接拓扑（连接所有主节点）"></a>&lt;1&gt;连接拓扑（连接所有主节点）</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Redis 集群：</span><br><span class="line">┌─────────┐     ┌─────────┐     ┌─────────┐</span><br><span class="line">│ 主节点1 │     │ 主节点2 │     │ 主节点3 │</span><br><span class="line">│  :7000  │     │  :7001  │     │  :7002  │</span><br><span class="line">└────┬────┘     └────┬────┘     └────┬────┘</span><br><span class="line"><span class="code">     │               │               │</span></span><br><span class="line"><span class="code">   从节点         从节点          从节点</span></span><br><span class="line"><span class="code">   :7003          :7004          :7005</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">客户端连接：</span><br><span class="line">┌──────────┐</span><br><span class="line">│ 客户端   │</span><br><span class="line">└────┬─────┘</span><br><span class="line"><span class="code">     ├─────直连─────→ 主节点1 (:7000) [连接池 3个连接]</span></span><br><span class="line"><span class="code">     ├─────直连─────→ 主节点2 (:7001) [连接池 3个连接]</span></span><br><span class="line"><span class="code">     └─────直连─────→ 主节点3 (:7002) [连接池 3个连接]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：Role::MASTER 连接<strong>所有</strong>主节点！！</li>
</ul>
<h4 id="为什么-Role-MASTER-要连接所有主节点？"><a href="#为什么-Role-MASTER-要连接所有主节点？" class="headerlink" title="&lt;2&gt;为什么 Role::MASTER 要连接所有主节点？"></a>&lt;2&gt;为什么 Role::MASTER 要连接所有主节点？</h4><ul>
<li><strong>redis集群是对redis的水平扩容</strong>：<ul>
<li>即启动N个redis节点，将整个数据分布存储在这个<strong>N个节点</strong>中，每个节<br>点<strong>存储总数据的1&#x2F;N</strong></li>
</ul>
</li>
</ul>
<h5 id="原因1：数据分片存储"><a href="#原因1：数据分片存储" class="headerlink" title="原因1：数据分片存储"></a>原因1：数据分片存储</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091913625.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091947050.png"></p>
<h5 id="原因2：写操作必须到主节点"><a href="#原因2：写操作必须到主节点" class="headerlink" title="原因2：写操作必须到主节点"></a>原因2：写操作必须到主节点</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092102449.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单主节点设计：</span><br><span class="line">请求 → 主节点1 → MOVED → 重定向 → 主节点2/3</span><br><span class="line">           ↓ 每次都要重定向</span><br><span class="line">      性能损失：额外的网络往返</span><br><span class="line"></span><br><span class="line">多主节点设计：</span><br><span class="line">请求 → 计算槽位 → 直接找到正确节点 → 立即返回</span><br><span class="line">           ↓ 零重定向</span><br><span class="line">      性能最优：一次网络往返</span><br></pre></td></tr></table></figure>

<h3 id="（2）Role-SLAVE-模式（连接每个主节点的一个随机从节点）"><a href="#（2）Role-SLAVE-模式（连接每个主节点的一个随机从节点）" class="headerlink" title="（2）Role::SLAVE 模式（连接每个主节点的一个随机从节点）"></a>（2）Role::SLAVE 模式（连接每个主节点的一个随机从节点）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">RedisCluster</span>(conn_opts, pool_opts, Role::SLAVE);</span><br></pre></td></tr></table></figure>

<h4 id="连接拓扑"><a href="#连接拓扑" class="headerlink" title="&lt;1&gt;连接拓扑"></a>&lt;1&gt;连接拓扑</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Redis 集群：</span><br><span class="line">┌─────────┐     ┌─────────┐     ┌─────────┐</span><br><span class="line">│ 主节点1 │     │ 主节点2 │     │ 主节点3 │</span><br><span class="line">│  :7000  │     │  :7001  │     │  :7002  │</span><br><span class="line">└────┬────┘     └────┬────┘     └────┬────┘</span><br><span class="line"><span class="code">     │               │               │</span></span><br><span class="line"><span class="code">   从节点1a        从节点2a        从节点3a</span></span><br><span class="line"><span class="code">   :7003          :7004          :7005</span></span><br><span class="line"><span class="code">     │               │</span></span><br><span class="line"><span class="code">   从节点1b        从节点2b</span></span><br><span class="line"><span class="code">   :7006          :7007</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">客户端连接（Role::SLAVE 模式）：</span><br><span class="line">┌──────────┐</span><br><span class="line">│ 客户端   │</span><br><span class="line">└────┬─────┘</span><br><span class="line"><span class="code">     ├─────直连─────→ 从节点1a (:7003) [连接池 3个连接]</span></span><br><span class="line"><span class="code">     │                ↑ 随机选择主节点1的一个从节点</span></span><br><span class="line"><span class="code">     │</span></span><br><span class="line"><span class="code">     ├─────直连─────→ 从节点2a (:7004) [连接池 3个连接]</span></span><br><span class="line"><span class="code">     │                ↑ 随机选择主节点2的一个从节点</span></span><br><span class="line"><span class="code">     │</span></span><br><span class="line"><span class="code">     └─────直连─────→ 从节点3a (:7005) [连接池 3个连接]</span></span><br><span class="line"><span class="code">                      ↑ 随机选择主节点3的一个从节点</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：Role::SLAVE 连接每个主节点的一个随机从节点</p>
<h4 id="为什么-Role-SLAVE-要连接每个主节点的一个随机从节点？"><a href="#为什么-Role-SLAVE-要连接每个主节点的一个随机从节点？" class="headerlink" title="&lt;2&gt;为什么 Role::SLAVE 要连接每个主节点的一个随机从节点？"></a>&lt;2&gt;为什么 Role::SLAVE 要连接每个主节点的一个随机从节点？</h4><h5 id="原因1-保持槽位覆盖"><a href="#原因1-保持槽位覆盖" class="headerlink" title="原因1:保持槽位覆盖"></a>原因1:保持槽位覆盖</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092349865.png"></p>
<h5 id="原因2：负载均衡"><a href="#原因2：负载均衡" class="headerlink" title="原因2：负载均衡"></a>原因2：负载均衡</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092417497.png"></p>
<h5 id="为什么不是所有从节点？"><a href="#为什么不是所有从节点？" class="headerlink" title="为什么不是所有从节点？"></a>为什么不是所有从节点？</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092451027.png"></p>
<h3 id="（3）“Role-MASTER-模式”-vs-“Role-SLAVE-模式”"><a href="#（3）“Role-MASTER-模式”-vs-“Role-SLAVE-模式”" class="headerlink" title="（3）“Role::MASTER 模式” vs “Role::SLAVE 模式”"></a>（3）“Role::MASTER 模式” vs “Role::SLAVE 模式”</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091249622.png"></p>
<h3 id="（4）常见误解"><a href="#（4）常见误解" class="headerlink" title="（4）常见误解"></a>（4）常见误解</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091358906.png"></p>
<h2 id="3-RedisCluster类的注意事项"><a href="#3-RedisCluster类的注意事项" class="headerlink" title="3.RedisCluster类的注意事项"></a>3.RedisCluster类的注意事项</h2><h3 id="（1）无法直接发送“无key参数的命令”"><a href="#（1）无法直接发送“无key参数的命令”" class="headerlink" title="（1）无法直接发送“无key参数的命令”"></a>（1）无法直接发送“无key参数的命令”</h3><p>RedisCluster 对象确实可以发送大多数请求，但“key参数命令”无法直接发送</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="&lt;1&gt;问题"></a>&lt;1&gt;问题</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093548922.png"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="&lt;2&gt;解决方案"></a>&lt;2&gt;解决方案</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093630371.png"></p>
<h4 id="“RedisCluster”-vs-“RedisCluster-redis-”"><a href="#“RedisCluster”-vs-“RedisCluster-redis-”" class="headerlink" title="&lt;3&gt;“RedisCluster” vs “RedisCluster::redis()”"></a>&lt;3&gt;“RedisCluster” vs “RedisCluster::redis()”</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093926722.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093942338.png"></p>
<p><strong>注意</strong>：</p>
<ul>
<li>RedisCluster::redis() 返回的 Redis 对象不是线程安全的</li>
<li>一旦抛出异常，必须销毁并重新创建</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚠️ 重要：返回的 Redis 对象不是线程安全的！</span></span><br><span class="line"><span class="keyword">auto</span> r = redis_cluster.<span class="built_in">redis</span>(<span class="string">&quot;hash-tag&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 如果抛出异常，必须销毁并重新创建</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    r.<span class="built_in">command</span>(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// r 不再可用，必须重建</span></span><br><span class="line">    r = redis_cluster.<span class="built_in">redis</span>(<span class="string">&quot;hash-tag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、Redis-命令的发送"><a href="#七、Redis-命令的发送" class="headerlink" title="七、Redis++ 命令的发送"></a>七、Redis++ 命令的发送</h1><h2 id="1-命令调用方式"><a href="#1-命令调用方式" class="headerlink" title="1.命令调用方式"></a>1.命令调用方式</h2><p>Redis++ 为每个 Redis 命令提供同名（小写）方法，支持多种重载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DEL 命令的 3 种重载</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::del</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;                    <span class="comment">// 单个 key</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input&gt;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::del</span><span class="params">(Input first, Input last)</span></span>;                  <span class="comment">// 迭代器范围</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::del</span><span class="params">(std::initializer_list&lt;T&gt; il)</span></span>;              <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure>

<h2 id="2-参数类型详解"><a href="#2-参数类型详解" class="headerlink" title="2.参数类型详解"></a>2.参数类型详解</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114102612093.png"></p>
<p><strong>StringView 详解</strong>:<br>	- C++17 下 StringView 就是 <strong>std::string_view</strong> 的别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringView 兼容多种字符串类型</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);                          <span class="comment">// C 风格字符串</span></span><br><span class="line"></span><br><span class="line">std::string key = <span class="string">&quot;key&quot;</span>, val = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">redis.<span class="built_in">set</span>(key, val);                                <span class="comment">// std::string</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; data = &#123;...&#125;;</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="built_in">StringView</span>(data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()));  <span class="comment">// 避免拷贝大数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-返回值详解"><a href="#3-返回值详解" class="headerlink" title="3.返回值详解"></a>3.返回值详解</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114102827965.png"></p>
<h2 id="4-bool-返回值"><a href="#4-bool-返回值" class="headerlink" title="4.bool 返回值"></a>4.bool 返回值</h2><ul>
<li>某些方法的返回类型为bool，例如 EXPIRE、HSET</li>
<li><strong>千万不要用返回值来检查命令是否成功发送到 Redis 服务器！！</strong>：<ul>
<li><strong>如果方法返回 false</strong>：<ul>
<li>并不意味着 Redis 未能将命令发送到服务器。相反，这意味着 Redis 服务器返回一个整数回复 ，且回复值为 0。</li>
</ul>
</li>
<li><strong>如果方法返回为真</strong>：<ul>
<li>意味着 Redis 服务器返回的是整数回复 ，且回复值为 1</li>
</ul>
</li>
</ul>
</li>
<li>如果 Redis 未能向服务器发送命令，就<strong>会抛出 Error 类型的异常</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚠️ 重要：bool 返回值不代表命令是否发送成功！</span></span><br><span class="line"><span class="comment">// true  = Redis 返回整数 1</span></span><br><span class="line"><span class="comment">// false = Redis 返回整数 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="built_in">expire</span>(<span class="string">&quot;key&quot;</span>, <span class="built_in">seconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">    <span class="comment">// 返回 1：超时设置成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 0：key 不存在（不是发送失败！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="built_in">setnx</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 返回 1：key 不存在，设置成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 0：key 已存在，设置失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 💡 命令发送失败会抛异常，不会返回 false</span></span><br></pre></td></tr></table></figure>

<h2 id="5-Optional-处理-NULL-回复"><a href="#5-Optional-处理-NULL-回复" class="headerlink" title="5.Optional 处理 NULL 回复"></a>5.Optional 处理 NULL 回复</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET 可能返回 NULL（key 不存在）</span></span><br><span class="line">OptionalString val = redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;       <span class="comment">// 解引用获取值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key 不存在&quot;</span> &lt;&lt; std::endl; <span class="comment">// NULL 回复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MGET 返回多个 Optional</span></span><br><span class="line">std::vector&lt;OptionalString&gt; values;</span><br><span class="line">redis.<span class="built_in">mget</span>(&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>&#125;, std::<span class="built_in">back_inserter</span>(values));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : values) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v) &#123;</span><br><span class="line">        std::cout &lt;&lt; *v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用 Optional 类型别名</span></span><br><span class="line"><span class="keyword">using</span> OptionalString = Optional&lt;std::string&gt;;</span><br><span class="line"><span class="keyword">using</span> OptionalLongLong = Optional&lt;<span class="type">long</span> <span class="type">long</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> OptionalDouble = Optional&lt;<span class="type">double</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> OptionalStringPair = Optional&lt;std::pair&lt;std::string, std::string&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="6-Variant-处理多类型回复（C-17）"><a href="#6-Variant-处理多类型回复（C-17）" class="headerlink" title="6. Variant 处理多类型回复（C++17）"></a>6. Variant 处理多类型回复（C++17）</h2><ul>
<li>如果<strong>回复类型不同</strong>，<strong>std::variant</strong> 是个不错的回复类型选择</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MEMORY STATS 返回混合类型</span></span><br><span class="line"><span class="comment">// 值可能是 long long、double 或嵌套 map</span></span><br><span class="line"><span class="keyword">using</span> Var = Variant&lt;<span class="type">double</span>, <span class="type">long</span> <span class="type">long</span>, std::unordered_map&lt;std::string, <span class="type">long</span> <span class="type">long</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = redis.command&lt;std::unordered_map&lt;std::string, Var&gt;&gt;(<span class="string">&quot;memory&quot;</span>, <span class="string">&quot;stats&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">double</span>&gt;(value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⚠️ Variant 的限制</strong>：</p>
<ul>
<li><strong>Variant 的类型参数不能有重复的项</strong>（Redis++ 库限制）<ul>
<li>例如 Variant&lt;double, long long, double&gt; 无法工作。</li>
</ul>
</li>
<li><strong>double 必须放在 std::string 之前</strong>：<ul>
<li>因为 double 回复实际是字符串格式</li>
<li>在解析变体时，我们尝试将回复解析为第一个匹配的类型，由左到右的类型参数指定</li>
<li>如果 double 放在 std::string 之后，回复总是会解析成 std::string</li>
</ul>
</li>
</ul>
<h2 id="7-输出迭代器与-STL-容器"><a href="#7-输出迭代器与-STL-容器" class="headerlink" title="7.输出迭代器与 STL 容器"></a>7.输出迭代器与 STL 容器</h2><ul>
<li>使用<strong>command通用命令接口</strong>时，你也可以把它解析成 STL 容器，而不是解析输出的回复。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用输出迭代器</span></span><br><span class="line">std::vector&lt;std::string&gt; members;</span><br><span class="line">redis.<span class="built_in">lrange</span>(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(members));</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; hash;</span><br><span class="line">redis.<span class="built_in">hgetall</span>(<span class="string">&quot;hash&quot;</span>, std::<span class="built_in">inserter</span>(hash, hash.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接返回 STL 容器（通用命令接口）</span></span><br><span class="line"><span class="keyword">auto</span> config = redis.command&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="8-各种参数类型"><a href="#8-各种参数类型" class="headerlink" title="8.各种参数类型"></a>8.各种参数类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ***** StringView 类型的参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式通过 C 风格字符串构造 StringView</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式通过 std::string 构造 StringView</span></span><br><span class="line"><span class="function">std::string <span class="title">key</span><span class="params">(<span class="string">&quot;key&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">val</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line">redis.<span class="built_in">set</span>(key, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式传递 StringView 作为参数</span></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; large_data;</span><br><span class="line"><span class="comment">// 避免数据拷贝</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="built_in">StringView</span>(large_data.<span class="built_in">data</span>(), large_data.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** long long 类型的参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于索引参数</span></span><br><span class="line">redis.<span class="built_in">bitcount</span>(key, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于数值参数</span></span><br><span class="line">redis.<span class="built_in">incrby</span>(<span class="string">&quot;num&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** double 类型的参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于分数（score）参数</span></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;m1&quot;</span>, <span class="number">2.5</span>);</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;m2&quot;</span>, <span class="number">3.5</span>);</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;m3&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于（经度，纬度）坐标参数</span></span><br><span class="line">redis.<span class="built_in">geoadd</span>(<span class="string">&quot;geo&quot;</span>, std::<span class="built_in">make_tuple</span>(<span class="string">&quot;member&quot;</span>, <span class="number">13.5</span>, <span class="number">15.6</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 时间相关参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">expire</span>(key, <span class="built_in">seconds</span>(<span class="number">1000</span>)); <span class="comment">// 设置过期时间为 1000 秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> tp = <span class="built_in">time_point_cast</span>&lt;seconds&gt;(system_clock::<span class="built_in">now</span>() + <span class="built_in">seconds</span>(<span class="number">100</span>));</span><br><span class="line">redis.<span class="built_in">expireat</span>(key, tp); <span class="comment">// 设置指定时间点过期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 命令的一些可选参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="built_in">set</span>(key, <span class="string">&quot;value&quot;</span>, <span class="built_in">milliseconds</span>(<span class="number">100</span>), UpdateType::NOT_EXIST)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;set 操作成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">linsert</span>(<span class="string">&quot;list&quot;</span>, InsertPosition::BEFORE, <span class="string">&quot;pivot&quot;</span>, <span class="string">&quot;val&quot;</span>); <span class="comment">// 在指定元素前插入值</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (-无穷, +无穷) 区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>, UnboundedInterval&lt;<span class="type">double</span>&gt;&#123;&#125;, std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, 6] 闭区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">BoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">6</span>, BoundType::CLOSED),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3, 6] 左开右闭区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">BoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">6</span>, BoundType::LEFT_OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3, 6) 开区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">BoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">6</span>, BoundType::OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, 6) 左闭右开区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">BoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">6</span>, BoundType::RIGHT_OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, +无穷) 左闭右无界区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">LeftBoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, BoundType::RIGHT_OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3, +无穷) 左开右无界区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">LeftBoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, BoundType::OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (-无穷, 6] 左无界右闭区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">RightBoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">6</span>, BoundType::LEFT_OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (-无穷, 6) 左无界右开区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">RightBoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">6</span>, BoundType::OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 迭代器对参数 *****</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; kvs = &#123;&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;, &#123;<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>&#125;, &#123;<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>&#125;&#125;;</span><br><span class="line">redis.<span class="built_in">mset</span>(kvs.<span class="built_in">begin</span>(), kvs.<span class="built_in">end</span>()); <span class="comment">// 批量设置键值对</span></span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; kv_map = &#123;&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;, &#123;<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>&#125;, &#123;<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>&#125;&#125;;</span><br><span class="line">redis.<span class="built_in">mset</span>(kv_map.<span class="built_in">begin</span>(), kv_map.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; str_map = &#123;&#123;<span class="string">&quot;f1&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;, &#123;<span class="string">&quot;f2&quot;</span>, <span class="string">&quot;v2&quot;</span>&#125;, &#123;<span class="string">&quot;f3&quot;</span>, <span class="string">&quot;v3&quot;</span>&#125;&#125;;</span><br><span class="line">redis.<span class="built_in">hmset</span>(<span class="string">&quot;hash&quot;</span>, str_map.<span class="built_in">begin</span>(), str_map.<span class="built_in">end</span>()); <span class="comment">// 批量设置哈希字段</span></span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">double</span>&gt; score_map = &#123;&#123;<span class="string">&quot;m1&quot;</span>, <span class="number">20</span>&#125;, &#123;<span class="string">&quot;m2&quot;</span>, <span class="number">12.5</span>&#125;, &#123;<span class="string">&quot;m3&quot;</span>, <span class="number">3.14</span>&#125;&#125;;</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>, score_map.<span class="built_in">begin</span>(), score_map.<span class="built_in">end</span>()); <span class="comment">// 批量添加有序集合元素</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; keys = &#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>&#125;;</span><br><span class="line">redis.<span class="built_in">del</span>(keys.<span class="built_in">begin</span>(), keys.<span class="built_in">end</span>()); <span class="comment">// 批量删除键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** initializer_list 类型的参数 *****</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">mset</span>(&#123;</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>),</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>),</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">&#125;); <span class="comment">// 用初始化列表批量设置键值对</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">hmset</span>(<span class="string">&quot;hash&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;f1&quot;</span>, <span class="string">&quot;v1&quot;</span>),</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;f2&quot;</span>, <span class="string">&quot;v2&quot;</span>),</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;f3&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">    &#125;); <span class="comment">// 用初始化列表批量设置哈希字段</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;m1&quot;</span>, <span class="number">20.0</span>),</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;m2&quot;</span>, <span class="number">34.5</span>),</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;m3&quot;</span>, <span class="number">23.4</span>)</span><br><span class="line">    &#125;); <span class="comment">// 用初始化列表批量添加有序集合元素</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">del</span>(&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>&#125;); <span class="comment">// 用初始化列表批量删除键</span></span><br></pre></td></tr></table></figure>

<h2 id="9-各种返回值类型"><a href="#9-各种返回值类型" class="headerlink" title="9.各种返回值类型"></a>9.各种返回值类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ***** 返回值为 void 类型 *****</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 std::string 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> info = redis.<span class="built_in">info</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 bool 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!redis.<span class="built_in">expire</span>(<span class="string">&quot;nonexistent&quot;</span>, std::chrono::<span class="built_in">seconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;键不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="built_in">setnx</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;set 操作成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 long long 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> len = redis.<span class="built_in">strlen</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> num = redis.<span class="built_in">del</span>(&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line">num = redis.<span class="built_in">incr</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 double 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> real = redis.<span class="built_in">incrbyfloat</span>(<span class="string">&quot;b&quot;</span>, <span class="number">23.4</span>);</span><br><span class="line">real = redis.<span class="built_in">hincrbyfloat</span>(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="number">34.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 Optional&lt;std::string&gt;（即 OptionalString）类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> os = redis.<span class="built_in">get</span>(<span class="string">&quot;kk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (os) &#123;</span><br><span class="line">    std::cout &lt;&lt; *os &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;键不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">os = redis.<span class="built_in">spop</span>(<span class="string">&quot;set&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (os) &#123;</span><br><span class="line">    std::cout &lt;&lt; *os &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;集合为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 Optional&lt;long long&gt;（即 OptionalLongLong）类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> oll = redis.<span class="built_in">zrank</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;mem&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (oll) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排名为 &quot;</span> &lt;&lt; *oll &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;成员不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 Optional&lt;double&gt;（即 OptionalDouble）类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ob = redis.<span class="built_in">zscore</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;m1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ob) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;分数为 &quot;</span> &lt;&lt; *ob &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;成员不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 Optional&lt;pair&lt;string, string&gt;&gt; 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> op = redis.<span class="built_in">blpop</span>(&#123;<span class="string">&quot;list1&quot;</span>, <span class="string">&quot;list2&quot;</span>&#125;, std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">if</span> (op) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;键为 &quot;</span> &lt;&lt; op-&gt;first &lt;&lt; <span class="string">&quot;，值为 &quot;</span> &lt;&lt; op-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;超时&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 输出迭代器接收返回值 *****</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;OptionalString&gt; os_vec;</span><br><span class="line">redis.<span class="built_in">mget</span>(&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>&#125;, std::<span class="built_in">back_inserter</span>(os_vec));</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; s_vec;</span><br><span class="line">redis.<span class="built_in">lrange</span>(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(s_vec));</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; hash;</span><br><span class="line">redis.<span class="built_in">hgetall</span>(<span class="string">&quot;hash&quot;</span>, std::<span class="built_in">inserter</span>(hash, hash.<span class="built_in">end</span>()));</span><br><span class="line"><span class="comment">// 也可以将结果保存到字符串键值对的向量中</span></span><br><span class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; hash_vec;</span><br><span class="line">redis.<span class="built_in">hgetall</span>(<span class="string">&quot;hash&quot;</span>, std::<span class="built_in">back_inserter</span>(hash_vec));</span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;std::string&gt; str_set;</span><br><span class="line">redis.<span class="built_in">smembers</span>(<span class="string">&quot;s1&quot;</span>, std::<span class="built_in">inserter</span>(str_set, str_set.<span class="built_in">end</span>()));</span><br><span class="line"><span class="comment">// 也可以将结果保存到字符串向量中</span></span><br><span class="line">s_vec.<span class="built_in">clear</span>();</span><br><span class="line">redis.<span class="built_in">smembers</span>(<span class="string">&quot;s1&quot;</span>, std::<span class="built_in">back_inserter</span>(s_vec));</span><br></pre></td></tr></table></figure>

<h1 id="八、Redis-的异常处理"><a href="#八、Redis-的异常处理" class="headerlink" title="八、Redis++ 的异常处理"></a>八、Redis++ 的异常处理</h1><h2 id="1-Redis-的Exception"><a href="#1-Redis-的Exception" class="headerlink" title="1.Redis++的Exception"></a>1.Redis++的Exception</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::exception</span><br><span class="line">    └── sw::redis::Error              // 基类：所有 Redis++ 异常的父类</span><br><span class="line">            ├── IoError               // IO 错误（连接相关）</span><br><span class="line">            │       └── TimeoutError  // 超时错误（读写超时）</span><br><span class="line">            ├── ClosedError           // 服务器关闭连接</span><br><span class="line">            ├── ProtoError            // 协议错误（命令/回复无效）</span><br><span class="line">            ├── OomError              // hiredis 内存不足</span><br><span class="line">            ├── ReplyError            // Redis 返回错误回复</span><br><span class="line">            └── WatchError            // WATCH 的 key 被修改</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095237003.png"><br><strong>注意！！</strong>：</p>
<ul>
<li><strong>NULL REPLY 不是异常</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095332179.png"></li>
</ul>
<h2 id="2-异常后的对象状态"><a href="#2-异常后的对象状态" class="headerlink" title="2.异常后的对象状态"></a>2.异常后的对象状态</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095437891.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095455051.png"></p>
<h2 id="3-异常处理模板"><a href="#3-异常处理模板" class="headerlink" title="3.异常处理模板"></a>3.异常处理模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_redis_operation</span><span class="params">(Redis&amp; redis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 超时：可重试</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;超时: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> ReplyError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// Redis 返回错误（如类型错误）：检查业务逻辑</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Redis 错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> IoError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// IO 错误：连接问题，自动重连</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;IO 错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 其他 Redis++ 错误</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// redis 对象仍然可用，下次调用会自动重连</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九、Redis-command（Redis-通用命令接口）"><a href="#九、Redis-command（Redis-通用命令接口）" class="headerlink" title="九、Redis::command（Redis++ 通用命令接口）"></a>九、Redis::command（Redis++ 通用命令接口）</h1><p>Redis++ 无法为所有 Redis 命令提供内置方法，Redis::command 允许你发送<strong>任意 Redis 命令</strong></p>
<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h2><h3 id="（1）直接指定返回类型（推荐）"><a href="#（1）直接指定返回类型（推荐）" class="headerlink" title="（1）直接指定返回类型（推荐）"></a>（1）直接指定返回类型（推荐）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无返回值的命令</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;my-connection&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串（可能为空）</span></span><br><span class="line"><span class="keyword">auto</span> val = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;getname&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回整数</span></span><br><span class="line"><span class="keyword">auto</span> num = redis.<span class="built_in">command</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="string">&quot;incrby&quot;</span>, <span class="string">&quot;counter&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回浮点数</span></span><br><span class="line"><span class="keyword">auto</span> real = redis.<span class="built_in">command</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;incrbyfloat&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="number">2.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组 - 方式1：使用输出迭代器</span></span><br><span class="line">std::vector&lt;OptionalString&gt; result;</span><br><span class="line">redis.<span class="built_in">command</span>(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>, std::<span class="built_in">back_inserter</span>(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组 - 方式2：直接解析为容器</span></span><br><span class="line"><span class="keyword">auto</span> result2 = redis.command&lt;std::vector&lt;OptionalString&gt;&gt;(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="（2）参数类型灵活"><a href="#（2）参数类型灵活" class="headerlink" title="（2）参数类型灵活"></a>（2）参数类型灵活</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 类没有内置的 *CLIENT SETNAME* 方法。</span></span><br><span class="line"><span class="comment">// 不过，你可以使用 Redis::command 手动发送该命令。</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> val = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;getname&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：以下代码仅作示例使用。实际上，Redis 已为</span></span><br><span class="line"><span class="comment">// 下述命令提供了内置方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令参数可以是字符串类型。</span></span><br><span class="line"><span class="comment">// 注意：对于 SET 命令，返回值并非始终为 void 类型，后续会详细说明。</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令参数可以是字符串和整数的组合。</span></span><br><span class="line"><span class="keyword">auto</span> num = redis.<span class="built_in">command</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="string">&quot;incrby&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数也可以是双精度浮点型（double）。</span></span><br><span class="line"><span class="keyword">auto</span> real = redis.<span class="built_in">command</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;incrbyfloat&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="number">2.3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至命令中的键（key）也可以是算术类型。</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;set&quot;</span>, <span class="number">100</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">val = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;get&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果命令返回元素数组。</span></span><br><span class="line">std::vector&lt;OptionalString&gt; result;</span><br><span class="line">redis.<span class="built_in">command</span>(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>, std::<span class="built_in">back_inserter</span>(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接解析为 vector 容器。</span></span><br><span class="line">result = redis.command&lt;std::vector&lt;OptionalString&gt;&gt;(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令参数可以是字符串范围（迭代器）。</span></span><br><span class="line"><span class="keyword">auto</span> set_cmd_strs = &#123;<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>&#125;;</span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(set_cmd_strs.<span class="built_in">begin</span>(), set_cmd_strs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> get_cmd_strs = &#123;<span class="string">&quot;get&quot;</span>, <span class="string">&quot;key&quot;</span>&#125;;</span><br><span class="line">val = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(get_cmd_strs.<span class="built_in">begin</span>(), get_cmd_strs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回的是元素数组。</span></span><br><span class="line">result.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">auto</span> mget_cmd_strs = &#123;<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>&#125;;</span><br><span class="line">redis.<span class="built_in">command</span>(mget_cmd_strs.<span class="built_in">begin</span>(), mget_cmd_strs.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(result));</span><br></pre></td></tr></table></figure>
<h2 id="2-重要注意事项"><a href="#2-重要注意事项" class="headerlink" title="2.重要注意事项"></a>2.重要注意事项</h2><h3 id="（1）多词命令必须分开传递"><a href="#（1）多词命令必须分开传递" class="headerlink" title="（1）多词命令必须分开传递"></a>（1）多词命令必须分开传递</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：分开传递</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;cluster&quot;</span>, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;maxmemory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：合并为一个字符串</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;client setname&quot;</span>, <span class="string">&quot;name&quot;</span>);  <span class="comment">// 失败！</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）返回类型不固定时的处理"><a href="#（2）返回类型不固定时的处理" class="headerlink" title="（2）返回类型不固定时的处理"></a>（2）返回类型不固定时的处理</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：使用 OptionalString 处理可能的 NULL</span></span><br><span class="line"><span class="keyword">auto</span> r = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">    <span class="comment">// 返回 &quot;OK&quot;，设置成功</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;设置成功: &quot;</span> &lt;&lt; *r &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 NULL，key 已存在，设置失败</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key 已存在，设置失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：使用 ReplyUPtr 手动解析</span></span><br><span class="line"><span class="keyword">auto</span> reply = redis.<span class="built_in">command</span>(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_NIL) &#123;</span><br><span class="line">    <span class="comment">// NULL 回复，设置失败</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key 已存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_STATUS) &#123;</span><br><span class="line">    <span class="comment">// 状态回复 &quot;OK&quot;，设置成功</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;设置成功: &quot;</span> &lt;&lt; reply-&gt;str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：封装成 bool（模拟内置 set() 的行为）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">set_if_not_exist</span><span class="params">(Redis&amp; redis, <span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;set&quot;</span>, key, val, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> r.<span class="built_in">has_value</span>();  <span class="comment">// 有值 = 成功，空 = 失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用封装函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set_if_not_exist</span>(redis, <span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;myval&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;设置成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key 已存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>常见陷阱</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚠️ SET 命令的返回类型不是固定的！</span></span><br><span class="line"><span class="comment">// 普通 SET → 返回 &quot;OK&quot;（Status Reply）</span></span><br><span class="line"><span class="comment">// SET ... NX → 可能返回 NULL（key 已存在时）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 可能出错</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;NX&quot;</span>);  <span class="comment">// NX 失败时无法判断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确处理</span></span><br><span class="line"><span class="keyword">auto</span> result = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 设置成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// key 已存在，设置失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="十、Redis-Pub-Sub（发布-订阅）"><a href="#十、Redis-Pub-Sub（发布-订阅）" class="headerlink" title="十、Redis++ Pub&#x2F;Sub（发布&#x2F;订阅）"></a>十、Redis++ Pub&#x2F;Sub（发布&#x2F;订阅）</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>你可以使用 <strong>Redis::publish方法</strong> 向频道（channels）发布消息<ul>
<li>Redis 会从底层连接池中<strong>随机选择</strong>一个连接，并通过该连接发布消息</li>
<li>因此，你发布的两条消息可能会使用两个不同的连接</li>
</ul>
</li>
<li>当你通过一个连接<strong>订阅某个频道</strong>时，发布到<strong>该频道的所有消息</strong>都会通过这个连接回传给客户端<ul>
<li>Redis 类中并<strong>没有Redis::subscribe方法</strong>：<ul>
<li>你可以调用 <strong>Redis::subscriber方法</strong> 创建一个 Subscriber（订阅者）对象，该对象会单独维护一个与 Redis 服务器的连接</li>
<li>这个底层连接是 <strong>新建的连接</strong>，<strong>“并非”从连接池中选取</strong>，且该新连接会 <strong>“沿用”原 Redis 对象的 ConnectionOptions（连接配置）</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">发布者                          Redis 服务器                      订阅者</span><br><span class="line">┌─────────┐                    ┌─────────────┐                 ┌─────────────┐</span><br><span class="line">│  Redis  │  ──<span class="built_in">publish</span>()──►   │             │  ──推送消息──►  │ Subscriber  │</span><br><span class="line">│ 对象    │                    │   Channel   │                 │ (独立连接)  │</span><br><span class="line">│(连接池) │                    │             │                 │             │</span><br><span class="line">└─────────┘                    └─────────────┘                 └─────────────┘</span><br><span class="line">   │                                                                  │</span><br><span class="line">   │ 随机选择连接发布                                          新建独立连接</span><br><span class="line">   └──────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>📊 速查表<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114120517753.png"></p>
<h2 id="2-Publish-发布消息"><a href="#2-Publish-发布消息" class="headerlink" title="2.Publish 发布消息"></a>2.Publish 发布消息</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向频道发布消息（从连接池随机选择连接）</span></span><br><span class="line">redis.<span class="built_in">publish</span>(<span class="string">&quot;channel1&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">redis.<span class="built_in">publish</span>(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;breaking news!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：收到消息的订阅者数量</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> receivers = redis.<span class="built_in">publish</span>(<span class="string">&quot;channel1&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;收到消息的订阅者: &quot;</span> &lt;&lt; receivers &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="3-Subscriber-订阅"><a href="#3-Subscriber-订阅" class="headerlink" title="3.Subscriber 订阅"></a>3.Subscriber 订阅</h2><h3 id="（1）创建Subscriber对象"><a href="#（1）创建Subscriber对象" class="headerlink" title="（1）创建Subscriber对象"></a>（1）创建Subscriber对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建订阅者（新建独立连接，不使用连接池）</span></span><br><span class="line"><span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br></pre></td></tr></table></figure>
<p><strong>注意！！：</strong></p>
<ul>
<li>如果你想有<strong>不同的连接选项</strong>，比如不同频道的 ConnectionOptions::socket_timeout ，你应该创建带有不同连接选项的 Redis 对象，然后你可以用这些 Redis 对象创建订阅对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 频道1：100ms 超时</span></span><br><span class="line">ConnectionOptions opts1;</span><br><span class="line">opts<span class="number">1.</span>host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts<span class="number">1.</span>port = <span class="number">6379</span>;</span><br><span class="line">opts<span class="number">1.</span>socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">auto</span> redis1 = <span class="built_in">Redis</span>(opts1);</span><br><span class="line"><span class="keyword">auto</span> sub1 = redis<span class="number">1.</span><span class="built_in">subscriber</span>();  <span class="comment">// 继承 100ms 超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 频道2：300ms 超时</span></span><br><span class="line">ConnectionOptions opts2;</span><br><span class="line">opts<span class="number">2.</span>host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts<span class="number">2.</span>port = <span class="number">6379</span>;</span><br><span class="line">opts<span class="number">2.</span>socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">auto</span> redis2 = <span class="built_in">Redis</span>(opts2);</span><br><span class="line"><span class="keyword">auto</span> sub2 = redis<span class="number">2.</span><span class="built_in">subscriber</span>();  <span class="comment">// 继承 300ms 超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意⚠️：虽然创建了两个 Redis 对象，但没有性能损失</span></span><br><span class="line"><span class="comment">// 因为 Redis 对象是懒加载的，只有调用 subscriber() 时才创建连接</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）Subscriber的使用"><a href="#（2）Subscriber的使用" class="headerlink" title="（2）Subscriber的使用"></a>（2）Subscriber的使用</h3><h3 id="订阅频道和模式"><a href="#订阅频道和模式" class="headerlink" title="&lt;1&gt;订阅频道和模式"></a>&lt;1&gt;订阅频道和模式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅单个频道</span></span><br><span class="line">sub.<span class="built_in">subscribe</span>(<span class="string">&quot;channel1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅多个频道</span></span><br><span class="line">sub.<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;channel2&quot;</span>, <span class="string">&quot;channel3&quot;</span>, <span class="string">&quot;channel4&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅模式（支持通配符）</span></span><br><span class="line">sub.<span class="built_in">psubscribe</span>(<span class="string">&quot;news:*&quot;</span>);      <span class="comment">// 匹配 news:sports, news:tech 等</span></span><br><span class="line">sub.<span class="built_in">psubscribe</span>(<span class="string">&quot;user:*:msg&quot;</span>);  <span class="comment">// 匹配 user:123:msg, user:456:msg 等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">sub.<span class="built_in">unsubscribe</span>(<span class="string">&quot;channel1&quot;</span>);</span><br><span class="line">sub.<span class="built_in">unsubscribe</span>(&#123;<span class="string">&quot;channel2&quot;</span>, <span class="string">&quot;channel3&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅模式</span></span><br><span class="line">sub.<span class="built_in">punsubscribe</span>(<span class="string">&quot;news:*&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消所有订阅（无参数）</span></span><br><span class="line">sub.<span class="built_in">unsubscribe</span>();   <span class="comment">// 取消所有频道订阅</span></span><br><span class="line">sub.<span class="built_in">punsubscribe</span>();  <span class="comment">// 取消所有模式订阅</span></span><br></pre></td></tr></table></figure>

<h4 id="Subscriber类-接收的6种消息类型"><a href="#Subscriber类-接收的6种消息类型" class="headerlink" title="&lt;2&gt; Subscriber类 接收的6种消息类型"></a>&lt;2&gt; Subscriber类 接收的6种消息类型</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114113148877.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114113623553.png"></p>
<ul>
<li>Subscriber 类是所有订阅消息（6 种类型）的<strong>唯一接收主体</strong></li>
<li>Subscriber类 通过消费方法（如 consume()）主动获取消息，且接收过程为<strong>阻塞式</strong><ul>
<li>调用 consume() 后会<strong>一直等待，直到有消息到达或超时</strong></li>
<li>这也是为什么 Subscriber 对象需要独占一个连接（<strong>不从连接池取</strong>）、且<strong>不建议多线程</strong>共用的原因。</li>
</ul>
</li>
</ul>
<h4 id="设置回调函数（处理6种消息）"><a href="#设置回调函数（处理6种消息）" class="headerlink" title="&lt;3&gt;设置回调函数（处理6种消息）"></a>&lt;3&gt;设置回调函数（处理6种消息）</h4><p><strong>为处理Subscriber类接收的6种消息，可以在 Subscriber 上设置“回调函数”</strong></p>
<ul>
<li><p><strong>Subscriber::on_message(MsgCallback)</strong>：</p>
<ul>
<li><strong>功能</strong>：<ul>
<li>为 MESSAGE 类型消息设置回调函数</li>
</ul>
</li>
<li><strong>回调接口定义</strong>：<ul>
<li>void (std::string channel, std::string msg)  </li>
<li>参数说明：<br>  - channel：消息所属频道<br>  - msg：实际消息内容</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Subscriber::on_pmessage(PatternMsgCallback)</strong>：</p>
<ul>
<li><strong>功能</strong><ul>
<li>为 PMESSAGE 类型消息设置回调函数</li>
</ul>
</li>
<li><strong>回调接口定义</strong>：<ul>
<li>void (std::string pattern, std::string channel, std::string msg) </li>
<li>参数说明：<br>  - pattern： 匹配的频道模式<br>  - channel：消息实际所属频道<br>  - msg：实际消息内容）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Subscriber::on_meta(MetaCallback)</strong>：</p>
<ul>
<li><strong>功能</strong>：<ul>
<li>为元消息（META MESSAGE）类型设置回调函数</li>
</ul>
</li>
<li><strong>回调接口定义</strong>：<ul>
<li>void (Subscriber::MsgType type, OptionalString channel, long long num)  </li>
<li>参数说明：<br>  - type：消息类型枚举<br>      - Subscriber::MsgType::SUBSCRIBE<br>      - Subscriber::MsgType::UNSUBSCRIBE<br>      - Subscriber::MsgType::PSUBSCRIBE<br>      - Subscriber::MsgType::PUNSUBSCRIBE<br>      - Subscriber::MsgType::MESSAGE（不会触发）<br>      - Subscriber::MsgType::PMESSAGE（不会触发）<br>  - channel：频道&#x2F;模式名称（OptionalString 类型，即可选字符串）<br>      - 若未订阅任何频道&#x2F;模式，且调用无参数的 unsubscribe&#x2F;punsubscribe（即取消所有订阅）时，该参数为 null；<br>  - num：当前仍处于订阅状态的频道&#x2F;模式总数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1️⃣ 普通消息回调（MESSAGE 类型）</span></span><br><span class="line">sub.<span class="built_in">on_message</span>([](std::string channel, std::string msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;频道 [&quot;</span> &lt;&lt; channel &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ✅ 可以安全地 move 这些参数</span></span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(channel), std::<span class="built_in">move</span>(msg));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 模式消息回调（PMESSAGE 类型）</span></span><br><span class="line">sub.<span class="built_in">on_pmessage</span>([](std::string pattern, std::string channel, std::string msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;模式 [&quot;</span> &lt;&lt; pattern &lt;&lt; <span class="string">&quot;] 频道 [&quot;</span> &lt;&lt; channel &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3️⃣ 元消息回调（SUBSCRIBE/UNSUBSCRIBE 等）</span></span><br><span class="line">sub.<span class="built_in">on_meta</span>([](Subscriber::MsgType type, OptionalString channel, <span class="type">long</span> <span class="type">long</span> num) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> Subscriber::MsgType::SUBSCRIBE:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;已订阅: &quot;</span> &lt;&lt; *channel &lt;&lt; <span class="string">&quot;, 当前订阅数: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Subscriber::MsgType::UNSUBSCRIBE:</span><br><span class="line">            <span class="keyword">if</span> (channel) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;已取消订阅: &quot;</span> &lt;&lt; *channel &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;已取消所有订阅&quot;</span> &lt;&lt; std::endl;  <span class="comment">// channel 可能为空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Subscriber::MsgType::PSUBSCRIBE:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;已订阅模式: &quot;</span> &lt;&lt; *channel &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Subscriber::MsgType::PUNSUBSCRIBE:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;已取消订阅模式&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="consume-消费消息"><a href="#consume-消费消息" class="headerlink" title="&lt;4&gt;consume 消费消息"></a>&lt;4&gt;consume 消费消息</h4><h5 id="1）consume函数执行特点"><a href="#1）consume函数执行特点" class="headerlink" title="1）consume函数执行特点"></a>1）consume函数执行特点</h5><ul>
<li>可以调用 <strong>Subscriber::consume方法</strong>，<strong>消费</strong>发布到该订阅者已订阅的频道 &#x2F; 模式的消息</li>
<li>Subscriber::consume 会<strong>阻塞等待</strong>底层连接传来消息：<ul>
<li>若达到 ConnectionOptions::socket_timeout 设定的超时时间，且无任何消息传入该连接<ul>
<li>Subscriber::consume 会<strong>抛出 TimeoutError 异常</strong>；</li>
</ul>
</li>
<li>若 ConnectionOptions::socket_timeout 设为 0 毫秒<ul>
<li>Subscriber::consume 会<strong>一直阻塞，直到接收到消息为止</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>接收到消息后，Subscriber::consume 会<strong>根据消息类型调用“对应的回调函数”处理消息</strong><ul>
<li>如果你未为某类消息设置回调函数，Subscriber::consume 会消费（读取）该消息并<strong>直接丢弃</strong></li>
<li>即 Subscriber::consume <strong>不会执行回调，直接返回</strong></li>
</ul>
</li>
<li>调用 consume() 后会<strong>一直等待，直到有消息到达或超时</strong>：<ul>
<li>这也是为什么 Subscriber 对象需要独占一个连接（不从连接池选取）、且不建议多线程共用的原因。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114171934666.png"></li>
</ul>
</li>
</ul>
<h5 id="2）不带超时的模式（设为0毫秒）"><a href="#2）不带超时的模式（设为0毫秒）" class="headerlink" title="2）不带超时的模式（设为0毫秒）"></a>2）不带超时的模式（设为0毫秒）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line"></span><br><span class="line">sub.<span class="built_in">on_message</span>([](std::string channel, std::string msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; channel &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sub.<span class="built_in">subscribe</span>(<span class="string">&quot;channel1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费消息（阻塞等待）</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sub.<span class="built_in">consume</span>();  <span class="comment">// 阻塞直到收到消息</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; err) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3）带超时的模式"><a href="#3）带超时的模式" class="headerlink" title="3）带超时的模式"></a>3）带超时的模式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置超时</span></span><br><span class="line">ConnectionOptions opts;</span><br><span class="line">opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts.port = <span class="number">6379</span>;</span><br><span class="line">opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);  <span class="comment">// 1秒超时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts);</span><br><span class="line"><span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line"></span><br><span class="line">sub.<span class="built_in">on_message</span>([](std::string channel, std::string msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; channel &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sub.<span class="built_in">subscribe</span>(<span class="string">&quot;channel1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sub.<span class="built_in">consume</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 超时不是错误，继续等待</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;等待消息中...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> ReplyError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// Redis 返回错误，可以继续使用 sub</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Redis 错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        <span class="comment">// ⚠️ 其他错误：必须销毁并重建 Subscriber</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;严重错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4）消息流向完整图示"><a href="#4）消息流向完整图示" class="headerlink" title="4）消息流向完整图示"></a>4）消息流向完整图示</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143816994.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143840833.png"></p>
<h4 id="完整示例"><a href="#完整示例" class="headerlink" title="&lt;5&gt;完整示例"></a>&lt;5&gt;完整示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConnectionOptions opts;</span><br><span class="line">        opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        opts.port = <span class="number">6379</span>;</span><br><span class="line">        opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts);</span><br><span class="line">        <span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置所有回调</span></span><br><span class="line">        sub.<span class="built_in">on_message</span>([](std::string channel, std::string msg) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[MESSAGE] &quot;</span> &lt;&lt; channel &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        sub.<span class="built_in">on_pmessage</span>([](std::string pattern, std::string channel, std::string msg) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[PMESSAGE] &quot;</span> &lt;&lt; pattern &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; channel &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        sub.<span class="built_in">on_meta</span>([](Subscriber::MsgType type, OptionalString channel, <span class="type">long</span> <span class="type">long</span> num) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[META] 类型=&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(type) </span><br><span class="line">                      &lt;&lt; <span class="string">&quot;, 频道=&quot;</span> &lt;&lt; (channel ? *channel : <span class="string">&quot;null&quot;</span>)</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;, 数量=&quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅</span></span><br><span class="line">        sub.<span class="built_in">subscribe</span>(<span class="string">&quot;chat&quot;</span>);</span><br><span class="line">        sub.<span class="built_in">psubscribe</span>(<span class="string">&quot;news:*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费循环</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开始监听消息...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sub.<span class="built_in">consume</span>();</span><br><span class="line">            &#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp;) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）Subscriber-使用注意事项"><a href="#（3）Subscriber-使用注意事项" class="headerlink" title="（3）Subscriber 使用注意事项"></a>（3）Subscriber 使用注意事项</h3><h4 id="非线程安全"><a href="#非线程安全" class="headerlink" title="&lt;1&gt;非线程安全"></a>&lt;1&gt;非线程安全</h4><ul>
<li><strong>Subscriber</strong>（订阅者）对象是 <strong>非线程安全</strong>的。如果你希望在多线程环境中调用其成员函数，需要<strong>手动实现线程间的同步</strong></li>
</ul>
<h4 id="特定Exception后不可复用"><a href="#特定Exception后不可复用" class="headerlink" title="&lt;2&gt;特定Exception后不可复用"></a>&lt;2&gt;特定Exception后不可复用</h4><ul>
<li>如果 <strong>Subscriber（订阅者）对象</strong>的任意方法抛出了**“非”** ReplyError（回复错误）或 TimeoutError（超时错误）类型的异常，那么该对象<strong>将无法再继续使用</strong>。此时你<strong>必须销毁</strong>这个 Subscriber 对象，并<strong>重新创建</strong>一个新的实例。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sub.<span class="built_in">consume</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ✅ 可以继续使用 sub</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> ReplyError&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ✅ 可以继续使用 sub</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ❌ 必须销毁并重建 sub</span></span><br><span class="line">    sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line">    sub.<span class="built_in">on_message</span>(...);  <span class="comment">// 重新设置回调</span></span><br><span class="line">    sub.<span class="built_in">subscribe</span>(<span class="string">&quot;channel1&quot;</span>);  <span class="comment">// 重新订阅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143913218.png"></p>
<h4 id="consume消费是“阻塞的”"><a href="#consume消费是“阻塞的”" class="headerlink" title="&lt;3&gt;consume消费是“阻塞的”"></a>&lt;3&gt;consume消费是“阻塞的”</h4><ul>
<li>调用 consume() 后会<strong>一直等待，直到有消息到达或超时</strong></li>
<li>这也是为什么 Subscriber 对象需要独占一个连接（<strong>不从连接池取</strong>）、且<strong>不建议多线程</strong>共用的原因。</li>
</ul>
<h1 id="十一、Redis-Pipeline（管道）"><a href="#十一、Redis-Pipeline（管道）" class="headerlink" title="十一、Redis++ Pipeline（管道）"></a>十一、Redis++ Pipeline（管道）</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>Pipeline 用于减少 RTT（往返时间），<strong>加速 Redis 查询</strong>。</li>
<li>通过将多个命令<strong>批量发送</strong>，一次性获取所有回复，避免每个命令都等待网络往返。</li>
</ul>
<h2 id="2-创建Pipeline"><a href="#2-创建Pipeline" class="headerlink" title="2.创建Pipeline"></a>2.创建Pipeline</h2><ul>
<li>可以通过 <code>Redis::pipeline</code> 方法创建一个pipeline，它会返回一个<strong>pipeline对象</strong></li>
<li>通过 <code>Redis::pipeline</code> 方法会创建的pipeline，是一个<strong>新的Redis服务连接</strong>，而不是直接使用连接池中的连接<ul>
<li>该连接与连接池中其它连接拥有相同的<code>ConnectionOptions</code></li>
</ul>
</li>
<li><strong>最好尽可能复用同一个“pipeline对象”！！</strong><ul>
<li>因为创建一个管道对象并不便宜，因为它会创建一个新的连接</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>();</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong></p>
<ul>
<li>创建pipeline是，可以直接从连接池获取连接而不创建新连接</li>
<li><a href="#pipeline_from_pool">用连接池中连接创建pipeline</a> <ul>
<li>⚠️ 此方式有死锁风险</li>
</ul>
</li>
</ul>
<h2 id="3-通过pipeline发送命令"><a href="#3-通过pipeline发送命令" class="headerlink" title="3.通过pipeline发送命令"></a>3.通过pipeline发送命令</h2><ul>
<li>通过 Pipeline 对象发送 Redis 命令 和 Redis 类一样。</li>
<li><strong>Pipeline 的设计</strong>:<ul>
<li>先批量添加命令，再一次性执行并获取结果</li>
</ul>
</li>
<li><strong>链式调用</strong>：<ul>
<li><strong>功能</strong>：<ul>
<li><strong>将命令批量添加到pipeline中</strong>（未发送！）</li>
</ul>
</li>
<li>通过“Pipeline对象”调用方法，不会直接返回响应，而是<strong>返回 Pipeline 对象本身</strong>，这样你就可以<strong>链式调用</strong>这些方法</li>
</ul>
</li>
<li><strong><code>Pipeline::exec</code>方法</strong>：<ul>
<li><strong>功能</strong>：<ul>
<li><strong>将pipeline中所有已缓存的命令发送到Redis，并返回批量执行的结果</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Pipeline::discard</code>方法</strong>：<ul>
<li><strong>功能</strong>：<ul>
<li><strong>丢弃pipeline中所有缓存的命令</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 方式1：添加与执行链式调用 ===================</span></span><br><span class="line"><span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">    .<span class="built_in">rpush</span>(<span class="string">&quot;list&quot;</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .<span class="built_in">hset</span>(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;field&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">    .<span class="built_in">command</span>(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;app&quot;</span>)</span><br><span class="line">    .<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 方式2： 添加与执行分开调用 ===================</span></span><br><span class="line"><span class="comment">// 链式调用：添加多个命令（还未执行）</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">    .<span class="built_in">rpush</span>(<span class="string">&quot;list&quot;</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .<span class="built_in">hset</span>(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;field&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">    .<span class="built_in">command</span>(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;app&quot;</span>);  <span class="comment">// 通用命令接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 exec() 发送命令并获取回复</span></span><br><span class="line"><span class="keyword">auto</span> replies = pipe.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 丢弃管道中的命令 ===================</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">discard</span>();</span><br></pre></td></tr></table></figure>
<p><strong>exec() 执行流程</strong></p>
<ul>
<li>发送所有已缓存的命令到 Redis</li>
<li>接收所有命令的回复</li>
<li>返回 <code>QueuedReplies</code>对象</li>
</ul>
<p><a id="parse_pipeline_result"></a></p>
<h2 id="4-解析pipeline执行结果"><a href="#4-解析pipeline执行结果" class="headerlink" title="4.解析pipeline执行结果"></a>4.解析pipeline执行结果</h2><ul>
<li>Pipeline::exec 返回一个 <code>QueuedReplylies</code>对象，该对象包含所有发送到 Redis 命令的回复</li>
<li>通过 <code>QueuedReplies::get</code> 方法来获取并解析回复</li>
<li><code>ueuedReplies</code> 提供 3 种 get() 方法：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114151808620.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114152209995.png"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)      <span class="comment">// 0: SET → bool</span></span><br><span class="line">                   .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)        <span class="comment">// 1: INCR → long long</span></span><br><span class="line">                   .<span class="built_in">lrange</span>(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>)  <span class="comment">// 2: LRANGE → vector</span></span><br><span class="line">                   .<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>)             <span class="comment">// 3: GET → OptionalString</span></span><br><span class="line">                   .<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析各个回复</span></span><br><span class="line"><span class="type">bool</span> set_ok = replies.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="number">0</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> counter = replies.<span class="built_in">get</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; list_items;</span><br><span class="line">replies.<span class="built_in">get</span>(<span class="number">2</span>, std::<span class="built_in">back_inserter</span>(list_items));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = replies.<span class="built_in">get</span>&lt;OptionalString&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="return_mechanism"></a></p>
<h2 id="5-连接归还机制"><a href="#5-连接归还机制" class="headerlink" title="5.连接归还机制"></a>5.连接归还机制</h2><ul>
<li>当pipeline执行exec、discard、对象析构、抛出异常时，会归还连接（主要针对“连接池”模式）<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170235009.png"></li>
</ul>
<h3 id="（1）两种创建方式的区别"><a href="#（1）两种创建方式的区别" class="headerlink" title="（1）两种创建方式的区别"></a>（1）两种创建方式的区别</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：默认创建（新建连接）</span></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>();        <span class="comment">// 创建新连接，不从连接池取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：使用连接池</span></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);   <span class="comment">// 从连接池借用连接</span></span><br></pre></td></tr></table></figure>
<h3 id="（2）”归还连接”只对连接池模式有意义"><a href="#（2）”归还连接”只对连接池模式有意义" class="headerlink" title="（2）”归还连接”只对连接池模式有意义"></a>（2）”归还连接”只对连接池模式有意义</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170102888.png"></p>
<h3 id="（3）”归还”的具体含义"><a href="#（3）”归还”的具体含义" class="headerlink" title="（3）”归还”的具体含义"></a>（3）”归还”的具体含义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;  <span class="comment">// 连接池有 3 个连接</span></span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(opts, pool_opts)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用连接池模式创建 Pipeline</span></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时：Pipeline 从连接池&quot;借走&quot;了一个连接</span></span><br><span class="line"><span class="comment">// 连接池状态：[连接1][连接2][ 空 ]  ← 只剩 2 个可用</span></span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 exec()</span></span><br><span class="line"><span class="keyword">auto</span> replies = pipe.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// exec() 完成后：连接&quot;归还&quot;到连接池</span></span><br><span class="line"><span class="comment">// 连接池状态：[连接1][连接2][连接3]  ← 恢复 3 个可用</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）-为什么”归还”很重要？"><a href="#（4）-为什么”归还”很重要？" class="headerlink" title="（4） 为什么”归还”很重要？"></a>（4） 为什么”归还”很重要？</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接池只有 3 个连接</span></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(opts, pool_opts)</span></span>;  <span class="comment">// pool_opts.size = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe1 = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 借走连接 #1</span></span><br><span class="line"><span class="keyword">auto</span> pipe2 = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 借走连接 #2</span></span><br><span class="line"><span class="keyword">auto</span> pipe3 = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 借走连接 #3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池已空！</span></span><br><span class="line"></span><br><span class="line">pipe<span class="number">1.</span><span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">pipe<span class="number">2.</span><span class="built_in">set</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">pipe<span class="number">3.</span><span class="built_in">set</span>(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 这里会阻塞或超时！因为连接池没有可用连接</span></span><br><span class="line">redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);  <span class="comment">// 等待连接...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须先执行 exec() 归还连接</span></span><br><span class="line">pipe<span class="number">1.</span><span class="built_in">exec</span>();  <span class="comment">// 归还连接 #1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 现在可以了</span></span><br><span class="line">redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);  <span class="comment">// 获取到连接 #1</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）归还之后再次触发呢？"><a href="#（5）归还之后再次触发呢？" class="headerlink" title="（5）归还之后再次触发呢？"></a>（5）归还之后再次触发呢？</h3><ul>
<li>归还连接后，Pipeline对象仍然存在，可以继续使用！</li>
<li>调用 exec() 或 discard() 后：<ul>
<li>连接被归还到连接池</li>
<li>下次调用命令时，会重新从连接池借用连接</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(opts, pool_opts)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 从连接池借用连接 #1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一批命令</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>).<span class="built_in">set</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> replies1 = pipe.<span class="built_in">exec</span>();  <span class="comment">// 执行后，连接 #1 归还到池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ Pipeline 对象仍可使用！</span></span><br><span class="line"><span class="comment">// 第二批命令（会重新从连接池借用连接，可能是 #1，也可能是 #2、#3）</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> replies2 = pipe.<span class="built_in">exec</span>();  <span class="comment">// 执行后，连接再次归还</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 可以一直这样复用</span></span><br><span class="line">pipe.<span class="built_in">get</span>(<span class="string">&quot;k1&quot;</span>).<span class="built_in">get</span>(<span class="string">&quot;k2&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> replies3 = pipe.<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170533657.png"></p>
<h2 id="6-pipeline-使用注意事项"><a href="#6-pipeline-使用注意事项" class="headerlink" title="6.pipeline 使用注意事项"></a>6.pipeline 使用注意事项</h2><h3 id="（1）特定Exception后不可复用"><a href="#（1）特定Exception后不可复用" class="headerlink" title="（1）特定Exception后不可复用"></a>（1）特定Exception后不可复用</h3><ul>
<li>如果pipeline的任何方法抛出除 ReplyError 以外的异常， 管道对象将进入无效状态<ul>
<li>不能再使用它了，只能摧毁该物体，然后创建一个新的</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;n&quot;</span>).<span class="built_in">exec</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> ReplyError&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ✅ ReplyError：Pipeline 仍可使用</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Redis 返回错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ❌ 其他异常：Pipeline 进入无效状态，必须销毁重建</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;严重错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    pipe = redis.<span class="built_in">pipeline</span>();  <span class="comment">// 重新创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114153043892.png"></p>
<h3 id="（2）非线程安全"><a href="#（2）非线程安全" class="headerlink" title="（2）非线程安全"></a>（2）非线程安全</h3><ul>
<li>Pipeline <strong>不是线程安全</strong>的</li>
<li>如果你想在多线程环境中调用其成员函数，就需要在线程间手动同步</li>
</ul>
<p><a id="pipeline_from_pool"></a></p>
<h2 id="5-创建管道而不创建新连接"><a href="#5-创建管道而不创建新连接" class="headerlink" title="5.创建管道而不创建新连接"></a>5.创建管道而不创建新连接</h2><h3 id="（1）用连接池中的连接创建pipeline对象（有死锁风险）"><a href="#（1）用连接池中的连接创建pipeline对象（有死锁风险）" class="headerlink" title="（1）用连接池中的连接创建pipeline对象（有死锁风险）"></a>（1）用连接池中的连接创建pipeline对象（有死锁风险）</h3><ul>
<li>可以创建一个带有底层连接池连接的管道对象，这样调用 Redis::pipeline 方法可以便宜得多（因为它不需要新建连接）</li>
<li><strong>Pipeline pipeline(bool new_connection &#x3D; true)</strong><ul>
<li>如果 new_connection 为假， 管道对象将与底层池的连接创建。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 false，从连接池获取连接</span></span><br><span class="line"><span class="comment">//⚠️在这种情况下，你必须非常小心，否则可能会表现不佳甚至死锁</span></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><a id="dead_lock"></a></p>
<h3 id="（2）死锁风险"><a href="#（2）死锁风险" class="headerlink" title="（2）死锁风险"></a>（2）死锁风险</h3><ul>
<li>当你用 Pipeline 对象执行命令时，它会保留连接，直到调用 Pipeline::exec、Pipeline::discard 或 Pipeline 的 destructor<ul>
<li>如果 Pipeline 的任何方法抛出异常 ，连接也会被释放</li>
</ul>
</li>
<li>如果管道对象长时间保持连接，其他 Redis 方法可能无法从底层池获取连接。</li>
</ul>
<p><strong>死锁示例（❌ 错误用法）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认只有 1 个连接，wait_timeout = 0（永久等待）</span></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 从连接池取连接</span></span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val&quot;</span>);  <span class="comment">// 占用连接</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val&quot;</span>);  <span class="comment">// 继续占用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 死锁！连接池为空，Redis::get 永久阻塞</span></span><br><span class="line">redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);  <span class="comment">// 等待连接池，但 pipe 还没释放</span></span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">exec</span>();  <span class="comment">// 永远执行不到</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）最佳实践"><a href="#（3）最佳实践" class="headerlink" title="（3）最佳实践"></a>（3）最佳实践</h3><ul>
<li>始终将 ConnectionPoolOptions::wait_timeout 设置为大于 0 毫秒<ul>
<li>即当连接池为空时，避免调用者永久阻塞</li>
</ul>
</li>
<li>最好将 Pipeline 相关代码放在代码块作用域内</li>
<li>避免在 Pipeline 方法调用之间执行耗时操作</li>
<li>尽量将 Pipeline 方法与 Pipeline::exec 链式调用在同一条语句中</li>
</ul>
<p>✅ 正确用法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions opts;</span><br><span class="line">opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts.port = <span class="number">6379</span>;</span><br><span class="line">opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ✅ 最佳实践1： ConnectionPoolOptions::wait_timeout &gt; 0ms</span></span><br><span class="line">pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts, pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 最佳实践2：使用块作用域</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//✅ 最佳实践3：避免在 Pipeline 方法调用之间执行耗时操作</span></span><br><span class="line">    <span class="comment">// ❌ 不要在这里做耗时操作！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>).<span class="built_in">set</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>).<span class="built_in">exec</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exec() 完成后，连接自动归还</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 最佳实践4：链式调用一气呵成</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>)</span><br><span class="line">                       .<span class="built_in">set</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>)</span><br><span class="line">                       .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">                       .<span class="built_in">exec</span>();  <span class="comment">// 立即发送并释放连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 这种操作（复用连接池连接创建 Pipeline）开销极低</span></span><br><span class="line">    <span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从底层连接池获取连接并持有</span></span><br><span class="line">    pipe.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使未调用 Pipeline::exec 或 Pipeline::discard（即pipeline还缓存有命令）</span></span><br><span class="line">    <span class="comment">// 当 Pipeline 对象析构时，连接也会被自动归还到连接池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二、Redis-Transaction（事务）"><a href="#十二、Redis-Transaction（事务）" class="headerlink" title="十二、Redis++ Transaction（事务）"></a>十二、Redis++ Transaction（事务）</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h2><p>Transaction 用于确保多个命令<strong>原子性执行</strong>——要么全部成功，要么全部不执行。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114155752421.png"></p>
<ul>
<li>前面提过，Redis是线程安全的，为减小开销，尽量复用同一个Redis ——&gt; 这也就可能导致一个线程通过Redis执行多个命令时，其它线程也通过同一个Redis执行命令，从而导致被打断</li>
</ul>
<h2 id="2-创建Transaction"><a href="#2-创建Transaction" class="headerlink" title="2.创建Transaction"></a>2.创建Transaction</h2><h3 id="（1）默认方式（创建新连接）"><a href="#（1）默认方式（创建新连接）" class="headerlink" title="（1）默认方式（创建新连接）"></a>（1）默认方式（创建新连接）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事务（默认创建新连接，不从连接池取）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>();</span><br></pre></td></tr></table></figure>
<p>⚠️ 注意：默认创建 Transaction 开销较大（需要新建连接），应尽量复用。</p>
<h3 id="（2）使用连接池连接创建（有死锁风险）"><a href="#（2）使用连接池连接创建（有死锁风险）" class="headerlink" title="（2）使用连接池连接创建（有死锁风险）"></a>（2）使用连接池连接创建（有死锁风险）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数说明：transaction(piped, new_connection)</span></span><br><span class="line"><span class="comment">// piped = false（非管道模式），new_connection = false（从连接池取）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="（3）创建管道化事务（性能更好）"><a href="#（3）创建管道化事务（性能更好）" class="headerlink" title="（3）创建管道化事务（性能更好）"></a>（3）创建管道化事务（性能更好）</h3><p><a href="#pipeline_transaction">管带事务</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// piped = true，命令通过 Pipeline 发送，减少 RTT</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用连接池 + 管道 () （有死锁风险）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-Transaction的使用"><a href="#3-Transaction的使用" class="headerlink" title="3.Transaction的使用"></a>3.Transaction的使用</h2><h3 id="（1）发送命令"><a href="#（1）发送命令" class="headerlink" title="（1）发送命令"></a>（1）发送命令</h3><p>Transaction 与 Pipeline 接口完全相同，支持链式调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">  .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">  .<span class="built_in">lpush</span>(<span class="string">&quot;list&quot;</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">  .<span class="built_in">hset</span>(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;field&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">  .<span class="built_in">command</span>(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;app&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>📌 你不需要向 Redis 发送多重命令。 交易会自动帮你完成这件事。</p>
<h3 id="（2）执行事务"><a href="#（2）执行事务" class="headerlink" title="（2）执行事务"></a>（2）执行事务</h3><ul>
<li>当你调用 Transaction::exec 时，你会明确要求 Redis 执行那些排队命令，并返回回复<ul>
<li>否则，这些命令不会被执行</li>
</ul>
</li>
<li>你可以调用 Transaction::discard 来丢弃执行，也就是说不会执行任何命令。</li>
</ul>
<p><strong>调用 exec() 执行</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：先发送，再执行</span></span><br><span class="line">tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> replies = tx.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：链式调用（推荐）</span></span><br><span class="line"><span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>).<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure>

<p><strong>放弃事务</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">tx.<span class="built_in">discard</span>();  <span class="comment">// 放弃执行，所有命令都不会执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）解析事务执行结果"><a href="#（3）解析事务执行结果" class="headerlink" title="（3）解析事务执行结果"></a>（3）解析事务执行结果</h3><p>与 Pipeline 完全相同：<a href="#parse_pipeline_result">解析回复</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)      <span class="comment">// 0: SET → bool</span></span><br><span class="line">                 .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)        <span class="comment">// 1: INCR → long long</span></span><br><span class="line">                 .<span class="built_in">lrange</span>(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>)  <span class="comment">// 2: LRANGE → vector</span></span><br><span class="line">                 .<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="type">bool</span> set_ok = replies.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="number">0</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> counter = replies.<span class="built_in">get</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; items;</span><br><span class="line">replies.<span class="built_in">get</span>(<span class="number">2</span>, std::<span class="built_in">back_inserter</span>(items));</span><br></pre></td></tr></table></figure>

<p><a id="pipeline_transaction"></a></p>
<h3 id="（4）管道事务（Piped-Transaction）"><a href="#（4）管道事务（Piped-Transaction）" class="headerlink" title="（4）管道事务（Piped Transaction）"></a>（4）管道事务（Piped Transaction）</h3><p>通常，一个事务会发送多条指令，为了提升性能，可以在pipeline中发送这些命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a piped transaction</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过这种piped transaction，所有命令都会通过pipeline发送到 Redis。</li>
</ul>
<h2 id="4-WATCH-乐观锁（CAS-机制）"><a href="#4-WATCH-乐观锁（CAS-机制）" class="headerlink" title="4. WATCH 乐观锁（CAS 机制）"></a>4. WATCH 乐观锁（CAS 机制）</h2><h3 id="（1）为什么需要-WATCH？"><a href="#（1）为什么需要-WATCH？" class="headerlink" title="（1）为什么需要 WATCH？"></a>（1）为什么需要 WATCH？</h3><p><strong>Transacation 并不安全于线程</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">场景：两个客户端同时对 counter 加 1</span><br><span class="line"></span><br><span class="line">客户端A（事务1）              客户端B （事务2）</span><br><span class="line">────────                    ────────</span><br><span class="line">GET counter → 10            GET counter → 10</span><br><span class="line">new<span class="emphasis">_counter = 10 + 1        new_</span>counter = 10 + 1</span><br><span class="line">SET counter new<span class="emphasis">_counter     SET counter new_</span>counter</span><br><span class="line"></span><br><span class="line">结果：counter = 11（错误！应该是 12）</span><br></pre></td></tr></table></figure>
<h3 id="（2）WATCH-的作用"><a href="#（2）WATCH-的作用" class="headerlink" title="（2）WATCH 的作用"></a>（2）WATCH 的作用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">客户端A（事务1）              客户端B（事务2）</span><br><span class="line">────────                    ────────</span><br><span class="line">WATCH counter  //监视 counter 是否被修改</span><br><span class="line">GET counter → 10</span><br><span class="line"><span class="code">                            SET counter 20（修改了 counter）</span></span><br><span class="line"><span class="code">MULTI    //开启事务</span></span><br><span class="line"><span class="code">SET counter </span></span><br><span class="line"><span class="code">EXEC → 失败！（因为 counter 被修改）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">→ 客户端A 重试整个流程</span><br></pre></td></tr></table></figure>

<h3 id="（3）Watch的使用"><a href="#（3）Watch的使用" class="headerlink" title="（3）Watch的使用"></a>（3）Watch的使用</h3><h4 id="概述"><a href="#概述" class="headerlink" title="&lt;1&gt;概述"></a>&lt;1&gt;概述</h4><ul>
<li><strong>WATCH 命令必须与该交易在同一连接中发送</strong></li>
<li>通常在 WATCH 命令之后，我们还需要发送其他命令<ul>
<li>如：<strong>执行事务前从 Redis 获取数据</strong></li>
</ul>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">WATCH key           // 监听指定的 key</span><br><span class="line">val = GET key       // 获取该 key 对应的 value</span><br><span class="line">new<span class="emphasis">_val = val + 1   // 对 value 执行自增操作</span></span><br><span class="line"><span class="emphasis">MULTI               // 开启事务</span></span><br><span class="line"><span class="emphasis">SET key new_</span>val     // 仅当该 key 的值未被其他客户端修改时，才执行此赋值操作</span><br><span class="line">EXEC                // 尝试执行事务</span><br><span class="line"><span class="code">                    // 若监听期间 val 已被修改，整个事务不会执行</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114163237592.png"></p>
<h4 id="使用-WATCH-的关键"><a href="#使用-WATCH-的关键" class="headerlink" title="&lt;2&gt;使用 WATCH 的关键"></a>&lt;2&gt;使用 WATCH 的关键</h4><ul>
<li>使用 Transaction 对象时，你无法获得命令的结果，直到整个事务完成。</li>
<li>相反，你需要从事务对象创建一个 Redis 对象。创建的 Redis 对象与事务对象<strong>共享连接</strong></li>
<li>有了这个创建的 Redis 对象，你可以向 Redis 服务器发送 WATCH 命令和其他 Redis 命令，并立即获得结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建共享连接的 Redis 对象</span></span><br><span class="line"><span class="keyword">auto</span> r = tx.<span class="built_in">redis</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// r 和 tx 使用同一个连接</span></span><br><span class="line">r.<span class="built_in">watch</span>(<span class="string">&quot;key&quot;</span>);           <span class="comment">// 在共享连接上执行 WATCH</span></span><br><span class="line"><span class="keyword">auto</span> val = r.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);  <span class="comment">// 可以立即获取结果</span></span><br><span class="line">tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, new_val).<span class="built_in">exec</span>();  <span class="comment">// 在同一连接上执行事务</span></span><br></pre></td></tr></table></figure>

<h4 id="WATCH-完整示例（CAS-实现）"><a href="#WATCH-完整示例（CAS-实现）" class="headerlink" title="&lt;3&gt;WATCH 完整示例（CAS 实现）"></a>&lt;3&gt;WATCH 完整示例（CAS 实现）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在循环外创建 Transaction（避免重复创建连接）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 WATCH 的 key 可能被其他客户端修改，需要重试</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建共享连接的 Redis 对象</span></span><br><span class="line">        <span class="keyword">auto</span> r = tx.<span class="built_in">redis</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 监视 key</span></span><br><span class="line">        r.<span class="built_in">watch</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前值</span></span><br><span class="line">        <span class="keyword">auto</span> val = r.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="type">int</span> num = val ? std::<span class="built_in">stoi</span>(*val) : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算新值</span></span><br><span class="line">        ++num;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行事务</span></span><br><span class="line">        <span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, std::<span class="built_in">to_string</span>(num)).<span class="built_in">exec</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 成功！验证并退出循环</span></span><br><span class="line">        <span class="built_in">assert</span>(replies.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; replies.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="number">0</span>) == <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> WatchError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// key 被其他客户端修改，重试</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 其他错误，Transaction 已失效</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-创建事务但不创建新连接"><a href="#5-创建事务但不创建新连接" class="headerlink" title="5.创建事务但不创建新连接"></a>5.创建事务但不创建新连接</h2><h3 id="（1）使用连接池内连接创建Transaction"><a href="#（1）使用连接池内连接创建Transaction" class="headerlink" title="（1）使用连接池内连接创建Transaction"></a>（1）使用连接池内连接创建Transaction</h3><ul>
<li>事实上，可以创建一个带有底层连接池连接的事务对象，这样调用 Redis::transaction 方法会便宜得多（因为不需要新建连接）。</li>
<li>Redis::transaction 的原型:<ul>
<li><code>Transaction transaction(bool piped = false, bool new_connection = true);</code><ul>
<li>如果 new_connection 为假， 交易对象将通过底层池的连接创建</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个事务（Transaction），但不新建连接。</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>不过，在这种情况下，你必须非常小心<ul>
<li>否则：<strong>可能会表现不佳甚至死锁!!</strong></li>
</ul>
</li>
</ul>
<p><strong>参考</strong>：<a href="#dead_lock">pipeline的死锁风险</a></p>
<h3 id="（2）使用连接池连接的最佳实践"><a href="#（2）使用连接池连接的最佳实践" class="headerlink" title="（2）使用连接池连接的最佳实践"></a>（2）使用连接池连接的最佳实践</h3><ul>
<li>限制 由Transaction::Redis创建的Redis对象的 作用域（生命周期）<ul>
<li>即尽快销毁Redis对象。</li>
</ul>
</li>
</ul>
<p><strong>⚠️ 特别注意</strong>：tx.redis() 创建的对象会持有连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts, pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Transaction 对象，且不新建连接（复用连接池中的现有连接）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 注：第一个 false = 不使用 Pipeline 模式执行事务；第二个 false = 不新建连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Redis 对象，共享同一个连接</span></span><br><span class="line"><span class="keyword">auto</span> r = tx.<span class="built_in">redis</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他业务代码（⚠️ 若此处有耗时操作，会长期占用连接，导致连接池耗尽）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute the transaction.</span></span><br><span class="line"><span class="comment">// 执行事务（提交事务队列中的所有命令）</span></span><br><span class="line"><span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管已调用 Transaction::exec 执行事务，但连接并未归还到连接池</span></span><br><span class="line"><span class="comment">// 原因：由 tx.redis() 创建的 Redis 对象（即变量 r）仍持有该连接</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 正确用法</strong>：确保 r 和 tx 都尽快销毁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionOptions opts;</span><br><span class="line">opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts.port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line">pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);  <span class="comment">// ⚠️ 必须 &gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts, pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ✅ 在循环内创建 Transaction（使用连接池，开销很小）</span></span><br><span class="line">        <span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ✅ r 和 tx 在同一作用域，同时销毁</span></span><br><span class="line">        <span class="keyword">auto</span> r = tx.<span class="built_in">redis</span>();</span><br><span class="line">        </span><br><span class="line">        r.<span class="built_in">watch</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> val = r.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="type">int</span> num = val ? std::<span class="built_in">stoi</span>(*val) : <span class="number">0</span>;</span><br><span class="line">        ++num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, std::<span class="built_in">to_string</span>(num)).<span class="built_in">exec</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">assert</span>(replies.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; replies.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ✅ 离开作用域时，r 和 tx 都销毁，连接归还</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> WatchError&amp;) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp;) &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-连接归还机制"><a href="#6-连接归还机制" class="headerlink" title="6.连接归还机制"></a>6.连接归还机制</h2><p><strong>参考</strong>：<a href="#return_mechanism">pipeline的连接归还机制</a></p>
<h2 id="7-Transaction-使用注意事项"><a href="#7-Transaction-使用注意事项" class="headerlink" title="7.Transaction 使用注意事项"></a>7.Transaction 使用注意事项</h2><h3 id="（1）特定Exception后不可复用-1"><a href="#（1）特定Exception后不可复用-1" class="headerlink" title="（1）特定Exception后不可复用"></a>（1）特定Exception后不可复用</h3><ul>
<li>如果事务的任何方法抛出除 WatchError 或 ReplyError 以外的异常， 事务对象将进入无效状态<ul>
<li>你不能再使用它，只能摧毁该物体并创建一个新的<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114161718422.png"></li>
</ul>
</li>
</ul>
<h3 id="（2）非线程安全-1"><a href="#（2）非线程安全-1" class="headerlink" title="（2）非线程安全"></a>（2）非线程安全</h3><ul>
<li>Transacation 并不安全于线程。</li>
<li>如果你想在多线程环境中调用其成员函数，就需要在线程间手动同步。</li>
</ul>
<p><a id="use"></a></p>
<h1 id="附录1：Redis-核心场景"><a href="#附录1：Redis-核心场景" class="headerlink" title="附录1：Redis++ 核心场景"></a>附录1：Redis++ 核心场景</h1><h2 id="1-缓存场景（最核心场景）"><a href="#1-缓存场景（最核心场景）" class="headerlink" title="1.缓存场景（最核心场景）"></a>1.缓存场景（最核心场景）</h2><h3 id="（1）适用场景"><a href="#（1）适用场景" class="headerlink" title="（1）适用场景"></a>（1）适用场景</h3><p>用户信息缓存、商品详情缓存、接口结果缓存、热点数据加速访问等，核心目标是减轻数据库压力，提升接口响应速度。</p>
<h3 id="（2）核心优势"><a href="#（2）核心优势" class="headerlink" title="（2）核心优势"></a>（2）核心优势</h3><ul>
<li>Redis 基于内存操作，响应速度快（毫秒级）；</li>
<li>Redis++ 提供丰富的缓存操作 API，支持过期时间设置、批量操作，配合<strong>连接池</strong>可高效支撑高并发缓存访问。</li>
</ul>
<h3 id="（3）生产实现要点（重点！）"><a href="#（3）生产实现要点（重点！）" class="headerlink" title="（3）生产实现要点（重点！）"></a>（3）生产实现要点（重点！）</h3><ul>
<li><strong>缓存key命名规范</strong>：<ul>
<li>采用“ <strong>业务模块:数据类型:唯一标识</strong> ”格式<ul>
<li>如： goods:detail:10086，避免键名冲突</li>
</ul>
</li>
</ul>
</li>
<li><strong>过期策略</strong>：<ul>
<li>必须设置合理的过期时间<ul>
<li>如：热点商品30分钟、用户token24小时</li>
<li>避免内存泄漏：Redis 内存持续增长且无法被有效回收，最终导致内存耗尽</li>
<li>可通过 <strong>set(key, val, expire)</strong> 实现</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存更新</strong>：<ul>
<li>采用“更新数据库+更新缓存”或“先删缓存+后更数据库”策略，避免缓存与数据库数据不一致；</li>
<li>高并发场景推荐“先删缓存+延迟双删”；</li>
</ul>
</li>
<li><strong>缓存异常防护</strong>：<ul>
<li><strong>缓存穿透</strong>（缓存和数据库均无数据）<ul>
<li>可<strong>设置空值缓存</strong>（短期过期）</li>
</ul>
</li>
<li><strong>缓存击穿</strong>（热点key过期瞬间高并发）<ul>
<li>可使用<strong>互斥锁</strong>或<strong>热点key永不过期</strong></li>
</ul>
</li>
<li><strong>缓存雪崩</strong>（大量key同时过期）<ul>
<li>可设置<strong>过期时间随机偏移</strong>（如基础过期30分钟+随机0-5分钟）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 UUID</span></span><br><span class="line"><span class="function">std::string <span class="title">generate_uuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::random_device rd;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="type">static</span> std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* hex = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    std::string uuid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        uuid += hex[<span class="built_in">dis</span>(gen)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">get_goods_detail_cache_safe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Redis&amp; redis, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; goods_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> max_retries = <span class="number">5</span>  <span class="comment">// ✅ 添加重试次数限制</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string cache_key = <span class="string">&quot;goods:detail:&quot;</span> + goods_id;</span><br><span class="line">    <span class="type">const</span> std::string lock_key = <span class="string">&quot;lock:goods:&quot;</span> + goods_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 查缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(cache_key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (*val == <span class="string">&quot;__EMPTY__&quot;</span>) ? std::<span class="literal">nullopt</span> : val;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2. 尝试获取锁</span></span><br><span class="line">    std::string lock_value = <span class="built_in">generate_uuid</span>();  <span class="comment">// ✅ 唯一标识</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> got_lock = redis.<span class="built_in">set</span>(</span><br><span class="line">        lock_key, </span><br><span class="line">        lock_value,  <span class="comment">// ✅ 用 UUID 防止误删</span></span><br><span class="line">        std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>), </span><br><span class="line">        sw::redis::UpdateType::NOT_EXIST</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (got_lock) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 双重检查（可能其他线程已写入）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(cache_key)) &#123;</span><br><span class="line">                redis.<span class="built_in">del</span>(lock_key);  <span class="comment">// ✅ 释放锁</span></span><br><span class="line">                <span class="keyword">return</span> (*val == <span class="string">&quot;__EMPTY__&quot;</span>) ? std::<span class="literal">nullopt</span> : val;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 查数据库</span></span><br><span class="line">            std::string db_val = <span class="built_in">query_goods_detail_from_db</span>(goods_id);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (db_val.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                redis.<span class="built_in">set</span>(cache_key, <span class="string">&quot;__EMPTY__&quot;</span>, std::chrono::<span class="built_in">minutes</span>(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redis.<span class="built_in">set</span>(cache_key, db_val, std::chrono::<span class="built_in">minutes</span>(<span class="number">30</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ✅ 安全释放锁（Lua 脚本，原子操作）</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* lua_script = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">                if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">                    return redis.call(&quot;del&quot;, KEYS[1])</span></span><br><span class="line"><span class="string">                else</span></span><br><span class="line"><span class="string">                    return 0</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string">            )&quot;</span>;</span><br><span class="line">            redis.<span class="built_in">eval</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(lua_script, &#123;lock_key&#125;, &#123;lock_value&#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> db_val.<span class="built_in">empty</span>() ? std::<span class="literal">nullopt</span> : std::optional&#123;db_val&#125;;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// ✅ 异常时也要释放锁</span></span><br><span class="line">            redis.<span class="built_in">eval</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(</span><br><span class="line">                <span class="string">R&quot;(if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then </span></span><br><span class="line"><span class="string">                     return redis.call(&quot;del&quot;, KEYS[1]) </span></span><br><span class="line"><span class="string">                   else </span></span><br><span class="line"><span class="string">                     return 0 </span></span><br><span class="line"><span class="string">                   end)&quot;</span>,</span><br><span class="line">                &#123;lock_key&#125;, &#123;lock_value&#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ✅ 改用循环代替递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_retries; ++i) &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再次查缓存（可能已被其他线程写入）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(cache_key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (*val == <span class="string">&quot;__EMPTY__&quot;</span>) ? std::<span class="literal">nullopt</span> : val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ✅ 超过重试次数，直接查数据库（降级）</span></span><br><span class="line">        std::string db_val = <span class="built_in">query_goods_detail_from_db</span>(goods_id);</span><br><span class="line">        <span class="keyword">return</span> db_val.<span class="built_in">empty</span>() ? std::<span class="literal">nullopt</span> : std::optional&#123;db_val&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-分布式锁场景"><a href="#2-分布式锁场景" class="headerlink" title="2.分布式锁场景"></a>2.分布式锁场景</h2><h3 id="（1）适用场景-1"><a href="#（1）适用场景-1" class="headerlink" title="（1）适用场景"></a>（1）适用场景</h3><p>秒杀活动、分布式事务、跨服务资源竞争、避免重复提交等，核心目标是保证分布式环境下资源访问的原子性。</p>
<h3 id="（2）核心优势-1"><a href="#（2）核心优势-1" class="headerlink" title="（2）核心优势"></a>（2）核心优势</h3><ul>
<li>Redis 单线程特性保证锁操作的原子性；</li>
<li>Redis++ 支持 Lua 脚本，可将“加锁+过期”、“解锁+验证持有者”等逻辑封装为原子操作，避免锁漏洞。</li>
</ul>
<h3 id="（3）生产实现要点"><a href="#（3）生产实现要点" class="headerlink" title="（3）生产实现要点"></a>（3）生产实现要点</h3><ul>
<li><p><strong>锁标识唯一性</strong>：</p>
<ul>
<li>每个锁持有者需携带唯一标识（如 UUID+线程ID），避免误解锁其他线程的锁；</li>
</ul>
</li>
<li><p><strong>锁过期机制</strong>：</p>
<ul>
<li>必须设置锁过期时间，<strong>防止持有者崩溃导致锁永久占用</strong><ul>
<li>可通过 <strong>Lua 脚本</strong>原子设置“NX+EX”；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>锁续约</strong>：</p>
<ul>
<li>如果业务逻辑执行时间可能超过锁过期时间，需启动后台线程定期续约（如每10秒续期20秒）；</li>
</ul>
</li>
<li><p><strong>解锁原子性</strong>：</p>
<ul>
<li>通过 Lua 脚本先验证锁持有者，再删除锁，避免锁过期后误删其他线程的锁。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedLock</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Redis&amp; redis_;</span><br><span class="line">    string lock_key_;      <span class="comment">// 锁的 key，如 &quot;lock:order:12345&quot;</span></span><br><span class="line">    string lock_val_;      <span class="comment">// 锁的唯一标识，用于验证持有者身份</span></span><br><span class="line">    <span class="type">int</span> expire_seconds_;   <span class="comment">// 锁过期时间（防止持有者崩溃导致死锁）</span></span><br><span class="line">    </span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt; holding_&#123;<span class="literal">false</span>&#125;;  <span class="comment">// 原子标志：当前是否持有锁（线程安全）</span></span><br><span class="line">    thread renew_thread_;          <span class="comment">// 后台续约线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line">    <span class="comment">// 续约循环：防止业务执行时间超过锁过期时间导致锁被抢</span></span><br><span class="line">    <span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renew_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Lua 脚本：原子操作 - 先验证是自己的锁，再续期</span></span><br><span class="line">        <span class="comment">// 避免续期了别人的锁（锁已过期被其他进程抢走的情况）</span></span><br><span class="line">        <span class="type">const</span> string renew_script = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">            if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">                return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 续约频率：过期时间的 1/3（如30秒过期，每10秒续约一次）</span></span><br><span class="line">        <span class="comment">// 留足安全边际，避免网络延迟导致锁意外过期</span></span><br><span class="line">        <span class="type">int</span> sleep_ms = (expire_seconds_ * <span class="number">1000</span>) / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (holding_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(sleep_ms));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 双重检查：sleep 期间可能已经 unlock 了</span></span><br><span class="line">            <span class="keyword">if</span> (!holding_.<span class="built_in">load</span>()) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> result = redis_.<span class="built_in">eval</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(</span><br><span class="line">                    renew_script,</span><br><span class="line">                    &#123;lock_key_&#125;,</span><br><span class="line">                    &#123;lock_val_, <span class="built_in">to_string</span>(expire_seconds_)&#125;</span><br><span class="line">                );</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// result == 0 说明锁已不属于自己（被抢或过期）</span></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                    holding_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="built_in">catch</span> (<span class="type">const</span> sw::redis::Error&amp; e) &#123;</span><br><span class="line">                <span class="comment">// 网络异常 → 保守处理：认为锁已丢失</span></span><br><span class="line">                <span class="comment">// 防止脑裂：宁可放弃锁，也不能两个进程同时认为自己持有锁</span></span><br><span class="line">                holding_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DistributedLock</span>(Redis&amp; redis, <span class="type">const</span> string&amp; key, <span class="type">int</span> expire_sec = <span class="number">30</span>)</span><br><span class="line">        : <span class="built_in">redis_</span>(redis), <span class="built_in">lock_key_</span>(key), <span class="built_in">expire_seconds_</span>(expire_sec) &#123;</span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="comment">// 锁标识必须全局唯一：UUID + 线程ID</span></span><br><span class="line">        <span class="comment">// 作用：解锁时验证身份，防止 A 误删 B 的锁</span></span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        lock_val_ = <span class="built_in">generate_uuid</span>() + <span class="string">&quot;:&quot;</span> + <span class="built_in">to_string</span>(this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">        <span class="comment">// 注意：generate_uuid() 需要自行实现，可使用 boost::uuid 或其他 UUID 库</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RAII：析构时自动释放锁</span></span><br><span class="line">    ~<span class="built_in">DistributedLock</span>() &#123;</span><br><span class="line">        <span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="comment">// SET key value EX seconds NX（原子操作）</span></span><br><span class="line">        <span class="comment">// NX = 仅当 key 不存在时才设置（互斥保证）</span></span><br><span class="line">        <span class="comment">// EX = 设置过期时间（防死锁保证）</span></span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="type">bool</span> acquired = redis_.<span class="built_in">set</span>(</span><br><span class="line">            lock_key_, </span><br><span class="line">            lock_val_,</span><br><span class="line">            chrono::<span class="built_in">seconds</span>(expire_seconds_),</span><br><span class="line">            sw::redis::UpdateType::NOT_EXIST  <span class="comment">// NX 语义</span></span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">            holding_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 启动后台续约线程，保证长任务不丢锁</span></span><br><span class="line">            renew_thread_ = <span class="built_in">thread</span>(&amp;DistributedLock::renew_loop, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> acquired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="comment">// exchange(false) 原子地：读取旧值 + 设置新值</span></span><br><span class="line">        <span class="comment">// 返回 false 说明之前就是 false，已经释放过了（幂等）</span></span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="keyword">if</span> (!holding_.<span class="built_in">exchange</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 必须等续约线程退出，否则可能：</span></span><br><span class="line">        <span class="comment">// 1. 续约线程还在跑，访问已析构的对象 → 崩溃</span></span><br><span class="line">        <span class="comment">// 2. 刚解锁又被续约 → 逻辑错误</span></span><br><span class="line">        <span class="keyword">if</span> (renew_thread_.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            renew_thread_.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="comment">// Lua 脚本原子解锁：验证 + 删除</span></span><br><span class="line">        <span class="comment">// 必须验证！场景：</span></span><br><span class="line">        <span class="comment">//   1. A 加锁成功，锁过期时间 30s</span></span><br><span class="line">        <span class="comment">//   2. A 业务卡了 35s，锁已自动过期</span></span><br><span class="line">        <span class="comment">//   3. B 抢到锁，开始执行业务</span></span><br><span class="line">        <span class="comment">//   4. A 终于执行完，调用 DEL 删锁 → 删掉了 B 的锁！</span></span><br><span class="line">        <span class="comment">// 用 Lua 脚本保证&quot;验证+删除&quot;原子性</span></span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="type">const</span> string unlock_script = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">            if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">                return redis.call(&#x27;del&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redis_.<span class="built_in">eval</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(unlock_script, &#123;lock_key_&#125;, &#123;lock_val_&#125;);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 解锁失败也没关系，锁会自动过期</span></span><br><span class="line">            <span class="comment">// 这是分布式锁的&quot;最终安全性&quot;保证</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_holding</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holding_.<span class="built_in">load</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;distributed_lock.hpp&quot;</span> <span class="comment">// 包含上述DistributedLock类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">generate_uuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简单实现，实际应使用标准UUID库</span></span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;uuid-&quot;</span> + std::<span class="built_in">to_string</span>(counter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接Redis</span></span><br><span class="line">    sw::<span class="function">redis::Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建分布式锁</span></span><br><span class="line">    <span class="type">const</span> std::string lockKey = <span class="string">&quot;lock:order:12345&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">DistributedLock <span class="title">lock</span><span class="params">(redis, lockKey, <span class="number">30</span>)</span></span>; <span class="comment">// 30秒过期时间</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lock.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取锁成功，执行业务逻辑...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟耗时业务逻辑</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">15</span>));</span><br><span class="line">            </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;业务逻辑执行完毕&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 锁会在作用域结束时自动释放</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取锁失败，资源被占用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 离开作用域，锁自动释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a id="mechanism"></a></p>
<h1 id="附录2：Redis-重要机制"><a href="#附录2：Redis-重要机制" class="headerlink" title="附录2：Redis++ 重要机制"></a>附录2：Redis++ 重要机制</h1><h2 id="1-Redis-的心跳机制（非自己实现）"><a href="#1-Redis-的心跳机制（非自己实现）" class="headerlink" title="1.Redis++ 的心跳机制（非自己实现）"></a>1.Redis++ 的心跳机制（非自己实现）</h2><h3 id="（1）介绍-3"><a href="#（1）介绍-3" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li><strong>心跳机制</strong>:<ul>
<li>是一种定期发送探测信号来确认通信双方是否存活的技术。</li>
</ul>
</li>
<li><strong>Redis++ 的心跳机制</strong>：<ul>
<li><strong>本质</strong>：<ul>
<li>直接启用了 <strong>Linux 内核的 TCP KeepAlive 机制</strong>。</li>
<li><strong>Redis++ 没有自己实现心跳逻辑</strong>，完全依赖操作系统内核的 TCP KeepAlive，这也是最高效的方式（零应用层开销）</li>
</ul>
</li>
<li><a href="/2026/01/13/Linux/TCP_IP%E7%9B%B8%E5%85%B3/TCP%20KeepAlive%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" title="TCP KeepAlive 心跳机制">TCP的心跳机制</a></li>
</ul>
</li>
</ul>
<h3 id="（2）时间流程图"><a href="#（2）时间流程图" class="headerlink" title="（2）时间流程图"></a>（2）时间流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间 ─────────────────────────────────────────────────────────────────────────▶</span><br><span class="line"></span><br><span class="line">[最后数据交互]</span><br><span class="line">      │</span><br><span class="line">      │◀─────── 第1阶段：长等待 ───────▶│◀───── 第2阶段：短间隔探测 ─────▶ │</span><br><span class="line">      │     tcp_keepalive_time          │     tcp_keepalive_intvl         │</span><br><span class="line">      │         = 7200s (2小时)         │         = 75s × 9次              |</span><br><span class="line">      │                                 │                                  │</span><br><span class="line">      │         （空闲，不探测）          │  💓──75s──💓──75s──...──💓     │</span><br><span class="line">      │                                 │  #1      #2          #9          │</span><br><span class="line">      │                                 │                                  │</span><br><span class="line">      └─────────────────────────────────┴──────────────────────────────────┘</span><br><span class="line">                                        │</span><br><span class="line">                                        ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                              最终判定逻辑                                    │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│  ✅ 任意探测收到 ACK → 重置计时器，回到第1阶段                                │</span><br><span class="line">│  ❌ 连续9次无响应    → 判定连接死亡，关闭连接                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">总检测时间 = 7200s + 75s × 9 = 7875s ≈ 2小时11分钟</span><br></pre></td></tr></table></figure>

<h3 id="（3）客户端-↔-Redis-交互示意图"><a href="#（3）客户端-↔-Redis-交互示意图" class="headerlink" title="（3）客户端 ↔ Redis 交互示意图"></a>（3）客户端 ↔ Redis 交互示意图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────┐                                                         ┌─────────────┐</span><br><span class="line">│  Redis++    │                                                         │   Redis     │</span><br><span class="line">│  Client     │                                                         │  Server     │</span><br><span class="line">└──────┬──────┘                                                         └──────┬──────┘</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │ [业务数据交互] → 最后一次数据收发完成 → 连接进入空闲状态                  │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │────────────────────────── 等待 7200s ────────────────────────────────────│</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  💓 发送第1个 Keepalive 探测包                                       │</span><br><span class="line">       │───────────────────────────────────────────────────────────────────────▶│</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │◀───────────────────────────────────────────────────────────────────────│</span><br><span class="line">       │       ✅ 收到 ACK → 重置计时器 → 回到空闲等待（最优路径）                │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  ❌ 未收到 ACK → 等待 75s                                              │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  💓 发送第2个 Keepalive 探测包                                       │</span><br><span class="line">       │───────────────────────────────────────────────────────────────────────▶│</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │◀───────────────────────────────────────────────────────────────────────│</span><br><span class="line">       │       ✅ 收到 ACK → 重置计时器 → 回到空闲等待                          │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  ... 重复探测逻辑，最多发送 9 次探测包 ...                              │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  💓 发送第9个 Keepalive 探测包（最后一次）                              │</span><br><span class="line">       │───────────────────────────────────────────────────────────────────────▶│</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  ❌ 仍未收到 ACK → 判定连接失效 → 关闭当前连接 → 触发应用层重连逻辑        │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       ▼                                                                       ▼</span><br></pre></td></tr></table></figure>


<p><a id="install"></a></p>
<h1 id="附录3：Redis-安装教程"><a href="#附录3：Redis-安装教程" class="headerlink" title="附录3：Redis++ 安装教程"></a>附录3：Redis++ 安装教程</h1><h2 id="1-便捷安装"><a href="#1-便捷安装" class="headerlink" title="1.便捷安装"></a>1.便捷安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先安装 hiredis（底层依赖）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install libhiredis-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 redis-plus-plus</span></span><br><span class="line"><span class="built_in">cd</span> ~/thirdparty    <span class="comment"># 切换到你自己的安装目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sewenew/redis-plus-plus.git</span><br><span class="line"><span class="built_in">cd</span> redis-plus-plus</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">         -DCMAKE_CXX_STANDARD=17 \</span><br><span class="line">         -DHIREDIS_LIB=/usr/local/lib/libhiredis.so</span><br><span class="line"></span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>
<p><strong>如果安装失败，可尝试下面的方法</strong></p>
<h2 id="2-普通安装"><a href="#2-普通安装" class="headerlink" title="2.普通安装"></a>2.普通安装</h2><p><strong>安装 hiredis</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install -y build-essential git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆并编译 hiredis</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/redis/hiredis.git</span><br><span class="line"><span class="built_in">cd</span> hiredis</span><br><span class="line">make &amp;&amp; <span class="built_in">sudo</span> make install</span><br><span class="line"><span class="built_in">sudo</span> ldconfig  <span class="comment"># 更新动态库缓存</span></span><br></pre></td></tr></table></figure>

<p><strong>安装Redis++</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆 Redis++ 源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sewenew/redis-plus-plus.git</span><br><span class="line"><span class="built_in">cd</span> redis-plus-plus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有可用版本</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到你想要的版本（以1.3.15为例）（可选）</span></span><br><span class="line"><span class="comment"># git checkout version</span></span><br><span class="line">git checkout 1.3.15</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置编译选项</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">      -DREDIS_PLUS_PLUS_BUILD_TEST=OFF \</span><br><span class="line">      -DREDIS_PLUS_PLUS_BUILD_STATIC=OFF \</span><br><span class="line">      -DREDIS_PLUS_PLUS_BUILD_SHARED=ON \</span><br><span class="line">      -DREDIS_PLUS_PLUS_CXX_STANDARD=17 \</span><br><span class="line">      ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译（使用多核加速）</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新动态链接库缓存</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>

<h2 id="3-验证安装是否成功"><a href="#3-验证安装是否成功" class="headerlink" title="3.验证安装是否成功"></a>3.验证安装是否成功</h2><h3 id="（1）验证安装是否成功"><a href="#（1）验证安装是否成功" class="headerlink" title="（1）验证安装是否成功"></a>（1）验证安装是否成功</h3><ol>
<li>检查库文件是否存在</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查 redis-plus-plus 库</span></span><br><span class="line"><span class="built_in">ls</span> /usr/local/lib/libredis++.so</span><br><span class="line"><span class="comment"># 检查 hiredis 库</span></span><br><span class="line"><span class="built_in">ls</span> /usr/local/lib/libhiredis.so</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开启Redis服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> redis-server</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写简单测试代码（如 test_redis.cpp）:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sw::redis::ConnectionOptions opts;</span><br><span class="line">    opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    sw::<span class="function">redis::Redis <span class="title">redis</span><span class="params">(opts)</span></span>;</span><br><span class="line">    </span><br><span class="line">    redis.<span class="built_in">set</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> it = redis.<span class="built_in">get</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 注意 *it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(nil)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="4">
<li>编译并运行测试代码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test_redis.cpp -o test_redis -lredis++ -lhiredis -std=c++17</span><br><span class="line"></span><br><span class="line">./test_redis</span><br></pre></td></tr></table></figure>

<h3 id="（2）查看当前安装的版本"><a href="#（2）查看当前安装的版本" class="headerlink" title="（2）查看当前安装的版本"></a>（2）查看当前安装的版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /usr/local/include/sw/redis++/version.h</span><br></pre></td></tr></table></figure>
<p><strong>可以看到</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> VERSION_MAJOR = <span class="number">1</span>;   <span class="comment">// 主版本</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> VERSION_MINOR = <span class="number">3</span>;   <span class="comment">// 次版本</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> VERSION_PATCH = <span class="number">15</span>;  <span class="comment">// 补丁版本</span></span><br><span class="line"><span class="comment">// 当前版本：1.3.15 </span></span><br></pre></td></tr></table></figure>

<h3 id="4-Redis-版本升级（切换）"><a href="#4-Redis-版本升级（切换）" class="headerlink" title="4.Redis++版本升级（切换）"></a>4.Redis++版本升级（切换）</h3><p>以我的安装目录“~&#x2F;thirdparty&#x2F;redis-plus-plus”为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/thirdparty/redis-plus-plus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理旧的构建</span></span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到最新稳定版</span></span><br><span class="line">git checkout 1.3.15</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">      -DREDIS_PLUS_PLUS_CXX_STANDARD=17 \</span><br><span class="line">      ..</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>

<h3 id="5-删除Redis"><a href="#5-删除Redis" class="headerlink" title="5.删除Redis++"></a>5.删除Redis++</h3><p>如果安装失败，可通过下述方式清理Redis++文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ========== 1. 清理 Redis++ 库文件 ==========</span></span><br><span class="line"><span class="comment"># 删除动态库文件（包括软链接）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/libredis++.so</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/libredis++.so.*</span><br><span class="line"><span class="comment"># 删除静态库文件（若有）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/libredis++.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 2. 清理 Redis++ CMake 配置文件 ==========</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/lib/cmake/redis++</span><br><span class="line"><span class="comment"># 删除 pkg-config 配置（若有）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/pkgconfig/redis++.pc</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 3. 清理 Redis++ 头文件 ==========</span></span><br><span class="line"><span class="comment"># 核心头文件目录（包含 StringView 定义）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/include/sw/redis++</span><br><span class="line"><span class="comment"># 若存在 sw 空目录，可一并删除（可选）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rmdir</span> /usr/local/include/sw 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 4. 刷新系统动态库缓存 ==========</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 5. 验证清理结果（可选） ==========</span></span><br><span class="line"><span class="comment"># 若以下命令均无输出，说明清理完成</span></span><br><span class="line">find /usr/local/lib -name <span class="string">&quot;libredis++*&quot;</span></span><br><span class="line">find /usr/local/include -name <span class="string">&quot;redis++&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 6. 删除Redis++目录 ==============</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf redis-plus-plus/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++后端开发库</category>
        <category>redis-plus-plus</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;type_traits&gt; “标准萃取库”</title>
    <url>/2026/01/08/C++/%E6%A0%87%E5%87%86%E5%BA%93/type-traits-%E2%80%9C%E6%A0%87%E5%87%86%E8%90%83%E5%8F%96%E5%BA%93%E2%80%9D/</url>
    <content><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>1.<type_traits> 是 C++11 起引入的<strong>类型萃取</strong>核心头文件，提供<strong>编译期 查询&#x2F;修改类型属性</strong>的工具，在<strong>泛型编程</strong>中高频使用<br>2. <strong>_v 后缀（C++17）</strong>：替代 ::value，<strong>返回布尔常量</strong><br>3. <strong>_t 后缀（C++14）</strong>：替代 ::type，<strong>返回修改后的类型</strong></p>
<p><strong>关键：编译期</strong></p>
<h1 id="2-关键API"><a href="#2-关键API" class="headerlink" title="2.关键API"></a>2.关键API</h1><p><strong>以下工具均来自<type_traits>头文件，是高性能开发（如泛型优化、内存管理、零开销抽象）的核心类型操作工具，兼具编译期无开销、类型安全的特性。</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108161948438.png"></p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="1-std-is-same-v（泛型函数分支优化）"><a href="#1-std-is-same-v（泛型函数分支优化）" class="headerlink" title="1.std::is_same_v&lt;T1, T2&gt;（泛型函数分支优化）"></a>1.std::is_same_v&lt;T1, T2&gt;（泛型函数分支优化）</h3><p><strong>核心功能：编译期区分int和double类型，选用位运算或普通乘法，实现无运行时开销的高效数值计算。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高性能数值计算：根据类型选择最优运算逻辑（编译期分支，无运行时开销）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">high_perf_calc</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期判断类型，int用位运算（比乘法高效），double用普通乘法</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt;&lt; <span class="number">1</span>; <span class="comment">// 位运算替代 *2，性能更优</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">return</span> val * <span class="number">2.0</span>; <span class="comment">// double不支持位运算，直接乘法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用场景</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">high_perf_calc</span>(a) &lt;&lt; std::endl; <span class="comment">// 输出20（位运算）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">high_perf_calc</span>(b) &lt;&lt; std::endl; <span class="comment">// 输出6.28（乘法）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-std-remove-reference-t（完美转发配套优化）"><a href="#2-std-remove-reference-t（完美转发配套优化）" class="headerlink" title="2.std::remove_reference_t（完美转发配套优化）"></a>2.std::remove_reference_t<T>（完美转发配套优化）</h3><p><strong>核心功能：配合std::forward实现参数完美转发，结合编译期类型校验，避免大对象构造时的冗余拷贝。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高性能对象构造：完美转发参数，避免大对象拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T* <span class="title">create_high_perf_obj</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期校验参数类型（移除引用后）是否可构造T，无运行时开销</span></span><br><span class="line">    <span class="built_in">static_assert</span>((std::is_constructible_v&lt;T, std::<span class="type">remove_reference_t</span>&lt;Args&gt;...&gt;), <span class="string">&quot;Args cannot construct T&quot;</span>);</span><br><span class="line">    <span class="comment">// 直接转发参数构造对象，无冗余拷贝（右值时移动，左值时复用）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用场景：大对象（如std::string）构造，避免拷贝开销</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string big_str = <span class="string">&quot;high performance string&quot;</span>;</span><br><span class="line">    <span class="comment">// 转发右值，移动构造（无拷贝）</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">create_high_perf_obj</span>&lt;std::string&gt;(std::<span class="built_in">move</span>(big_str));</span><br><span class="line">    <span class="comment">// 转发临时右值，直接构造（无拷贝）</span></span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">create_high_perf_obj</span>&lt;std::string&gt;(<span class="string">&quot;temporary string&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-std-decay-t（容器元素类型统一）"><a href="#3-std-decay-t（容器元素类型统一）" class="headerlink" title="3.std::decay_t（容器元素类型统一）"></a>3.std::decay_t<T>（容器元素类型统一）</h3><p><strong>核心功能：统一容器元素类型，移除引用、const等限定，通过原地构造优化内存布局，提升容器访问效率。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高性能容器创建：统一元素类型，优化内存布局</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">create_unified_container</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 退化类型：移除引用、const等，确保容器元素类型统一（避免存储引用/const类型）</span></span><br><span class="line">    <span class="keyword">using</span> DecayedType = std::<span class="type">decay_t</span>&lt;T&gt;;</span><br><span class="line">    <span class="comment">// 容器存储退化后的类型，内存布局紧凑，访问效率高</span></span><br><span class="line">    std::vector&lt;DecayedType&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(val)); <span class="comment">// 原地构造，避免拷贝</span></span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用场景：适配不同类型输入，统一容器元素类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string&amp; ref_str = <span class="string">&quot;const reference string&quot;</span>;</span><br><span class="line">    <span class="comment">// 退化后类型为std::string，容器存储非const、非引用类型</span></span><br><span class="line">    <span class="keyword">auto</span> vec = <span class="built_in">create_unified_container</span>(ref_str);</span><br><span class="line">    std::cout &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; std::endl; <span class="comment">// 输出：const reference string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-std-conditional-t（动态类型适配优化）"><a href="#4-std-conditional-t（动态类型适配优化）" class="headerlink" title="4.std::conditional_t&lt;Cond, T1, T2&gt;（动态类型适配优化）"></a>4.std::conditional_t&lt;Cond, T1, T2&gt;（动态类型适配优化）</h3><p><strong>核心功能：根据类型大小动态选择存储方式，小类型栈存储提升访问速度，大类型堆存储避免栈溢出，平衡内存与性能。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高性能内存分配：根据类型大小选择存储方式（小类型栈存，大类型堆存）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">high_perf_allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期判断类型大小，小类型（&lt;=8字节）栈存储，大类型堆存储（平衡内存与速度）</span></span><br><span class="line">    <span class="keyword">using</span> StorageType = std::<span class="type">conditional_t</span>&lt;</span><br><span class="line">        <span class="built_in">sizeof</span>(T) &lt;= <span class="number">8</span>,</span><br><span class="line">        T,                  <span class="comment">// 小类型：栈存储，访问更快</span></span><br><span class="line">        std::unique_ptr&lt;T&gt;  <span class="comment">// 大类型：堆存储，避免栈溢出</span></span><br><span class="line">    &gt;;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>(T) &lt;= <span class="number">8</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StorageType&#123;&#125;;  <span class="comment">// 栈上默认构造</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;T&gt;();  <span class="comment">// 堆上分配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用场景：不同大小类型的差异化存储，提升访问效率</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int（4字节，小类型）：栈存储</span></span><br><span class="line">    <span class="keyword">auto</span> small_storage = <span class="built_in">high_perf_allocate</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="comment">// 大类型（假设BigType占32字节）：堆存储（智能指针自动管理内存）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BigType</span> &#123; <span class="type">char</span> data[<span class="number">32</span>]; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> big_storage = <span class="built_in">high_perf_allocate</span>&lt;BigType&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-std-is-integral-v（数值计算优化）"><a href="#5-std-is-integral-v（数值计算优化）" class="headerlink" title="5.std::is_integral_v（数值计算优化）"></a>5.std::is_integral_v<T>（数值计算优化）</h3><p><strong>核心功能：区分整数与非整数类型，整数用高效位运算处理，非整数用数学函数，实现针对性的数值处理优化。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高性能数值处理：区分整数/非整数，执行专属优化逻辑</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">high_perf_num_process</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 整数类型：用高效位运算处理</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val &amp; <span class="number">0x0F</span>); <span class="comment">// 取低4位，位运算比取模高效</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非整数类型：用数学函数处理</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用场景：通用数值处理函数，兼顾整数高效运算</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">25</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">25.0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">high_perf_num_process</span>(a) &lt;&lt; std::endl; <span class="comment">// 输出9（25的低4位）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">high_perf_num_process</span>(b) &lt;&lt; std::endl; <span class="comment">// 输出5.0（平方根）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-std-enable-if-t-据类型特性启用不同的优化版本"><a href="#6-std-enable-if-t-据类型特性启用不同的优化版本" class="headerlink" title="6.std::enable_if_t&lt;Condition, T&#x3D;void&gt;  据类型特性启用不同的优化版本"></a>6.std::enable_if_t&lt;Condition, T&#x3D;void&gt;  据类型特性启用不同的优化版本</h3><p><strong>核心功能：根据类型是否为算术类型，编译期启用不同版本函数，数值类型执行乘法优化，非数值类型使用通用逻辑，实现精准的类型适配优化。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高性能数值处理：根据类型特性启用不同的优化版本</span></span><br><span class="line"><span class="comment">// 版本1：处理数值类型（启用条件：是数值类型）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;std::is_arithmetic_v&lt;T&gt;, T&gt; </span><br><span class="line"><span class="built_in">optimize_process</span>(T val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数值类型优化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本2：处理非数值类型（启用条件：不是数值类型）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;!std::is_arithmetic_v&lt;T&gt;, T&gt; </span><br><span class="line"><span class="built_in">optimize_process</span>(T val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;非数值类型通用版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用场景：根据类型特性自动选择最优算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">optimize_process</span>(<span class="number">10</span>);     <span class="comment">// 调用数值优化版本</span></span><br><span class="line">    <span class="built_in">optimize_process</span>(std::<span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>)); <span class="comment">// 调用非数值通用版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-std-remove-cv-t（内存操作优化）"><a href="#7-std-remove-cv-t（内存操作优化）" class="headerlink" title="7.std::remove_cv_t（内存操作优化）"></a>7.std::remove_cv_t<T>（内存操作优化）</h3><p><strong>核心功能：移除类型的const&#x2F;volatile限定，确保分配可写内存，同时通过类型转换工具保留原始cv限定供安全使用，实现高性能内存分配与安全访问的平衡。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用std::remove_cv_t的高性能内存处理示例</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">high_perf_mem_alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 移除const/volatile限定，确保分配可写内存</span></span><br><span class="line">    <span class="keyword">using</span> MutableType = std::<span class="type">remove_cv_t</span>&lt;T&gt;;</span><br><span class="line">    <span class="comment">// 分配原始可写内存，即使T是const类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MutableType</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换工具：保留原始类型的cv限定符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">convert_to_original_type</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 即使请求const int类型的内存，也分配可修改的内存</span></span><br><span class="line">    <span class="type">void</span>* memory = <span class="built_in">high_perf_mem_alloc</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充数据（因为实际内存是可写的）</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(memory, &amp;value, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换回const int*类型供后续安全使用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* result = <span class="built_in">convert_to_original_type</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;(memory);</span><br><span class="line">    std::cout &lt;&lt; *result &lt;&lt; std::endl; <span class="comment">// 输出42</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理内存（需要转回非const类型）</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(memory);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-std-common-type-t（多类型运算统一）"><a href="#8-std-common-type-t（多类型运算统一）" class="headerlink" title="8. std::common_type_t&lt;T1, T2…&gt;（多类型运算统一）"></a>8. std::common_type_t&lt;T1, T2…&gt;（多类型运算统一）</h3><p><strong>核心功能：获取多类型的公共兼容类型，统一混合运算的结果类型，避免多次隐式转换，提升运算效率。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高性能多类型混合运算：统一运算结果类型，避免冗余转换开销</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">high_perf_mixed_calc</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取两个类型的公共类型，作为运算结果类型（编译期确定，无运行时开销）</span></span><br><span class="line">    <span class="keyword">using</span> CommonType = std::<span class="type">common_type_t</span>&lt;T1, T2&gt;;</span><br><span class="line">    <span class="comment">// 转换为公共类型运算，避免多次隐式转换，提升效率</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;CommonType&gt;(a) + <span class="built_in">static_cast</span>&lt;CommonType&gt;(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展：支持3个及以上类型的公共类型获取</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">high_perf_mixed_calc</span><span class="params">(T1 a, T2 b, T3 c, Rest... rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> CommonType = std::<span class="type">common_type_t</span>&lt;T1, T2, T3, Rest...&gt;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;CommonType&gt;(a) + <span class="built_in">high_perf_mixed_calc</span>(b, c, rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用场景：多类型混合运算，统一结果类型提升效率</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int与double的公共类型为double</span></span><br><span class="line">    <span class="keyword">auto</span> res1 = <span class="built_in">high_perf_mixed_calc</span>(<span class="number">10</span>, <span class="number">3.14</span>);</span><br><span class="line">    std::cout &lt;&lt; res1 &lt;&lt; <span class="string">&quot; (类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(res1).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出13.14（double）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int、float、long的公共类型为double</span></span><br><span class="line">    <span class="keyword">auto</span> res2 = <span class="built_in">high_perf_mixed_calc</span>(<span class="number">5</span>, <span class="number">2.5f</span>, <span class="number">8L</span>,<span class="number">3.0</span>);</span><br><span class="line">    std::cout &lt;&lt; res2 &lt;&lt; <span class="string">&quot; (类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(res2).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出18.5（double）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-常用API"><a href="#3-常用API" class="headerlink" title="3.常用API"></a>3.常用API</h1><h2 id="1-类型判断"><a href="#1-类型判断" class="headerlink" title="1.类型判断"></a>1.类型判断</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108153048510.png"></p>
<h2 id="2-类型修改"><a href="#2-类型修改" class="headerlink" title="2.类型修改"></a>2.类型修改</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108153216236.png"></p>
<p><strong>补充：”数组退化”与”函数退化”</strong><br>1.T是数组类型：std::decay_t<T> 会将其转换为对应的指针类型<br>2.T 是函数类型：std::decay_t<T> 会将其转换为对应的函数指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.数组退化</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> OriginalType = <span class="keyword">decltype</span>(arr);       <span class="comment">// int[10]</span></span><br><span class="line"><span class="keyword">using</span> DecayedType = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arr)&gt;;  <span class="comment">// int*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;DecayedType, <span class="type">int</span>*&gt;); <span class="comment">// 通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.函数退化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> FuncType = <span class="keyword">decltype</span>(add);           <span class="comment">// int(int, int)</span></span><br><span class="line"><span class="keyword">using</span> DecayedFuncType = std::<span class="type">decay_t</span>&lt;FuncType&gt;;  <span class="comment">// int(*)(int, int)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;DecayedFuncType, <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>)&gt;); <span class="comment">// 通过</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-类型选择"><a href="#3-类型选择" class="headerlink" title="3.类型选择"></a>3.类型选择</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108153946662.png"></p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108154031540.png"></p>
<hr>
<h1 id="4-最佳实践与注意事项"><a href="#4-最佳实践与注意事项" class="headerlink" title="4.最佳实践与注意事项"></a>4.最佳实践与注意事项</h1><h2 id="1-最佳实践"><a href="#1-最佳实践" class="headerlink" title="1.最佳实践"></a>1.最佳实践</h2><p>1.<strong>编译期优化</strong>：优先使用类型特性在编译期解决问题，避免运行时开销<br>2.<strong>与if constexpr结合</strong>：C++17后，结合条件编译实现零开销分支<br>3.<strong>模板特化替代方案</strong>：使用std::enable_if_t代替繁琐的模板特化<br>4.<strong>类型安全转换</strong>：使用static_cast&lt;std::common_type_t&lt;T1, T2&gt;&gt;确保类型安全</p>
<h2 id="2-潜在陷阱"><a href="#2-潜在陷阱" class="headerlink" title="2.潜在陷阱"></a>2.潜在陷阱</h2><p>1.<strong>移除const的限制</strong>：std::remove_cv_t只在类型系统中工作，不能用于绕过const限制<br>2.<strong>类型修饰符检测顺序</strong>：std::is_const_v&lt;int* const&gt; 为false，因为const修饰指针而非int<br>3.<strong>引用类型特性</strong>：引用类型需特别注意，如std::is_same_v&lt;T&amp;, T&gt;永远为false<br>4.<strong>继承关系识别</strong>：std::is_same_v不识别继承关系，需用std::is_base_of_v</p>
<h2 id="3-性能考量"><a href="#3-性能考量" class="headerlink" title="3.性能考量"></a>3.性能考量</h2><p>1.<strong>所有类型特性在编译期计算</strong>：运行时零开销<br>2.<strong>模板实例化增加编译时间和二进制大小</strong>：大型项目中需平衡使用<br>3.<strong>类型特性组合可能导致复杂编译错误</strong>：建议使用概念(Concepts, C++20)简化<br>4.<strong>SFINAE模式可能增加编译时间</strong>：大量使用std::enable_if_t会影响编译性能</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>标准库</category>
        <category>&lt; type_traits &gt; “标准萃取库”</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++关键字</title>
    <url>/2026/01/18/C++/C++%E7%89%B9%E6%80%A7/C-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="1-explicit"><a href="#1-explicit" class="headerlink" title="1.explicit"></a>1.explicit</h1><h2 id="（1）核心作用"><a href="#（1）核心作用" class="headerlink" title="（1）核心作用"></a>（1）核心作用</h2><ul>
<li><strong>阻止隐式类型转换</strong>，强制要求显式调用，避免编译器”自作聪明”地进行意外转换。</li>
<li>explicit 最初是为<strong>单参数构造函数</strong>设计的，但 C++11 之后<strong>扩展了它的用途</strong>。</li>
</ul>
<h2 id="（2）使用场景汇总"><a href="#（2）使用场景汇总" class="headerlink" title="（2）使用场景汇总"></a>（2）使用场景汇总</h2><h3 id="单参数构造函数（最经典）"><a href="#单参数构造函数（最经典）" class="headerlink" title="&lt;1&gt;单参数构造函数（最经典）"></a>&lt;1&gt;单参数构造函数（最经典）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ❌ 不加 explicit</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">int</span> size);  <span class="comment">// 可能导致：String s = 42; 意外编译通过</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ✅ 加 explicit</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">String</span><span class="params">(<span class="type">int</span> size)</span></span>;  <span class="comment">// 必须：String s(42); 或 String s&#123;42&#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐患示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> String&amp; s)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">42</span>);  <span class="comment">// ❌ 不加 explicit：编译通过，42 被隐式转成 String</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">42</span>);  <span class="comment">// ✅ 加 explicit：编译错误，必须 print(String(42))</span></span><br></pre></td></tr></table></figure>
<h3 id="带默认参数的多参数构造函数"><a href="#带默认参数的多参数构造函数" class="headerlink" title="&lt;2&gt;带默认参数的多参数构造函数"></a>&lt;2&gt;带默认参数的多参数构造函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本质上可以只传一个参数调用</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buffer</span><span class="params">(<span class="type">size_t</span> size, <span class="type">char</span> fill = <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Buffer buf = <span class="number">1024</span>;       <span class="comment">// ❌ explicit 阻止</span></span><br><span class="line"><span class="function">Buffer <span class="title">buf</span><span class="params">(<span class="number">1024</span>)</span></span>;        <span class="comment">// ✅ OK</span></span><br><span class="line">Buffer buf&#123;<span class="number">1024</span>, <span class="string">&#x27;x&#x27;</span>&#125;;   <span class="comment">// ✅ OK</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换运算符（C-11）"><a href="#类型转换运算符（C-11）" class="headerlink" title="&lt;3&gt;类型转换运算符（C++11）"></a>&lt;3&gt;类型转换运算符（C++11）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line">    <span class="type">void</span>* ptr_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ❌ 不加 explicit —— 危险</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_ != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ✅ 加 explicit —— 安全</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_ != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="comment">// explicit operator int() const &#123;...&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不加 explicit 的隐患</span></span><br><span class="line"><span class="type">int</span> x = p + <span class="number">1</span>;      <span class="comment">// ❌ 编译通过！p → bool → int</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">1</span>) &#123;&#125;      <span class="comment">// ❌ 编译通过！意外的比较</span></span><br><span class="line">std::cout &lt;&lt; p;     <span class="comment">// ❌ 编译通过！输出 0 或 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加 explicit 后</span></span><br><span class="line"><span class="type">int</span> x = p + <span class="number">1</span>;      <span class="comment">// ✅ 编译错误</span></span><br><span class="line"><span class="keyword">if</span> (p) &#123;&#125;           <span class="comment">// ✅ 布尔上下文允许</span></span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(p);  <span class="comment">// ✅ 显式转换</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化列表构造函数（C-11）"><a href="#初始化列表构造函数（C-11）" class="headerlink" title="&lt;4&gt;初始化列表构造函数（C++11）"></a>&lt;4&gt;初始化列表构造函数（C++11）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vector</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;   <span class="comment">// ❌ explicit 阻止拷贝初始化</span></span><br><span class="line">Vector v2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;      <span class="comment">// ✅ 直接初始化 OK</span></span><br><span class="line"><span class="function">Vector <span class="title">v3</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span></span>;    <span class="comment">// ✅ OK</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++特性</category>
        <category>C++关键字</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++开发规范</title>
    <url>/2026/01/18/C++/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/C-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="一、现代C-规范"><a href="#一、现代C-规范" class="headerlink" title="一、现代C++规范"></a>一、现代C++规范</h1><h2 id="1-汇总表格"><a href="#1-汇总表格" class="headerlink" title="1.汇总表格"></a>1.汇总表格</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118211230598.png"></p>
<h2 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2.使用示例"></a>2.使用示例</h2><p>###（1）常量：constexpr &gt; const &gt; #define</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 首选：constexpr（编译期常量）</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kMaxSize = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> kPi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> kAppName = <span class="string">&quot;MyApp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constexpr 函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">square</span>(<span class="number">10</span>);  <span class="comment">// 编译期计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 运行时常量用 const</span></span><br><span class="line"><span class="type">const</span> std::string configPath = <span class="built_in">getConfigPath</span>();  <span class="comment">// 运行时确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免：宏定义常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100      <span class="comment">// 无类型检查，无作用域</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159        <span class="comment">// 难以调</span></span></span><br></pre></td></tr></table></figure>

<h3 id="（2）字符串：std-string-view（只读）"><a href="#（2）字符串：std-string-view（只读）" class="headerlink" title="（2）字符串：std::string_view（只读）"></a>（2）字符串：std::string_view（只读）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：只读参数用 string_view</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(std::string_view msg)</span> </span>&#123;       <span class="comment">// 零拷贝</span></span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>);                          <span class="comment">// const char* 直接传</span></span><br><span class="line"><span class="built_in">log</span>(std::<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>));             <span class="comment">// std::string 也可以</span></span><br><span class="line"><span class="built_in">log</span>(someStringView);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 函数内只读访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string_view data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">starts_with</span>(<span class="string">&quot;prefix&quot;</span>)) &#123;  <span class="comment">// C++20</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免：不必要的拷贝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;      <span class="comment">// 传 &quot;hello&quot; 会构造临时对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span>;             <span class="comment">// 无法直接传 std::string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 注意：string_view 不拥有数据</span></span><br><span class="line"><span class="function">std::string_view <span class="title">bad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;  <span class="comment">// ❌ 危险！s 被销毁，view 悬空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）初始化：统一初始化"><a href="#（3）初始化：统一初始化" class="headerlink" title="（3）初始化：统一初始化 {}"></a>（3）初始化：统一初始化 {}</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：统一使用 &#123;&#125; 初始化</span></span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">double</span> d&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line">std::string s&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj&#123;arg1, arg2&#125;;</span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;(arg1, arg2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125; 防止窄化转换</span></span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">3.14</span>&#125;;        <span class="comment">// ❌ 编译错误，防止精度丢失</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">3.14</span>;       <span class="comment">// ⚠️ 编译通过，但丢失精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免：混用多种风格</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> c&#123;<span class="number">3</span>&#125;;           <span class="comment">// 同一文件风格不一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 注意：vector 的特殊情况</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;   <span class="comment">// 5 个 1：&#123;1, 1, 1, 1, 1&#125;</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">5</span>, <span class="number">1</span>&#125;;   <span class="comment">// 2 个元素：&#123;5, 1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）类型转换：static-cast-等"><a href="#（4）类型转换：static-cast-等" class="headerlink" title="（4）类型转换：static_cast 等"></a>（4）类型转换：static_cast 等</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：使用 C++ 风格转换</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d);           <span class="comment">// 数值转换</span></span><br><span class="line"></span><br><span class="line">Base* base = &amp;derived;</span><br><span class="line">Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(base);  <span class="comment">// 下行转换（确定类型时）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* vp = &amp;x;</span><br><span class="line"><span class="type">int</span>* ip = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(vp);       <span class="comment">// void* 转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ dynamic_cast：安全的多态转换</span></span><br><span class="line">Base* base = <span class="built_in">getObject</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base)) &#123;</span><br><span class="line">    derived-&gt;<span class="built_in">specialMethod</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ const_cast：移除 const（慎用）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* cp = &amp;x;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ reinterpret_cast：底层位转换（慎用）</span></span><br><span class="line"><span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免：C 风格转换</span></span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)d;                        <span class="comment">// 不安全，难以搜索</span></span><br><span class="line">Derived* d = (Derived*)base;           <span class="comment">// 危险</span></span><br></pre></td></tr></table></figure>

<h1 id="二、项目组织"><a href="#二、项目组织" class="headerlink" title="二、项目组织"></a>二、项目组织</h1><h2 id="1-项目目录结构"><a href="#1-项目目录结构" class="headerlink" title="1.项目目录结构"></a>1.项目目录结构</h2><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">project_name<span class="symbol">/</span></span><br><span class="line">│</span><br><span class="line">├── CMakeLists.txt                    <span class="comment"># 顶层构建文件</span></span><br><span class="line">├── README.md                         <span class="comment"># 项目说明</span></span><br><span class="line">├── LICENSE                           <span class="comment"># 开源协议</span></span><br><span class="line">├── .gitignore</span><br><span class="line">├── .clang-format                     <span class="comment"># 代码格式化配置</span></span><br><span class="line">├── .clang-tidy                       <span class="comment"># 静态分析配置</span></span><br><span class="line">│</span><br><span class="line">├── cmake<span class="symbol">/</span>                            <span class="comment"># CMake 模块和工具</span></span><br><span class="line">│   ├── FindXxx.cmake                 <span class="comment"># 自定义 Find 模块</span></span><br><span class="line">│   ├── ProjectConfig.cmake.<span class="keyword">in</span>        <span class="comment"># 导出配置模板</span></span><br><span class="line">│   └── utils.cmake                   <span class="comment"># 通用 CMake 函数</span></span><br><span class="line">│</span><br><span class="line">├── include<span class="symbol">/</span>                          <span class="comment"># 公开头文件（对外 API）</span></span><br><span class="line">│   └── project_name<span class="symbol">/</span></span><br><span class="line">│       ├── module_a.h</span><br><span class="line">│       ├── module_b.h</span><br><span class="line">│       └── types.h</span><br><span class="line">│</span><br><span class="line">├── src<span class="symbol">/</span>                              <span class="comment"># 源码实现</span></span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── module_a.cpp</span><br><span class="line">│   ├── module_b.cpp</span><br><span class="line">│   │</span><br><span class="line">│   └── detail<span class="symbol">/</span>                       <span class="comment"># 内部实现（不对外暴露）</span></span><br><span class="line">│       ├── internal_utils.h</span><br><span class="line">│       ├── internal_utils.cpp</span><br><span class="line">│       └── impl_helper.h</span><br><span class="line">│</span><br><span class="line">├── test<span class="symbol">/</span>                             <span class="comment"># 单元测试</span></span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── module_a_test.cpp</span><br><span class="line">│   ├── module_b_test.cpp</span><br><span class="line">│   └── test_utils.h                  <span class="comment"># 测试辅助工具</span></span><br><span class="line">│</span><br><span class="line">├── benchmark<span class="symbol">/</span>                        <span class="comment"># 性能测试（可选）</span></span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── module_a_bench.cpp</span><br><span class="line">│</span><br><span class="line">├── examples<span class="symbol">/</span>                         <span class="comment"># 使用示例（可选）</span></span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── basic_usage.cpp</span><br><span class="line">│   └── advanced_usage.cpp</span><br><span class="line">│</span><br><span class="line">├── docs<span class="symbol">/</span>                             <span class="comment"># 文档</span></span><br><span class="line">│   ├── design.md                     <span class="comment"># 设计文档</span></span><br><span class="line">│   ├── api.md                        <span class="comment"># API 文档</span></span><br><span class="line">│   └── Doxyfile                      <span class="comment"># Doxygen 配置</span></span><br><span class="line">│</span><br><span class="line">├── scripts<span class="symbol">/</span>                          <span class="comment"># 脚本工具</span></span><br><span class="line">│   ├── build.sh</span><br><span class="line">│   ├── format.sh                     <span class="comment"># 代码格式化脚本</span></span><br><span class="line">│   └── install_deps.sh</span><br><span class="line">│</span><br><span class="line">├── third_party<span class="symbol">/</span>                      <span class="comment"># 第三方依赖（或用 git submodule）</span></span><br><span class="line">│   └── json<span class="symbol">/</span></span><br><span class="line">│       └── json.hpp</span><br><span class="line">│</span><br><span class="line">└── docker<span class="symbol">/</span>                           <span class="comment"># 容器化（可选）</span></span><br><span class="line">    ├── Dockerfile</span><br><span class="line">    └── docker-compose.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-CMakeLists-txt模板"><a href="#2-CMakeLists-txt模板" class="headerlink" title="2.CMakeLists.txt模板"></a>2.CMakeLists.txt模板</h2><h3 id="（1）顶层CMakeLists-txt"><a href="#（1）顶层CMakeLists-txt" class="headerlink" title="（1）顶层CMakeLists.txt"></a>（1）顶层CMakeLists.txt</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.16)</span><br><span class="line"></span><br><span class="line">project(project_name</span><br><span class="line">    VERSION 1.0.0</span><br><span class="line">    DESCRIPTION &quot;Project description&quot;</span><br><span class="line">    LANGUAGES CXX</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># ============ 编译选项 ============</span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line">set(CMAKE_CXX_EXTENSIONS OFF)</span><br><span class="line">set(CMAKE_EXPORT_COMPILE_COMMANDS ON)  # 生成 compile_commands.json</span><br><span class="line"></span><br><span class="line"># ============ 构建选项 ============</span><br><span class="line">option(BUILD_TESTS &quot;Build unit tests&quot; ON)</span><br><span class="line">option(BUILD_BENCHMARKS &quot;Build benchmarks&quot; OFF)</span><br><span class="line">option(BUILD_EXAMPLES &quot;Build examples&quot; ON)</span><br><span class="line">option(BUILD_DOCS &quot;Build documentation&quot; OFF)</span><br><span class="line"></span><br><span class="line"># ============ 输出目录 ============</span><br><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/bin)</span><br><span class="line">set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)</span><br><span class="line">set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line"># ============ 自定义 CMake 模块路径 ============</span><br><span class="line">list(APPEND CMAKE_MODULE_PATH &quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;)</span><br><span class="line"></span><br><span class="line"># ============ 第三方依赖 ============</span><br><span class="line"># find_package(Boost 1.70 REQUIRED COMPONENTS system filesystem)</span><br><span class="line"># find_package(spdlog REQUIRED)</span><br><span class="line"></span><br><span class="line"># ============ 子目录 ============</span><br><span class="line">add_subdirectory(src)</span><br><span class="line"></span><br><span class="line">if(BUILD_TESTS)</span><br><span class="line">    enable_testing()</span><br><span class="line">    add_subdirectory(test)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">if(BUILD_BENCHMARKS)</span><br><span class="line">    add_subdirectory(benchmark)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">if(BUILD_EXAMPLES)</span><br><span class="line">    add_subdirectory(examples)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"># ============ 安装配置 ============</span><br><span class="line">include(GNUInstallDirs)</span><br><span class="line"></span><br><span class="line">install(</span><br><span class="line">    DIRECTORY include/</span><br><span class="line">    DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="（2）src-CMakeLists-txt-模板"><a href="#（2）src-CMakeLists-txt-模板" class="headerlink" title="（2）src&#x2F;CMakeLists.txt 模板"></a>（2）src&#x2F;CMakeLists.txt 模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 收集源文件</span><br><span class="line">set(SOURCES</span><br><span class="line">    module_a.cpp</span><br><span class="line">    module_b.cpp</span><br><span class="line">    detail/internal_utils.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 创建库</span><br><span class="line">add_library($&#123;PROJECT_NAME&#125; $&#123;SOURCES&#125;)</span><br><span class="line">add_library($&#123;PROJECT_NAME&#125;::$&#123;PROJECT_NAME&#125; ALIAS $&#123;PROJECT_NAME&#125;)</span><br><span class="line"></span><br><span class="line"># 头文件路径</span><br><span class="line">target_include_directories($&#123;PROJECT_NAME&#125;</span><br><span class="line">    PUBLIC</span><br><span class="line">        $&lt;BUILD_INTERFACE:$&#123;CMAKE_SOURCE_DIR&#125;/include&gt;</span><br><span class="line">        $&lt;INSTALL_INTERFACE:$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&gt;</span><br><span class="line">    PRIVATE</span><br><span class="line">        $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;          # src/ 目录</span><br><span class="line">        $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/detail   # detail/ 目录</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 链接依赖</span><br><span class="line"># target_link_libraries($&#123;PROJECT_NAME&#125;</span><br><span class="line">#     PUBLIC</span><br><span class="line">#         Boost::system</span><br><span class="line">#     PRIVATE</span><br><span class="line">#         spdlog::spdlog</span><br><span class="line"># )</span><br><span class="line"></span><br><span class="line"># 编译选项</span><br><span class="line">target_compile_options($&#123;PROJECT_NAME&#125; PRIVATE</span><br><span class="line">    $&lt;$&lt;CXX_COMPILER_ID:GNU,Clang&gt;:-Wall -Wextra -Wpedantic&gt;</span><br><span class="line">    $&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/W4&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 安装目标</span><br><span class="line">install(TARGETS $&#123;PROJECT_NAME&#125;</span><br><span class="line">    EXPORT $&#123;PROJECT_NAME&#125;Targets</span><br><span class="line">    LIBRARY DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;</span><br><span class="line">    ARCHIVE DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;</span><br><span class="line">    RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="（2）test-CMakeLists-txt-模板"><a href="#（2）test-CMakeLists-txt-模板" class="headerlink" title="（2）test&#x2F;CMakeLists.txt 模板"></a>（2）test&#x2F;CMakeLists.txt 模板</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找测试框架</span><br><span class="line">find_package(GTest REQUIRED)</span><br><span class="line"># 或使用 FetchContent 自动下载</span><br><span class="line"># include(FetchContent)</span><br><span class="line"># FetchContent_Declare(googletest</span><br><span class="line">#     GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">#     GIT_TAG release-1.12.1</span><br><span class="line"># )</span><br><span class="line"># FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line"># 测试源文件</span><br><span class="line">set(TEST_SOURCES</span><br><span class="line">    module_a_test.cpp</span><br><span class="line">    module_b_test.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 创建测试可执行文件</span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125;_test $&#123;TEST_SOURCES&#125;)</span><br><span class="line"></span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125;_test</span><br><span class="line">    PRIVATE</span><br><span class="line">        $&#123;PROJECT_NAME&#125;</span><br><span class="line">        GTest::gtest</span><br><span class="line">        GTest::gtest_main</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 注册测试</span><br><span class="line">include(GoogleTest)</span><br><span class="line">gtest_discover_tests($&#123;PROJECT_NAME&#125;_test)</span><br></pre></td></tr></table></figure>



<h1 id="三、命名规范"><a href="#三、命名规范" class="headerlink" title="三、命名规范"></a>三、命名规范</h1><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118151618231.png"></p>
<h1 id="四、代码风格规范"><a href="#四、代码风格规范" class="headerlink" title="四、代码风格规范"></a>四、代码风格规范</h1><h2 id="1-头文件规范"><a href="#1-头文件规范" class="headerlink" title="1.头文件规范"></a>1.头文件规范</h2><h3 id="（1）汇总表格"><a href="#（1）汇总表格" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118205115805.png"></p>
<h3 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h3><h4 id="用-pragma-once"><a href="#用-pragma-once" class="headerlink" title="&lt;1&gt;用 #pragma once"></a>&lt;1&gt;用 #pragma once</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 传统方式（冗长，容易出错）</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USER_SERVICE_USER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_SERVICE_USER_H_</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 推荐方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="头文件自包含"><a href="#头文件自包含" class="headerlink" title="&lt;2&gt;头文件自包含"></a>&lt;2&gt;头文件自包含</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：依赖外部先 include &lt;string&gt;</span></span><br><span class="line"><span class="comment">// user.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    std::string name;  <span class="comment">// 编译失败，std::string 未定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：头文件自己包含所有依赖</span></span><br><span class="line"><span class="comment">// user.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    std::string name;  <span class="comment">// ✅ 可独立编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="include-顺序"><a href="#include-顺序" class="headerlink" title="&lt;3&gt;include 顺序"></a>&lt;3&gt;include 顺序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user_service.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_service.h&quot;</span>      <span class="comment">// ① 对应的 .h（验证头文件自包含）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>              <span class="comment">// ② C 标准库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>              <span class="comment">// ③ C++ 标准库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;spdlog/spdlog.h&gt;</span>     <span class="comment">// ④ 第三方库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/utils.h&quot;</span>      <span class="comment">// ⑤ 项目头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;models/user.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="组间空行"><a href="#组间空行" class="headerlink" title="&lt;4&gt; 组间空行"></a>&lt;4&gt; 组间空行</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：不同类别之间空一行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;order_service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;models/order.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：全部挤在一起</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;order_service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common/config.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="前向声明优先"><a href="#前向声明优先" class="headerlink" title="&lt;5&gt;前向声明优先"></a>&lt;5&gt;前向声明优先</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 不推荐：不必要的 include（增加编译依赖）</span></span><br><span class="line"><span class="comment">// user_service.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;models/user.h&quot;</span>       <span class="comment">// 完整定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;repositories/user_repository.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function">User* <span class="title">getUser</span><span class="params">(<span class="type">int</span> id)</span></span>;     <span class="comment">// 只用指针，不需要完整定义</span></span><br><span class="line">    UserRepository* repo_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 推荐：使用前向声明</span></span><br><span class="line"><span class="comment">// user_service.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>;                    <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepository</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function">User* <span class="title">getUser</span><span class="params">(<span class="type">int</span> id)</span></span>;     <span class="comment">// ✅ 指针/引用只需前向声明</span></span><br><span class="line">    UserRepository* repo_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user_service.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;models/user.h&quot;</span>       <span class="comment">// 实现文件才 include 完整定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;repositories/user_repository.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>何时必须 include（不能前向声明）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    Foo* ptr;      <span class="comment">// ✅ 指针 - 可以</span></span><br><span class="line">    Foo&amp; ref;      <span class="comment">// ✅ 引用 - 可以</span></span><br><span class="line">    Foo obj;       <span class="comment">// ❌ 对象 - 需要完整定义</span></span><br><span class="line">    <span class="function">Foo <span class="title">func</span><span class="params">()</span></span>;    <span class="comment">// ✅ 返回值 - 可以（声明时）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Foo)</span></span>;   <span class="comment">// ✅ 参数 - 可以（声明时）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-注释规范"><a href="#2-注释规范" class="headerlink" title="2.注释规范"></a>2.注释规范</h2><h3 id="（1）汇总表格-1"><a href="#（1）汇总表格-1" class="headerlink" title="（1）汇总表格"></a>（1）汇总表格</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118210302886.png"></p>
<h3 id="（2）使用示例"><a href="#（2）使用示例" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><h4 id="文件头注释"><a href="#文件头注释" class="headerlink" title="&lt;1&gt;文件头注释"></a>&lt;1&gt;文件头注释</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file user_service.h</span></span><br><span class="line"><span class="comment"> * @brief 用户服务模块，提供用户的增删改查功能</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author zhangsan</span></span><br><span class="line"><span class="comment"> * @date 2024-01-15</span></span><br><span class="line"><span class="comment"> * @version 1.0.0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2024 MyCompany</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="类注释"><a href="#类注释" class="headerlink" title="&lt;2&gt;类注释"></a>&lt;2&gt;类注释</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用户服务类，封装用户相关的业务逻辑</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 负责用户的创建、查询、更新、删除等操作，</span></span><br><span class="line"><span class="comment"> * 通过 UserRepository 与数据层交互。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note 线程安全：此类非线程安全，多线程使用需外部同步</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @see UserRepository</span></span><br><span class="line"><span class="comment"> * @see User</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 简单类可以用单行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="函数注释"><a href="#函数注释" class="headerlink" title="&lt;3&gt;函数注释"></a>&lt;3&gt;函数注释</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据 ID 查找用户</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param id 用户 ID，必须为正整数</span></span><br><span class="line"><span class="comment"> * @return User* 找到返回用户指针，未找到返回 nullptr</span></span><br><span class="line"><span class="comment"> * @throw std::invalid_argument 当 id &lt;= 0 时抛出</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note 返回的指针由 Repository 管理，调用者不应删除</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @code</span></span><br><span class="line"><span class="comment"> * auto* user = service.findById(123);</span></span><br><span class="line"><span class="comment"> * if (user) &#123;</span></span><br><span class="line"><span class="comment"> *     std::cout &lt;&lt; user-&gt;name &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * @endcode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">User* <span class="title">findById</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建新用户</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in] name 用户名，不能为空</span></span><br><span class="line"><span class="comment"> * @param[in] email 邮箱地址</span></span><br><span class="line"><span class="comment"> * @param[out] errorMsg 失败时的错误信息</span></span><br><span class="line"><span class="comment"> * @return int 成功返回用户 ID，失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createUser</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; email, std::string&amp; errorMsg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单函数可用单行注释</span></span><br><span class="line"><span class="comment">/// @brief 获取用户数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getUserCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="行内注释"><a href="#行内注释" class="headerlink" title="&lt;4&gt;行内注释"></a>&lt;4&gt;行内注释</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：// 后空一格，与代码间隔至少 2 空格</span></span><br><span class="line"><span class="type">int</span> maxRetry = <span class="number">3</span>;  <span class="comment">// 最大重试次数</span></span><br><span class="line"><span class="type">int</span> timeout = <span class="number">5000</span>;  <span class="comment">// 超时时间（毫秒）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 复杂逻辑前单独一行注释</span></span><br><span class="line"><span class="comment">// 使用二分查找优化性能，时间复杂度 O(log n)</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：无空格或间隔不足</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;<span class="comment">// 说明</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>; <span class="comment">//说明</span></span><br></pre></td></tr></table></figure>

<h4 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="&lt;5&gt;TODO 注释"></a>&lt;5&gt;TODO 注释</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(zhangsan): 优化数据库查询性能，考虑添加缓存</span></span><br><span class="line"><span class="function">User* <span class="title">findById</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repo_-&gt;<span class="built_in">findById</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO(zhangsan): 2024-Q2 支持批量查询接口</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 添加分页功能（无作者时可省略）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(lisi): 这里需要添加输入校验</span></span><br><span class="line">    <span class="built_in">doSomething</span>(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FIXME-注释"><a href="#FIXME-注释" class="headerlink" title="&lt;6&gt;FIXME 注释"></a>&lt;6&gt;FIXME 注释</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FIXME(lisi): 修复当 name 为空时的崩溃问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;  <span class="comment">// 未检查空值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FIXME(wangwu): 边界情况：当列表为空时返回值不正确</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> 内存泄漏，需要在析构函数中释放</span></span><br></pre></td></tr></table></figure>

<h4 id="HACK-注释"><a href="#HACK-注释" class="headerlink" title="&lt;7&gt;HACK 注释"></a>&lt;7&gt;HACK 注释</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">HACK:</span> 临时绕过第三方库的 bug，等待 v2.0 修复后移除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">100</span>);  <span class="comment">// 延迟避免竞态条件</span></span><br><span class="line">    client.<span class="built_in">connect</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">HACK:</span> Windows 下的特殊处理，Linux 不需要</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>);  <span class="comment">// <span class="doctag">HACK:</span> 强制 UTF-8 输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">HACK:</span> 硬编码魔数，后续需要改为配置项</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAGIC_BUFFER_SIZE = <span class="number">4096</span>;</span><br></pre></td></tr></table></figure>

<h4 id="废弃标记"><a href="#废弃标记" class="headerlink" title="&lt;8&gt;废弃标记"></a>&lt;8&gt;废弃标记</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取用户名（已废弃）</span></span><br><span class="line"><span class="comment"> * @deprecated 使用 getDisplayName() 替代，将在 v2.0 移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;Use getDisplayName() instead, will be removed in v2.0&quot;</span>)]]</span><br><span class="line"><span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新接口</span></span><br><span class="line"><span class="function">std::string <span class="title">getDisplayName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> displayName_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 废弃整个类</span></span><br><span class="line"><span class="keyword">class</span> [[<span class="built_in">deprecated</span>(<span class="string">&quot;Use NewUserManager instead&quot;</span>)]] OldUserManager &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="禁止：无意义的注释"><a href="#禁止：无意义的注释" class="headerlink" title="&lt;9&gt;禁止：无意义的注释"></a>&lt;9&gt;禁止：无意义的注释</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：显而易见的注释</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 定义 count 变量</span></span><br><span class="line">i++;  <span class="comment">// i 加 1</span></span><br><span class="line"><span class="comment">// 循环遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 调用处理函数</span></span><br><span class="line">    <span class="built_in">process</span>(arr[i]);  <span class="comment">// 处理 arr[i]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：注释解释&quot;为什么&quot;，而非&quot;是什么&quot;</span></span><br><span class="line"><span class="comment">// 从 1 开始，跳过已处理的头元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">process</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：装饰性注释</span></span><br><span class="line"><span class="comment">/*************************************/</span></span><br><span class="line"><span class="comment">/*          这是注释                  */</span></span><br><span class="line"><span class="comment">/*************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：简洁的分隔符（如果需要）</span></span><br><span class="line"><span class="comment">// ═══════════════════════════════════</span></span><br><span class="line"><span class="comment">// 用户相关函数</span></span><br><span class="line"><span class="comment">// ═══════════════════════════════════</span></span><br></pre></td></tr></table></figure>

<h2 id="3-代码组织规范"><a href="#3-代码组织规范" class="headerlink" title="3.代码组织规范"></a>3.代码组织规范</h2><h3 id="（1）表格汇总"><a href="#（1）表格汇总" class="headerlink" title="（1）表格汇总"></a>（1）表格汇总</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118210850782.png"></p>
<h3 id="（2）使用示例-1"><a href="#（2）使用示例-1" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><h4 id="类成员顺序：public-→-protected-→-private"><a href="#类成员顺序：public-→-protected-→-private" class="headerlink" title="&lt;1&gt;类成员顺序：public → protected → private"></a>&lt;1&gt;类成员顺序：public → protected → private</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：按访问权限从宽到严排列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公开接口在最前，使用者最关心</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">User* <span class="title">findById</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 子类可能用到的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">validateUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部实现细节</span></span><br><span class="line">    UserRepository* repo_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：顺序混乱</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UserRepository* repo_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createUser</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cache_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">User* <span class="title">findById</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="成员内部顺序"><a href="#成员内部顺序" class="headerlink" title="&lt;2&gt;成员内部顺序"></a>&lt;2&gt;成员内部顺序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ① 类型别名</span></span><br><span class="line">    <span class="keyword">using</span> Ptr = std::shared_ptr&lt;UserService&gt;;</span><br><span class="line">    <span class="keyword">using</span> UserList = std::vector&lt;User*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 静态成员</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kMaxUsers = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> UserService&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 构造/析构</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UserService</span><span class="params">(std::shared_ptr&lt;UserRepository&gt; repo)</span></span>;</span><br><span class="line">    ~<span class="built_in">UserService</span>();</span><br><span class="line">    <span class="built_in">UserService</span>(<span class="type">const</span> UserService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    UserService&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UserService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④ 普通函数</span></span><br><span class="line">    <span class="function">User* <span class="title">findById</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">    <span class="function">UserList <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">createUser</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deleteUser</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ① 类型别名</span></span><br><span class="line">    <span class="keyword">using</span> CacheMap = std::unordered_map&lt;<span class="type">int</span>, User*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 静态成员</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> instanceCount_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④ 普通函数（私有辅助函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refreshCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateInput</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑤ 数据成员（最后）</span></span><br><span class="line">    std::shared_ptr&lt;UserRepository&gt; repo_;</span><br><span class="line">    CacheMap cache_;</span><br><span class="line">    <span class="type">int</span> maxCacheSize_ = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参数数量：不超过-5-个"><a href="#参数数量：不超过-5-个" class="headerlink" title="&lt;3&gt;参数数量：不超过 5 个"></a>&lt;3&gt;参数数量：不超过 5 个</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：参数过多（7 个）</span></span><br><span class="line"><span class="function">User* <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; email,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; password,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> age,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; phone,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; address,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> isAdmin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：使用结构体封装</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CreateUserOptions</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string email;</span><br><span class="line">    std::string password;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">    std::string phone;</span><br><span class="line">    std::string address;</span><br><span class="line">    <span class="type">bool</span> isAdmin = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">User* <span class="title">createUser</span><span class="params">(<span class="type">const</span> CreateUserOptions&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时更清晰</span></span><br><span class="line"><span class="keyword">auto</span> user = <span class="built_in">createUser</span>(&#123;</span><br><span class="line">    .name = <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    .email = <span class="string">&quot;zhangsan@example.com&quot;</span>,</span><br><span class="line">    .password = <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    .age = <span class="number">25</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 另一种方式：Builder 模式</span></span><br><span class="line"><span class="keyword">auto</span> user = <span class="built_in">UserBuilder</span>()</span><br><span class="line">    .<span class="built_in">name</span>(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">    .<span class="built_in">email</span>(<span class="string">&quot;zhangsan@example.com&quot;</span>)</span><br><span class="line">    .<span class="built_in">password</span>(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    .<span class="built_in">age</span>(<span class="number">25</span>)</span><br><span class="line">    .<span class="built_in">build</span>();</span><br></pre></td></tr></table></figure>

<h2 id="4-格式化规范"><a href="#4-格式化规范" class="headerlink" title="4.格式化规范"></a>4.格式化规范</h2><h3 id="（1）表格汇总-1"><a href="#（1）表格汇总-1" class="headerlink" title="（1）表格汇总"></a>（1）表格汇总</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118205735765.png"></p>
<p>####（2）使用示例</p>
<h4 id="大括号风格"><a href="#大括号风格" class="headerlink" title="&lt;1&gt;大括号风格"></a>&lt;1&gt;大括号风格</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ K&amp;R 风格（推荐）：左括号不换行</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">doOther</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ Allman 风格：左括号换行</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">doOther</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：混用</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                    <span class="comment">// 风格不一致</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">doOther</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针-引用位置"><a href="#指针-引用位置" class="headerlink" title="&lt;2&gt;指针&#x2F;引用位置"></a>&lt;2&gt;指针&#x2F;引用位置</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 风格 A：靠近类型（推荐，强调类型）</span></span><br><span class="line"><span class="type">int</span>* ptr;</span><br><span class="line"><span class="type">const</span> std::string&amp; name;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;* vec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 风格 B：靠近变量</span></span><br><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line"><span class="type">const</span> std::string &amp;name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：混用</span></span><br><span class="line"><span class="type">int</span>* ptr1;</span><br><span class="line"><span class="type">int</span> *ptr2;              <span class="comment">// 同一文件风格不一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 注意：多变量声明时的陷阱</span></span><br><span class="line"><span class="type">int</span>* a, b;              <span class="comment">// a 是指针，b 是 int！</span></span><br><span class="line"><span class="type">int</span> *a, *b;             <span class="comment">// 都是指针（风格 B 更清晰）</span></span><br><span class="line"><span class="type">int</span>* a;                 <span class="comment">// ✅ 推荐：每行只声明一个变量</span></span><br><span class="line"><span class="type">int</span>* b;</span><br></pre></td></tr></table></figure>

<h4 id="函数参数换行"><a href="#函数参数换行" class="headerlink" title="&lt;3&gt;函数参数换行"></a>&lt;3&gt;函数参数换行</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 短参数：一行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 超过 120 字符：每个参数独占一行，对齐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createUserWithFullInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; username,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; email,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; password,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Address&amp; address,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;std::string&gt;&amp; roles)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 函数调用同理</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">sendHttpRequest</span>(</span><br><span class="line">    <span class="string">&quot;https://api.example.com/users&quot;</span>,</span><br><span class="line">    HttpMethod::POST,</span><br><span class="line">    headers,</span><br><span class="line">    requestBody,</span><br><span class="line">    timeoutMs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 链式调用</span></span><br><span class="line"><span class="keyword">auto</span> query = db.<span class="built_in">select</span>(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">    .<span class="built_in">where</span>(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    .<span class="built_in">where</span>(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="string">&quot;active&quot;</span>)</span><br><span class="line">    .<span class="built_in">orderBy</span>(<span class="string">&quot;created_at&quot;</span>, <span class="string">&quot;DESC&quot;</span>)</span><br><span class="line">    .<span class="built_in">limit</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h4 id="行尾空格-文件末尾"><a href="#行尾空格-文件末尾" class="headerlink" title="&lt;4&gt;行尾空格 &amp; 文件末尾"></a>&lt;4&gt;行尾空格 &amp; 文件末尾</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：行尾有空格（不可见但存在）</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;   ␣␣␣        <span class="comment">// ← 行尾空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：无行尾空格</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 文件末尾：有且仅有一个空行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lastFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">⏎                       <span class="comment">// ← 文件最后一行是空行，然后 EOF</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>开发笔记</category>
        <category>C++开发规范</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板基础语法</title>
    <url>/2026/01/19/C++/C++%E7%89%B9%E6%80%A7/CPP%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、函数模板"><a href="#一、函数模板" class="headerlink" title="一、函数模板"></a>一、函数模板</h1><h2 id="1-定义格式"><a href="#1-定义格式" class="headerlink" title="1.定义格式"></a>1.定义格式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.基本格式（类型参数）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.多类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max_val</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;  <span class="comment">// C++11后auto可推导返回值类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.非类型参数（必须是编译期可确定的常量，如整数、指针、引用）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="function">T <span class="title">sum_array</span><span class="params">(T arr[N])</span> </span>&#123;</span><br><span class="line">    T sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.默认模板参数（类型参数与非类型参数均可设置默认值）</span></span><br><span class="line"><span class="comment">// 规则：无默认值的参数在前，有默认值的参数在后，避免歧义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> E = std::string&gt;  <span class="comment">// 类型参数默认值</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">printPair</span>(T a, E b) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pair: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N = <span class="number">5</span>&gt;  <span class="comment">// 非类型参数默认值</span></span><br><span class="line">T <span class="built_in">getMax</span>(T arr[]) &#123;</span><br><span class="line">    T max_val = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max_val) max_val = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// === 1. 基本格式 ===</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=== 基本格式 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl;           <span class="comment">// 自动推导：int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.5</span>, <span class="number">2.3</span>) &lt;&lt; std::endl;       <span class="comment">// 自动推导：double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl;      <span class="comment">// 显式指定类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 2. 多类型参数 ===</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== 多类型参数 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max_val</span>(<span class="number">3</span>, <span class="number">5.5</span>) &lt;&lt; std::endl;     <span class="comment">// int vs double → double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max_val</span>(<span class="number">10.2</span>, <span class="number">5</span>) &lt;&lt; std::endl;    <span class="comment">// double vs int → double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max_val</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">100</span>) &lt;&lt; std::endl;   <span class="comment">// char vs int → int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 3. 非类型参数 ===</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== 非类型参数 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">double</span> arr2[] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum_array</span>(arr1) &lt;&lt; std::endl;     <span class="comment">// 自动推导 N=5，输出 15</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum_array</span>(arr2) &lt;&lt; std::endl;     <span class="comment">// 自动推导 N=3，输出 6.6</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 4. 默认模板参数 ===</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== 默认模板参数 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// printPair</span></span><br><span class="line">    <span class="built_in">printPair</span>(<span class="number">42</span>, <span class="string">&quot;hello&quot;</span>);                        <span class="comment">// T=int, E=string（默认）</span></span><br><span class="line">    <span class="built_in">printPair</span>(<span class="number">3.14</span>, <span class="string">&quot;world&quot;</span>);                      <span class="comment">// T=double, E=string（默认）</span></span><br><span class="line">    <span class="built_in">printPair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">10</span>, <span class="number">20</span>);                   <span class="comment">// 显式指定 E=int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getMax</span></span><br><span class="line">    <span class="type">int</span> arr3[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr4[<span class="number">3</span>] = &#123;<span class="number">100</span>, <span class="number">50</span>, <span class="number">75</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>(arr3) &lt;&lt; std::endl;        <span class="comment">// N=5（默认），输出 9</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getMax</span>&lt;<span class="type">int</span>, <span class="number">3</span>&gt;(arr4) &lt;&lt; std::endl;<span class="comment">// 显式指定 N=3，输出 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、类模板"><a href="#二、类模板" class="headerlink" title="二、类模板"></a>二、类模板</h1><h2 id="1-定义格式-1"><a href="#1-定义格式-1" class="headerlink" title="1.定义格式"></a>1.定义格式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="comment">// 1. 基本格式（类型参数）</span></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(T v)</span> </span>&#123; value = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="comment">// 2. 多类型参数</span></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pair</span>(K k, V v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="comment">// 3. 非类型参数（编译期常量）</span></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[Size];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Size; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="comment">// 4. 默认模板参数</span></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1 类型参数默认值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> E = std::string&gt;</span><br><span class="line"><span class="keyword">class</span> DataHolder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T id;</span><br><span class="line">    E description;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DataHolder</span>(T i, E desc) : <span class="built_in">id</span>(i), <span class="built_in">description</span>(desc) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Desc: &quot;</span> &lt;&lt; description &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.2 非类型参数默认值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="type">int</span> Capacity = <span class="number">10</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[Capacity];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &lt; Capacity - <span class="number">1</span>) data[++top] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (top &gt;= <span class="number">0</span>) ? data[top--] : T&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="number">-1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.3 混合默认参数（类型 + 非类型）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="keyword">typename</span> E = std::string, <span class="type">int</span> Capacity = <span class="number">10</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Container &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T keys[Capacity];</span><br><span class="line">    E values[Capacity];</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T key, E value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; Capacity) &#123;</span><br><span class="line">            keys[count] = key;</span><br><span class="line">            values[count] = value;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; keys[i] &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; values[i] &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Capacity; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="comment">// 5. 模板模板参数</span></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T, std::allocator&lt;T&gt;&gt; container;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; item)</span> </span>&#123; container.<span class="built_in">push_back</span>(item); &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> container.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="comment">// 6. 类外定义成员函数</span></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Calculator</span>(T v) : <span class="built_in">val</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">add</span><span class="params">(T x)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">multiply</span><span class="params">(T x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Calculator&lt;T&gt;::<span class="built_in">add</span>(T x) &#123;</span><br><span class="line">    <span class="keyword">return</span> val + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Calculator&lt;T&gt;::<span class="built_in">multiply</span>(T x) &#123;</span><br><span class="line">    <span class="keyword">return</span> val * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// ===========================================</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;========== 1. 基本格式 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Box&lt;<span class="type">int</span>&gt; <span class="title">intBox</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="function">Box&lt;std::string&gt; <span class="title">strBox</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Box&lt;<span class="type">double</span>&gt; <span class="title">dblBox</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;intBox: &quot;</span> &lt;&lt; intBox.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;strBox: &quot;</span> &lt;&lt; strBox.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dblBox: &quot;</span> &lt;&lt; dblBox.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    intBox.<span class="built_in">set</span>(<span class="number">100</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;intBox after set: &quot;</span> &lt;&lt; intBox.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== 2. 多类型参数 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">1</span>, <span class="number">99.99</span>)</span></span>;</span><br><span class="line">    <span class="function">Pair&lt;std::string, std::string&gt; <span class="title">p3</span><span class="params">(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; p<span class="number">1.</span><span class="built_in">getKey</span>() &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">2.</span><span class="built_in">getKey</span>() &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">3.</span><span class="built_in">getKey</span>() &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; p<span class="number">3.</span><span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== 3. 非类型参数 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr1;</span><br><span class="line">    Array&lt;<span class="type">double</span>, <span class="number">3</span>&gt; arr2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        arr1[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr2[<span class="number">0</span>] = <span class="number">1.1</span>; arr2[<span class="number">1</span>] = <span class="number">2.2</span>; arr2[<span class="number">2</span>] = <span class="number">3.3</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr1 (size=&quot;</span> &lt;&lt; arr<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr2 (size=&quot;</span> &lt;&lt; arr<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr<span class="number">2.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== 4.1 类型参数默认值 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">DataHolder&lt;<span class="type">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;First Item&quot;</span>)</span></span>;           <span class="comment">// E = std::string（默认）</span></span><br><span class="line">    <span class="function">DataHolder&lt;<span class="type">double</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">3.14</span>, <span class="string">&quot;Pi Value&quot;</span>)</span></span>;       <span class="comment">// E = std::string（默认）</span></span><br><span class="line">    <span class="function">DataHolder&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;             <span class="comment">// E = int（显式指定）</span></span><br><span class="line">    <span class="function">DataHolder&lt;std::string, <span class="type">double</span>&gt; <span class="title">d4</span><span class="params">(<span class="string">&quot;price&quot;</span>, <span class="number">99.99</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    d<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line">    d<span class="number">2.</span><span class="built_in">print</span>();</span><br><span class="line">    d<span class="number">3.</span><span class="built_in">print</span>();</span><br><span class="line">    d<span class="number">4.</span><span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== 4.2 非类型参数默认值 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Stack&lt;&gt; s1;                  <span class="comment">// T=int, Capacity=10（全部默认）</span></span><br><span class="line">    Stack&lt;<span class="type">double</span>&gt; s2;            <span class="comment">// T=double, Capacity=10（默认）</span></span><br><span class="line">    Stack&lt;<span class="type">char</span>, <span class="number">5</span>&gt; s3;           <span class="comment">// T=char, Capacity=5</span></span><br><span class="line">    </span><br><span class="line">    s<span class="number">1.</span><span class="built_in">push</span>(<span class="number">10</span>); s<span class="number">1.</span><span class="built_in">push</span>(<span class="number">20</span>); s<span class="number">1.</span><span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 pop: &quot;</span> &lt;&lt; s<span class="number">1.</span><span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s<span class="number">1.</span><span class="built_in">pop</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    s<span class="number">2.</span><span class="built_in">push</span>(<span class="number">1.1</span>); s<span class="number">2.</span><span class="built_in">push</span>(<span class="number">2.2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 pop: &quot;</span> &lt;&lt; s<span class="number">2.</span><span class="built_in">pop</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    s<span class="number">3.</span><span class="built_in">push</span>(<span class="string">&#x27;A&#x27;</span>); s<span class="number">3.</span><span class="built_in">push</span>(<span class="string">&#x27;B&#x27;</span>); s<span class="number">3.</span><span class="built_in">push</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s3 pop: &quot;</span> &lt;&lt; s<span class="number">3.</span><span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s<span class="number">3.</span><span class="built_in">pop</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== 4.3 混合默认参数 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Container&lt;&gt; c1;                              <span class="comment">// T=int, E=string, Capacity=10</span></span><br><span class="line">    Container&lt;<span class="type">double</span>&gt; c2;                        <span class="comment">// T=double, E=string, Capacity=10</span></span><br><span class="line">    Container&lt;<span class="type">int</span>, <span class="type">int</span>&gt; c3;                      <span class="comment">// T=int, E=int, Capacity=10</span></span><br><span class="line">    Container&lt;std::string, <span class="type">double</span>, <span class="number">5</span>&gt; c4;        <span class="comment">// 全部显式指定</span></span><br><span class="line">    </span><br><span class="line">    c<span class="number">1.</span><span class="built_in">add</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    c<span class="number">1.</span><span class="built_in">add</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c1 (capacity=&quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    c<span class="number">1.</span><span class="built_in">printAll</span>();</span><br><span class="line">    </span><br><span class="line">    c<span class="number">2.</span><span class="built_in">add</span>(<span class="number">1.1</span>, <span class="string">&quot;one point one&quot;</span>);</span><br><span class="line">    c<span class="number">2.</span><span class="built_in">add</span>(<span class="number">2.2</span>, <span class="string">&quot;two point two&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    c<span class="number">2.</span><span class="built_in">printAll</span>();</span><br><span class="line">    </span><br><span class="line">    c<span class="number">3.</span><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    c<span class="number">3.</span><span class="built_in">add</span>(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c3:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    c<span class="number">3.</span><span class="built_in">printAll</span>();</span><br><span class="line">    </span><br><span class="line">    c<span class="number">4.</span><span class="built_in">add</span>(<span class="string">&quot;pi&quot;</span>, <span class="number">3.14159</span>);</span><br><span class="line">    c<span class="number">4.</span><span class="built_in">add</span>(<span class="string">&quot;e&quot;</span>, <span class="number">2.71828</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c4 (capacity=&quot;</span> &lt;&lt; c<span class="number">4.</span><span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    c<span class="number">4.</span><span class="built_in">printAll</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== 5. 模板模板参数 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Wrapper&lt;<span class="type">int</span>, std::vector&gt; w1;</span><br><span class="line">    Wrapper&lt;std::string, std::vector&gt; w2;</span><br><span class="line">    </span><br><span class="line">    w<span class="number">1.</span><span class="built_in">add</span>(<span class="number">10</span>); w<span class="number">1.</span><span class="built_in">add</span>(<span class="number">20</span>); w<span class="number">1.</span><span class="built_in">add</span>(<span class="number">30</span>);</span><br><span class="line">    w<span class="number">2.</span><span class="built_in">add</span>(<span class="string">&quot;hello&quot;</span>); w<span class="number">2.</span><span class="built_in">add</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w1 size: &quot;</span> &lt;&lt; w<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2 size: &quot;</span> &lt;&lt; w<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n========== 6. 类外定义成员函数 ==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Calculator&lt;<span class="type">int</span>&gt; <span class="title">calc1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Calculator&lt;<span class="type">double</span>&gt; <span class="title">calc2</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;calc1: 10 + 5 = &quot;</span> &lt;&lt; calc<span class="number">1.</span><span class="built_in">add</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;calc1: 10 * 3 = &quot;</span> &lt;&lt; calc<span class="number">1.</span><span class="built_in">multiply</span>(<span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;calc2: 3.5 + 1.5 = &quot;</span> &lt;&lt; calc<span class="number">2.</span><span class="built_in">add</span>(<span class="number">1.5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;calc2: 3.5 * 2 = &quot;</span> &lt;&lt; calc<span class="number">2.</span><span class="built_in">multiply</span>(<span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-模板类的继承"><a href="#2-模板类的继承" class="headerlink" title="2.模板类的继承"></a>2.模板类的继承</h2><p>模板类可作为基类，子类可分为“普通子类”和“模板子类”，需注意模板参数的传递。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类作为基类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(T val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.普通子类（需指定基类的模板参数）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived1</span>(<span class="type">int</span> val) : <span class="built_in">Base</span>&lt;<span class="type">int</span>&gt;(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.模板子类（可复用父类的模板参数，也可新增参数）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    U extra;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived2</span>(T val1, U val2) : <span class="built_in">Base</span>&lt;T&gt;(val1), <span class="built_in">extra</span>(val2) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="三、模板特化"><a href="#三、模板特化" class="headerlink" title="三、模板特化"></a>三、模板特化</h1><p>模板特化是针对特定模板参数（类型&#x2F;值），提供定制化的实现逻辑，解决通用模板在特定场景下的适配问题。特化分为全特化和偏特化。</p>
<h2 id="1-全特化"><a href="#1-全特化" class="headerlink" title="1.全特化"></a>1.全特化</h2><ul>
<li>全特化是对模板的**“所有参数”都指定“具体值&#x2F;类型”**，本质是模板的一个“特例实现”。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pair</span>(T1 f, T2 s) : <span class="built_in">first</span>(f), <span class="built_in">second</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic Pair: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化（T1=int，T2=double）</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;  <span class="comment">// 全特化无模板参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    <span class="type">double</span> second;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pair</span>(<span class="type">int</span> f, <span class="type">double</span> s) : <span class="built_in">first</span>(f), <span class="built_in">second</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized Pair (int, double): &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">print</span>();  <span class="comment">// 调用通用模板</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    p<span class="number">2.</span><span class="built_in">print</span>();  <span class="comment">// 调用全特化版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-偏特化"><a href="#2-偏特化" class="headerlink" title="2.偏特化"></a>2.偏特化</h2><ul>
<li>偏特化是对模板的**“部分参数”指定“具体值&#x2F;类型”**，或对参数进行“限定”（如指针、引用、const修饰），仍保留部分泛型参数。<ul>
<li>仅类模板支持偏特化，函数模板不支持偏特化（可通过重载替代）。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化1：部分参数指定（T2=std::string）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T1, std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial Specialization (T1, string)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化2：参数限定为指针类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T1*, T2*&gt; &#123;  <span class="comment">// 两个参数均为指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial Specialization (T1*, T2*)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化3：参数限定为const类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">const</span> T1, T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial Specialization (const T1, T2)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、实战补充示例"><a href="#四、实战补充示例" class="headerlink" title="四、实战补充示例"></a>四、实战补充示例</h1><h2 id="1-的含义：使用所有模板参数的默认值"><a href="#1-的含义：使用所有模板参数的默认值" class="headerlink" title="1. &lt;&gt; 的含义：使用所有模板参数的默认值"></a>1. &lt;&gt; 的含义：使用所有模板参数的默认值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="keyword">typename</span> E = std::string&gt;</span><br><span class="line"><span class="keyword">using</span> Result = std::pair&lt;T, E&gt;;</span><br><span class="line"></span><br><span class="line">Result&lt;&gt;           <span class="comment">// = Result&lt;int, std::string&gt;</span></span><br><span class="line">Result&lt;<span class="type">double</span>&gt;     <span class="comment">// = Result&lt;double, std::string&gt;</span></span><br><span class="line">Result&lt;<span class="type">double</span>, X&gt;  <span class="comment">// = Result&lt;double, X&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++特性</category>
        <category>C++模板基础语法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>exception异常在哪捕捉好？</title>
    <url>/2026/01/19/C++/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/exception%E5%BC%82%E5%B8%B8%E5%9C%A8%E5%93%AA%E6%8D%95%E6%8D%89%E5%A5%BD%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="1-错误处理分层原则（以Rdkafka为例）"><a href="#1-错误处理分层原则（以Rdkafka为例）" class="headerlink" title="1.错误处理分层原则（以Rdkafka为例）"></a>1.错误处理分层原则（以Rdkafka为例）</h1><p><strong>核心思想</strong>：封装层是技术细节和业务逻辑之间的隔离带。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         错误处理职责分层                                     │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────┐</span><br><span class="line">│   业务层        │  ← 只关心<span class="string">&quot;能不能用&quot;</span>，决定降级/重试/告警策略</span><br><span class="line">│ (UserService)   │     不关心底层技术细节</span><br><span class="line">└────────┬────────┘</span><br><span class="line">         │ 接收封装后的错误 (KafkaResult / std::expected)</span><br><span class="line">         │</span><br><span class="line">┌────────▼────────┐</span><br><span class="line">│   封装层        │  ← 捕获所有底层错误，转换为统一的错误类型</span><br><span class="line">│ (KafkaProducer) │     记录详细日志，隐藏技术细节</span><br><span class="line">└────────┬────────┘</span><br><span class="line">         │ 调用底层 API</span><br><span class="line">         │</span><br><span class="line">┌────────▼────────┐</span><br><span class="line">│   库层          │  ← 返回原始错误码/抛出异常</span><br><span class="line">│ (librdkafka)    │</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure>

<h1 id="2-实际代码对比"><a href="#2-实际代码对比" class="headerlink" title="2.实际代码对比"></a>2.实际代码对比</h1><h2 id="（1）❌-不好的做法：让异常穿透"><a href="#（1）❌-不好的做法：让异常穿透" class="headerlink" title="（1）❌ 不好的做法：让异常穿透"></a>（1）❌ 不好的做法：让异常穿透</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务层需要了解 librdkafka 的异常类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserService::CreateUser</span><span class="params">(<span class="type">const</span> User&amp; user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        kafka_producer_.<span class="built_in">Send</span>(<span class="string">&quot;user-events&quot;</span>, user.id, <span class="built_in">Serialize</span>(user));</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> RdKafka::Exception&amp; e) &#123;  <span class="comment">// 业务层耦合了 librdkafka</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（2）✅-推荐做法：封装层捕获并转换"><a href="#（2）✅-推荐做法：封装层捕获并转换" class="headerlink" title="（2）✅ 推荐做法：封装层捕获并转换"></a>（2）✅ 推荐做法：封装层捕获并转换</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==================== 封装层：捕获一切，返回统一错误 ====================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KafkaProducer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">KafkaResult <span class="title">Send</span><span class="params">(<span class="type">const</span> std::string&amp; topic, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> std::string&amp; key, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 所有错误在这里捕获和转换</span></span><br><span class="line">        <span class="keyword">if</span> (!producer_) &#123;</span><br><span class="line">            <span class="keyword">return</span> KafkaResult::<span class="built_in">Error</span>(KafkaError::NOT_INITIALIZED, <span class="string">&quot;Producer not init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RdKafka::ErrorCode err = producer_-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 记录详细技术日志（封装层职责）</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Kafka send failed: topic=&#123;&#125;, err=&#123;&#125;&quot;</span>, topic, RdKafka::<span class="built_in">err2str</span>(err));</span><br><span class="line">            <span class="comment">// 返回业务可理解的错误</span></span><br><span class="line">            <span class="keyword">return</span> KafkaResult::<span class="built_in">Error</span>(<span class="built_in">MapError</span>(err), RdKafka::<span class="built_in">err2str</span>(err));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> KafkaResult::<span class="built_in">Ok</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 业务层：只关心成功/失败 ====================</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserService::CreateUser</span><span class="params">(<span class="type">const</span> User&amp; user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = kafka_producer_.<span class="built_in">Send</span>(<span class="string">&quot;user-events&quot;</span>, user.id, <span class="built_in">Serialize</span>(user));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="comment">// 业务层只关心&quot;失败了&quot;，决定业务策略</span></span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Event publish failed, saving to retry queue&quot;</span>);</span><br><span class="line">        retry_queue_.<span class="built_in">Push</span>(user);  <span class="comment">// 降级策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（3）封装层的职责清单"><a href="#（3）封装层的职责清单" class="headerlink" title="（3）封装层的职责清单"></a>（3）封装层的职责清单</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KafkaProducer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">KafkaResult <span class="title">Send</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1️⃣ 前置检查（状态、参数）</span></span><br><span class="line">        <span class="keyword">if</span> (!producer_) &#123;</span><br><span class="line">            <span class="keyword">return</span> KafkaResult::<span class="built_in">Error</span>(KafkaError::NOT_INITIALIZED, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value.<span class="built_in">size</span>() &gt; max_message_size_) &#123;</span><br><span class="line">            <span class="keyword">return</span> KafkaResult::<span class="built_in">Error</span>(KafkaError::MESSAGE_TOO_LARGE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2️⃣ 调用底层 API</span></span><br><span class="line">        RdKafka::ErrorCode err = producer_-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3️⃣ 处理特定错误（如队列满重试）</span></span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR__QUEUE_FULL) &#123;</span><br><span class="line">            <span class="comment">// 内部重试，业务层无感知</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; err == RdKafka::ERR__QUEUE_FULL; i++) &#123;</span><br><span class="line">                producer_-&gt;<span class="built_in">poll</span>(<span class="number">100</span>);</span><br><span class="line">                err = producer_-&gt;<span class="built_in">produce</span>(...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4️⃣ 错误转换 + 日志</span></span><br><span class="line">        <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Kafka error: &#123;&#125;&quot;</span>, RdKafka::<span class="built_in">err2str</span>(err));  <span class="comment">// 详细日志</span></span><br><span class="line">            <span class="keyword">return</span> KafkaResult::<span class="built_in">Error</span>(<span class="built_in">MapError</span>(err), RdKafka::<span class="built_in">err2str</span>(err));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5️⃣ 成功</span></span><br><span class="line">        <span class="keyword">return</span> KafkaResult::<span class="built_in">Ok</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>开发笔记</category>
        <category>exception异常在哪捕捉好？</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>‘变长参数列表’的多种实现方式</title>
    <url>/2026/01/08/C++/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E2%80%98%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E2%80%99%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-实现方式"><a href="#1-实现方式" class="headerlink" title="1.实现方式"></a>1.实现方式</h1><ul>
<li><strong>参数类型有限 &#x2F; 不修改参数 &#x2F; 想实现简单</strong> → std::initializer_list + std::variant；</li>
<li><strong>参数类型多样</strong> → 变参模板 typename… Args（如日志系统、线程池）；</li>
<li><strong>需存储 &#x2F; 修改参数</strong> → std::vector + std::variant；</li>
</ul>
<h2 id="1-std-initializer-list-std-variant"><a href="#1-std-initializer-list-std-variant" class="headerlink" title="1.std::initializer_list + std::variant"></a>1.std::initializer_list + std::variant</h2><h3 id="1-std-initializer-list介绍"><a href="#1-std-initializer-list介绍" class="headerlink" title="(1)std::initializer_list介绍"></a>(1)std::initializer_list介绍</h3><h4 id="概述"><a href="#概述" class="headerlink" title="&lt;1&gt;概述"></a>&lt;1&gt;概述</h4><ul>
<li>std::initializer_list 是 C++11 引入的轻量级模板类（头文件 <initializer_list>）</li>
<li><strong>核心目标</strong>：实现统一、简洁的 花括号 {} 初始化语法</li>
</ul>
<h4 id="核心本质与特质"><a href="#核心本质与特质" class="headerlink" title="&lt;2&gt;核心本质与特质"></a>&lt;2&gt;核心本质与特质</h4><ul>
<li><strong>只读的轻量级视图</strong>：内部仅存储「指向底层数组的指针 + 元素个数」，无内存拷贝，底层数组由编译器管理（只读，无法修改元素）；</li>
<li><strong>模板类特性</strong>：需指定元素类型（如 std::initializer_list<int>），支持范围 for、begin()&#x2F;end() 遍历；</li>
<li><strong>可拷贝但无开销</strong>：拷贝仅复制指针和长度，不复制底层数组，生命周期与对象绑定（临时对象在语句结束后销毁）。</li>
</ul>
<h4 id="std-initializer-list的使用（这里主要介绍与’变长参数相关的’）"><a href="#std-initializer-list的使用（这里主要介绍与’变长参数相关的’）" class="headerlink" title="&lt;3&gt;std::initializer_list的使用（这里主要介绍与’变长参数相关的’）"></a>&lt;3&gt;std::initializer_list的使用（这里主要介绍与’变长参数相关的’）</h4><p>1.通过 花括号{} 传入参数<br>2.通过for循环遍历读取值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历变长参数列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        total += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传递不同数量的变长参数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;sum(1,2,3) = &quot;</span> &lt;&lt; <span class="built_in">sum</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;) &lt;&lt; std::endl;          <span class="comment">// 3个参数，输出：6</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;sum(10,20,30,40) = &quot;</span> &lt;&lt; <span class="built_in">sum</span>(&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;) &lt;&lt; std::endl; <span class="comment">// 4个参数，输出：100</span></span><br></pre></td></tr></table></figure>

<h4 id="关键避坑点"><a href="#关键避坑点" class="headerlink" title="&lt;4&gt;关键避坑点"></a>&lt;4&gt;关键避坑点</h4><ul>
<li><strong>元素只读</strong>：无法修改 initializer_list 内的元素（如 il[0] &#x3D; 10 编译报错）；</li>
<li><strong>生命周期陷阱</strong>：不要保存其迭代器 &#x2F; 指针到函数外部，否则会因底层数组销毁导致悬空指针；</li>
<li><strong>空列表支持</strong>：空列表 {} 合法，size() 返回 0，begin() &#x3D;&#x3D; end()；</li>
</ul>
<h4 id="与vector的对比图"><a href="#与vector的对比图" class="headerlink" title="&lt;5&gt; 与vector的对比图"></a>&lt;5&gt; 与vector的对比图</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108101908382.png"></p>
<h3 id="2-std-variant介绍"><a href="#2-std-variant介绍" class="headerlink" title="(2)std::variant介绍"></a>(2)std::variant介绍</h3><p><strong>参考：</strong><a href="https://xianyubuxian-txy.github.io/2026/01/08/16-std-variant/">16.std::variant</a></p>
<h3 id="3-std-initializer-list-std-variant-实现‘变长参数列表’-实例"><a href="#3-std-initializer-list-std-variant-实现‘变长参数列表’-实例" class="headerlink" title="(3)std::initializer_list + std::variant 实现‘变长参数列表’ 实例"></a>(3)std::initializer_list + std::variant 实现‘变长参数列表’ 实例</h3><p><strong>目标：封装sql语句，允许其以（”INSERT INTO user (name, age, score) VALUES (?, ?, ?)”,{“张三”, 25, 95.5}）形式作为“参数”传递</strong></p>
<ul>
<li>‘?’为“占位符”，也就要求原sql中，不可以有冗余的’?’造成干扰（这存在一定的局限性）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 万能盒子：能 NULL/int64/uint64/double/string 五种类型(可自行增加)</span></span><br><span class="line"><span class="keyword">using</span> Param = std::variant&lt;std::<span class="type">nullptr_t</span>, <span class="type">int64_t</span>, <span class="type">uint64_t</span>, <span class="type">double</span>, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">BuildSQL</span><span class="params">(<span class="type">const</span> std::string&amp; sql, std::initializer_list&lt;Param&gt; params)</span></span>&#123;</span><br><span class="line">    std::string result;</span><br><span class="line">    result.<span class="built_in">reserve</span>(sql.<span class="built_in">size</span>()*<span class="number">2</span>);  <span class="comment">//预分配空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = params.<span class="built_in">begin</span>();  <span class="comment">// 修正：parmas → params</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sql.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sql[i] == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it == params.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Not enough parameters&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//用 std::visit 解析 variant 的实际类型</span></span><br><span class="line">            std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span>&amp;&amp; arg)&#123;</span><br><span class="line">                <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 编译期类型判断（constexpr if，C++17）</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T, std::<span class="type">nullptr_t</span>&gt;)&#123;</span><br><span class="line">                    result += <span class="string">&quot;NULL&quot;</span>;  <span class="comment">// NULL 类型直接拼 &quot;NULL&quot;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T, std::<span class="type">int64_t</span>&gt;)&#123;</span><br><span class="line">                    result += std::<span class="built_in">to_string</span>(arg);  <span class="comment">// 修正：加上std::</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T, std::<span class="type">uint64_t</span>&gt;)&#123;  <span class="comment">// 修正：uint64 → uint64_t</span></span><br><span class="line">                    result += std::<span class="built_in">to_string</span>(arg);  <span class="comment">// 修正：加上std::</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T, <span class="type">double</span>&gt;)&#123;  <span class="comment">// 修正：std::double → double</span></span><br><span class="line">                    result += std::<span class="built_in">to_string</span>(arg);  <span class="comment">// 修正：参数应为arg而非double</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T, std::string&gt;)&#123;</span><br><span class="line">                    result += <span class="string">&#x27;\&#x27;&#x27;</span>;  <span class="comment">// 修正：缺少分号</span></span><br><span class="line">                    result += arg;</span><br><span class="line">                    result += <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, *it);</span><br><span class="line">            </span><br><span class="line">            ++it;  <span class="comment">// 参数迭代器后移</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += sql[i];  <span class="comment">// 非占位符，直接拼接字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it != params.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Too many parameters&quot;</span>);  <span class="comment">// 参数过多</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明（接收变长参数列表）</span></span><br><span class="line"><span class="function">MySQLResult <span class="title">Query</span><span class="params">(<span class="type">const</span> std::string&amp; sql, std::initializer_list&lt;Param&gt; params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者代码（极致简洁）</span></span><br><span class="line">conn.<span class="built_in">Query</span>(<span class="string">&quot;SELECT * FROM user WHERE name=? AND age=? AND height=?&quot;</span>, &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>, <span class="number">175</span>&#125;);</span><br><span class="line">conn.<span class="built_in">Execute</span>(<span class="string">&quot;INSERT INTO user (name, age) VALUES (?, ?)&quot;</span>, &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-优缺点-适用场景"><a href="#4-优缺点-适用场景" class="headerlink" title="(4)优缺点 &amp; 适用场景"></a>(4)优缺点 &amp; 适用场景</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108103335014.png"></p>
<h2 id="2-变参模板-template"><a href="#2-变参模板-template" class="headerlink" title="2.变参模板 template&lt;typename… Args&gt;"></a>2.变参模板 template&lt;typename… Args&gt;</h2><p><strong>之后再补充</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>开发笔记</category>
        <category>功能点</category>
        <category>‘变长参数列表’的多种实现方式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名命名空间</title>
    <url>/2026/01/18/C++/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><ul>
<li>匿名命名空间是 C++ 特有的语言特性（C 无此概念），核心作用是限定作用域内的符号仅在当前编译单元（.cpp 文件）可见</li>
<li>与用 static 定义的 “全局变量”、“函数” 作用类似</li>
</ul>
<h1 id="2-基础语法-与-底层本质"><a href="#2-基础语法-与-底层本质" class="headerlink" title="2.基础语法 与 底层本质"></a>2.基础语法 与 底层本质</h1><h2 id="（1）基础语法"><a href="#（1）基础语法" class="headerlink" title="（1）基础语法"></a>（1）基础语法</h2><p>匿名命名空间通过 namespace { … } 定义，<strong>无命名标识符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译单元：foo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名命名空间：仅 foo.cpp 可见</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInternal</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Internal] &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 私有类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InternalHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; <span class="built_in">printInternal</span>(<span class="string">&quot;Helper working&quot;</span>); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InternalHelper helper;</span><br><span class="line">    helper.<span class="built_in">doWork</span>(); <span class="comment">// 可访问匿名命名空间内的符号</span></span><br><span class="line">    <span class="built_in">printInternal</span>(<span class="string">&quot;publicFunc called&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max value: &quot;</span> &lt;&lt; MAX_VALUE &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其它文件无法访问“匿名空间”内的内容</strong></p>
<h2 id="（2）底层本质"><a href="#（2）底层本质" class="headerlink" title="（2）底层本质"></a>（2）底层本质</h2><p>匿名命名空间的本质是<strong>编译器自动生成唯一命名的命名空间</strong> + <strong>全局范围内的 using namespace 唯一名称</strong>;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器实际处理后的等效代码（伪代码）</span></span><br><span class="line"><span class="keyword">namespace</span> __ANON_NAMESPACE_123456 &#123; <span class="comment">// 123456 是编译器生成的唯一标识</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInternal</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __ANON_NAMESPACE_123456; <span class="comment">// 全局生效</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publicFunc</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这意味着：<ul>
<li>匿名命名空间内的符号<strong>具有静态存储期</strong>（生命周期同程序）；</li>
</ul>
</li>
<li>每个编译单元的匿名命名空间是独立的，<strong>即使符号名相同也不会冲突</strong>。</li>
</ul>
<h1 id="3-核心特性与优势"><a href="#3-核心特性与优势" class="headerlink" title="3.核心特性与优势"></a>3.核心特性与优势</h1><h2 id="（1）核心优势"><a href="#（1）核心优势" class="headerlink" title="（1）核心优势"></a>（1）核心优势</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118221344372.png"></p>
<h2 id="（2）核心优势"><a href="#（2）核心优势" class="headerlink" title="（2）核心优势"></a>（2）核心优势</h2><ul>
<li><p><strong>替代 static，功能更全面</strong></p>
<ul>
<li>C++ 中 static 仅能修饰全局函数&#x2F;变量，使其文件私有，但无法修饰类、模板；</li>
<li>匿名命名空间可覆盖所有符号类型的文件私有需求，是 <strong>C++ 标准推荐的方式</strong>（C++17 后 static 对全局符号的支持已被标记为「过时」）。</li>
</ul>
</li>
<li><p><strong>避免命名污染</strong></p>
<ul>
<li>无需为了避免全局命名冲突而给内部符号加冗长前缀（如 foo_internal_print），匿名命名空间天然隔离内部符号。</li>
</ul>
</li>
<li><p><strong>语义更清晰</strong>：</p>
<ul>
<li>匿名命名空间明确表达「这些符号仅当前文件使用」，<strong>比 static 更易读</strong>（static 语义易与「静态成员」「静态局部变量」混淆）。</li>
</ul>
</li>
</ul>
<h1 id="4-典型使用场景"><a href="#4-典型使用场景" class="headerlink" title="4.典型使用场景"></a>4.典型使用场景</h1><h2 id="（1）封装编译单元内的辅助函数-变量"><a href="#（1）封装编译单元内的辅助函数-变量" class="headerlink" title="（1）封装编译单元内的辅助函数&#x2F;变量"></a>（1）封装编译单元内的辅助函数&#x2F;变量</h2><p>最常见场景：对外暴露的函数&#x2F;类需要依赖内部辅助逻辑，这些辅助逻辑无需对外可见。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math_utils.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math_utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// 内部辅助函数：计算平方（仅当前文件可用）</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部常量：精度阈值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> EPS = <span class="number">1e-9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露的函数：计算欧几里得距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">euclideanDistance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = x1 - x2;</span><br><span class="line">    <span class="type">double</span> dy = y1 - y2;</span><br><span class="line">    <span class="comment">// 调用内部辅助函数</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">square</span>(dx) + <span class="built_in">square</span>(dy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露的函数：判断浮点数相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">fabs</span>(a - b) &lt; EPS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（2）封装内部工具类-模板"><a href="#（2）封装内部工具类-模板" class="headerlink" title="（2）封装内部工具类&#x2F;模板"></a>（2）封装内部工具类&#x2F;模板</h2><p>匿名命名空间可包含类、模板等 static 无法修饰的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// json_parser.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json_parser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// 内部工具类：仅当前文件使用</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JsonValidator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> nlohmann::json&amp; j)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> j.<span class="built_in">contains</span>(<span class="string">&quot;code&quot;</span>) &amp;&amp; j[<span class="string">&quot;code&quot;</span>].<span class="built_in">is_number_integer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部模板函数：转换 JSON 字段</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">T <span class="title">getJsonField</span><span class="params">(<span class="type">const</span> nlohmann::json&amp; j, <span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!j.<span class="built_in">contains</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Field &quot;</span> + key + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j[key].<span class="built_in">get</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露的函数：解析 JSON 响应</span></span><br><span class="line"><span class="function">JsonResponse <span class="title">parseJson</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> j = nlohmann::json::<span class="built_in">parse</span>(jsonStr);</span><br><span class="line">    <span class="keyword">if</span> (!JsonValidator::<span class="built_in">isValid</span>(j)) &#123; <span class="comment">// 调用内部类</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Invalid JSON response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    JsonResponse resp;</span><br><span class="line">    resp.code = <span class="built_in">getJsonField</span>&lt;<span class="type">int</span>&gt;(j, <span class="string">&quot;code&quot;</span>); <span class="comment">// 调用内部模板</span></span><br><span class="line">    resp.msg = <span class="built_in">getJsonField</span>&lt;std::string&gt;(j, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（3）避免跨文件符号冲突"><a href="#（3）避免跨文件符号冲突" class="headerlink" title="（3）避免跨文件符号冲突"></a>（3）避免跨文件符号冲突</h2><p>多个编译单元可定义同名符号，无需担心链接冲突</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[A] &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123; <span class="built_in">log</span>(<span class="string">&quot;funcA called&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">// 同名函数，但属于不同匿名命名空间，无冲突</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[B] &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123; <span class="built_in">log</span>(<span class="string">&quot;funcB called&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-注意事项与避坑点"><a href="#5-注意事项与避坑点" class="headerlink" title="5.注意事项与避坑点"></a>5.注意事项与避坑点</h1><h2 id="（1）关键注意事项"><a href="#（1）关键注意事项" class="headerlink" title="（1）关键注意事项"></a>（1）关键注意事项</h2><ol>
<li><p><strong>仅作用于编译单元，而非头文件</strong></p>
<ul>
<li><strong>禁止在头文件中定义匿名命名空间！</strong><ul>
<li>若头文件包含匿名命名空间，每个包含该头文件的 .cpp 都会生成独立的匿名命名空间，导致符号重复定义（如头文件中的匿名命名空间包含 int x &#x3D; 10;，每个 .cpp 都会定义 x，链接时冲突）。</li>
</ul>
</li>
<li>头文件中如需私有符号，应使用「命名空间 + 细节命名」（如 namespace MyLib::detail），而非匿名命名空间。</li>
</ul>
</li>
<li><p><strong>无法跨编译单元访问</strong></p>
</li>
</ol>
<ul>
<li>即使通过 extern 声明，也无法访问其他编译单元匿名命名空间内的符号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> value; <span class="comment">// 编译通过，但链接时找不到符号（undefined reference）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="comment">// 链接错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>与 static 的区别（关键）</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118222330530.png"></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>开发笔记</category>
        <category>匿名命名空间</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>10 编译期if语句</title>
    <url>/2026/01/07/C++/%E3%80%8AC++17%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E3%80%8B/10-%E7%BC%96%E8%AF%91%E6%9C%9Fif%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>1.通过使用语法<strong>if constexpr(…)</strong>，编译器可以计算编译期的条件表达式来<strong>在编译期决定</strong>使用一个if语句<br>的then的部分还是else的部分。<br>2.其余部分的代码将会被丢弃，这意味着它们甚至不会被生成。<br>3.这并不意味着被丢弃的部分完全被忽略，这些部分中的代码也会像没使用的模板一样进行语法检查。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/2026.1.7_1.png"></p>
<p><strong>特别强调：被忽略的语句也必须符合正确的语法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">foo</span>(t‐<span class="number">1</span>);<span class="comment">// OK</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">undeclared</span>(t); <span class="comment">// 如果未被声明且未被丢弃将导致错误</span></span><br><span class="line">            <span class="built_in">undeclared</span>(); <span class="comment">// 如果未声明将导致错误（即使被丢弃也一样）</span></span><br><span class="line">            <span class="built_in">static_assert</span>(<span class="literal">false</span>, <span class="string">&quot;no integral&quot;</span>); <span class="comment">// 总是会进行断言（即使被丢弃也一样）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/2026.1.7_2.png"></p>
<h1 id="2-使用编译期if语句"><a href="#2-使用编译期if语句" class="headerlink" title="2.使用编译期if语句"></a>2.使用编译期if语句</h1><p><strong>1.理论上来说：只要条件表达式是编译期的表达式你就可以像使用运行期if一样使用编译期if</strong><br><strong>2.也可以混合使用编译期和运行期的if</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::numeric_limits&lt;<span class="type">char</span>&gt;::is_signed)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// char 是有符号的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// char 是无符号的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// val &lt;= 10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// T 不是整型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意:你不能在函数体之外使用if constexpr。因此，你不能使用它来替换预处理器的条件编译(#if &#x2F; #ifdef)。</strong></p>
<h2 id="2-1-编译期if的注意事项"><a href="#2-1-编译期if的注意事项" class="headerlink" title="2.1 编译期if的注意事项"></a>2.1 编译期if的注意事项</h2><h3 id="1-编译期if可能影响返回值类型"><a href="#1-编译期if可能影响返回值类型" class="headerlink" title="1.编译期if可能影响返回值类型"></a>1.编译期if可能影响返回值类型</h3><p><strong>下面的代码总能通过编译，但返回值的类型可能会不同：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(<span class="keyword">sizeof</span>(<span class="type">int</span>)&gt;<span class="number">4</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果大于4字节，返回42的返回语句将会生效，因此返回值类型是int。</li>
<li>否则，返回42u的返回语句将生效，因此返回值类型是unsigned int。</li>
</ul>
<h3 id="2-即使在then部分返回也要考虑else部分"><a href="#2-即使在then部分返回也要考虑else部分" class="headerlink" title="2.即使在then部分返回也要考虑else部分"></a>2.即使在then部分返回也要考虑else部分</h3><p><strong>运行期if有一个模式不能应用于编译期if</strong></p>
<ul>
<li>如果代码在then和else部分都会返回，那么在运行期if中你可以跳过else部分<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107090515331.png"></li>
</ul>
<h2 id="2-2其他编译期if的示例"><a href="#2-2其他编译期if的示例" class="headerlink" title="2.2其他编译期if的示例"></a>2.2其他编译期if的示例</h2><h3 id="完美返回泛型值"><a href="#完美返回泛型值" class="headerlink" title="完美返回泛型值"></a>完美返回泛型值</h3><ul>
<li>先对返回值进行一些处理，再进行完美转发</li>
<li>因为decltype(auto)不能推导<br>为void（因为void是不完全类型），所以你必须像下面这么写：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107091404987.png"></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>《C++17完全指南》</category>
        <category>二、模板特性</category>
        <category>10 编译期if语句</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型编程常用技巧</title>
    <url>/2026/01/07/C++/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-编译期if语句"><a href="#1-编译期if语句" class="headerlink" title="1.编译期if语句"></a>1.编译期if语句</h1><p>通过使用语法<strong>if constexpr(…)</strong>，编译器可以计算编译期的条件表达式来<strong>在编译期决定</strong>使用一个if语句<br>的then的部分还是else的部分。<br><strong>可参考</strong>：<a href="https://xianyubuxian-txy.github.io/2026/01/07/10-%E7%BC%96%E8%AF%91%E6%9C%9Fif%E8%AF%AD%E5%8F%A5/">10 编译期if语句</a></p>
<hr>
<h1 id="2-类型萃取（Type-Traits）-工具"><a href="#2-类型萃取（Type-Traits）-工具" class="headerlink" title="2.类型萃取（Type Traits） 工具"></a>2.类型萃取（Type Traits） 工具</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>(1)头文件： #include&lt;type_traits&gt;</strong><br><strong>(2)功能：提供的编译期类型判断 &#x2F; 转换工具，核心作用是在模板编程中获取或修改类型的属性，实现编译期决策。</strong></p>
<h2 id="2-类型判断类（判断类型属性）"><a href="#2-类型判断类（判断类型属性）" class="headerlink" title="2.类型判断类（判断类型属性）"></a>2.类型判断类（判断类型属性）</h2><ul>
<li>这类萃取工具以 is_xxx 命名，C++17 后提供 is_xxx_v 便捷别名（等价于 is_xxx<T>::value），返回编译期布尔常量。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107100035470.png"></li>
</ul>
<h2 id="3-std-conditional-t-：编译期条件类型选择工具"><a href="#3-std-conditional-t-：编译期条件类型选择工具" class="headerlink" title="3.std::conditional_t&lt;Condition, T, F&gt; ：编译期条件类型选择工具"></a>3.std::conditional_t&lt;Condition, T, F&gt; ：编译期条件类型选择工具</h2><h3 id="1-核心作用"><a href="#1-核心作用" class="headerlink" title="1.核心作用"></a>1.核心作用</h3><ul>
<li>根据一个<strong>编译期布尔常量</strong>，在两种类型（T 和 F）中选择其一</li>
<li>整个选择过程完全发生在编译阶段，不会产生任何运行时开销。</li>
<li>如果 Condition 为 true → 最终类型是 T</li>
<li>如果 Condition 为 false → 最终类型是 F</li>
</ul>
<h3 id="2-核心要求"><a href="#2-核心要求" class="headerlink" title="2.核心要求"></a>2.核心要求</h3><ul>
<li>Condition 必须是编译期可确定的布尔值<ul>
<li>true&#x2F;false 字面量</li>
<li>constexpr 常量</li>
<li>static_assert</li>
<li>is_same_v、is_integral_v…</li>
<li>等类型萃取的结果，不能是运行时才能确定的变量。</li>
</ul>
</li>
</ul>
<h2 id="4-可调用对象相关类"><a href="#4-可调用对象相关类" class="headerlink" title="4.可调用对象相关类"></a>4.可调用对象相关类</h2><p><strong>用于推导可调用对象（函数、Lambda、仿函数）的属性，是泛型回调、函数包装的核心工具。</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107120513290.png"></p>
<hr>
<h2 id="5-使用示例"><a href="#5-使用示例" class="headerlink" title="5.使用示例"></a>5.使用示例</h2><h3 id="连接池模板示例（部分代码）"><a href="#连接池模板示例（部分代码）" class="headerlink" title="连接池模板示例（部分代码）"></a>连接池模板示例（部分代码）</h3><p><strong>1.知识点：</strong></p>
<ul>
<li>if constexpr</li>
<li>std::is_same_v</li>
<li>std::conditional_t</li>
</ul>
<p><strong>2.功能概述</strong></p>
<ul>
<li>实现一个“连接池模板”，用于创建mysql、redis连接池</li>
<li>mysql和redis都有各自的“配置”(通过文件加载)，连接池需要获取对应的配置来进行初始化</li>
<li>为获取对应的配置 ——&gt;“连接池模板”需在编译期根据T的实际类型(MySQLConnection &#x2F; RedisConnection)，获取对应“配置”(MySQLConfig &#x2F; RedisConfig)</li>
<li>获取对应配置后，就可以获取对应的pool_size确定连接池大小，并将“配置”传给“创建连接回调函数”进行连接的创建<br><strong>注：个人能力有限，示例代码可能并不是很完美实用，仅作演示</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="comment">//mysql配置结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MySQLConfig</span>&#123;</span><br><span class="line">    <span class="type">int</span> pool_size=<span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPoolSize</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> pool_size;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//redis配置结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RedisConfig</span>&#123;</span><br><span class="line">    <span class="type">int</span> pool_size=<span class="number">5</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPoolSize</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> pool_size;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局配置结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GlobalConfig</span>&#123;</span><br><span class="line">    MySQLConfig mysql;</span><br><span class="line">    RedisConfig redis;</span><br><span class="line">    ...</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------泛型连接池模板类部分代码-----------------*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnection</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisConnection</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemplateConnectionPool</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ConnectionPtr=std::unique_ptr&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过嵌套std::conditional_t在编译期确定“配置类型”</span></span><br><span class="line">    <span class="keyword">using</span> Config =  std::<span class="type">conditional_t</span>&lt;std::is_same_v&lt;T, MySQLConnection&gt;,MySQLConfig,</span><br><span class="line">                    std::<span class="type">conditional_t</span>&lt;std::is_same_v&lt;T, RedisConnection&gt;,RedisConfig,</span><br><span class="line">                    <span class="type">void</span>&gt;&gt;;</span><br><span class="line">    <span class="keyword">using</span> ConfigPtr=std::shared_ptr&lt;<span class="type">const</span> Config&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TemplateConnectionPool</span>(std::shared_ptr&lt;GlobalConfig&gt; global_config,std::function&lt;<span class="built_in">ConnectionPtr</span>(<span class="type">const</span> Config&amp;)&gt;func)</span><br><span class="line">    :<span class="built_in">createConnFunc_</span>(std::<span class="built_in">move</span>(func))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!global_config)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;config is nullptr&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ExtractSubConfig</span>(global_config); <span class="comment">// 提取子配置</span></span><br><span class="line">        <span class="built_in">InitPool</span>();    <span class="comment">//初始化连接池</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 提取子配置（封装分支逻辑，便于后续扩展）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExtractSubConfig</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;GlobalConfig&gt;global_config)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 编译期判断：如果是MySQL连接类型，提取mysql子配置</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;T,MySQLConnection&gt;)</span></span>&#123;</span><br><span class="line">            config_=std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> Config&gt;(global_config-&gt;mysql);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编译期判断：如果是Redis连接类型，提取redis子配置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T,RedisConnection&gt;)&#123;</span><br><span class="line">            config_=std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> Config&gt;(global_config-&gt;redis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编译期兜底：非支持类型直接触发编译错误</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// static_assert(false)会强制编译失败，提示不支持的连接类型</span></span><br><span class="line">            <span class="comment">// 注：std::is_void_v&lt;T&gt;仅作为占位，核心是触发编译报错</span></span><br><span class="line">            <span class="built_in">static_assert</span>(std::is_void_v&lt;T&gt;, <span class="string">&quot;Unsupported connection type, no matching sub-config&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取池大小</span></span><br><span class="line">        <span class="type">int</span> poolSize=config_-&gt;<span class="built_in">GetPoolSize</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;poolSize;++i)&#123;</span><br><span class="line">            <span class="comment">//将config_传入“回调函数”创建连接</span></span><br><span class="line">            <span class="keyword">auto</span> conn=std::<span class="built_in">move</span>(<span class="built_in">createConnFunc_</span>(*config_));</span><br><span class="line">            <span class="keyword">if</span>(!conn)&#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create connection&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pool_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(conn));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;ConnectionPtr&gt; pool_;	<span class="comment">//连接池</span></span><br><span class="line">    ConfigPtr config_;					<span class="comment">//配置</span></span><br><span class="line">    <span class="comment">//创建连接回调函数</span></span><br><span class="line">    std::function&lt;ConnectionPtr(<span class="type">const</span> Config&amp;)&gt; createConnFunc_;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-可变参数模板（variadic-templates）"><a href="#3-可变参数模板（variadic-templates）" class="headerlink" title="3.可变参数模板（variadic templates）"></a>3.可变参数模板（variadic templates）</h1><h2 id="1-参数包（typename…-Args）"><a href="#1-参数包（typename…-Args）" class="headerlink" title="1.参数包（typename… Args）"></a>1.参数包（typename… Args）</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="(1)概述"></a>(1)概述</h3><ul>
<li><strong>Args：一个占位符名字，可以任意取（常见 Args、Ts、Types 等）。</strong></li>
<li><strong>typename… Args：告诉编译器 “这里有零个或多个类型参数，它们集合在一起叫做 Args”</strong></li>
<li><strong>当你实例化模板时，可以给 Args 传入任意个类型：</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tuple</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 实例化：</span></span><br><span class="line">Tuple&lt;&gt;                t0;    <span class="comment">// Args 为空包</span></span><br><span class="line">Tuple&lt;<span class="type">int</span>&gt;             t1;    <span class="comment">// Args = &#123;int&#125;</span></span><br><span class="line">Tuple&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt; t3;  <span class="comment">// Args = &#123;int, double, char&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-函数模板中的可变参数"><a href="#2-函数模板中的可变参数" class="headerlink" title="2.函数模板中的可变参数"></a>2.函数模板中的可变参数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个可接收任意类型、任意个参数的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAll</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">     (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// C++17 折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="built_in">logAll</span>(<span class="number">1</span>, <span class="string">&quot; + &quot;</span>, <span class="number">2.5</span>, <span class="string">&quot; = &quot;</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Args常配合其它库函数使用，这里就不演示“解包”了</strong></p>
<h2 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3.使用示例"></a>3.使用示例</h2><h3 id="线程池“任务提交函数”"><a href="#线程池“任务提交函数”" class="headerlink" title="线程池“任务提交函数”"></a>线程池“任务提交函数”</h3><p><strong>1.本节相关知识点：</strong></p>
<ul>
<li>typename… Args：做可变参数</li>
<li>std::invoke_result_t：推导返回值类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// submitTask：把 func 和 args 绑定成一个无参的可调用对象，直接打包进 packaged_task</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;std::<span class="type">invoke_result_t</span>&lt;std::<span class="type">decay_t</span>&lt;Func&gt;,</span></span><br><span class="line"><span class="function">                                       std::<span class="type">decay_t</span>&lt;Args&gt;...&gt;&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> DecayF    = std::<span class="type">decay_t</span>&lt;Func&gt;;</span><br><span class="line">    <span class="keyword">using</span> RType     = std::<span class="type">invoke_result_t</span>&lt;DecayF, std::<span class="type">decay_t</span>&lt;Args&gt;...&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 把 func 和 args 全部 decay 后，bind_front 绑定成一个 RType() 可调用对象 （std::bind_front 是 C++20 的特性）</span></span><br><span class="line">    <span class="keyword">auto</span> bound = std::<span class="built_in">bind_front</span>( <span class="built_in">DecayF</span>(std::forward&lt;Func&gt;(func)),</span><br><span class="line">                                  std::forward&lt;Args&gt;(args)... );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 用这个 “无参可调用对象” 构造 packaged_task</span></span><br><span class="line">    <span class="keyword">auto</span> taskPtr = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(std::<span class="built_in">move</span>(bound));</span><br><span class="line">    <span class="keyword">auto</span> result  = taskPtr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 直接在新线程里执行它</span></span><br><span class="line">    std::<span class="built_in">thread</span>([taskPtr]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="comment">// packaged_task 在调用 operator() 时，</span></span><br><span class="line">        <span class="comment">// 内部会用 std::invoke 特殊处理各种可调用对象</span></span><br><span class="line">        (*taskPtr)();</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里主要想演示一下”typename… Args”、”std::invoke_result_t”的使用场景</strong></p>
<h1 id="4-”类型traits映射”-技巧"><a href="#4-”类型traits映射”-技巧" class="headerlink" title="4.”类型traits映射” 技巧"></a>4.”类型traits映射” 技巧</h1><a href="/2026/01/19/C++/C++%E7%89%B9%E6%80%A7/CPP%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="C++模板基础语法">C++模板基础语法</a>
<h2 id="1-核心思路"><a href="#1-核心思路" class="headerlink" title="1.核心思路"></a>1.核心思路</h2><h3 id="1-声明一个“空”主模板（primary-template）"><a href="#1-声明一个“空”主模板（primary-template）" class="headerlink" title="(1)声明一个“空”主模板（primary template）"></a>(1)声明一个“空”主模板（primary template）</h3><p><strong>不给它任何定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection_config</span>;  <span class="comment">// 只是声明，不定义</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果有人写 connection_config<SomeType>，而你又没有给出对 SomeType 的特化，编译器就会立刻报“找不到 connection_config<SomeType>::type”的错误，提示“这个类型不受支持”。</li>
</ul>
<h3 id="2-对受支持的类型做显式特化（explicit-specialization）"><a href="#2-对受支持的类型做显式特化（explicit-specialization）" class="headerlink" title="(2)对受支持的类型做显式特化（explicit specialization）"></a>(2)对受支持的类型做显式特化（explicit specialization）</h3><p><strong>在特化里定义一个 using type &#x3D; …;</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只为 MySQLConnection 提供映射</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection_config</span>&lt;MySQLConnection&gt; &#123; </span><br><span class="line">  <span class="keyword">using</span> type = MySQLConfig; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只为 RedisConnection 提供映射</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection_config</span>&lt;RedisConnection&gt; &#123; </span><br><span class="line">  <span class="keyword">using</span> type = RedisConfig; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样，connection_config<MySQLConnection>::type 就是 MySQLConfig，而 connection_config<RedisConnection>::type 就是 RedisConfig。</li>
</ul>
<h3 id="3-再用一个-alias-template（别名模板）简化写法："><a href="#3-再用一个-alias-template（别名模板）简化写法：" class="headerlink" title="(3)再用一个 alias template（别名模板）简化写法："></a>(3)再用一个 alias template（别名模板）简化写法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> Config_t = <span class="keyword">typename</span> connection_config&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>
<p><strong>注意：必须使用 typename 告诉编译器connection_config<T>::type是“类型”，否则编译器无法知道它是“类型”还是“变量”</strong></p>
<ul>
<li>以后在代码里直接写 Config_t<T>，就等同于 connection_config<T>::type，更简洁。</li>
</ul>
<h3 id="4-为什么这么做？"><a href="#4-为什么这么做？" class="headerlink" title="(4)为什么这么做？"></a>(4)为什么这么做？</h3><p><strong>1.集中管理支持列表</strong>：所有支持的连接类型映射都集中在 connection_config&lt;…&gt; 的特化里，新加一种连接只要加一个特化即可，其他逻辑不用改。<br><strong>2.这种模式在 C++ 标准库里也很常见</strong>：比如 std::iterator_traits<Iter>、std::char_traits<Char>、std::common_type&lt;T,U&gt;、std::hash<T> 等，都是“空主模板 + 针对受支持类型的特化 + alias template” 组合的变体。</p>
<h3 id="5-实例：-对泛型连接池模板进行一定的优化"><a href="#5-实例：-对泛型连接池模板进行一定的优化" class="headerlink" title="(5)实例： 对泛型连接池模板进行一定的优化"></a>(5)实例： 对泛型连接池模板进行一定的优化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="comment">//mysql配置结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MySQLConfig</span>&#123;</span><br><span class="line">    <span class="type">int</span> pool_size=<span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPoolSize</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> pool_size;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//redis配置结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RedisConfig</span>&#123;</span><br><span class="line">    <span class="type">int</span> pool_size=<span class="number">5</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPoolSize</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> pool_size;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局配置结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GlobalConfig</span>&#123;</span><br><span class="line">    MySQLConfig mysql;</span><br><span class="line">    RedisConfig redis;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------类型traits映射-------------------------*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnection</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisConnection</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnectionConfig</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnectionConfig</span>&lt;MySQLConnection&gt;&#123;<span class="keyword">using</span> type=MySQLConfig;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnectionConfig</span>&lt;RedisConnection&gt;&#123;<span class="keyword">using</span> type=RedisConfig;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typename： 告诉编译器ConnectionConfig&lt;T&gt;::type为类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Config_t= <span class="keyword">typename</span> ConnectionConfig&lt;T&gt;::type;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------泛型连接池模板类部分代码-----------------*/</span></span><br><span class="line"><span class="comment">// always_false 模板，用于依赖式 static_assert</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> always_false = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemplateConnectionPool</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ConnectionPtr=std::unique_ptr&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> Config=Config_t&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> ConfigPtr=std::shared_ptr&lt;<span class="type">const</span> Config&gt;;    </span><br><span class="line">    <span class="keyword">using</span> CreateFunc=std::function&lt;<span class="built_in">ConnectionPtr</span>(<span class="type">const</span> Config&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TemplateConnectionPool</span>(std::shared_ptr&lt;GlobalConfig&gt; global_config,CreateFunc func)</span><br><span class="line">    :<span class="built_in">createConnFunc_</span>(std::<span class="built_in">move</span>(func))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!global_config)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;config is nullptr&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ExtractSubConfig</span>(global_config); <span class="comment">// 提取子配置</span></span><br><span class="line">        <span class="built_in">InitPool</span>();    <span class="comment">//初始化连接池</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 提取子配置（封装分支逻辑，便于后续扩展）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExtractSubConfig</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;GlobalConfig&gt;global_config)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 编译期判断：如果是MySQL连接类型，提取mysql子配置</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;T,MySQLConnection&gt;)</span></span>&#123;</span><br><span class="line">            config_=std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> Config&gt;(global_config-&gt;mysql);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编译期判断：如果是Redis连接类型，提取redis子配置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T,RedisConnection&gt;)&#123;</span><br><span class="line">            config_=std::<span class="built_in">make_shared</span>&lt;<span class="type">const</span> Config&gt;(global_config-&gt;redis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编译期兜底：非支持类型直接触发编译错误</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 不应该到这里：若没有对应的 connection_config 特化，上面的 using Config 已经报错了</span></span><br><span class="line">            <span class="built_in">static_assert</span>(always_false&lt;T&gt;, <span class="string">&quot;Unsupported connection type, no matching sub-config&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取池大小</span></span><br><span class="line">        <span class="type">int</span> poolSize=config_-&gt;<span class="built_in">GetPoolSize</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;poolSize;++i)&#123;</span><br><span class="line">            <span class="comment">//将config_传入“回调函数”创建连接</span></span><br><span class="line">            <span class="keyword">auto</span> conn=std::<span class="built_in">move</span>(<span class="built_in">createConnFunc_</span>(*config_));</span><br><span class="line">            <span class="keyword">if</span>(!conn)&#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create connection&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pool_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(conn));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;ConnectionPtr&gt; pool_;	<span class="comment">//连接池</span></span><br><span class="line">    ConfigPtr config_;					<span class="comment">//配置</span></span><br><span class="line">    <span class="comment">//创建连接回调函数</span></span><br><span class="line">    CreateFunc createConnFunc_;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-补充：“只声明主模板-不给出定义-特化”"><a href="#2-补充：“只声明主模板-不给出定义-特化”" class="headerlink" title="2.补充：“只声明主模板,不给出定义 + 特化”"></a>2.补充：“只声明主模板,不给出定义 + 特化”</h2><h3 id="1-声明而不定义：不完整类型（incomplete-type）"><a href="#1-声明而不定义：不完整类型（incomplete-type）" class="headerlink" title="(1)声明而不定义：不完整类型（incomplete type）"></a>(1)声明而不定义：不完整类型（incomplete type）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnectionConfig</span>;  <span class="comment">// 这里只有声明，没有定义</span></span><br></pre></td></tr></table></figure>
<p>1.这行代码告诉编译器 “存在一个模版 ConnectionConfig<T>”，但你没有给它任何成员或定义。<br>2.因此，对于任意 T，ConnectionConfig<T> 都是一个 不完整类型，除非后面有特化（template&lt;&gt; struct ConnectionConfig<Foo> { … };）给出完整定义。<br>3.如果用为提供“特化”的类型进行“实例化”——&gt;“报错”</p>
<h3 id="2-完全特化"><a href="#2-完全特化" class="headerlink" title="(2)完全特化"></a>(2)完全特化</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="&lt;1&gt;语法："></a>&lt;1&gt;语法：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主模板（需先声明或定义）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//struct Foo &#123; /* primary template */ &#125;;    //定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>;    <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全特化：用 template&lt;&gt;，并把所有参数具体化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&lt;<span class="type">int</span>&gt; &#123; <span class="comment">/* specialization for int */</span> &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="语法要点"><a href="#语法要点" class="headerlink" title="&lt;2&gt;语法要点"></a>&lt;2&gt;语法要点</h4><ul>
<li><strong>必须写template&lt;&gt;（空模板参数表），然后给出具体参数。</strong></li>
<li><strong>特化体可以与主模板完全不同（成员名&#x2F;行为可不同）。</strong></li>
<li>完全特化是对某一具体类型的替代定义（不是重载）。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>开发笔记</category>
        <category>泛型模板编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>15.std::optional&lt;&gt;</title>
    <url>/2026/01/07/C++/%E3%80%8AC++17%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E3%80%8B/15-std-optional/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><ul>
<li><strong>1.std::optional&lt;&gt;模拟了一个可以为空的任意类型的实例,可以被用作成员、参数、返回值等</strong></li>
<li><strong>2.拷贝一个无内含值的std::optional&lt;&gt;的开销很小</strong></li>
<li><strong>3.但拷贝有内含值的std::optional&lt;&gt;的开销约等于拷贝内含值的开销</strong></li>
<li><strong>4.std::optional&lt;&gt;对象也支持move语义</strong></li>
</ul>
<h1 id="2-常用API"><a href="#2-常用API" class="headerlink" title="2.常用API"></a>2.常用API</h1><h2 id="0-头文件"><a href="#0-头文件" class="headerlink" title="0.头文件"></a>0.头文件</h2><p><strong>#include&lt;optional&gt;</strong></p>
<h2 id="1-创建-初始化"><a href="#1-创建-初始化" class="headerlink" title="1.创建&#x2F;初始化"></a>1.创建&#x2F;初始化</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107191619544.png"></p>
<h2 id="2-取值相关"><a href="#2-取值相关" class="headerlink" title="2.取值相关"></a>2.取值相关</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107192204439.png"></p>
<h2 id="3-状态判断"><a href="#3-状态判断" class="headerlink" title="3.状态判断"></a>3.状态判断</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107191715927.png"></p>
<h2 id="4-修改-重置"><a href="#4-修改-重置" class="headerlink" title="4.修改&#x2F;重置"></a>4.修改&#x2F;重置</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107191826919.png"></p>
<h2 id="5-其它常用API"><a href="#5-其它常用API" class="headerlink" title="5.其它常用API"></a>5.其它常用API</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107191849790.png"></p>
<p><strong>注意：普通类型可以隐式转换为 std::optional,std::optional 不能直接隐式转换为普通类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.普通类型——&gt;optional*/</span></span><br><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt = <span class="number">100</span>; <span class="comment">// 隐式转换（int → optional&lt;int&gt;）</span></span><br><span class="line">std::optional&lt;std::string&gt; opt_str = <span class="string">&quot;mysql&quot;</span>; <span class="comment">// 隐式转换（const char* → string → optional&lt;string&gt;）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.optional——&gt;普通类型*/</span></span><br><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// int val = opt; // 错误：不支持隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：显式取值</span></span><br><span class="line"><span class="type">int</span> val1 = *opt;          <span class="comment">// 确定有值时用</span></span><br><span class="line"><span class="type">int</span> val2 = opt.<span class="built_in">value</span>();   <span class="comment">// 允许抛异常时用</span></span><br><span class="line"><span class="type">int</span> val3 = opt.<span class="built_in">value_or</span>(<span class="number">0</span>); <span class="comment">// 空值兜底时用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3.使用示例"></a>3.使用示例</h1><h2 id="1-可选的返回值"><a href="#1-可选的返回值" class="headerlink" title="1.可选的返回值"></a>1.可选的返回值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">asInt</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">size_t</span> pos;</span><br><span class="line">        <span class="type">int</span> result = std::<span class="built_in">stoi</span>(s, &amp;pos);  <span class="comment">// stoi 会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (pos != s.<span class="built_in">length</span>()) &#123;  <span class="comment">// 部分转换</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s: &#123;<span class="string">&quot;111&quot;</span>,<span class="string">&quot;123c&quot;</span>&#125;)&#123;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; oi=<span class="built_in">asInt</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(oi.<span class="built_in">has_value</span>())&#123; <span class="comment">// 或 if(oi)</span></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;convert &#x27;&quot;</span>&lt;&lt;s&lt;&lt;<span class="string">&quot;&#x27; to int: &quot;</span>&lt;&lt;oi.<span class="built_in">value</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;convert failed&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-可选的参数和数据成员"><a href="#2-可选的参数和数据成员" class="headerlink" title="2.可选的参数和数据成员"></a>2.可选的参数和数据成员</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string first;</span><br><span class="line">    std::optional&lt;std::string&gt; middle;</span><br><span class="line">    std::string last;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span> (std::string f, std::optional&lt;std::string&gt; m, std::string l)</span><br><span class="line">        :first&#123;std::<span class="built_in">move</span>(f)&#125;, middle&#123;std::<span class="built_in">move</span>(m)&#125;, last&#123;std::<span class="built_in">move</span>(l)&#125; &#123; <span class="comment">//移动构造</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; strm, <span class="type">const</span> Name&amp; n) &#123;</span><br><span class="line">        strm &lt;&lt; n.first &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (n.middle.<span class="built_in">has_value</span>()) &#123; <span class="comment">//也可以直接： n.middle</span></span><br><span class="line">            strm &lt;&lt; n.middle.<span class="built_in">value</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;  <span class="comment">//也可以： *n.middle</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strm &lt;&lt; n.last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-实际使用场景：连接池配置"><a href="#3-实际使用场景：连接池配置" class="headerlink" title="3.实际使用场景：连接池配置"></a>3.实际使用场景：连接池配置</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="(1)概述"></a>(1)概述</h3><ul>
<li><strong>在配置中，有些配置项可能使用，也可能不使用，这时就可以std::optional&lt;&gt;</strong></li>
<li><strong>配置是从文件中读取，然后根据有无值，存储到配置结构体中</strong></li>
</ul>
<h3 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="(2)代码示例"></a>(2)代码示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql部分配置（yaml格式）</span></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="comment"># 超时配置（毫秒）</span></span><br><span class="line">  <span class="attr">connection_timeout_ms:</span> <span class="number">5000</span>      <span class="comment"># 存在</span></span><br><span class="line">  <span class="comment"># read_timeout_ms: 30000        # 不存在</span></span><br><span class="line">  <span class="comment"># write_timeout_ms: 30000        # 不存在</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 重试配置</span></span><br><span class="line">  <span class="attr">max_retries:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">retry_interval_ms:</span> <span class="number">1000</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 其他配置</span></span><br><span class="line">  <span class="attr">auto_reconnect:</span> <span class="literal">true</span>            <span class="comment"># 存在</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MySQL配置部分代码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MySQLConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超时配置(ms)(可能有，可能无)</span></span><br><span class="line">    std::optional&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; connection_timeout_ms;</span><br><span class="line">    std::optional&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; read_timeout_ms;</span><br><span class="line">    std::optional&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; write_timeout_ms;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接失败，重试配置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_retries=<span class="number">3</span>; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> retry_interval_ms=<span class="number">1000</span>; <span class="comment">//重试间隔（ms）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其它配置</span></span><br><span class="line">    std::optional&lt;<span class="type">bool</span>&gt; auto_reconnect; <span class="comment">//可能有可能无</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySQLConnection::InitAndSetOptions</span><span class="params">(<span class="type">const</span> MySQLConfig&amp; config)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果“连接超时”存在，就设置“连接超时选项”</span></span><br><span class="line">    <span class="keyword">if</span>(config.connection_timeout_ms.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="type">int</span> connection_timeout=config.connection_timeout_ms.<span class="built_in">value</span>()/<span class="number">1000</span>; <span class="comment">//获取值</span></span><br><span class="line">        <span class="built_in">mysql_options</span>(mysql_,MYSQL_OPT_CONNECT_TIMEOUT,&amp;connection_timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果“读超时”存在，就设置“读超时选项”</span></span><br><span class="line">    <span class="keyword">if</span>(config.read_timeout_ms.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="type">int</span> read_timeout=config.read_timeout_ms.<span class="built_in">value</span>()/<span class="number">1000</span>; <span class="comment">//获取值</span></span><br><span class="line">        <span class="built_in">mysql_options</span>(mysql_,MYSQL_OPT_READ_TIMEOUT,&amp;read_timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果“写超时”存在，就设置“写超时选项”</span></span><br><span class="line">    <span class="keyword">if</span>(config.write_timeout_ms.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="type">int</span> write_timeout=config.write_timeout_ms.<span class="built_in">value</span>()/<span class="number">1000</span>; <span class="comment">//获取值</span></span><br><span class="line">        <span class="built_in">mysql_options</span>(mysql_,MYSQL_OPT_WRITE_TIMEOUT,&amp;write_timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果“重连接”存在，就设置“重连接选项”</span></span><br><span class="line">    <span class="keyword">if</span>(config.auto_reconnect.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> mybool=config.auto_reconnect.<span class="built_in">value</span>()?<span class="number">1</span>:<span class="number">0</span>; <span class="comment">//获取值</span></span><br><span class="line">        <span class="built_in">mysql_options</span>(mysql_,MYSQL_OPT_RECONNECT,&amp;mybool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySQLConnection::<span class="built_in">MySQLConnection</span>(<span class="type">const</span> MySQLConfig&amp; config)&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">mysql_real_connect</span>(mysql_,</span><br><span class="line">                            config.host.<span class="built_in">c_str</span>(),</span><br><span class="line">                            config.username.<span class="built_in">c_str</span>(),</span><br><span class="line">                            config.password.<span class="built_in">c_str</span>(),</span><br><span class="line">                            config.database.<span class="built_in">c_str</span>(),</span><br><span class="line">                            config.port,</span><br><span class="line">                            <span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="comment">//连接失败</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不重连的条件： 重连配置不存在 || 重连配置存在 但 设置为false ——&gt; value_or(false) </span></span><br><span class="line">        <span class="type">bool</span> should_retry = config.auto_reconnect.<span class="built_in">value_or</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!should_retry) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;mysql_real_connect failed [&#123;&#125;]: &#123;&#125;&quot;</span>, err_code, err_msg);</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">MySQLException</span>(err_code, err_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重连</span></span><br><span class="line">        <span class="built_in">ConnectWithRetry</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>《C++17完全指南》</category>
        <category>三、新的标准库组件</category>
        <category>15.std::optional&lt;&gt;</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>16.std::variant&lt;&gt;</title>
    <url>/2026/01/08/C++/%E3%80%8AC++17%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E3%80%8B/16-std-variant/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>1.std::variant&lt;&gt; 可以认为是c++中类型安全的 union<br>2.variant所占的内存大小等于所有可能的底层类型中<strong>最大的</strong>再加上一个记录当前选项的固定内存开销。不<br>会分配堆内存。<br>3.和std::optional&lt;&gt;、std::any一样，variant对象是值语义 ——&gt; 拷贝被实现为<strong>深拷贝</strong><br>4.拷贝std::variant&lt;&gt;的开销要比拷贝当前选项的<strong>开销稍微大一点</strong>，因为variant必须找出要拷贝哪个值。<br>5.variant也支持move语义。</p>
<hr>
<h1 id="2-常用API"><a href="#2-常用API" class="headerlink" title="2.常用API"></a>2.常用API</h1><h2 id="0-头文件"><a href="#0-头文件" class="headerlink" title="0.头文件"></a>0.头文件</h2><p><strong>#include&lt;variant&gt;</strong></p>
<p><strong>注意</strong>：两个不同选项的类型也有可能相同，这在多个类型相同的选项分别代表不同含义的时候很有用</p>
<ul>
<li>例如：有两个选项类型都是字符串，分别代表数据库中不同列的名称，你可以知道当前的值代表哪一个列）</li>
</ul>
<h2 id="1-构造与赋值"><a href="#1-构造与赋值" class="headerlink" title="1.构造与赋值"></a>1.构造与赋值</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108110315903.png"></p>
<h2 id="2-取值访问-API"><a href="#2-取值访问-API" class="headerlink" title="2.取值访问 API"></a>2.取值访问 API</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108110558319.png"></p>
<h2 id="3-状态查询-API"><a href="#3-状态查询-API" class="headerlink" title="3.状态查询 API"></a>3.状态查询 API</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108110959759.png"></p>
<h2 id="4-修改与交换-API"><a href="#4-修改与交换-API" class="headerlink" title="4.修改与交换 API"></a>4.修改与交换 API</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108111102983.png"></p>
<h2 id="5-编译期辅助-API"><a href="#5-编译期辅助-API" class="headerlink" title="5.编译期辅助 API"></a>5.编译期辅助 API</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108111233871.png"></p>
<hr>
<h1 id="3-std-variant中的类型要求"><a href="#3-std-variant中的类型要求" class="headerlink" title="3.std::variant中的类型要求"></a>3.std::variant中的类型要求</h1><p><strong>std::variant 可以包含几乎任何类型，包括 std::optional、自定义类、容器等。</strong></p>
<h2 id="1-基本要求"><a href="#1-基本要求" class="headerlink" title="1.基本要求"></a>1.基本要求</h2><ul>
<li><strong>可析构</strong>（Destructible）</li>
<li><strong>不能是引用类型</strong>（int&amp; ❌）</li>
<li><strong>不能是数组类型</strong>（int[10] ❌）</li>
<li><strong>不能是</strong> void</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 全部合法</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; v1;                    <span class="comment">// 基础类型 + string</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>, std::optional&lt;<span class="type">int</span>&gt;&gt; v2;                     <span class="comment">// 包含 optional</span></span><br><span class="line">std::variant&lt;std::vector&lt;<span class="type">int</span>&gt;, std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v3;        <span class="comment">// 包含容器</span></span><br><span class="line">std::variant&lt;std::monostate, <span class="type">int</span>, std::string&gt; v4;            <span class="comment">// monostate 用于表示&quot;空&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line">std::variant&lt;<span class="type">int</span>, MyClass, std::optional&lt;MyClass&gt;&gt; v5;        <span class="comment">// ✅ 自定义类型也可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套 variant</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>, std::variant&lt;<span class="type">double</span>, std::string&gt;&gt; v6;      <span class="comment">// ✅ 套娃也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 这些是非法的</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>&amp;, <span class="type">double</span>&gt; bad1;           <span class="comment">// 引用类型不行</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>[10], <span class="type">double</span>&gt; bad2;        <span class="comment">// C 数组不行</span></span><br><span class="line">std::variant&lt;<span class="type">void</span>, <span class="type">int</span>&gt; bad3;              <span class="comment">// void 不行</span></span><br></pre></td></tr></table></figure>


<h2 id="2-对自定义类型的要求"><a href="#2-对自定义类型的要求" class="headerlink" title="2.对自定义类型的要求"></a>2.对自定义类型的要求</h2><ul>
<li><strong>最低要求：可析构</strong></li>
<li><strong>其它要求</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108141739842.png"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 完整实用的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Good</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">Good</span>() = <span class="keyword">default</span>;                        <span class="comment">//默认构造函数		</span></span><br><span class="line">    <span class="built_in">Good</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line">    <span class="built_in">Good</span>(<span class="type">const</span> Good&amp;) = <span class="keyword">default</span>;             <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">Good</span>(Good&amp;&amp;) = <span class="keyword">default</span>;                  <span class="comment">// 移动构造</span></span><br><span class="line">    Good&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Good&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Good&amp; <span class="keyword">operator</span>=(Good&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Good</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 没有默认构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoDefault</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">NoDefault</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;       <span class="comment">// 只有带参构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">std::variant&lt;Good, <span class="type">int</span>&gt; v1;              <span class="comment">// ✅ Good 可以默认构造</span></span><br><span class="line">std::variant&lt;NoDefault, <span class="type">int</span>&gt; v2;         <span class="comment">// ❌ 编译错误！NoDefault 不能默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案：用 monostate 或把有默认构造的类型放前面</span></span><br><span class="line">std::variant&lt;std::monostate, NoDefault&gt; v3;  <span class="comment">// ✅</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>, NoDefault&gt; v4;             <span class="comment">// ✅ int 在前面，可以默认构造</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-用-std-monostate-表示”无值”"><a href="#3-用-std-monostate-表示”无值”" class="headerlink" title="3.用 std::monostate 表示”无值”"></a>3.用 std::monostate 表示”无值”</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 variant 的第一个类型没有默认构造函数，需要用 monostate</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoDefault</span> &#123;</span><br><span class="line">    <span class="built_in">NoDefault</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::variant&lt;NoDefault, int&gt; v;  // ❌ 编译错误，NoDefault 没有默认构造</span></span><br><span class="line">std::variant&lt;std::monostate, NoDefault, <span class="type">int</span>&gt; v;  <span class="comment">// ✅ monostate 可以默认构造</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="4-std-visit-多类型分支处理详解"><a href="#4-std-visit-多类型分支处理详解" class="headerlink" title="4.std::visit 多类型分支处理详解"></a>4.std::visit 多类型分支处理详解</h1><h2 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1.核心原理"></a>1.核心原理</h2><ul>
<li><strong>访问器（visitor）</strong>：可是 lambda 表达式、函数对象，要求能接收 variant 所有可能存储的类型作为参数；</li>
<li><strong>匹配规则</strong>：std::visit 会在编译期检查访问器是否支持 variant 的所有类型，运行时自动根据 variant实际存储类型调用对应重载的函数&#x2F;分支；</li>
<li><strong>优势</strong>：类型安全（编译期校验）、无分支冗余（<strong>无需手动判断 index()</strong> 或 holds_alternative）。</li>
</ul>
<h2 id="2-使用示例（按场景分类）"><a href="#2-使用示例（按场景分类）" class="headerlink" title="2.使用示例（按场景分类）"></a>2.使用示例（按场景分类）</h2><h3 id="场景1：单-variant-多类型分支（基础场景）"><a href="#场景1：单-variant-多类型分支（基础场景）" class="headerlink" title="场景1：单 variant 多类型分支（基础场景）"></a>场景1：单 variant 多类型分支（基础场景）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义访问器（lambda 表达式，用 constexpr if 实现分支）</span></span><br><span class="line">    <span class="keyword">auto</span> type_visitor = [](<span class="keyword">auto</span>&amp;&amp; val) &#123;</span><br><span class="line">        <span class="comment">// 用 decay_t 获取val的原始类型（排除引用、右值引用）</span></span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(val)&gt;;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前类型：int，值：&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;，执行int专属逻辑（加10）：&quot;</span> &lt;&lt; val + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前类型：string，值：&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;，执行string专属逻辑（拼接后缀）：&quot;</span> &lt;&lt; val + <span class="string">&quot;_suffix&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前类型：double，值：&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;，执行double专属逻辑（乘2）：&quot;</span> &lt;&lt; val * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 切换 variant 存储类型，测试访问器</span></span><br><span class="line">    var = <span class="number">100</span>;          <span class="comment">// 存储 int</span></span><br><span class="line">    std::<span class="built_in">visit</span>(type_visitor, var); <span class="comment">// 输出：当前类型：int，值：100，执行int专属逻辑（加10）：110</span></span><br><span class="line"></span><br><span class="line">    var = <span class="string">&quot;hello variant&quot;</span>; <span class="comment">// 存储 string</span></span><br><span class="line">    std::<span class="built_in">visit</span>(type_visitor, var); <span class="comment">// 输出：当前类型：string，值：hello variant，执行string专属逻辑（拼接后缀）：hello variant_suffix</span></span><br><span class="line"></span><br><span class="line">    var = <span class="number">3.14</span>;         <span class="comment">// 存储 double</span></span><br><span class="line">    std::<span class="built_in">visit</span>(type_visitor, var); <span class="comment">// 输出：当前类型：double，值：3.14，执行double专属逻辑（乘2）：6.28</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用 <strong>constexpr if</strong>实现编译期分支判断，避免运行时开销；</li>
<li>用 <strong>std::decay_t</strong> 处理 val 的引用属性，确保类型匹配准确；</li>
<li>若访问器遗漏 variant 支持的某类类型，编译期会直接报错（类型安全保障）。</li>
</ul>
<h3 id="场景2：多-variant-组合分支（进阶场景）"><a href="#场景2：多-variant-组合分支（进阶场景）" class="headerlink" title="场景2：多 variant 组合分支（进阶场景）"></a>场景2：多 variant 组合分支（进阶场景）</h3><p><strong>适用于需要同时处理多个 variant 的场景，std::visit 会匹配所有 variant 的类型组合，执行对应逻辑。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个 variant（可存储不同类型列表）</span></span><br><span class="line">    std::variant&lt;<span class="type">int</span>, std::string&gt; var1;</span><br><span class="line">    std::variant&lt;<span class="type">double</span>, std::string&gt; var2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义访问器（处理 var1 和 var2 的所有类型组合）</span></span><br><span class="line">    <span class="keyword">auto</span> combo_visitor = [](<span class="keyword">auto</span>&amp;&amp; v1, <span class="keyword">auto</span>&amp;&amp; v2) &#123;</span><br><span class="line">        <span class="keyword">using</span> T1 = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(v1)&gt;;</span><br><span class="line">        <span class="keyword">using</span> T2 = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(v2)&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组合分支1：var1=int，var2=double</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T1, <span class="type">int</span>&gt; &amp;&amp; std::is_same_v&lt;T2, <span class="type">double</span>&gt;)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;组合类型：int + double，执行求和：&quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组合分支2：var1=int，var2=string</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T1, <span class="type">int</span>&gt; &amp;&amp; std::is_same_v&lt;T2, std::string&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;组合类型：int + string，执行拼接：&quot;</span> &lt;&lt; std::<span class="built_in">to_string</span>(v1) + <span class="string">&quot;_&quot;</span> + v2 &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组合分支3：var1=string，var2=double</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T1, std::string&gt; &amp;&amp; std::is_same_v&lt;T2, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;组合类型：string + double，执行拼接：&quot;</span> &lt;&lt; v1 + <span class="string">&quot;_&quot;</span> + std::<span class="built_in">to_string</span>(v2) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组合分支4：var1=string，var2=string</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T1, std::string&gt; &amp;&amp; std::is_same_v&lt;T2, std::string&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;组合类型：string + string，执行拼接：&quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试不同类型组合</span></span><br><span class="line">    var1 = <span class="number">10</span>; var2 = <span class="number">3.14</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>(combo_visitor, var1, var2); <span class="comment">// 输出：组合类型：int + double，执行求和：13.14</span></span><br><span class="line"></span><br><span class="line">    var1 = <span class="number">20</span>; var2 = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>(combo_visitor, var1, var2); <span class="comment">// 输出：组合类型：int + string，执行拼接：20_test</span></span><br><span class="line"></span><br><span class="line">    var1 = <span class="string">&quot;hello&quot;</span>; var2 = <span class="number">6.28</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>(combo_visitor, var1, var2); <span class="comment">// 输出：组合类型：string + double，执行拼接：hello_6.28xxxx（精度取决于实现）</span></span><br><span class="line"></span><br><span class="line">    var1 = <span class="string">&quot;hello&quot;</span>; var2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>(combo_visitor, var1, var2); <span class="comment">// 输出：组合类型：string + string，执行拼接：helloworld</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>std::visit 支持传入多个 variant 参数（逗号分隔），访问器需接收对应数量的参数；</li>
<li>需覆盖所有可能的类型组合，否则编译报错；<strong>若部分组合无需处理，可添加默认分支（else）</strong>。</li>
</ul>
<h2 id="3-std-visit-关键注意事项"><a href="#3-std-visit-关键注意事项" class="headerlink" title="3.std::visit 关键注意事项"></a>3.std::visit 关键注意事项</h2><p><strong>1.类型安全校验</strong>:访问器必须支持 variant 所有模板类型，否则编译失败（避免遗漏类型处理）；<br><strong>2.避免窄化转换</strong>:若 variant 存储的类型可隐式转换（如 int 和 long），需明确区分，避免分支匹配歧义；<br><strong>3.右值引用处理</strong>:若需修改 variant 中的值，访问器参数可声明为非 const 引用（如 auto&amp; val）；若需转移所有权，可声明为右值引用（auto&amp;&amp; val）；<br><strong>4.返回值支持</strong>:访问器可返回值，所有分支的返回值类型需一致（或可隐式转换为同一类型）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问器返回值示例</span></span><br><span class="line"><span class="keyword">auto</span> return_visitor = [](<span class="keyword">auto</span>&amp;&amp; val) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(val)&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span> <span class="keyword">return</span> val</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;) <span class="keyword">return</span> val.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;) <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::variant&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; var = <span class="string">&quot;return test&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = std::<span class="built_in">visit</span>(return_visitor, var);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;访问器返回值：&quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出：10（字符串长度）</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>《C++17完全指南》</category>
        <category>三、新的标准库组件</category>
        <category>16.std::variant&lt;&gt;</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>19.std::string_view</title>
    <url>/2026/01/18/C++/%E3%80%8AC++17%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E3%80%8B/19-std-string-view/</url>
    <content><![CDATA[<h1 id="一、std-string-view-的介绍、核心特点、优势"><a href="#一、std-string-view-的介绍、核心特点、优势" class="headerlink" title="一、std::string_view 的介绍、核心特点、优势"></a>一、std::string_view 的介绍、核心特点、优势</h1><h2 id="1-核心介绍"><a href="#1-核心介绍" class="headerlink" title="1.核心介绍"></a>1.核心介绍</h2><ul>
<li>std::string_view 是 C++17 引入的标准库类型，定义在 <string_view> 头文件中，本质是字符序列的<strong>轻量级引用</strong><ul>
<li>它<strong>不持有字符数据</strong>，仅通过「<strong>起始指针 + 长度</strong>」的方式引用外部字符序列（如字符串字面量、std::string、字符数组等），无需分配内存，也不管理字符序列的生命周期。</li>
</ul>
</li>
</ul>
<h2 id="2-核心特点"><a href="#2-核心特点" class="headerlink" title="2.核心特点"></a>2.核心特点</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118213057119.png"></p>
<h2 id="3-核心优势"><a href="#3-核心优势" class="headerlink" title="3.核心优势"></a>3.核心优势</h2><ul>
<li><strong>性能优化</strong>：<ul>
<li>避免不必要的内存分配（如字符串字面量传参给 const std::string&amp; 时的临时对象创建）、减少拷贝，尤其适合处理子字符串、内存映射文件等场景；</li>
</ul>
</li>
<li><strong>接口友好</strong>：<ul>
<li>提供与 std::string 几乎一致的只读接口，无需改变使用习惯；</li>
</ul>
</li>
<li><strong>编译期支持</strong>：<ul>
<li>可通过 constexpr 初始化，支持编译期字符序列操作；</li>
</ul>
</li>
<li><strong>多字符类型适配</strong>：<ul>
<li>提供 u16string_view&#x2F;u32string_view&#x2F;wstring_view 特化版本，适配宽字符场景。</li>
</ul>
</li>
</ul>
<h1 id="二、与-std-string、const-std-string-的区别"><a href="#二、与-std-string、const-std-string-的区别" class="headerlink" title="二、与 std::string、const std::string&amp; 的区别"></a>二、与 std::string、const std::string&amp; 的区别</h1><h2 id="1-对比表"><a href="#1-对比表" class="headerlink" title="1.对比表"></a>1.对比表</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118213442111.png"></p>
<h2 id="2-std-string-view-何时代替-const-std-string-？"><a href="#2-std-string-view-何时代替-const-std-string-？" class="headerlink" title="2.std::string_view 何时代替 const std::string&amp; ？"></a>2.std::string_view 何时代替 const std::string&amp; ？</h2><h3 id="（1）核心区别"><a href="#（1）核心区别" class="headerlink" title="（1）核心区别"></a>（1）核心区别</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118213703783.png"></p>
<h3 id="（2）必须使用-const-std-string-的场景（无法用std-string-view-代替）"><a href="#（2）必须使用-const-std-string-的场景（无法用std-string-view-代替）" class="headerlink" title="（2）必须使用 const std::string&amp; 的场景（无法用std::string_view 代替）"></a>（2）必须使用 const std::string&amp; 的场景（无法用std::string_view 代替）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">┌─ 需要存储字符串？</span><br><span class="line">│   └─ 是 → std::<span class="built_in">string</span> (参数可以是 string_view，内部转换存储)</span><br><span class="line">│</span><br><span class="line">├─ 需要传给 C API / 使用 <span class="built_in">c_str</span>()？</span><br><span class="line">│   └─ 是 → <span class="type">const</span> std::string&amp;</span><br><span class="line">│</span><br><span class="line">├─ 需要修改字符串？</span><br><span class="line">│   └─ 是 → std::string&amp;</span><br><span class="line">│</span><br><span class="line">├─ 是函数返回值？</span><br><span class="line">│   ├─ 返回局部变量 → std::string</span><br><span class="line">│   └─ 返回成员/参数 → std::string_view 或 <span class="type">const</span> std::string&amp;</span><br><span class="line">│</span><br><span class="line">├─ 数据会跨越作用域/线程？</span><br><span class="line">│   └─ 是 → std::string</span><br><span class="line">│</span><br><span class="line">└─ 只读参数，短期使用？</span><br><span class="line">    └─ 是 → std::string_view ✅</span><br></pre></td></tr></table></figure>

<h4 id="需要传给-C-API（要求-null-结尾）"><a href="#需要传给-C-API（要求-null-结尾）" class="headerlink" title="&lt;1&gt;需要传给 C API（要求 null 结尾）"></a>&lt;1&gt;需要传给 C API（要求 null 结尾）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：string_view 不保证 null 结尾</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openFile</span><span class="params">(std::string_view path)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fopen</span>(path.<span class="built_in">data</span>(), <span class="string">&quot;r&quot;</span>);  <span class="comment">// ❌ 危险！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openFile</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>);  <span class="comment">// ✅ 保证 null 结尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见 C API：fopen, open, printf, 系统调用, 数据库接口等</span></span><br></pre></td></tr></table></figure>

<h4 id="需要使用-c-str-方法"><a href="#需要使用-c-str-方法" class="headerlink" title="&lt;2&gt;需要使用 c_str() 方法"></a>&lt;2&gt;需要使用 c_str() 方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ string_view 没有 c_str()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callLegacy</span><span class="params">(std::string_view s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">legacy_api</span>(s.<span class="built_in">c_str</span>());  <span class="comment">// ❌ 编译错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callLegacy</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">legacy_api</span>(s.<span class="built_in">c_str</span>());  <span class="comment">// ✅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口与旧代码兼容"><a href="#接口与旧代码兼容" class="headerlink" title="&lt;3&gt;接口与旧代码兼容"></a>&lt;3&gt;接口与旧代码兼容</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧接口设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldLibrary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span></span>;  <span class="comment">// 已有大量调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果改成 string_view，所有返回 c_str() 的地方都要改</span></span><br></pre></td></tr></table></figure>

<h4 id="需要延长临时对象生命周期"><a href="#需要延长临时对象生命周期" class="headerlink" title="&lt;4&gt;需要延长临时对象生命周期"></a>&lt;4&gt;需要延长临时对象生命周期</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ const 引用可以延长临时对象生命周期</span></span><br><span class="line"><span class="type">const</span> std::string&amp; ref = <span class="built_in">createString</span>();  <span class="comment">// 临时对象生命周期延长</span></span><br><span class="line"><span class="built_in">use</span>(ref);  <span class="comment">// ✅ 安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ string_view 不能延长</span></span><br><span class="line">std::string_view view = <span class="built_in">createString</span>();  <span class="comment">// 临时对象立即销毁</span></span><br><span class="line"><span class="built_in">use</span>(view);  <span class="comment">// ❌ 悬空引用！</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）⚠️-string-view-的危险场景"><a href="#（3）⚠️-string-view-的危险场景" class="headerlink" title="（3）⚠️ string_view 的危险场景"></a>（3）⚠️ string_view 的危险场景</h3><h4 id="存储-string-view（生命周期陷阱）"><a href="#存储-string-view（生命周期陷阱）" class="headerlink" title="&lt;1&gt;存储 string_view（生命周期陷阱）"></a>&lt;1&gt;存储 string_view（生命周期陷阱）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    std::string_view name_;  <span class="comment">// ❌ 危险！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string_view name)</span> </span>&#123;</span><br><span class="line">        name_ = name;  <span class="comment">// 如果 name 来自临时对象，会悬空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误使用</span></span><br><span class="line">Config c;</span><br><span class="line">c.<span class="built_in">setName</span>(std::<span class="built_in">string</span>(<span class="string">&quot;temp&quot;</span>));  <span class="comment">// 临时 string 销毁，name_ 悬空！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：存储 std::string</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    std::string name_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string_view name)</span> </span>&#123;</span><br><span class="line">        name_ = name;  <span class="comment">// 隐式转换，拷贝数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="返回局部变量的-string-view"><a href="#返回局部变量的-string-view" class="headerlink" title="&lt;2&gt;返回局部变量的 string_view"></a>&lt;2&gt;返回局部变量的 string_view</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误</span></span><br><span class="line"><span class="function">std::string_view <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string result = <span class="built_in">compute</span>();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// ❌ result 销毁，view 悬空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：返回 string</span></span><br><span class="line"><span class="function">std::string <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string result = <span class="built_in">compute</span>();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// ✅ 移动语义，高效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跨越异步边界"><a href="#跨越异步边界" class="headerlink" title="&lt;3&gt;跨越异步边界"></a>&lt;3&gt;跨越异步边界</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：异步任务中使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async</span><span class="params">(std::string_view data)</span> </span>&#123;</span><br><span class="line">    threadPool.<span class="built_in">submit</span>([=] &#123;</span><br><span class="line">        <span class="built_in">use</span>(data);  <span class="comment">// ❌ 原始数据可能已销毁</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：捕获 string</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async</span><span class="params">(std::string data)</span> </span>&#123;</span><br><span class="line">    threadPool.<span class="built_in">submit</span>([data = std::<span class="built_in">move</span>(data)] &#123;</span><br><span class="line">        <span class="built_in">use</span>(data);  <span class="comment">// ✅ 拥有数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、核心-API-与std-string相似"><a href="#三、核心-API-与std-string相似" class="headerlink" title="三、核心 API (与std::string相似)"></a>三、核心 API (与std::string相似)</h1><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118214152000.png"></p>
<h1 id="四、使用示例"><a href="#四、使用示例" class="headerlink" title="四、使用示例"></a>四、使用示例</h1><h2 id="1-作为函数参数优化性能（替代-const-std-string-）"><a href="#1-作为函数参数优化性能（替代-const-std-string-）" class="headerlink" title="1.作为函数参数优化性能（替代 const std::string&amp;）"></a>1.作为函数参数优化性能（替代 const std::string&amp;）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化前：传 const std::string&amp; 会导致字符串字面量创建临时对象</span></span><br><span class="line"><span class="comment">// 优化后：传 string_view 无内存分配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">(<span class="type">const</span> <span class="keyword">auto</span>&amp; coll, std::string_view prefix = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : coll) &#123;</span><br><span class="line">        <span class="comment">// 排除 nullptr 情况</span></span><br><span class="line">        <span class="keyword">if</span> (!prefix.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; elem &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="comment">// 传递字符串字面量，无临时 string 创建</span></span><br><span class="line">    <span class="built_in">printElements</span>(vec, <span class="string">&quot;Number&quot;</span>);</span><br><span class="line">    <span class="comment">// 传递 std::string，隐式转换为 string_view</span></span><br><span class="line">    std::string str = <span class="string">&quot;Value&quot;</span>;</span><br><span class="line">    <span class="built_in">printElements</span>(vec, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-字符串转整数（高效处理字符序列）"><a href="#2-字符串转整数（高效处理字符序列）" class="headerlink" title="2.字符串转整数（高效处理字符序列）"></a>2.字符串转整数（高效处理字符序列）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">asInt</span><span class="params">(std::string_view sv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">// 直接传递字符范围，无需分配内存</span></span><br><span class="line">    <span class="keyword">auto</span> [ptr, ec] = std::<span class="built_in">from_chars</span>(sv.<span class="built_in">data</span>(), sv.<span class="built_in">data</span>() + sv.<span class="built_in">size</span>(), val);</span><br><span class="line">    <span class="keyword">if</span> (ec != std::errc&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (std::string_view s : &#123;<span class="string">&quot;42&quot;</span>, <span class="string">&quot;  77&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;0x33&quot;</span>&#125;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> res = <span class="built_in">asInt</span>(s)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Convert &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27; to int: &quot;</span> &lt;&lt; *res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Can&#x27;t convert &#x27;&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&#x27; to int\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-处理子字符串（无内存分配）"><a href="#3-处理子字符串（无内存分配）" class="headerlink" title="3.处理子字符串（无内存分配）"></a>3.处理子字符串（无内存分配）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; coll = &#123;<span class="string">&quot;apple123&quot;</span>, <span class="string">&quot;banana456&quot;</span>, <span class="string">&quot;cherry789&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 按子串（从第3位开始）排序，无内存分配</span></span><br><span class="line">    std::<span class="built_in">sort</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::string_view&#123;a&#125;.<span class="built_in">substr</span>(<span class="number">3</span>) &lt; std::string_view&#123;b&#125;.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : coll) &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、使用注意事项（核心避坑点）"><a href="#五、使用注意事项（核心避坑点）" class="headerlink" title="五、使用注意事项（核心避坑点）"></a>五、使用注意事项（核心避坑点）</h1><h2 id="1-生命周期管理（最核心）"><a href="#1-生命周期管理（最核心）" class="headerlink" title="1.生命周期管理（最核心）"></a>1.生命周期管理（最核心）</h2><h3 id="（1）禁止绑定临时字符串"><a href="#（1）禁止绑定临时字符串" class="headerlink" title="（1）禁止绑定临时字符串"></a>（1）禁止绑定临时字符串</h3><p>std::string_view 不会延长外部字符序列的生命周期，绑定临时 std::string 会导致悬空引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例：临时 string 销毁后，sv 引用无效</span></span><br><span class="line">std::string_view sv = std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; sv; <span class="comment">// 未定义行为！</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）禁止返回-string-view-指向局部变量"><a href="#（2）禁止返回-string-view-指向局部变量" class="headerlink" title="（2）禁止返回 string_view 指向局部变量"></a>（2）禁止返回 string_view 指向局部变量</h3><p>函数返回的 string_view 不能引用函数内的局部字符序列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function">std::string_view <span class="title">badFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// 返回后 s 销毁，视图悬空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）允许返回的场景"><a href="#（3）允许返回的场景" class="headerlink" title="（3）允许返回的场景"></a>（3）允许返回的场景</h3><p>仅当 string_view 转发函数输入参数，或引用全局&#x2F;静态字符序列时可返回。</p>
<h2 id="2-空字符与-nullptr-处理"><a href="#2-空字符与-nullptr-处理" class="headerlink" title="2.空字符与 nullptr 处理"></a>2.空字符与 nullptr 处理</h2><h3 id="（1）必须用-size-确认长度"><a href="#（1）必须用-size-确认长度" class="headerlink" title="（1）必须用 size() 确认长度"></a>（1）必须用 size() 确认长度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeAccess</span><span class="params">(std::string_view sv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sv.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; sv.<span class="built_in">data</span>(); <span class="comment">// 避免 nullptr 访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）避免直接传给要求-0-终止的函数"><a href="#（2）避免直接传给要求-0-终止的函数" class="headerlink" title="（2）避免直接传给要求 \0 终止的函数"></a>（2）避免直接传给要求 \0 终止的函数</h3><p>如 strlen()、printf(“%s”)，需先转换为 std::string</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：sv 可能无 \0 结尾</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, sv.<span class="built_in">data</span>());</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, std::<span class="built_in">string</span>(sv).<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<h2 id="3-接口设计避坑"><a href="#3-接口设计避坑" class="headerlink" title="3.接口设计避坑"></a>3.接口设计避坑</h2><h3 id="（1）不要用-string-view-初始化-string-成员"><a href="#（1）不要用-string-view-初始化-string-成员" class="headerlink" title="（1）不要用 string_view 初始化 string 成员"></a>（1）不要用 string_view 初始化 string 成员</h3><p>会破坏 std::move 优化，导致额外内存分配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(std::string_view n) : <span class="built_in">name</span>(n) &#123;&#125; <span class="comment">// 传入 move 的 string 也会拷贝</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 正确设计</span></span><br><span class="line"><span class="built_in">Person</span>(std::string n) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(n)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）函数模板返回-auto-而非-T"><a href="#（2）函数模板返回-auto-而非-T" class="headerlink" title="（2）函数模板返回 auto 而非 T"></a>（2）函数模板返回 auto 而非 T</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例：T 为 string_view 时，返回值悬空</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">concat</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>(a) + std::<span class="built_in">string</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确示例：auto 推导为 std::string</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">concat</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>(a) + std::<span class="built_in">string</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>《C++17完全指南》</category>
        <category>三、新的标准库组件</category>
        <category>19.std::string_view</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章：Python数据模型</title>
    <url>/2026/01/09/Python/%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84python%E3%80%8B/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9APython%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>特殊方法快速查表</strong>：<a href="#%E4%B8%89%E3%80%81%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0">三、特殊方法概述</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-特殊方法（”魔术方法”）"><a href="#1-特殊方法（”魔术方法”）" class="headerlink" title="1.特殊方法（”魔术方法”）"></a>1.特殊方法（”魔术方法”）</h2><ul>
<li><p><strong>特征</strong>：名称前后两端都有双下划线。如：</p>
<ul>
<li>在 obj[key] 句法背后提供支持的是特殊方法 <strong>getitem</strong></li>
</ul>
</li>
<li><p><strong>作用</strong>：在特殊语句中自动触发调用，不需要显示手动调用。如：</p>
<ul>
<li>my_collection[key]：Python 解释器自动调用my_collection.<strong>getitem</strong>(key)。</li>
<li>print(my_object)：Python 解释器自动调用print(my_object.<strong>repr</strong>())<br><strong>很大程度上方便了我们的使用</strong></li>
</ul>
</li>
<li><p><strong>重要性</strong>：想让对象支持以下基本的语言结构并与其交互，就需要实现特殊方<br>法：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109141629741.png"></p>
</li>
</ul>
<h2 id="2-实例：“纸牌”"><a href="#2-实例：“纸牌”" class="headerlink" title="2.实例：“纸牌”"></a>2.实例：“纸牌”</h2><h3 id="1-实现-“特殊方法”"><a href="#1-实现-“特殊方法”" class="headerlink" title="(1) 实现+“特殊方法”"></a>(1) 实现+“特殊方法”</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109142035218.png"></p>
<ul>
<li><strong>Card</strong>： 纸牌类，只有属性无方法<ul>
<li><strong>collections.namedtuple(‘类名’, [‘字段1’, ‘字段2’, …])</strong>：用于构建只有属性而没有自定义方法的类对象</li>
</ul>
</li>
<li><strong>FrenchDeck</strong>： 法式扑克牌类，包含Card列表、<strong>魔法方法</strong><ul>
<li>[str(n) for n in range(2, 11)] ：“<strong>列表推导式语法</strong>”，下一章会学到</li>
<li><strong>魔法方法</strong>：__getitem__ 和 __len__</li>
</ul>
</li>
</ul>
<p><strong>本节关键：FrenchDeck类</strong></p>
<h3 id="2-“FrenchDeck类”的使用"><a href="#2-“FrenchDeck类”的使用" class="headerlink" title="(2)“FrenchDeck类”的使用"></a>(2)“FrenchDeck类”的使用</h3><h4 id="返回一摞牌有多少张"><a href="#返回一摞牌有多少张" class="headerlink" title="&lt;1&gt;返回一摞牌有多少张"></a>&lt;1&gt;返回一摞牌有多少张</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109143542901.png"></p>
<ul>
<li><strong>得益于__len__魔法方法</strong>：底层调用了该魔法方法</li>
</ul>
<h4 id="从这摞牌中抽取某一张"><a href="#从这摞牌中抽取某一张" class="headerlink" title="&lt;2&gt;从这摞牌中抽取某一张"></a>&lt;2&gt;从这摞牌中抽取某一张</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109143739371.png"></p>
<ul>
<li><strong>得益于__getitem__魔法方法</strong>：底层调用了该魔法方法</li>
</ul>
<h4 id="“-getitem-魔法方法”-其它功效"><a href="#“-getitem-魔法方法”-其它功效" class="headerlink" title="&lt;3&gt;“__getitem__魔法方法” 其它功效"></a>&lt;3&gt;“__getitem__魔法方法” 其它功效</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109143955133.png"></p>
<ul>
<li><strong>支持“切片”</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109144028869.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109144054149.png"></p>
<ul>
<li><strong>支持“正向&#x2F;反向 迭代”</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109144216884.png"></p>
<ul>
<li><strong>迭代往往是隐式的</strong>：如果一个容器没有实现 <strong>contains</strong> 方法，那么 in 运算符就会做一次顺序扫描<ul>
<li>FrenchDeck 类支持 in 运算符，因为该类可迭代。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109144536685.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109144549525.png"></p>
<ul>
<li><strong>支持“排序”</strong></li>
</ul>
<p>1.通过前面使用reversed 和 sorted 的示例可以看出，实现 __len__ 和 __getitem__ 两个特殊方法后，FrenchDeck 的行为就像标准的 Python序列一样，受益于语言核心特性（例如迭代和切片）和标准库。<br>2.__len__ 和 __getitem__ 的实现利用组合模式，把所有工作委托给一个 list 对象，即 self._cards.</p>
<h1 id="二、特殊方法是如何使用的"><a href="#二、特殊方法是如何使用的" class="headerlink" title="二、特殊方法是如何使用的"></a>二、特殊方法是如何使用的</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li><strong>特殊方法供 Python 解释器调用，而不是你自己</strong><ul>
<li>如：没有 my_object.__len__() 这种写法，正确的写法是len(my_object)</li>
</ul>
</li>
<li><strong>如果my_object 是用户定义的类的实例，Python将调用你实现的“魔法方法”</strong><ul>
<li>如：__len__方法</li>
</ul>
</li>
<li><strong>很多时候，特殊方法是“隐式调用”的！</strong><ul>
<li>如：for i in x: 语句其实在背后调用 iter(x)，接着又调用x.__iter__()（前提是有该方法）或 x.__getitem__()</li>
</ul>
</li>
<li><strong>特殊方法的调用</strong><ul>
<li>在编写代码时<strong>一般不直接显示调用</strong>特殊方法，除非涉及大量元编程。<strong>唯一例外的是__init__ 方法</strong>，为自定义的类实现 __init__ 方法时经常直接调用它调取超类的初始化方法。</li>
<li>如果需要调用特殊方法，则<strong>最好调用相应的内置函数</strong>，例如len、iter、str等。这些内置函数不仅调用对应的特殊方法，通常还提供额外服务，而且对于内置类型来说，速度比调用方法更快</li>
</ul>
</li>
</ul>
<h2 id="2-实例：Vector类"><a href="#2-实例：Vector类" class="headerlink" title="2.实例：Vector类"></a>2.实例：Vector类</h2><p><strong>Vector类模拟一个二维向量类，即数学和物理中使用的欧几里得向量</strong></p>
<h3 id="（1）Vector类的实现"><a href="#（1）Vector类的实现" class="headerlink" title="（1）Vector类的实现"></a>（1）Vector类的实现</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109150648100.png"></p>
<ul>
<li><strong>__abs__：绝对值</strong></li>
<li><strong>__add__、__mul__：分别用于实现 + 和 * 运算符</strong></li>
</ul>
<p><strong>使用：</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109151219492.png"></p>
<h3 id="（2）-Vector-类的其他特殊方法"><a href="#（2）-Vector-类的其他特殊方法" class="headerlink" title="（2） Vector 类的其他特殊方法"></a>（2） Vector 类的其他特殊方法</h3><h4 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="&lt;1&gt;字符串表示形式"></a>&lt;1&gt;字符串表示形式</h4><h5 id="1-repr-特殊方法"><a href="#1-repr-特殊方法" class="headerlink" title="1.__repr__ 特殊方法"></a>1.__repr__ 特殊方法</h5><ul>
<li><strong>供内置函数 repr 调用</strong>：获取对象的<strong>标准</strong>字符串表示形式。<ul>
<li>如未定义 <strong>repr</strong> 方法，Vector 实例在 Python 控制台中显示为 &lt;Vector object at 0x10e100070&gt; 形式</li>
</ul>
</li>
<li><strong><strong>repr</strong> 方法返回的字符串应当没有歧义</strong>：最好与源码保持一致，方便重新创建所表示的对象。<ul>
<li><strong>!r</strong>:   Vector 类 __repr__ 方法中的 f 字符串使用 !r 以<strong>标准的表示形式显示属性</strong>。<ul>
<li>这样做比较好，因为 Vector(1, 2) 和Vector(‘1’, ‘2’)之间是有区别的，后者在这个示例中不可用，因为构造函数接受的参数是数值而不是字符串。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-str-特殊方法"><a href="#2-str-特殊方法" class="headerlink" title="2.__str__ 特殊方法"></a>2.__str__ 特殊方法</h5><ul>
<li><strong>供内置函数 str() 调用</strong>：返回<strong>对终端用户友好</strong>的字符串。</li>
<li>有时，<strong>repr</strong> 方法返回的字符串足够友好，无须再定义 __str__方法，因为继承自 object 类的实现最终会调用 __repr__ 方法</li>
</ul>
<h5 id="3-repr-与-str-的区别"><a href="#3-repr-与-str-的区别" class="headerlink" title="3.__repr__ 与 __str__ 的区别"></a>3.__repr__ 与 __str__ 的区别</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109153141165.png"></p>
<h4 id="自定义类型的布尔值"><a href="#自定义类型的布尔值" class="headerlink" title="&lt;2&gt;自定义类型的布尔值"></a>&lt;2&gt;自定义类型的布尔值</h4><ul>
<li><strong>Python 有一个 bool 类型，在需要布尔值的地方处理对象</strong><ul>
<li>如：if 或 while 语句的条件表达式，或者 and、or 和 not 的运算对象。</li>
</ul>
</li>
<li><strong>为了确定 x 表示的值为 “真” 或为 “假”，Python 调用 bool(x)，返回 True 或 False。</strong></li>
<li><strong>默认情况下，用户定义类的实例都是真值，除非实现了 __bool__ 或 __len__ 方法</strong><ul>
<li><strong>实现了__bool__ 方法</strong>：bool(x) 调用 x.__bool__()，以后者返回的结果为准。</li>
<li><strong>没有实现 __bool__ 方法</strong>：则 Python 尝试调用x.__len__()；<ul>
<li>如果该方法返回零值，则 bool 函数返回 False，否则返回 True</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="补充：Python中，万物皆对象-——-万物皆有布尔值"><a href="#补充：Python中，万物皆对象-——-万物皆有布尔值" class="headerlink" title="&lt;3&gt;补充：Python中，万物皆对象 ——&gt; 万物皆有布尔值"></a>&lt;3&gt;补充：Python中，万物皆对象 ——&gt; 万物皆有布尔值</h4><ul>
<li><strong>未实现__bool__</strong>：布尔值恒为True</li>
<li><strong>实现了__bool__</strong>：以x.__bool__()调用结果为准<ul>
<li><strong>空容器、0、None、False被视为假</strong></li>
<li><strong>其他值被视为真</strong></li>
</ul>
</li>
</ul>
<h4 id="自定义API-（先了解，可以之后再回头看）"><a href="#自定义API-（先了解，可以之后再回头看）" class="headerlink" title="&lt;4&gt;自定义API （先了解，可以之后再回头看）"></a>&lt;4&gt;自定义API （先了解，可以之后再回头看）</h4><p><strong>本节简要说明 Python 中最重要的容器接口，纵览容器类型对特殊方法<br>的使用情况。</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109154613470.png"><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109154741486.png"></p>
<h1 id="三、特殊方法汇总表格"><a href="#三、特殊方法汇总表格" class="headerlink" title="三、特殊方法汇总表格"></a>三、特殊方法汇总表格</h1><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109155341846.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109155359478.png"></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>《流畅的python》</category>
        <category>第1章 Python数据模型</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章：丰富的序列</title>
    <url>/2026/01/06/Python/%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84python%E3%80%8B/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="一、内置序列类型概览"><a href="#一、内置序列类型概览" class="headerlink" title="一、内置序列类型概览"></a>一、内置序列类型概览</h1><h2 id="1-“序列类型”按存放分类"><a href="#1-“序列类型”按存放分类" class="headerlink" title="1.“序列类型”按存放分类"></a>1.“序列类型”按存放分类</h2><h3 id="（1）容器序列：list、tuple、collections-deque"><a href="#（1）容器序列：list、tuple、collections-deque" class="headerlink" title="（1）容器序列：list、tuple、collections.deque"></a>（1）容器序列：list、tuple、collections.deque</h3><ul>
<li>可存放不同类型的项</li>
<li>存放的是所包含对象的引用，对象可以是任意类型</li>
</ul>
<h3 id="（2）扁平序列：str、bytes、array-array"><a href="#（2）扁平序列：str、bytes、array-array" class="headerlink" title="（2）扁平序列：str、bytes、array.array"></a>（2）扁平序列：str、bytes、array.array</h3><ul>
<li>可存放一种简单类型的项</li>
<li>在自己的内存空间中存储所含内容的值</li>
</ul>
<p><img src="/images/2026.1.6_1.png" alt="内存简图"></p>
<h2 id="2-“序列类型”按可变性分类"><a href="#2-“序列类型”按可变性分类" class="headerlink" title="2.“序列类型”按可变性分类"></a>2.“序列类型”按可变性分类</h2><h3 id="（1）可变序列：list、collections-deque、bytearray、array-array"><a href="#（1）可变序列：list、collections-deque、bytearray、array-array" class="headerlink" title="（1）可变序列：list、collections.deque、bytearray、array.array"></a>（1）可变序列：list、collections.deque、bytearray、array.array</h3><ul>
<li>可变序列继承不可变序列的所有方法，另外还多实现了几个方法</li>
</ul>
<h3 id="（2）不可变序列：tuple、str、bytes"><a href="#（2）不可变序列：tuple、str、bytes" class="headerlink" title="（2）不可变序列：tuple、str、bytes"></a>（2）不可变序列：tuple、str、bytes</h3><p><img src="/images/2026.1.6_2.png" alt="简化UML类图">  </p>
<hr>
<h1 id="二、“列表推导式（listcomps）”和“生成器表达式（genexps）”"><a href="#二、“列表推导式（listcomps）”和“生成器表达式（genexps）”" class="headerlink" title="二、“列表推导式（listcomps）”和“生成器表达式（genexps）”"></a>二、“列表推导式（listcomps）”和“生成器表达式（genexps）”</h1><ul>
<li>使用“列表推导式”或“生成器表达式”可以快速构建一个序列</li>
<li>代码更容易理解，速度通常更快</li>
</ul>
<h2 id="1-列表推导式（目标：列表）"><a href="#1-列表推导式（目标：列表）" class="headerlink" title="1.列表推导式（目标：列表）"></a>1.列表推导式（目标：列表）</h2><h3 id="（1）基本语法结构：-expression-for-item-in-iterable-if-condition"><a href="#（1）基本语法结构：-expression-for-item-in-iterable-if-condition" class="headerlink" title="（1）基本语法结构： [ expression for item in iterable [if condition] ]"></a>（1）基本语法结构： [ expression for item in iterable [if condition] ]</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例1：无if</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes </span><br><span class="line">[<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例2：有if</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii = [<span class="built_in">ord</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">127</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii </span><br><span class="line">[<span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 例3：生成“笛卡尔积”（双循环）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts </span><br><span class="line">[(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), </span><br><span class="line">    (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="（2）建议"><a href="#（2）建议" class="headerlink" title="（2）建议"></a>（2）建议</h3><ul>
<li>如果你不打算使用生成的列表，那就不要使用列表推导式句法。</li>
<li>列表推导式应保持简短，如果超过两行，最好把语句拆开，或者使用传统的 for 循环重写</li>
</ul>
<h2 id="2-生成器表达式（目标：其它序列类型）"><a href="#2-生成器表达式（目标：其它序列类型）" class="headerlink" title="2.生成器表达式（目标：其它序列类型）"></a>2.生成器表达式（目标：其它序列类型）</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><ul>
<li>生成器表达式的句法跟列表推导式几乎一样，只不过把方括号换成圆括号而已。</li>
<li>虽然列表推导式也可以生成元组、数组或其他类型的序列，但是生成器表达式占用的内存更少。</li>
</ul>
<h3 id="（2）基本语法：-expression-for-item-in-iterable-if-condition"><a href="#（2）基本语法：-expression-for-item-in-iterable-if-condition" class="headerlink" title="（2）基本语法：(expression for item in iterable [if condition])"></a>（2）基本语法：(expression for item in iterable [if condition])</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例1：构建一个元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)</span><br><span class="line">(<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 例2：构建一个数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array.array(<span class="string">&#x27;I&#x27;</span>, (<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols))</span><br><span class="line">array(<span class="string">&#x27;I&#x27;</span>, [<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例3：生成“笛卡尔积”</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">f&#x27;<span class="subst">&#123;c&#125;</span> <span class="subst">&#123;s&#125;</span>&#x27;</span> <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes): </span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(tshirt) </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">black S </span><br><span class="line">black M </span><br></pre></td></tr></table></figure>
<ul>
<li>如果生成器表达式是函数唯一的参数，则不需要额外再使用圆括号括起来。</li>
<li>array 构造函数接受两个参数，因此必须在生成器表达式两侧加上圆括号。</li>
</ul>
<h2 id="3-两者对比表"><a href="#3-两者对比表" class="headerlink" title="3.两者对比表"></a>3.两者对比表</h2><h3 id="（1）核心特点对比表"><a href="#（1）核心特点对比表" class="headerlink" title="（1）核心特点对比表"></a>（1）核心特点对比表</h3><p><img src="/images/2026.1.6_4.png" alt="对比表"></p>
<h3 id="（2）使用场景对比表"><a href="#（2）使用场景对比表" class="headerlink" title="（2）使用场景对比表"></a>（2）使用场景对比表</h3><p><img src="/images/2026.1.6_3.png" alt="对比表"></p>
<hr>
<h1 id="三、元组不仅仅是不可变列表"><a href="#三、元组不仅仅是不可变列表" class="headerlink" title="三、元组不仅仅是不可变列表"></a>三、元组不仅仅是不可变列表</h1><h2 id="1-用作记录"><a href="#1-用作记录" class="headerlink" title="1.用作记录"></a>1.用作记录</h2><ul>
<li>用元组存放记录，元组中的一项对应一个字段的数据，项的位置决定数据的意义。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 洛杉矶国际机场的经纬度。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="number">33.9425</span>, -<span class="number">118.408056</span>)</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">&gt;&gt;&gt;traveler_ids = [(<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;31195855&#x27;</span>), (<span class="string">&#x27;BRA&#x27;</span>, <span class="string">&#x27;CE342567&#x27;</span>),(<span class="string">&#x27;ESP&#x27;</span>, <span class="string">&#x27;XDA205856&#x27;</span>)] </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> passport <span class="keyword">in</span> <span class="built_in">sorted</span>(traveler_ids): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s/%s&#x27;</span> % passport)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> country, _ <span class="keyword">in</span> traveler_ids:  ❻ </span><br><span class="line">        <span class="built_in">print</span>(country) </span><br></pre></td></tr></table></figure>
<ul>
<li>% 格式化运算符理解元组结构，把每一项当作不同的字段。</li>
<li>for 循环知道如何获取元组中单独的每一项，这叫**“元组拆包”**。这里对第二项不感兴趣，把它赋值给虚拟变量。</li>
</ul>
<h2 id="2-用作不可变列表"><a href="#2-用作不可变列表" class="headerlink" title="2.用作不可变列表"></a>2.用作不可变列表</h2><h3 id="（1）好处"><a href="#（1）好处" class="headerlink" title="（1）好处"></a>（1）好处</h3><p>1.意图清晰：只要在源码中见到元组，就知道它的长度永不可变。<br>2.性能优越：长度相同的元组和列表，元组占用的内存更少，而且 Python 可对<br>元组做些优化。</p>
<h3 id="（2）注意点："><a href="#（2）注意点：" class="headerlink" title="（2）注意点："></a>（2）注意点：</h3><p>元组的不可变性仅针对元组中的引用而言。元组中的<br>引用不可删除、不可替换。倘若引用的是可变对象，改动对象之后，元<br>组的值也会随之变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 b 中的最后一项，b 和 a 不相等了。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">10</span>, <span class="string">&#x27;alpha&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">10</span>, <span class="string">&#x27;alpha&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b </span><br><span class="line"><span class="literal">True</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[-<span class="number">1</span>].append(<span class="number">99</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b </span><br><span class="line"><span class="literal">False</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b </span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;alpha&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">99</span>])</span><br></pre></td></tr></table></figure>

<h2 id="3-列表和元组方法的比较"><a href="#3-列表和元组方法的比较" class="headerlink" title="3.列表和元组方法的比较"></a>3.列表和元组方法的比较</h2><p><img src="/images/2026.1.6_5.png" alt="比较图"><br><img src="/images/2026.1.6_6.png" alt="比较图"></p>
<hr>
<h1 id="四、序列和可迭代对象拆包"><a href="#四、序列和可迭代对象拆包" class="headerlink" title="四、序列和可迭代对象拆包"></a>四、序列和可迭代对象拆包</h1><p><strong>拆包的特点是不用我们自己动手通过索引从序列中提取元素，这样就减少了出错的可能。</strong></p>
<h2 id="1-并行赋值"><a href="#1-并行赋值" class="headerlink" title="1.并行赋值"></a>1.并行赋值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="number">33.9425</span>, -<span class="number">118.408056</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>latitude, longitude = lax_coordinates  <span class="comment"># 拆包 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>latitude </span><br><span class="line"><span class="number">33.9425</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>longitud</span><br></pre></td></tr></table></figure>

<h2 id="2-调用函数时在参数前面加上一个"><a href="#2-调用函数时在参数前面加上一个" class="headerlink" title="2.调用函数时在参数前面加上一个 *"></a>2.调用函数时在参数前面加上一个 *</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">20</span>, <span class="number">8</span>) </span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(*t) </span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder = <span class="built_in">divmod</span>(*t) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder </span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-使用-获取余下的项"><a href="#3-使用-获取余下的项" class="headerlink" title="3.使用 * 获取余下的项"></a>3.使用 * 获取余下的项</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest </span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) </span><br></pre></td></tr></table></figure>
<p><strong>注</strong>： * 前缀只能应用到一个变量上，不过可以是任何位置上的变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = <span class="built_in">range</span>(<span class="number">5</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d </span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*head, b, c, d = <span class="built_in">range</span>(<span class="number">5</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>head, b, c, d </span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-在函数调用和序列字面量中使用-拆包"><a href="#4-在函数调用和序列字面量中使用-拆包" class="headerlink" title="4.在函数调用和序列字面量中使用 * 拆包"></a>4.在函数调用和序列字面量中使用 * 拆包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例1：在函数调用中可以多次使用 *</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b, c, d, *rest</span>): </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b, c, d, rest </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(*[<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, *<span class="built_in">range</span>(<span class="number">4</span>, <span class="number">7</span>)) </span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, (<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例2：定义列表、元组或集合字面量时，使用 *</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span> </span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span>] </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;*<span class="built_in">range</span>(<span class="number">4</span>), <span class="number">4</span>, *(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)&#125; </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-嵌套拆包"><a href="#5-嵌套拆包" class="headerlink" title="5.嵌套拆包"></a>5.嵌套拆包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;nested_tuple = ((<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>), (<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>))</span><br><span class="line">&gt;&gt;&gt;(name1, age1), (name2, age2) = nested_tuple</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="五、序列模式匹配（match-case）"><a href="#五、序列模式匹配（match-case）" class="headerlink" title="五、序列模式匹配（match&#x2F;case）"></a>五、序列模式匹配（match&#x2F;case）</h1><h2 id="1-示例1"><a href="#1-示例1" class="headerlink" title="1.示例1"></a>1.示例1</h2><p><img src="/images/2026.1.6_7.png" alt="图片"><br><img src="/images/2026.1.6_8.png" alt="图片"></p>
<h2 id="2-示例2"><a href="#2-示例2" class="headerlink" title="2.示例2"></a>2.示例2</h2><p><img src="/images/2026.1.6_9.png" alt="图片"><br><img src="/images/2026.1.6_10.png" alt="图片"></p>
<h2 id="3-示例3：as关键字绑定变量"><a href="#3-示例3：as关键字绑定变量" class="headerlink" title="3.示例3：as关键字绑定变量"></a>3.示例3：as关键字绑定变量</h2><p><img src="/images/2026.1.6_11.png" alt="图片"></p>
<h2 id="4-示例4：添加类型信息可以让模式更具体"><a href="#4-示例4：添加类型信息可以让模式更具体" class="headerlink" title="4.示例4：添加类型信息可以让模式更具体"></a>4.示例4：添加类型信息可以让模式更具体</h2><p><img src="/images/2026.1.6_12.png" alt="图片"></p>
<h2 id="5-示例5：-匹配任意数量的项"><a href="#5-示例5：-匹配任意数量的项" class="headerlink" title="5.示例5：*_ 匹配任意数量的项"></a>5.示例5：*_ 匹配任意数量的项</h2><ul>
<li>匹配任何以字符串开头、以嵌套两个浮点数的序列结尾的序列<br><img src="/images/2026.1.6_13.png" alt="图片"></li>
</ul>
<h2 id="6-示例6：if语句"><a href="#6-示例6：if语句" class="headerlink" title="6.示例6：if语句"></a>6.示例6：if语句</h2><p><img src="/images/2026.1.6_14.png" alt="图片"></p>
<hr>
<h1 id="六、切片"><a href="#六、切片" class="headerlink" title="六、切片"></a>六、切片</h1><h2 id="1-为什么切片和区间排除最后一项？"><a href="#1-为什么切片和区间排除最后一项？" class="headerlink" title="1.为什么切片和区间排除最后一项？"></a>1.为什么切片和区间排除最后一项？</h2><p><img src="/images/2026.1.6_15.png" alt="解析"></p>
<h2 id="2-切片对象slice"><a href="#2-切片对象slice" class="headerlink" title="2.切片对象slice"></a>2.切片对象slice</h2><h3 id="（1）seq-start-stop-step-句法-——-指定步距step，让切片操作跳过部分项。步距也可以是负数，反向返回项。"><a href="#（1）seq-start-stop-step-句法-——-指定步距step，让切片操作跳过部分项。步距也可以是负数，反向返回项。" class="headerlink" title="（1）seq[start:stop:step] 句法 ——&gt;指定步距step，让切片操作跳过部分项。步距也可以是负数，反向返回项。"></a>（1）seq[start:stop:step] 句法 ——&gt;指定步距step，让切片操作跳过部分项。步距也可以是负数，反向返回项。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;bicycle&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">3</span>] </span><br><span class="line"><span class="string">&#x27;bye&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">1</span>] </span><br><span class="line"><span class="string">&#x27;elcycib&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">2</span>] </span><br><span class="line"><span class="string">&#x27;eccb&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="（2）命名切片"><a href="#（2）命名切片" class="headerlink" title="（2）命名切片"></a>（2）命名切片</h3><p><img src="/images/2026.1.6_16.png" alt="示例"></p>
<h3 id="（3）多维切片和省略号"><a href="#（3）多维切片和省略号" class="headerlink" title="（3）多维切片和省略号"></a>（3）多维切片和省略号</h3><p><img src="/images/2026.1.6_17.png" alt="图片"><br><img src="/images/2026.1.6_18.png" alt="图片"></p>
<h3 id="（4）为切片赋值"><a href="#（4）为切片赋值" class="headerlink" title="（4）为切片赋值"></a>（4）为切片赋值</h3><p>1.在赋值语句的左侧使用切片表示法，或者作为 del 语句的目标，可以就<br>地移植、切除或以其他方式修改可变序列。<br>2.如果赋值目标是一个切片，则右边必须是一个可迭代对象，即使只有<br>一项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">9</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span>  ❶ </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">TypeError: can only assign an iterable </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h1 id="七、使用-和-处理序列"><a href="#七、使用-和-处理序列" class="headerlink" title="七、使用 + 和 * 处理序列"></a>七、使用 + 和 * 处理序列</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>1.通常，+ 的两个运算对象必须是同一种序列，而且都不可修改，拼接的结果是一个同类型的新序列。<br>2.如果想多次拼接同一个序列，可以乘以一个整数<br>3.+ 和 * 始终创建一个新对象，绝不更改操作数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l * <span class="number">5</span> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="string">&#x27;abcd&#x27;</span> </span><br><span class="line"><span class="string">&#x27;abcdabcdabcdabcdabcd&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<br><img src="/images/2026.1.6_19.png" alt="图片"></p>
<h2 id="2-构建嵌套列表"><a href="#2-构建嵌套列表" class="headerlink" title="2.构建嵌套列表"></a>2.构建嵌套列表</h2><p><img src="/images/2026.1.6_20.png" alt="图片"><br><img src="/images/2026.1.6_21.png" alt="图片"><br><strong>不理解本节所讲的问题或解决方案，没关系——&gt;第 6 章<br>就是为了阐明引用和可变对象的机制和陷阱而编写的。</strong></p>
<h2 id="3-使用增量赋值运算符处理序列"><a href="#3-使用增量赋值运算符处理序列" class="headerlink" title="3.使用增量赋值运算符处理序列"></a>3.使用增量赋值运算符处理序列</h2><p>1.增量赋值运算符 +&#x3D; 和 *&#x3D; 的行为差异较大,<br>2.，本节重点关注增量加法运算符（+&#x3D;），不过相关概念也<br>适用于 * &#x3D; 和其他增量赋值运算符</p>
<h3 id="（1）-运算符"><a href="#（1）-运算符" class="headerlink" title="（1）+&#x3D; 运算符"></a>（1）+&#x3D; 运算符</h3><p>1.背后支持 +&#x3D; 运算符的是特殊方法 __iadd__（就地相加）<br>2.如果没有实现 __iadd__，那么 Python 转而调用 __add__<br><img src="/images/2026.1.6_22.png" alt="图片"></p>
<h3 id="（2）一个-运算符赋值谜题"><a href="#（2）一个-运算符赋值谜题" class="headerlink" title="（2）一个 +&#x3D; 运算符赋值谜题"></a>（2）一个 +&#x3D; 运算符赋值谜题</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109095902220.png"><br>解析：</p>
<ul>
<li>1.如果t实现了“<em>iadd</em>”,则t[2]+&#x3D;[50,60]后，t[2]还是原来对象的引用，故A正确</li>
<li>2.如果t没有实现”<em>iadd</em>“,则t[2]+&#x3D;[50,60]后，t[2]不在是原来对象的引用，违反了”元组中元素引用指向不可变“<ul>
<li><strong>注</strong>：这里的不可变，指”引用的指向“不可变，但引用对象本身可变</li>
</ul>
</li>
</ul>
<h1 id="八、list-sort-与-内置函数sorted"><a href="#八、list-sort-与-内置函数sorted" class="headerlink" title="八、list.sort 与 内置函数sorted"></a>八、list.sort 与 内置函数sorted</h1><p><strong>接收者</strong>：被调用的对象本身<br><strong>注意</strong>：本节所讲的内容大都适用于一般意义上的序列，不仅限于列表和元<br>组。</p>
<h2 id="1-list-sort"><a href="#1-list-sort" class="headerlink" title="1.list.sort"></a>1.list.sort</h2><ul>
<li><strong>“就地排序”列表</strong>：更改接收者本身，不创建副本，返回值为“None”</li>
<li><strong>Python API的一个重要约定</strong>：“就地更改对象”的函数或方法应该<strong>返回None</strong>，让调用者清晰地知道接受者已被更改，没有创建对象<ul>
<li>例如：random.shuffle(s)函数也有类似的行为：就地混洗可变序列s，返回None</li>
</ul>
</li>
<li><strong>“就地更改”的缺点</strong>：不能“级联调用”</li>
</ul>
<h2 id="2-内置函数sorted"><a href="#2-内置函数sorted" class="headerlink" title="2.内置函数sorted"></a>2.内置函数sorted</h2><ul>
<li><strong>返回创建新列表</strong>：接收任何可迭代对象作为参数，包括不可变序列和生成器，时钟返回新创建的列表</li>
<li>可以级联使用</li>
</ul>
<h2 id="3-两者共同的“行为参数”"><a href="#3-两者共同的“行为参数”" class="headerlink" title="3.两者共同的“行为参数”"></a>3.两者共同的“行为参数”</h2><p><strong>list.sort和sort均接受“两个可选的关键字”参数</strong></p>
<h3 id="（1）reverse"><a href="#（1）reverse" class="headerlink" title="（1）reverse"></a>（1）reverse</h3><ul>
<li><strong>值为False</strong>：升序返回项（“默认值”）</li>
<li><strong>值为True</strong>：降序返回项</li>
</ul>
<h3 id="（2）key"><a href="#（2）key" class="headerlink" title="（2）key"></a>（2）key</h3><ul>
<li>一个只接受一个参数的函数 ——&gt; 应用到每一个项上，作为<strong>排序依据</strong>，例如：<ul>
<li>key&#x3D;str.lower：执行不区分大小写排序（str.lower是一个只接受一个参数的函数）</li>
<li>key&#x3D;len：按字符长度排序各个字符串。</li>
<li><strong>key的默认值</strong>：“恒等函数”，即比较项本身</li>
</ul>
</li>
</ul>
<h2 id="4-使用例子"><a href="#4-使用例子" class="headerlink" title="4.使用例子"></a>4.使用例子</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109104257243.png"></p>
<h1 id="九、当列表不适用时"><a href="#九、当列表不适用时" class="headerlink" title="九、当列表不适用时"></a>九、当列表不适用时</h1><p><strong>list 类型简单灵活，不过，针对具体的需求，或许还有更好的选择。</strong></p>
<ul>
<li><strong>数组</strong>：处理上百万个浮点值可以节省大量内存</li>
<li><strong>deque</strong>：处理需要在列表的两端添加和删除项</li>
<li><strong>set</strong>：在较多项数时检查容器中是否存在某一项</li>
</ul>
<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><h3 id="（1）概述-1"><a href="#（1）概述-1" class="headerlink" title="（1）概述"></a>（1）概述</h3><ul>
<li>如果一个列表只包含数值，那么使用 array.array 会更高效</li>
<li>数组支<br>持所有可变序列操作（包括 .pop、.insert 和 .extend）</li>
<li>数组还<br>有快速加载项和保存项的方法，例如 .frombytes 和 .tofile</li>
<li><strong>不允许向数组中添加与指定类型不同的值</strong></li>
</ul>
<h3 id="（2）使用"><a href="#（2）使用" class="headerlink" title="（2）使用"></a>（2）使用</h3><p><strong>创建array 对象时要提供类型代码，它是一个字母，用来确定底层使用什么 C 类型存储数组中各项。</strong></p>
<ul>
<li>例如：类型代码 b 对应 C 语言中的 signed char 类型，即取值范围是 -128~127 的整数</li>
</ul>
<h4 id="示例：创建一个含有-1000-万个随机浮点数的数组，把这些浮点数存入文件，再从文件中读取出来。"><a href="#示例：创建一个含有-1000-万个随机浮点数的数组，把这些浮点数存入文件，再从文件中读取出来。" class="headerlink" title="示例：创建一个含有 1000 万个随机浮点数的数组，把这些浮点数存入文件，再从文件中读取出来。"></a>示例：创建一个含有 1000 万个随机浮点数的数组，把这些浮点数存入文件，再从文件中读取出来。</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109110350348.png"></p>
<p><strong>补充：</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109110106804.png"></p>
<h3 id="（3）list-和-array-的功能对比"><a href="#（3）list-和-array-的功能对比" class="headerlink" title="（3）list 和 array 的功能对比"></a>（3）list 和 array 的功能对比</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112208269.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112226325.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112243893.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112305765.png"><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112416245.png"></p>
<h2 id="2-memoryview"><a href="#2-memoryview" class="headerlink" title="2.memoryview"></a>2.memoryview</h2><h3 id="（1）概述-2"><a href="#（1）概述-2" class="headerlink" title="（1）概述"></a>（1）概述</h3><ul>
<li>memoryview 类是一种<strong>共享内存</strong>的序列类型</li>
<li>memoryview 在数据结构<br>（例如 PIL 图像、SQLite 数据库、NumPy 数组等）之间共享内<br>存，而不是事先复制。这对大型数据集来说非常重要</li>
</ul>
<h3 id="（2）使用示例"><a href="#（2）使用示例" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><p><strong>memoryview.cast 方法</strong>：是改<br>变读写多字节单元的方式，无须移动位。</p>
<h4 id="将同一个-6-字节数组处理为不同的视图，分别以-1×6、2×3-和-3×2-矩阵的视图处理-6-字节内存"><a href="#将同一个-6-字节数组处理为不同的视图，分别以-1×6、2×3-和-3×2-矩阵的视图处理-6-字节内存" class="headerlink" title="&lt;1&gt;将同一个 6 字节数组处理为不同的视图，分别以 1×6、2×3 和 3×2 矩阵的视图处理 6 字节内存"></a>&lt;1&gt;将同一个 6 字节数组处理为不同的视图，分别以 1×6、2×3 和 3×2 矩阵的视图处理 6 字节内存</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> array <span class="keyword">import</span> array </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = array(<span class="string">&#x27;B&#x27;</span>, <span class="built_in">range</span>(<span class="number">6</span>))  <span class="comment"># 创建B类型（1字节无符号字符）的array数组，元素是0-5，共6字节连续内存</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m1 = <span class="built_in">memoryview</span>(octets)  <span class="comment"># 创建octets的内存视图，指向同一块6字节内存，默认一维，格式为&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m1.tolist()  <span class="comment"># 将内存视图转为列表，直观查看数据</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 = m1.cast(<span class="string">&#x27;B&#x27;</span>, [<span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 零拷贝转换：类型仍为&#x27;B&#x27;，形状改为2行3列的二维视图（总元素数2*3=6，与原内存字节数匹配）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2.tolist()  <span class="comment"># 二维视图的展示形式：按2行3列排列原数据</span></span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m3 = m1.cast(<span class="string">&#x27;B&#x27;</span>, [<span class="number">3</span>, <span class="number">2</span>])  <span class="comment"># 零拷贝转换：类型仍为&#x27;B&#x27;，形状改为3行2列的二维视图（总元素数3*2=6，匹配原内存字节数）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m3.tolist()  <span class="comment"># 二维视图的展示形式：按3行2列排列原数据</span></span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2[<span class="number">1</span>,<span class="number">1</span>] = <span class="number">22</span>  <span class="comment"># 修改m2视图中「第2行第2列」的元素（对应原内存第4个字节，原数值4），赋值22</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m3[<span class="number">1</span>,<span class="number">1</span>] = <span class="number">33</span>  <span class="comment"># 修改m3视图中「第2行第2列」的元素（对应原内存第3个字节，原数值3），赋值33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets  <span class="comment"># 原array数组被同步修改（所有视图指向同一块内存），最终元素为[0,1,2,33,22,5]</span></span><br><span class="line">array(<span class="string">&#x27;B&#x27;</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<h4 id="修改一个-16-位整数数组中某一项的字节，改变该项的值"><a href="#修改一个-16-位整数数组中某一项的字节，改变该项的值" class="headerlink" title="&lt;2&gt;　修改一个 16 位整数数组中某一项的字节，改变该项的值"></a>&lt;2&gt;　修改一个 16 位整数数组中某一项的字节，改变该项的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># 创建array数组：类型码&#x27;h&#x27;对应C的signed short</span></span><br><span class="line"><span class="comment"># 元素为5个整数，总内存5×2=10字节</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv = <span class="built_in">memoryview</span>(numbers)  <span class="comment"># 生成numbers的内存视图memv，指向同一块10字节连续内存，默认格式为&#x27;h&#x27;（2字节短整型）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(memv)  <span class="comment"># 查看内存视图的元素个数（按&#x27;h&#x27;类型解读，10字节÷2字节/个=5个）</span></span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv[<span class="number">0</span>] <span class="comment"># 按&#x27;h&#x27;类型读取第0个元素，即原数组的第一个元素-2</span></span><br><span class="line">-<span class="number">2</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct = memv.cast(<span class="string">&#x27;B&#x27;</span>) <span class="comment"># 零拷贝转换：将视图格式转为&#x27;B&#x27;（1字节无符号字符），原10字节内存被拆分为10个1字节元素解读</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct.tolist() <span class="comment"># 按1字节无符号字符展示所有内存：这里是短整型的补码存储（小端序，低字节在前）</span></span><br><span class="line"><span class="comment"># 对应关系（每个短整型拆为2个字节）：</span></span><br><span class="line"><span class="comment"># -2 → 补码0xFFFE → 小端序存储为[254, 255]；-1 → 补码0xFFFF → [255, 255]；0 → 0x0000 → [0, 0]；</span></span><br><span class="line"><span class="comment">#1 → 0x0001 → [1, 0]；2 → 0x0002 → [2, 0]</span></span><br><span class="line">[<span class="number">254</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct[<span class="number">5</span>] = <span class="number">4</span> <span class="comment"># 修改第5个1字节元素（索引从0开始）：原第5个字节是0（对应原数组第2个元素0的高字节），改为4</span></span><br><span class="line"><span class="comment"># 关键：原数组第2个元素（索引2）是0，对应内存为第4、5字节（索引4=0，索引5=0）；修改索引5为4后，该元素的内存变为[0, 4]（小端序→实际是0x0400）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers  <span class="comment"># 查看原数组：第2个元素从0变为0x0400对应的十进制数1024，其他元素因内存未被修改保持不变</span></span><br><span class="line">array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1024</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<h2 id="3-Numpy"><a href="#3-Numpy" class="headerlink" title="3.Numpy"></a>3.Numpy</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="(1)概述"></a>(1)概述</h3><ul>
<li>科学计算经常需要做一些高级数组和矩阵运算，得益于 NumPy，Python成为这一领域的主流语言</li>
<li><strong>NumPy</strong> 实现了多维同构数组和矩阵类型，除了存放数值之外，还可以存放用户定义的记录，而且提供了高效的元素层面操作</li>
<li>在 NumPy 基础之上编写的 <strong>SciPy</strong> 库提供了许多科学计算算法，从线性代数到数值微积分和统计学，不一而足。</li>
</ul>
<h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="(2)使用示例"></a>(2)使用示例</h3><h4 id="NumPy对二维数组做一些基本操作"><a href="#NumPy对二维数组做一些基本操作" class="headerlink" title="&lt;1&gt;NumPy对二维数组做一些基本操作"></a>&lt;1&gt;NumPy对二维数组做一些基本操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># 导入numpy库并简写为np（numpy常规用法，方便后续调用）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)  <span class="comment"># 生成0-11的连续整数数组，默认是1维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a </span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a) </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;  <span class="comment"># 查看类型，确认是numpy的数组类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape  <span class="comment"># 查看数组形状：(12,) 表示1维数组，共12个元素</span></span><br><span class="line">(<span class="number">12</span>,) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape = <span class="number">3</span>, <span class="number">4</span>  <span class="comment"># 调整数组形状为3行4列的2维数组（不改变数据，仅改变解读维度）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>], </span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>], </span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>]  <span class="comment"># 取第3行（索引从0开始）的所有元素</span></span><br><span class="line">array([ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>, <span class="number">1</span>]  <span class="comment"># 取第3行第2列的元素（行索引2，列索引1）</span></span><br><span class="line"><span class="number">9</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:, <span class="number">1</span>]  <span class="comment"># 取所有行（:表示全部）的第2列元素</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.transpose()  <span class="comment"># 数组转置（行变列、列变行），3行4列转为4行3列</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>], </span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>], </span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">6</span>, <span class="number">10</span>], </span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">7</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>

<h4 id="NumPy的一些高级操作"><a href="#NumPy的一些高级操作" class="headerlink" title="&lt;2&gt;NumPy的一些高级操作"></a>&lt;2&gt;NumPy的一些高级操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy  <span class="comment"># 导入numpy库（未简写，直接用库名调用）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats = numpy.loadtxt(<span class="string">&#x27;floats-10M-lines.txt&#x27;</span>)  <span class="comment"># 从文本文件读取1000万行浮点数，加载为numpy数组（注意：文本读取速度较慢，适合小/中型数据）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats[-<span class="number">3</span>:]  <span class="comment"># 查看数组最后3个元素（验证数据加载正常）</span></span><br><span class="line">array([ <span class="number">3016362.69195522</span>,   <span class="number">535281.10514262</span>,  <span class="number">4566560.44373946</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats *= <span class="number">.5</span>  <span class="comment"># 数组所有元素原地乘以0.5（numpy广播机制，无需循环，效率高）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats[-<span class="number">3</span>:]  <span class="comment"># 再次查看最后3个元素，确认修改生效</span></span><br><span class="line">array([ <span class="number">1508181.34597761</span>,   <span class="number">267640.55257131</span>,  <span class="number">2283280.22186973</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> time <span class="keyword">import</span> perf_counter <span class="keyword">as</span> pc <span class="comment"># 从time模块导入高精度计时器perf_counter，简写为pc（方便计时）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t0 = pc(); floats /= <span class="number">3</span>; pc() - t0 <span class="comment"># 计时：计算数组所有元素原地除以3的耗时，输出耗时（numpy数组运算比Python原生循环快得多）</span></span><br><span class="line"><span class="number">0.03690556302899495</span>  <span class="comment"># 输出结果：耗时约0.037秒（处理1000万浮点数，体现numpy高效性）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numpy.save(<span class="string">&#x27;floats-10M&#x27;</span>, floats)  <span class="comment"># 将数组以numpy专用二进制格式（.npy）保存到文件（二进制格式读写快、占用空间小，适合大数据）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2 = numpy.load(<span class="string">&#x27;floats-10M.npy&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>)  <span class="comment"># 以读写模式（r+）加载.npy文件，返回memmap（内存映射）对象（无需将整个大数据载入内存，节省内存）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2 *= <span class="number">6</span>  <span class="comment"># 对memmap对象原地乘以6（直接操作磁盘文件中的数据，不占大量内存）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2[-<span class="number">3</span>:]  <span class="comment"># 查看memmap对象最后3个元素，验证修改生效（memmap对象用法与numpy数组一致）</span></span><br><span class="line">memmap([ <span class="number">3016362.69195522</span>,   <span class="number">535281.10514262</span>,  <span class="number">4566560.44373946</span>])</span><br></pre></td></tr></table></figure>

<h2 id="4-deque-双端队列"><a href="#4-deque-双端队列" class="headerlink" title="4.deque(双端队列)"></a>4.deque(双端队列)</h2><h3 id="（1）概述-3"><a href="#（1）概述-3" class="headerlink" title="（1）概述"></a>（1）概述</h3><ul>
<li>collections.deque 类实现一种<strong>线程安全的双端队列</strong>，旨在快速在两端插入和删除项。</li>
<li><strong>deque对象可以有界</strong>，即长度固定 ——&gt; 对象填满之后，从一端添加新项，将从另一端丢弃一项。</li>
</ul>
<h3 id="（2）使用示例-1"><a href="#（2）使用示例-1" class="headerlink" title="（2）使用示例"></a>（2）使用示例</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109115841494.png"></p>
<h3 id="（3）list-和-deque-实现的方法对比"><a href="#（3）list-和-deque-实现的方法对比" class="headerlink" title="（3）list 和 deque 实现的方法对比"></a>（3）list 和 deque 实现的方法对比</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109120042686.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109120103430.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109120124149.png"></p>
<h3 id="（4）Python-标准库中的其他包中的队列"><a href="#（4）Python-标准库中的其他包中的队列" class="headerlink" title="（4）Python 标准库中的其他包中的队列"></a>（4）Python 标准库中的其他包中的队列</h3><h4 id="queue包"><a href="#queue包" class="headerlink" title="&lt;1&gt;queue包"></a>&lt;1&gt;queue包</h4><ul>
<li><strong>队列类</strong>：SimpleQueue、Queue、LifoQueue 和 PriorityQueue。<ul>
<li>这些类都是<strong>线程安全</strong>的，可在线程之间安全通信</li>
</ul>
</li>
<li>除SimpleQueue 之外，其他几个类都可以有界 ——&gt; 为构造函数提供maxsize 参数，设为大于 0 的值。</li>
<li><strong>与deque的区别</strong>：不像 deque 那样为了腾出空间而把项丢弃，而是在<strong>队列填满后阻塞插入新项</strong>，等待其他线程从队列中取出一项。<ul>
<li>利用这种行为可以限制活动线程的数量。</li>
</ul>
</li>
</ul>
<h4 id="multiprocessing包"><a href="#multiprocessing包" class="headerlink" title="&lt;2&gt;multiprocessing包"></a>&lt;2&gt;multiprocessing包</h4><ul>
<li><strong>队列类</strong>：无界的 SimpleQueue 和有界的 Queue<ul>
<li>这与 queue包中的队列类非常相似，只不过专门针对进程间通信</li>
</ul>
</li>
<li>为任务管理提供了专用的 multiprocessing.JoinableQueue。</li>
</ul>
<h4 id="asyncio"><a href="#asyncio" class="headerlink" title="&lt;3&gt;asyncio"></a>&lt;3&gt;asyncio</h4><ul>
<li><strong>队列类</strong>：Queue、LifoQueue、PriorityQueue 和 JoinableQueue</li>
<li>API 源自 queue 和 multiprocessing 模块中的类，不过为管理异步编程任务而做了修改。</li>
</ul>
<h4 id="heapq"><a href="#heapq" class="headerlink" title="&lt;4&gt;heapq"></a>&lt;4&gt;heapq</h4><ul>
<li><strong>队列类</strong>：没有实现任何队列类</li>
<li><strong>功能</strong>：提供了heappush 和 heappop 等函数，可把可变序列当作<strong>堆队列</strong>或<strong>优先级队列</strong>使用。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>《流畅的python》</category>
        <category>第2章 丰富的序列</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章：字典和集合</title>
    <url>/2026/01/09/Python/%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84python%E3%80%8B/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="三、映射类型标准-API"><a href="#三、映射类型标准-API" class="headerlink" title="三、映射类型标准 API"></a>三、映射类型标准 API</h1><p><strong>这里最先提，方便熟悉后查询</strong></p>
<h2 id="1-常用映射方法概述"><a href="#1-常用映射方法概述" class="headerlink" title="1.常用映射方法概述"></a>1.常用映射方法概述</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109172728193.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109172753032.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109172812129.png"></p>
<h2 id="2-插入或更新可变的值（dict-setdefault方法）"><a href="#2-插入或更新可变的值（dict-setdefault方法）" class="headerlink" title="2.插入或更新可变的值（dict.setdefault方法）"></a>2.插入或更新可变的值（dict.setdefault方法）</h2><h3 id="（1）处理缺少键的常用方法"><a href="#（1）处理缺少键的常用方法" class="headerlink" title="（1）处理缺少键的常用方法"></a>（1）处理缺少键的常用方法</h3><ul>
<li><strong>抛出错误</strong>：根据 Python 的“快速失败”原则，当键 k 不存在时，d[k] 抛出错误。</li>
<li><strong>设置默认值</strong>：如果觉得默认值比抛出 KeyError 更好，那么可以把 d[k] 换成 <strong>d.get(k, default)</strong></li>
</ul>
<p><strong>然而，如果你想更新得到的可变值，那么还有更好的方法。</strong></p>
<h3 id="（2）代码示例"><a href="#（2）代码示例" class="headerlink" title="（2）代码示例"></a>（2）代码示例</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109174026857.png"><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109174123769.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109174153949.png"><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109174309417.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109174349353.png"></p>
<h1 id="一、字典的现代句法"><a href="#一、字典的现代句法" class="headerlink" title="一、字典的现代句法"></a>一、字典的现代句法</h1><h2 id="1-字典推导式"><a href="#1-字典推导式" class="headerlink" title="1.字典推导式"></a>1.字典推导式</h2><h3 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li><strong>功能</strong>：从任何可迭代对象中获取键值对，构建 dict 实例。</li>
<li><strong>来历</strong>：由列表推导式和生成器表达式改造而来</li>
</ul>
<h3 id="（2）基础语法结构"><a href="#（2）基础语法结构" class="headerlink" title="（2）基础语法结构"></a>（2）基础语法结构</h3><h4 id="语法结构：-key-expression-value-expression-for-item-in-iterable-if-condition"><a href="#语法结构：-key-expression-value-expression-for-item-in-iterable-if-condition" class="headerlink" title="&lt;1&gt;语法结构：{key_expression: value_expression for item in iterable [if condition]}"></a>&lt;1&gt;语法结构：{key_expression: value_expression for item in iterable [if condition]}</h4><ul>
<li><strong>key_expression: 用于生成字典的键</strong></li>
<li><strong>value_expression: 用于生成字典的值</strong></li>
<li><strong>for item in iterable: 迭代数据源</strong></li>
<li><strong>if condition: 可选的过滤条件</strong></li>
</ul>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><h5 id="示例-1：最简字典推导式（遍历生成）"><a href="#示例-1：最简字典推导式（遍历生成）" class="headerlink" title="示例 1：最简字典推导式（遍历生成）"></a>示例 1：最简字典推导式（遍历生成）</h5><ul>
<li><strong>只保留长度大于 5 的单词</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>]</span><br><span class="line"><span class="comment"># 条件：只保留长度&gt;5的键值对</span></span><br><span class="line">word_len_filter = &#123;word: <span class="built_in">len</span>(word) <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">if</span> <span class="built_in">len</span>(word) &gt; <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(word_len_filter)</span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;banana&#x27;: 6, &#x27;cherry&#x27;: 6&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="示例-2：遍历两个可迭代对象（zip-配合）"><a href="#示例-2：遍历两个可迭代对象（zip-配合）" class="headerlink" title="示例 2：遍历两个可迭代对象（zip 配合）"></a>示例 2：遍历两个可迭代对象（zip 配合）</h5><ul>
<li><strong>用 zip 配对两个列表，分别作为 key 和 value</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 遍历zip后的配对数据</span></span><br><span class="line">my_dict = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values)&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_dict)</span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>zip( *iterables)</strong>：用于将多个可迭代对象（列表、元组等）“打包” 成一个迭代器</p>
<ul>
<li>*iterables：一个或多个可迭代对象（列表、元组、字符串、字典等）；</li>
<li>返回值：zip 对象（迭代器），<strong>可通过 list()&#x2F;dict() 转换为列表 &#x2F; 字典，或直接遍历</strong>。</li>
</ul>
<h5 id="示例-3：对原字典做转换"><a href="#示例-3：对原字典做转换" class="headerlink" title="示例 3：对原字典做转换"></a>示例 3：对原字典做转换</h5><ul>
<li><strong>修改原字典的键 &#x2F; 值（如将 value 翻倍）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">original = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 推导式修改value</span></span><br><span class="line">new_dict = &#123;k: v*<span class="number">2</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> original.items()&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(new_dict)</span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 4, &#x27;c&#x27;: 6&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="关键注意事项！"><a href="#关键注意事项！" class="headerlink" title="关键注意事项！"></a>关键注意事项！</h5><p>1.<strong>键必须唯一</strong>：如果推导式生成重复的 key，后出现的会覆盖先出现的<br>2.<strong>可迭代对象的遍历</strong>:遍历字典时需用items()获取键值对，而非直接遍历（直接遍历字典默认只取 key）<br>3.<strong>简化 vs 可读性</strong>：推导式适合简单逻辑，复杂逻辑（多条件 &#x2F; 多运算）建议用普通循环，避免可读性差。</p>
<h2 id="2-映射拆包（-）"><a href="#2-映射拆包（-）" class="headerlink" title="2.映射拆包（**）"></a>2.映射拆包（**）</h2><h3 id="（1）演示代码"><a href="#（1）演示代码" class="headerlink" title="（1）演示代码"></a>（1）演示代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数：**kwargs 会收集所有传入的关键字参数，打包成字典返回</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">**kwargs</span>): </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> kwargs  <span class="comment"># 返回收集到的关键字参数字典</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数：混合使用两次字典解包（**）+ 直接关键字参数（y=2）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dump(**&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;, y=<span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;) </span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;  <span class="comment"># 最终所有参数被合并为一个字典</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）代码解析"><a href="#（2）代码解析" class="headerlink" title="（2）代码解析"></a>（2）代码解析</h3><h4 id="kwargs：关键字参数收集"><a href="#kwargs：关键字参数收集" class="headerlink" title="&lt;1&gt;**kwargs：关键字参数收集"></a>&lt;1&gt;**kwargs：关键字参数收集</h4><ul>
<li><strong>作用</strong>：函数定义时，**kwargs 是 <strong>「关键字参数收集器」</strong>，会把调用时传入的所有关键字参数（如 y&#x3D;2）、以及通过 <strong>**解包</strong> 传入的字典键值对，统一收集成一个字典。</li>
<li><strong>规则</strong>：<ul>
<li>kwargs 只是约定俗成的变量名，可换成任意合法名称（如 **params），但行业惯例用kwargs（keyword arguments）；</li>
<li><strong>必须放在函数参数列表的最后</strong>（否则语法报错）；</li>
<li><strong>只会收集「未被显式定义的关键字参数」</strong>。</li>
</ul>
</li>
</ul>
<h4 id="函数调用中的-：字典解包传参"><a href="#函数调用中的-：字典解包传参" class="headerlink" title="&lt;2&gt;函数调用中的 **：字典解包传参"></a>&lt;2&gt;函数调用中的 **：字典解包传参</h4><ul>
<li><strong>作用</strong>：调用函数时，<em><strong>**字典</strong></em> 会把字典的 <strong>「键值对」解包为「关键字参数」</strong>（如 **{‘x’:1} 等价于 x&#x3D;1）。</li>
<li><strong>关键规则</strong>：<ul>
<li>Python 3.5+ <strong>支持多次解包</strong>（如示例中 **{‘x’:1} + **{‘z’:3}），且可和直接的关键字参数（y&#x3D;2\）混合使用；</li>
<li>解包后的键必须是<strong>字符串类型</strong>：因为关键字参数名本质是字符串；</li>
<li>若解包 &#x2F; 直接传参出现<strong>重复键</strong>，后传入的会<strong>覆盖</strong>先传入的（如 dump(**{‘x’:1}, x&#x3D;10) → {‘x’:10}）;</li>
</ul>
</li>
</ul>
<h4 id="执行过程拆解（从调用到返回）"><a href="#执行过程拆解（从调用到返回）" class="headerlink" title="&lt;3&gt;执行过程拆解（从调用到返回）"></a>&lt;3&gt;执行过程拆解（从调用到返回）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">调用 dump(**&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>&#125;, y=<span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;) 的步骤：</span><br><span class="line"><span class="number">1.</span> 解包第一个字典：**&#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>&#125; → 转为关键字参数 x=<span class="number">1</span>；</span><br><span class="line"><span class="number">2.</span> 保留直接传入的关键字参数：y=<span class="number">2</span>；</span><br><span class="line"><span class="number">3.</span> 解包第二个字典：**&#123;<span class="string">&#x27;z&#x27;</span>:<span class="number">3</span>&#125; → 转为关键字参数 z=<span class="number">3</span>；</span><br><span class="line"><span class="number">4.</span> 函数内的 **kwargs 收集所有关键字参数 → 合并为 &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>:<span class="number">3</span>&#125;；</span><br><span class="line"><span class="number">5.</span> 函数返回这个合并后的字典。</span><br></pre></td></tr></table></figure>

<h2 id="3-使用-合并映射"><a href="#3-使用-合并映射" class="headerlink" title="3.使用 | 合并映射"></a>3.使用 | 合并映射</h2><p><strong>Python 3.9 支持使用 | 和 |&#x3D; 合并映射。这不难理解，因为二者也是<br>并集运算符。</strong></p>
<h3 id="（1）-运算符创建一个新映射"><a href="#（1）-运算符创建一个新映射" class="headerlink" title="（1）| 运算符创建一个新映射"></a>（1）| 运算符创建一个新映射</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109170521809.png"></p>
<ul>
<li>“键”相同时，后者覆盖前者</li>
</ul>
<h3 id="（2）-运算符就地更新现有映射"><a href="#（2）-运算符就地更新现有映射" class="headerlink" title="（2）|&#x3D; 运算符就地更新现有映射"></a>（2）|&#x3D; 运算符就地更新现有映射</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109170630056.png"></p>
<hr>
<h1 id="二、使用模式匹配处理映射"><a href="#二、使用模式匹配处理映射" class="headerlink" title="二、使用模式匹配处理映射"></a>二、使用模式匹配处理映射</h1><p><strong>模式匹配是一种强大的工具：不同类型的模式可以组合和嵌套来进行匹配</strong></p>
<h2 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109171401376.png"></p>
<ul>
<li><strong>模式中键的顺序无关紧要</strong><ul>
<li>即使 b2 是一个 OrderedDict，也能作为匹配对象。</li>
</ul>
</li>
<li><strong>就算只有部分匹配，映射模式也算成功匹配（即可以是”超集”）</strong><ul>
<li>在上述doctest 中，b1 和 b2 两个匹配对象中都有 ‘title’ 键，尽管任何’book’ 模式中都没有这个键，但依然可以匹配。</li>
</ul>
</li>
<li><strong>没有必要使用 **extra 匹配多出的键值对</strong><ul>
<li>倘若你想把多出的键值对捕获到一个 dict 中，可以在一个变量前面加上 **，不过<strong>必须放在模式最后</strong>。</li>
</ul>
</li>
<li><strong>**_ 是无效的，纯属画蛇添足</strong></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>《流畅的python》</category>
        <category>第3章 Python数据模型</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置VPN代理（解决github连接问题）</title>
    <url>/2026/01/12/Linux/Linux%E7%9A%84%E4%BD%BF%E7%94%A8/Linux%E8%AE%BE%E7%BD%AEVPN%E4%BB%A3%E7%90%86%EF%BC%88%E8%A7%A3%E5%86%B3github%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-前提要求：宿主机上需要有VPN"><a href="#1-前提要求：宿主机上需要有VPN" class="headerlink" title="1.前提要求：宿主机上需要有VPN"></a>1.前提要求：宿主机上需要有VPN</h2><h2 id="2-设置临时代理步骤"><a href="#2-设置临时代理步骤" class="headerlink" title="2.设置临时代理步骤"></a>2.设置临时代理步骤</h2><h4 id="（1）（虚拟机）通过-ifconfig-命令查看虚拟机的IP，确定局域网网关，如下："><a href="#（1）（虚拟机）通过-ifconfig-命令查看虚拟机的IP，确定局域网网关，如下：" class="headerlink" title="（1）（虚拟机）通过 ifconfig 命令查看虚拟机的IP，确定局域网网关，如下："></a>（1）（虚拟机）通过 ifconfig 命令查看虚拟机的IP，确定局域网网关，如下：</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260112165452726.png"></p>
<ul>
<li><strong>网关为：192.168.36.1 （即“最后一位”为 1）</strong></li>
</ul>
<h4 id="（2）（宿主机）打开VPN连接，并开启“允许局域网连接”，如下："><a href="#（2）（宿主机）打开VPN连接，并开启“允许局域网连接”，如下：" class="headerlink" title="（2）（宿主机）打开VPN连接，并开启“允许局域网连接”，如下："></a>（2）（宿主机）打开VPN连接，并开启“允许局域网连接”，如下：</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260112165739343.png"></p>
<h4 id="（3）（虚拟机）设置“临时代理”，并进行测试，如下："><a href="#（3）（虚拟机）设置“临时代理”，并进行测试，如下：" class="headerlink" title="（3）（虚拟机）设置“临时代理”，并进行测试，如下："></a>（3）（虚拟机）设置“临时代理”，并进行测试，如下：</h4><ul>
<li>以上面我的网关 192.168.36.1为例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设代理端口是 7890（通常都是）</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://192.168.36.1:7890</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://192.168.36.1:7890</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">curl -I https://github.com</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>：Clash for Windows 查看代理端口<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260112170039920.png"></p>
<h3 id="3-备选方案"><a href="#3-备选方案" class="headerlink" title="3.备选方案"></a>3.备选方案</h3><p>如果配置后还是不行，可以：<strong>使用SSH 克隆（绕过 HTTPS）</strong></p>
<ul>
<li>需要先配置 SSH key</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/HowardHinnant/date.git <span class="comment"># 失败</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:HowardHinnant/date.git <span class="comment"># 成功</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux的使用</category>
        <category>Linux设置VPN代理（解决github连接问题）</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sysctl 与 systemctl</title>
    <url>/2026/01/13/Linux/Linux%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/sysctl%E4%B8%8Esystemctl/</url>
    <content><![CDATA[<h1 id="1-sysctl-与-systemctl"><a href="#1-sysctl-与-systemctl" class="headerlink" title="1.sysctl 与 systemctl"></a>1.sysctl 与 systemctl</h1><p>sysctl 和 systemctl 是 Linux 系统中功能完全不同的两个工具，核心区别在于<strong>管理对象</strong>和<strong>作用场景</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113105938893.png"></p>
<p><strong>作用层面</strong>：</p>
<ul>
<li>sysctl 作用于 <strong>内核层</strong>：<ul>
<li>修改的是内核运行时的参数，影响整个系统的底层行为（比如网络协议栈、内存管理）。</li>
</ul>
</li>
<li>systemctl 作用于 <strong>用户层&#x2F;服务层</strong>：<ul>
<li>管理的是用户态的服务进程，不涉及内核参数的调整。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux系统工具</category>
        <category>sysctl 与 systemctl</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章 观测工具</title>
    <url>/2026/01/06/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E3%80%8A%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E3%80%8B/%E7%AC%AC4%E7%AB%A0-%E8%A7%82%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="工具类型"><a href="#工具类型" class="headerlink" title="工具类型"></a>工具类型</h1><p><strong>概述：性能观测工具可以按照“系统级别”和“进程级别”来分类，多数的工具要么基于“计数器”要么基于“跟踪”</strong><br><img src="/images/2026.1.6-1.png" alt="图片"></p>
<ul>
<li>有些工具不只适用于一个象限，例如，top(1)还有一个系统级别的视图，DTrace也有进程级别的能力。</li>
</ul>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>1.内核维护了各种统计数据，称为“计数器”，用于对事件计数。<br>2.计数器的使用可以认为是“零开销”的，因为它们默认是开启的，而且始终由内核维护。<br><img src="/images/2026.1.6-2.png" alt="图片1"><img src="/images/2026.1.6-3.png" alt="图片2"></p>
<p><strong>一般来说，上述这些工具是从&#x2F;proc文件系统里读取统计信息的</strong></p>
<h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><p>1.跟踪收集每一个时间的数据以供分析。<br>2.跟踪框架一般默认是不启用的，因为跟踪捕获数据会有CPU开销，另外还需要不小的存储空间来存放数据。<br>3.这些开销会拖慢所跟踪的对象，在解释测量时间的时候需要加以考虑。<br>4.日志，包括系统日志，可以认为是一种默认开启的低频跟踪。<br><img src="/images/2026.1.6-4.png" alt="图片"><img src="/images/2026.1.6-5.png" alt="图片"></p>
<h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>1.剖析（profiling）通过对目标收集采样或快照来归纳目标特征</p>
<ul>
<li>如对于CPU的使用率，对程序计数器采样，或跟踪来找到消耗CPU周期的代码路径。这些样本采集对于所有的CPU都是按福鼎频率进行的</li>
</ul>
<p>2.剖析也能基于非计时的硬件时间</p>
<ul>
<li>如CPU硬件缓存未命中或者总线活动</li>
<li>可以显示出哪行代码路径负责任，这类信息尤其可以帮助开发人员针对系统资源的使用来优化自己的代码</li>
</ul>
<p><img src="/images/2026.1.6-6.png" alt="图片"></p>
<h2 id="监视（sar）"><a href="#监视（sar）" class="headerlink" title="监视（sar）"></a>监视（sar）</h2><p>1.最广泛用于监视单一操作系统的工具是star(1)。<br>2.sar(1)是基于计数器的，在预定的时间（通过cron）执行以记录系统计数器的状态<br>3.sar(1)工具支持用命令行来查看这些数据<br><img src="/images/2026.1.6-7.png" alt="图片"></p>
<hr>
<h1 id="观测来源"><a href="#观测来源" class="headerlink" title="观测来源"></a>观测来源</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>1.本节介绍给观测工具提供统计数据的各种接口和框架<br>2.系统性能统计的主要来源是：&#x2F;proc、&#x2F;sys、&#x2F;kstat<br><img src="/images/2026.1.6-8.png" alt="图片"></p>
<h2 id="proc"><a href="#proc" class="headerlink" title="&#x2F;proc"></a>&#x2F;proc</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>1.这是一个提供内核统计信息的文件系统接口<br>2.其中<strong>以进程ID命名的目录代表的就是哪个进程</strong><br>3.这些目录下的众多文件包含了进程的信息和统计数据，由内核结构映射而来<br>4.&#x2F;proc是多态创建的，不需要任何存储设备（在内存中运行）。<br>5.多数文件是只读的，为观测工具提供统计数据；一部分文件是可写的，用于控制进程和内核的行为<br><img src="/images/2026.1.6-9.png" alt="图片"></p>
]]></content>
      <categories>
        <category>《性能之巅》</category>
        <category>第4章 观测工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP KeepAlive 心跳机制</title>
    <url>/2026/01/13/Linux/TCP_IP%E7%9B%B8%E5%85%B3/TCP%20KeepAlive%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1-机制原理"><a href="#1-机制原理" class="headerlink" title="1.机制原理"></a>1.机制原理</h2><p>TCP KeepAlive 是 <strong>操作系统内核层面</strong> 的连接保活机制，用于检测长时间空闲的 TCP 连接是否仍然有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    TCP KeepAlive 工作原理                        │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│   连接空闲                 开始探测                 判定结果      │</span><br><span class="line">│      │                       │                       │          │</span><br><span class="line">│      ▼                       ▼                       ▼          │</span><br><span class="line">│  ┌───────┐    超时后    ┌───────┐   连续失败    ┌───────┐       │</span><br><span class="line">│  │ IDLE  │───────────▶│ PROBE │─────────────▶│ DEAD  │       │</span><br><span class="line">│  └───────┘             └───────┘              └───────┘       │</span><br><span class="line">│      │                     │                                   │</span><br><span class="line">│      │                     │ 收到 ACK                          │</span><br><span class="line">│      │◀────────────────────┘                                   │</span><br><span class="line">│   重置计时器                                                    │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>时间线详解</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间轴 ════════════════════════════════════════════════════════════════▶</span><br><span class="line"></span><br><span class="line">[最后一次数据交互]</span><br><span class="line">        │</span><br><span class="line">        │◀══════════ tcp_keepalive_time ══════════▶│</span><br><span class="line">        │                 7200 秒                   │</span><br><span class="line">        │              (连接空闲)                   │</span><br><span class="line">        │                                          │</span><br><span class="line">        │                                          ▼</span><br><span class="line">        │                                    ┌──────────┐</span><br><span class="line">        │                                    │ 发送探测 │</span><br><span class="line">        │                                    │  包 #1   │</span><br><span class="line">        │                                    └────┬─────┘</span><br><span class="line">        │                                         │</span><br><span class="line">        │                         ┌───────────────┴───────────────┐</span><br><span class="line">        │                         ▼                               ▼</span><br><span class="line">        │                    收到 ACK                         无响应</span><br><span class="line">        │                        │                               │</span><br><span class="line">        │                        ▼                               ▼</span><br><span class="line">        │               重置计时器，回到                  等待 75 秒</span><br><span class="line">        │               空闲等待状态                    (tcp_keepalive_intvl)</span><br><span class="line">        │                                                        │</span><br><span class="line">        │                                                        ▼</span><br><span class="line">        │                                                  ┌──────────┐</span><br><span class="line">        │                                                  │ 发送探测 │</span><br><span class="line">        │                                                  │  包 #2   │</span><br><span class="line">        │                                                  └────┬─────┘</span><br><span class="line">        │                                                       │</span><br><span class="line">        │                                          ... 重复最多 9 次 ...</span><br><span class="line">        │                                                       │</span><br><span class="line">        │                                                       ▼</span><br><span class="line">        │                                              ┌─────────────────┐</span><br><span class="line">        │                                              │ 连续 9 次无响应  │</span><br><span class="line">        │                                              │ 判定连接死亡     │</span><br><span class="line">        │                                              │ 内核关闭 socket  │</span><br><span class="line">        │                                              └─────────────────┘</span><br><span class="line"></span><br><span class="line">总检测时间 = 7200 + (75 × 9) = 7875 秒 ≈ 2小时11分钟</span><br></pre></td></tr></table></figure>



<h2 id="2-核心参数-与-相关配置"><a href="#2-核心参数-与-相关配置" class="headerlink" title="2.核心参数 与 相关配置"></a>2.核心参数 与 相关配置</h2><h3 id="（1）三个核心参数"><a href="#（1）三个核心参数" class="headerlink" title="（1）三个核心参数"></a>（1）三个核心参数</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113104040724.png"></p>
<h3 id="（2）查看当前系统参数"><a href="#（2）查看当前系统参数" class="headerlink" title="（2）查看当前系统参数"></a>（2）查看当前系统参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统参数</span></span><br><span class="line">sysctl net.ipv4.tcp_keepalive_time</span><br><span class="line">sysctl net.ipv4.tcp_keepalive_intvl</span><br><span class="line">sysctl net.ipv4.tcp_keepalive_probes</span><br></pre></td></tr></table></figure>
<a href="/2026/01/13/Linux/Linux%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/sysctl%E4%B8%8Esystemctl/" title="sysctl 与 systemctl">sysctl介绍</a>

<h3 id="（3）参数配置（系统级）"><a href="#（3）参数配置（系统级）" class="headerlink" title="（3）参数配置（系统级）"></a>（3）参数配置（系统级）</h3><h4 id="临时修改（重启失效）"><a href="#临时修改（重启失效）" class="headerlink" title="&lt;1&gt;临时修改（重启失效）"></a>&lt;1&gt;临时修改（重启失效）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 30秒空闲后开始探测</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -w net.ipv4.tcp_keepalive_time=30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每10秒探测一次</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -w net.ipv4.tcp_keepalive_intvl=10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最多探测3次</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -w net.ipv4.tcp_keepalive_probes=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证修改</span></span><br><span class="line">sysctl net.ipv4.tcp_keepalive_time</span><br><span class="line">sysctl net.ipv4.tcp_keepalive_intvl</span><br><span class="line">sysctl net.ipv4.tcp_keepalive_probes</span><br></pre></td></tr></table></figure>

<h4 id="永久修改"><a href="#永久修改" class="headerlink" title="&lt;2&gt;永久修改"></a>&lt;2&gt;永久修改</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line"><span class="built_in">sudo</span> vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 30</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 10</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置生效</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用单行命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_keepalive_time = 30&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_keepalive_intvl = 10&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_keepalive_probes = 3&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure>

<h4 id="生产环境推荐配置"><a href="#生产环境推荐配置" class="headerlink" title="&lt;3&gt;生产环境推荐配置"></a>&lt;3&gt;生产环境推荐配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/sysctl.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ═══════════════════════════════════════════════</span></span><br><span class="line"><span class="comment"># TCP KeepAlive 配置（生产环境推荐）</span></span><br><span class="line"><span class="comment"># ═══════════════════════════════════════════════</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内网稳定环境</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 60</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 10</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 6</span><br><span class="line"><span class="comment"># 总检测时间 = 60 + 10×6 = 120秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跨机房/云环境（更激进）</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_keepalive_time = 30</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_keepalive_intvl = 5</span></span><br><span class="line"><span class="comment"># net.ipv4.tcp_keepalive_probes = 3</span></span><br><span class="line"><span class="comment"># 总检测时间 = 30 + 5×3 = 45秒</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）应用层配置（Socket-编程）"><a href="#（4）应用层配置（Socket-编程）" class="headerlink" title="（4）应用层配置（Socket 编程）"></a>（4）应用层配置（Socket 编程）</h3><p><strong>封装为工具类</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpKeepAlive</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="type">int</span> idle_seconds = <span class="number">30</span>;      <span class="comment">// 空闲多久后开始探测</span></span><br><span class="line">        <span class="type">int</span> interval_seconds = <span class="number">10</span>;  <span class="comment">// 探测间隔</span></span><br><span class="line">        <span class="type">int</span> max_probes = <span class="number">3</span>;         <span class="comment">// 最大探测次数</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">enable</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> Config&amp; cfg = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set_option</span>(sockfd, SOL_SOCKET, SO_KEEPALIVE, <span class="number">1</span>, <span class="string">&quot;SO_KEEPALIVE&quot;</span>);</span><br><span class="line">        <span class="built_in">set_option</span>(sockfd, IPPROTO_TCP, TCP_KEEPIDLE, cfg.idle_seconds, <span class="string">&quot;TCP_KEEPIDLE&quot;</span>);</span><br><span class="line">        <span class="built_in">set_option</span>(sockfd, IPPROTO_TCP, TCP_KEEPINTVL, cfg.interval_seconds, <span class="string">&quot;TCP_KEEPINTVL&quot;</span>);</span><br><span class="line">        <span class="built_in">set_option</span>(sockfd, IPPROTO_TCP, TCP_KEEPCNT, cfg.max_probes, <span class="string">&quot;TCP_KEEPCNT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">disable</span><span class="params">(<span class="type">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set_option</span>(sockfd, SOL_SOCKET, SO_KEEPALIVE, <span class="number">0</span>, <span class="string">&quot;SO_KEEPALIVE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Config <span class="title">get_config</span><span class="params">(<span class="type">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">        Config cfg;</span><br><span class="line">        cfg.idle_seconds = <span class="built_in">get_option</span>(sockfd, IPPROTO_TCP, TCP_KEEPIDLE);</span><br><span class="line">        cfg.interval_seconds = <span class="built_in">get_option</span>(sockfd, IPPROTO_TCP, TCP_KEEPINTVL);</span><br><span class="line">        cfg.max_probes = <span class="built_in">get_option</span>(sockfd, IPPROTO_TCP, TCP_KEEPCNT);</span><br><span class="line">        <span class="keyword">return</span> cfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">is_enabled</span><span class="params">(<span class="type">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_option</span>(sockfd, SOL_SOCKET, SO_KEEPALIVE) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_option</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">int</span> value, <span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(fd, level, optname, &amp;value, <span class="built_in">sizeof</span>(value)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(std::<span class="built_in">string</span>(<span class="string">&quot;setsockopt &quot;</span>) + name + <span class="string">&quot; failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_option</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> level, <span class="type">int</span> optname)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getsockopt</span>(fd, level, optname, &amp;value, &amp;len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;getsockopt failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（5）快速验证-KeepAlive-是否生效"><a href="#（5）快速验证-KeepAlive-是否生效" class="headerlink" title="（5）快速验证 KeepAlive 是否生效"></a>（5）快速验证 KeepAlive 是否生效</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看某个连接的 KeepAlive 状态</span></span><br><span class="line">ss -tno state established | grep &lt;目标IP&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出中 timer:(keepalive,...) 表示已启用</span></span><br></pre></td></tr></table></figure>

<h2 id="3-核心作用"><a href="#3-核心作用" class="headerlink" title="3.核心作用"></a>3.核心作用</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113102020940.png"></p>
<h3 id="（1）各作用解析"><a href="#（1）各作用解析" class="headerlink" title="（1）各作用解析"></a>（1）各作用解析</h3><ul>
<li>“<strong>Redis++的心跳机制</strong>”就是直接使用“<strong>Linux TCP的心跳机制</strong>”，下面我们以Redis++为使用场景进行讲解</li>
</ul>
<h4 id="检测”半死连接”（最核心）"><a href="#检测”半死连接”（最核心）" class="headerlink" title="&lt;1&gt;检测”半死连接”（最核心）"></a>&lt;1&gt;检测”半死连接”（最核心）</h4><p><strong>问题场景</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis 服务器异常（断电/进程被杀/网线断开）</span><br><span class="line">         ↓</span><br><span class="line">客户端未收到 FIN/RST 包，误认为连接存活</span><br><span class="line">         ↓</span><br><span class="line">发送请求 → 永久阻塞/超时，业务异常</span><br></pre></td></tr></table></figure>
<p><strong>心跳解决逻辑</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定期发探测包 → 对端无响应 → 判定连接死亡 → 关闭连接 → 触发重连</span><br></pre></td></tr></table></figure>

<h4 id="防止中间设备关闭空闲连接"><a href="#防止中间设备关闭空闲连接" class="headerlink" title="&lt;2&gt;防止中间设备关闭空闲连接"></a>&lt;2&gt;防止中间设备关闭空闲连接</h4><ul>
<li>中间设备（如防火墙、负载均衡器）的核心资源是**「连接表项」**<ul>
<li>每维护一个 TCP 连接，都需要占用内存存储连接四元组（源 IP、源端口、目的 IP、目的端口）、连接状态（ESTABLISHED&#x2F;CLOSED 等）、超时计时器等信息。</li>
</ul>
</li>
<li>但设备的内存、连接表容量是<strong>有限的</strong>（比如一台普通防火墙可能仅支持数万到数十万并发连接）<ul>
<li>如果长期保留大量空闲连接，会耗尽连接表资源，导致无法接收新的正常连接，直接影响网络服务可用性。</li>
</ul>
</li>
<li>对中间设备而言，「空闲连接」意味着长时间没有数据交互，属于 “低价值” 连接，保留这类连接的收益极低；</li>
</ul>
<p><strong>问题场景</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端 ←──→ [防火墙/NAT/云负载均衡] ←──→ Redis 服务器</span><br><span class="line">                    │</span><br><span class="line">                    │ 空闲超阈值 → 直接断开（不通知两端）</span><br><span class="line">                    ↓</span><br><span class="line">客户端下次请求 → 连接失效 → 报错</span><br></pre></td></tr></table></figure>
<ul>
<li>常见设备空闲超时阈值:<ul>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113102652571.png"></li>
</ul>
</li>
</ul>
<p><strong>心跳解决逻辑</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按小于超时阈值的频率发探测包（如每30秒）→ 中间设备判定连接活跃 → 不被断开</span><br></pre></td></tr></table></figure>

<h4 id="及时回收连接池资源"><a href="#及时回收连接池资源" class="headerlink" title="&lt;3&gt;及时回收连接池资源"></a>&lt;3&gt;及时回收连接池资源</h4><p><strong>问题场景</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接池含无效连接 → 高并发时拿到死连接 → 请求失败→重试 → 性能下降</span><br></pre></td></tr></table></figure>

<p><strong>心跳解决逻辑</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检测到死连接 → 从池移除 → 创建新连接补充 → 连接池全为有效连接</span><br></pre></td></tr></table></figure>

<h3 id="（2）完整交互流程图（简化版）"><a href="#（2）完整交互流程图（简化版）" class="headerlink" title="（2）完整交互流程图（简化版）"></a>（2）完整交互流程图（简化版）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────┐                              ┌─────────────┐</span><br><span class="line">│  Redis++    │                              │   Redis     │</span><br><span class="line">│  Client     │                              │  Server     │</span><br><span class="line">└──────┬──────┘                              └──────┬──────┘</span><br><span class="line">       │                                            │</span><br><span class="line">       │ ══════ 正常业务交互 ══════                  │</span><br><span class="line">       │ ─ ─ ─ 连接空闲（如30秒） ─ ─ ─              │</span><br><span class="line">       │  💓 发送KeepAlive探测包                     │</span><br><span class="line">       │───────────────────────────────────────────▶│</span><br><span class="line">       │◀───────────────────────────────────────────│</span><br><span class="line">       │         ✅ ACK响应（服务器正常）             │</span><br><span class="line">       │ ─ ─ ─ 连接继续保持，重置空闲计时 ─ ─ ─       │</span><br><span class="line">       │                                            │</span><br><span class="line">       │ ═════════ 异常场景：服务器崩溃 ═════════     │</span><br><span class="line">       │  💓 发送KeepAlive探测包                     │</span><br><span class="line">       │───────────────────────────────────────────▶│ (无响应)</span><br><span class="line">       │  💓 重试探测 × 9次                          │</span><br><span class="line">       │───────────────────────────────────────────▶│ (仍无响应)</span><br><span class="line">       │  ❌ 判定连接死亡                            │</span><br><span class="line">       │  → 关闭socket → 从连接池移除 → 自动重连      │</span><br><span class="line">       ▼                                            ▼</span><br></pre></td></tr></table></figure>

<h3 id="（3）“开启心跳机制”-vs-“不开心跳机制”"><a href="#（3）“开启心跳机制”-vs-“不开心跳机制”" class="headerlink" title="（3）“开启心跳机制” vs “不开心跳机制”"></a>（3）“开启心跳机制” vs “不开心跳机制”</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113103013458.png"></p>
<h2 id="4-注意事项与建议"><a href="#4-注意事项与建议" class="headerlink" title="4.注意事项与建议"></a>4.注意事项与建议</h2><h3 id="（1）系统级-vs-应用级配置优先级"><a href="#（1）系统级-vs-应用级配置优先级" class="headerlink" title="（1）系统级 vs 应用级配置优先级"></a>（1）系统级 vs 应用级配置优先级</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────┐</span><br><span class="line">│              配置优先级（从高到低）                     │</span><br><span class="line">├───────────────────────────────────────────────────────┤</span><br><span class="line">│  1. setsockopt() 应用级配置     ← 最高优先级          │</span><br><span class="line">│  2. /etc/sysctl.conf 永久配置                         │</span><br><span class="line">│  3. 内核默认值                  ← 最低优先级          │</span><br><span class="line">└───────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p><strong>注意!!</strong>：应用级配置仅影响当前 socket，不影响其他连接</p>
<h3 id="（2）生产环境配置建议"><a href="#（2）生产环境配置建议" class="headerlink" title="（2）生产环境配置建议"></a>（2）生产环境配置建议</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113111046526.png"></p>
<h3 id="（3）常见问题"><a href="#（3）常见问题" class="headerlink" title="（3）常见问题"></a>（3）常见问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：只开启 KeepAlive，不设置参数</span></span><br><span class="line"><span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line"><span class="comment">// 结果：使用系统默认值（7200秒），2小时后才开始检测，生产环境太慢！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：开启后必须设置参数</span></span><br><span class="line"><span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line"><span class="built_in">setsockopt</span>(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;idle, <span class="built_in">sizeof</span>(idle));</span><br><span class="line"><span class="built_in">setsockopt</span>(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;interval, <span class="built_in">sizeof</span>(interval));</span><br><span class="line"><span class="built_in">setsockopt</span>(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;count, <span class="built_in">sizeof</span>(count));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-补充"><a href="#5-补充" class="headerlink" title="5.补充"></a>5.补充</h2><h3 id="（1）探测包"><a href="#（1）探测包" class="headerlink" title="（1）探测包"></a>（1）探测包</h3><h4 id="KeepAlive-探测包的结构特征"><a href="#KeepAlive-探测包的结构特征" class="headerlink" title="&lt;1&gt;KeepAlive 探测包的结构特征"></a>&lt;1&gt;KeepAlive 探测包的结构特征</h4><p><strong>KeepAlive 探测包</strong>是一个<strong>特殊的 TCP 包</strong>：</p>
<ul>
<li><strong>序列号</strong> &#x3D; 上一次发送的最后字节序号 - 1（故意”倒退”）</li>
<li><strong>数据长度</strong> &#x3D; 0 字节</li>
<li><strong>ACK 标志</strong> &#x3D; 1</li>
<li><strong>目的</strong>：触发对端回复一个 ACK，以此确认连接存活</li>
</ul>
<h4 id="抓包命令"><a href="#抓包命令" class="headerlink" title="&lt;2&gt;抓包命令"></a>&lt;2&gt;抓包命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 tcpdump 抓取</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i eth0 <span class="string">&#x27;tcp[tcpflags] &amp; tcp-ack != 0&#x27;</span> -nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wireshark 过滤器</span></span><br><span class="line">tcp.analysis.keep_alive</span><br></pre></td></tr></table></figure>

<h3 id="（2）KeepAlive-的局限性"><a href="#（2）KeepAlive-的局限性" class="headerlink" title="（2）KeepAlive 的局限性"></a>（2）KeepAlive 的局限性</h3><p><strong>局限性</strong>：</p>
<ul>
<li><strong>检测延迟高</strong>：即使优化参数，最快也要几十秒才能发现死连接</li>
<li><strong>无法检测应用层故障</strong>：对端进程死锁但 TCP 栈正常时，KeepAlive 仍会成功</li>
<li><strong>跨 NAT 场景</strong>：某些 NAT 设备会”代答” KeepAlive，导致检测失效</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>关键业务可增加<strong>应用层心跳</strong>（如 Redis 的 PING 命令）</li>
<li>结合 <code>socket_timeout</code> 设置读写超时</li>
</ul>
<h3 id="（3）“TCP-KeepAlive”-vs-“应用层心跳”"><a href="#（3）“TCP-KeepAlive”-vs-“应用层心跳”" class="headerlink" title="（3）“TCP KeepAlive” vs “应用层心跳”"></a>（3）“TCP KeepAlive” vs “应用层心跳”</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113112324791.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>TCP_IP相关</category>
        <category>TCP KeepAlive 心跳机制</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后问题</title>
    <url>/2026/01/05/%E7%BC%96%E7%A8%8B%E9%A2%98/%E9%80%92%E5%BD%92/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h1><p><img src="/images/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.png" alt="题目描述"></p>
<h1 id="2-问题分析："><a href="#2-问题分析：" class="headerlink" title="2.问题分析："></a>2.问题分析：</h1><pre><code>思路很直接：按行放皇后，每放一个就标记该列和两条对角线被占用，放完最后一行时计数＋＋，然后回溯撤销。
</code></pre>
<h1 id="3-解决方法：递归-回溯"><a href="#3-解决方法：递归-回溯" class="headerlink" title="3.解决方法：递归+回溯"></a>3.解决方法：递归+回溯</h1><h2 id="1-利用矩阵的性质"><a href="#1-利用矩阵的性质" class="headerlink" title="(1)利用矩阵的性质"></a>(1)利用矩阵的性质</h2><pre><code>1./ 方向的所有格子满足 i+j == 常量
2.\ 方向的所有格子满足 i−j == 常量，为了下标非负，偏移了 +(n−1) ——&gt;注意：不可以简单的用绝对值，如（1,2），(2,1)
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span>&amp; res,<span class="type">int</span> row,vector&lt;<span class="type">bool</span>&gt;&amp; col,vector&lt;<span class="type">bool</span>&gt;&amp;diag1,vector&lt;<span class="type">bool</span>&gt;&amp;diag2,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历每一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        <span class="comment">//检查所在列、对角线是否还可用</span></span><br><span class="line">        <span class="comment">//关键点1：“/斜线上：row+col=定值”，“\斜线上：row-col=定值——&gt;为保持非负，向右偏移n-1（注意不可以简单的用“绝对值”）”</span></span><br><span class="line">        <span class="keyword">if</span>(col[j] || diag1[row+j] || diag2[row-j+n<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//可用：占用并更新col、diag1、diag2</span></span><br><span class="line">        col[j]=diag1[row+j]=diag2[row-j+n<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归遍历下一行</span></span><br><span class="line">        <span class="built_in">backtrace</span>(res,row<span class="number">+1</span>,col,diag1,diag2,n);</span><br><span class="line">        <span class="comment">//关键点2：回溯</span></span><br><span class="line">        col[j]=diag1[row+j]=diag2[row-j+n<span class="number">-1</span>]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Nqueen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//col：同列是否可用   diag1：/对角线是否可用  diag2：\对角线是否可用  -&gt;false:未占用  true:占用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">col</span><span class="params">(n,<span class="literal">false</span>)</span>,<span class="title">diag1</span><span class="params">(n*<span class="number">2</span>,<span class="literal">false</span>)</span>,<span class="title">diag2</span><span class="params">(n*<span class="number">2</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtrace</span>(res,<span class="number">0</span>,col,diag1,diag2,n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-逐行记录已放皇后的列，并每次遍历已放皇后检查冲突（如果不知道上述矩阵的性质）"><a href="#2-逐行记录已放皇后的列，并每次遍历已放皇后检查冲突（如果不知道上述矩阵的性质）" class="headerlink" title="(2)逐行记录已放皇后的列，并每次遍历已放皇后检查冲突（如果不知道上述矩阵的性质）"></a>(2)逐行记录已放皇后的列，并每次遍历已放皇后检查冲突（如果不知道上述矩阵的性质）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span>&amp; res,<span class="type">int</span> row,vector&lt;<span class="type">int</span>&gt;&amp; pos,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试把第 row 行的皇后放到 col 列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 检查和前面所有行的冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; row; ++r) &#123;</span><br><span class="line">            <span class="comment">// 同列冲突 或 同对角线冲突（|行差|==|列差|）</span></span><br><span class="line">            <span class="keyword">if</span> (pos[r] == col || <span class="built_in">abs</span>(row - r) == <span class="built_in">abs</span>(col - pos[r])) &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 放置皇后</span></span><br><span class="line">        pos[row] = col;</span><br><span class="line">        <span class="built_in">backtrace</span>(res, row + <span class="number">1</span>, pos, n);</span><br><span class="line">        <span class="comment">// 回溯时不需要手动清理 pos[row]，下次覆盖即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Nqueen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">//记录每行放置在哪一列</span></span><br><span class="line">    <span class="built_in">backtrace</span>(res, <span class="number">0</span>, pos, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程题</category>
        <category>递归/回溯</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2026/01/06/%E7%BC%96%E7%A8%8B%E9%A2%98/%E9%80%92%E5%BD%92/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="/images/2026.1.6-1-oj.png" alt="题目"></p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>1.时间复杂度O(n) ——&gt;“回溯”<br>2.映射： ‘(‘—&gt;1   ‘)’—&gt;-1<br>3.sum表示“和”，sum&gt;&#x3D;0合法，sum&lt;0不合法<br>4.每次增加一个括号</p>
<ul>
<li>‘(‘ : sum+1</li>
<li>‘)’ : sum-1</li>
<li>判断是否维持sum&gt;&#x3D;0<br>5.最后：“左&#x2F;右括号数”&#x3D;0，且sum&#x3D;0 ——&gt; “合法！”</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//res:结果集   tmpRes：每次的结果   sum：&quot;和&quot;  leftNum:&#x27;(&#x27;剩余数量  right: &#x27;)&#x27;剩余数量  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(vector&lt;string&gt;&amp; res,string&amp; tmpRes,<span class="type">int</span> sum,<span class="type">int</span> leftNum,<span class="type">int</span> rightNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//sum&lt;0:说明当前&#x27;)&#x27;数量 大于 &#x27;(&#x27;数量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(leftNum==<span class="number">0</span> &amp;&amp; rightNum==<span class="number">0</span> &amp;&amp; sum==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//最后都为0，则为合法组合</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(tmpRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加左括号</span></span><br><span class="line">    <span class="keyword">if</span>(leftNum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        tmpRes.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="built_in">func</span>(res,tmpRes,sum<span class="number">+1</span>,leftNum<span class="number">-1</span>,rightNum);</span><br><span class="line">        tmpRes.<span class="built_in">pop_back</span>(); <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加右括号</span></span><br><span class="line">    <span class="keyword">if</span>(rightNum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        tmpRes.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="built_in">func</span>(res,tmpRes,sum<span class="number">-1</span>,leftNum,rightNum<span class="number">-1</span>);</span><br><span class="line">        tmpRes.<span class="built_in">pop_back</span>(); <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    string tmpRes;</span><br><span class="line">    <span class="built_in">func</span>(res,tmpRes,<span class="number">0</span>,n,n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程题</category>
        <category>递归/回溯</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵最长递增路径(重点)</title>
    <url>/2026/01/06/%E7%BC%96%E7%A8%8B%E9%A2%98/%E9%80%92%E5%BD%92/%E7%9F%A9%E9%98%B5%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="/images/2026.1.6-2-oj.png" alt="题目"></p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h3 id="方法1：记忆化搜索-DFS"><a href="#方法1：记忆化搜索-DFS" class="headerlink" title="方法1：记忆化搜索 DFS"></a>方法1：记忆化搜索 DFS</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> row,col;</span><br><span class="line"><span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//四个方向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dp:记忆数组  matrix[i][j]:当前位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;matrix,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已经计算过，直接返回——&gt;&quot;剪枝&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(dp[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    dp[i][j]=<span class="number">1</span>; <span class="comment">//至少包含自己</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it: dirs)&#123;</span><br><span class="line">        <span class="type">int</span> ni=i+it[<span class="number">0</span>],nj=j+it[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//分别向4个方向移动</span></span><br><span class="line">        <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; row &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; col </span><br><span class="line">            &amp;&amp; matrix[ni][nj] &gt; matrix[i][j]) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="number">1</span> + <span class="built_in">dfs</span>(matrix, dp, ni, nj));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    row=matrix.<span class="built_in">size</span>();</span><br><span class="line">    col=matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;++j)&#123;</span><br><span class="line">            <span class="comment">//因为是“递增”，所以不会出现循环依赖，不需要考虑visit数组</span></span><br><span class="line">            res=<span class="built_in">max</span>(res,<span class="built_in">dfs</span>(matrix,dp,i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法2：-思路与1类似（更复杂冗余，但感觉更容易想到）"><a href="#方法2：-思路与1类似（更复杂冗余，但感觉更容易想到）" class="headerlink" title="方法2： 思路与1类似（更复杂冗余，但感觉更容易想到）"></a>方法2： 思路与1类似（更复杂冗余，但感觉更容易想到）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//val: 当前位置的值  d_r: dest_row  d_c: dest_col</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canMove</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix,<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> val,<span class="type">int</span> d_r,<span class="type">int</span> d_c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d_r&lt;<span class="number">0</span> || d_r&gt;=row) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(d_c&lt;<span class="number">0</span> || d_c&gt;=col) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(matrix[d_r][d_c]&lt;=val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;dp,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp;visit,<span class="type">int</span> row,<span class="type">int</span> col,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;src,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cur,<span class="type">int</span> pathLong)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.如果dp[c_f][c_s]!=0,则已经求过其最长路径——&gt;“剪枝”</span></span><br><span class="line">    <span class="type">int</span> c_f=cur.first,c_s=cur.second;</span><br><span class="line">    <span class="type">int</span> s_f=src.first,s_s=src.second;</span><br><span class="line">    <span class="keyword">if</span>(dp[c_f][c_s]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        pathLong+=dp[c_f][c_s];</span><br><span class="line">        <span class="keyword">if</span>(pathLong&gt;dp[s_f][s_s])&#123;</span><br><span class="line">            dp[s_f][s_s]=pathLong;</span><br><span class="line">            <span class="keyword">if</span>(pathLong&gt;res) res=pathLong;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//2.如果已经访问过了，则直接返回，避免“循环访问”</span></span><br><span class="line">    <span class="keyword">if</span>(visit[c_f][c_s]) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3.处理当前位置</span></span><br><span class="line">    visit[c_f][c_s]=<span class="literal">true</span>;</span><br><span class="line">    pathLong+=<span class="number">1</span>; <span class="comment">//注意：pathLong初始为0</span></span><br><span class="line">    <span class="keyword">if</span>(pathLong&gt;dp[s_f][s_s]) dp[s_f][s_s]=pathLong;</span><br><span class="line">    <span class="keyword">if</span>(pathLong&gt;res) res=pathLong;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.分别向“上下左右”四个方向移动</span></span><br><span class="line">    <span class="type">int</span> curVal=matrix[c_f][c_s];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">canMove</span>(matrix,row,col,curVal,c_f<span class="number">-1</span>,c_s))&#123;</span><br><span class="line">        visit[c_f][c_s]=<span class="literal">true</span>;</span><br><span class="line">        cur.first-=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">func</span>(matrix,dp,visit,row,col,src,cur,pathLong);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        visit[c_f][c_s]=<span class="literal">false</span>;</span><br><span class="line">        cur.first+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">canMove</span>(matrix,row,col,curVal,c_f<span class="number">+1</span>,c_s))&#123;</span><br><span class="line">        visit[c_f][c_s]=<span class="literal">true</span>; <span class="comment">//避免前面的if分支影响</span></span><br><span class="line">        cur.first+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">func</span>(matrix,dp,visit,row,col,src,cur,pathLong);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        visit[c_f][c_s]=<span class="literal">true</span>;</span><br><span class="line">        cur.first-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">canMove</span>(matrix,row,col,curVal,c_f,c_s<span class="number">-1</span>))&#123;</span><br><span class="line">        visit[c_f][c_s]=<span class="literal">true</span>;</span><br><span class="line">        cur.second-=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        <span class="built_in">func</span>(matrix,dp,visit,row,col,src,cur,pathLong);</span><br><span class="line">        visit[c_f][c_s]=<span class="literal">true</span>;</span><br><span class="line">        cur.second+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">canMove</span>(matrix,row,col,curVal,c_f,c_s<span class="number">+1</span>))&#123;</span><br><span class="line">        visit[c_f][c_s]=<span class="literal">true</span>;</span><br><span class="line">        cur.second+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">func</span>(matrix,dp,visit,row,col,src,cur,pathLong);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        visit[c_f][c_s]=<span class="literal">true</span>;</span><br><span class="line">        cur.second-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(visit[c_f][c_s]) visit[c_f][c_s]=<span class="literal">false</span>; <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> row=matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(row==<span class="number">1</span> &amp;&amp; col==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//dp[i][j]: matrix[i][j]的最长递增路径</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col,<span class="number">-1</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visit</span>(row,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//求出以每个位置为起点的最长路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;++j)&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; src&#123;i,j&#125;;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cur&#123;i,j&#125;;</span><br><span class="line">            <span class="built_in">func</span>(matrix,dp,visit,row,col,src,cur,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可优化点：</strong><br><strong>- visit数组不需要：因为是“递增”，不会出现“循环访问” ……</strong><br><strong>- 就照着“方法1”去优化吧</strong></p>
]]></content>
      <categories>
        <category>编程题</category>
        <category>递归/回溯</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>没有重复项数字的全排列问题</title>
    <url>/2026/01/02/%E7%BC%96%E7%A8%8B%E9%A2%98/%E9%80%92%E5%BD%92/%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h1><p><img src="/images/%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98.png" alt="题目描述"></p>
<h1 id="2-问题分析："><a href="#2-问题分析：" class="headerlink" title="2.问题分析："></a>2.问题分析：</h1><pre><code>明显的一种想法：
- 第一个数有n种可能，第二个数有n-1中可能，....,最后一个数
- 从小到达遍历，每次挑选一个还未被挑选的数，被挑选了的则标记为“被访问状态”
- 如果用for循环，则需要n层，而明显写不出——&gt;递归此时似乎是很直观的一种选择
</code></pre>
<h1 id="3-解决方法：递归"><a href="#3-解决方法：递归" class="headerlink" title="3.解决方法：递归"></a>3.解决方法：递归</h1><h2 id="1-普通方法"><a href="#1-普通方法" class="headerlink" title="(1) 普通方法"></a>(1) 普通方法</h2><pre><code>1.每次从小到达遍历，挑选第一个未被挑选的数字，然后设置为“被访问”状态
2.注意点：记得回溯
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//res:存放结果  num:原数组  tmp:存储每次递归的结果  visit:访问数组  floor:递归层数  size:num数组的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res,vector&lt;<span class="type">int</span>&gt;&amp; num,vector&lt;<span class="type">int</span>&gt;tmp,vector&lt;<span class="type">bool</span>&gt;&amp; visit,<span class="type">int</span> floor,<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(floor==size) res.<span class="built_in">push_back</span>(tmp); </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//每次从0开始遍历所有数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]) <span class="keyword">continue</span>; <span class="comment">//被访问，则跳过</span></span><br><span class="line">            <span class="comment">//tmp[floor]表示存储该层被挑选的数字</span></span><br><span class="line">            <span class="comment">//num[i]未被访问，则加入，并将其在visit中的状态设置为true</span></span><br><span class="line">            tmp[floor]=num[i];</span><br><span class="line">            visit[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">find</span>(res,num,tmp,visit,floor<span class="number">+1</span>,size); <span class="comment">//递归进入下一层</span></span><br><span class="line">            visit[i]=<span class="literal">false</span>; <span class="comment">//回溯:因为后面的递归仍可挑选num[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; num) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> size=num.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="built_in">tmp</span>(size,<span class="number">-1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(size,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">find</span>(res,num,tmp,visit,<span class="number">0</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-原地交换的回溯-（常见、高效、空间少）"><a href="#2-原地交换的回溯-（常见、高效、空间少）" class="headerlink" title="(2) 原地交换的回溯 （常见、高效、空间少）"></a>(2) 原地交换的回溯 （常见、高效、空间少）</h2><p>关键解析：<br>	1.floor表示递归层数，也表示挑选了的个数，从0——&gt;size 依次递增，floor&#x3D;&#x3D;size表示全部挑选（结束递归）<br>	2.每一次调用，num[floor]存储当前调用挑选的数字——&gt;通过swap(num[floor],num[i])原地交换实现<br>	3.因为num是‘引用传递’，且floor递增，故当第floor层执行完swap后，num[0,floor]都是被挑选了的,num[floor+1,size]则还未被挑选（因为1,2…,floor-1都执行了swap）——&gt;这也是为什么每一层都从i&#x3D;floor开始循环<br>	4.注意点：因为num是’引用传递’，故递归调用完后，需要’回溯’（交换回来）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res,vector&lt;<span class="type">int</span>&gt;&amp; num,<span class="type">int</span> floor,<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(floor==size) res.<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=floor;i&lt;size;++i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(num[floor],num[i]); <span class="comment">//交换后：num[0,floor]都是被选择的了，num[floor+1,size)则是还未被选择的</span></span><br><span class="line">            <span class="built_in">dfs</span>(res,num,floor<span class="number">+1</span>,size); <span class="comment">//递归：选择下一个</span></span><br><span class="line">            <span class="built_in">swap</span>(num[i],num[floor]); <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; num) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> size=num.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(res,num,<span class="number">0</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程题</category>
        <category>递归/回溯</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>引用限定符（Ref-qualifier）</title>
    <url>/2026/01/19/C++/C++%E7%89%B9%E6%80%A7/C++11%E7%89%B9%E6%80%A7/%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="1-引用限定符（Ref-qualifier）"><a href="#1-引用限定符（Ref-qualifier）" class="headerlink" title="1.引用限定符（Ref-qualifier）"></a>1.引用限定符（Ref-qualifier）</h1><p>引用限定符<strong>限定的是调用者（this）的值类别！！</strong></p>
<h2 id="（1）语法"><a href="#（1）语法" class="headerlink" title="（1）语法"></a>（1）语法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> &amp;</span>;       <span class="comment">// 只能被左值调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="type">const</span>&amp;</span>;  <span class="comment">// 只能被 const 左值调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> &amp;&amp;</span>;      <span class="comment">// 只能被右值调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">    std::string data_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 左值版本：返回引用，避免拷贝</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">get</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// const 左值版本</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span>&amp; </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右值版本：直接移动，对象即将销毁</span></span><br><span class="line">    <span class="function">std::string <span class="title">get</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(data_); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyString s;</span><br><span class="line">s.<span class="built_in">get</span>();                    <span class="comment">// 调用 &amp; 版本，返回 std::string&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> MyString cs;</span><br><span class="line">cs.<span class="built_in">get</span>();                   <span class="comment">// 调用 const&amp; 版本，返回 const std::string&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MyString</span>().<span class="built_in">get</span>();           <span class="comment">// 调用 &amp;&amp; 版本，返回 std::string（移动出来）</span></span><br><span class="line">std::<span class="built_in">move</span>(s).<span class="built_in">get</span>();         <span class="comment">// 调用 &amp;&amp; 版本</span></span><br></pre></td></tr></table></figure>

<h2 id="（3）为什么需要？"><a href="#（3）为什么需要？" class="headerlink" title="（3）为什么需要？"></a>（3）为什么需要？</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有引用限定符时的问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span> &#123;</span><br><span class="line">    std::string data_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Bad</span>().<span class="built_in">get</span>() = <span class="string">&quot;oops&quot;</span>;  <span class="comment">// 编译通过！但修改了临时对象，毫无意义</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用引用限定符防止误用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Good</span> &#123;</span><br><span class="line">    std::string data_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">get</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> data_; &#125;  <span class="comment">// 只允许左值调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Good</span>().<span class="built_in">get</span>() = <span class="string">&quot;oops&quot;</span>;  <span class="comment">// ❌ 编译错误！临时对象不能调用 &amp; 方法</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑错误难以发现"><a href="#逻辑错误难以发现" class="headerlink" title="&lt;1&gt;逻辑错误难以发现"></a>&lt;1&gt;逻辑错误难以发现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    std::string value_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value_; &#125;</span><br><span class="line">    <span class="function">Config <span class="title">withDefault</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Config&#123;<span class="string">&quot;default&quot;</span>&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Config c;</span><br><span class="line">c.<span class="built_in">withDefault</span>().<span class="built_in">get</span>() = <span class="string">&quot;custom&quot;</span>;  <span class="comment">// 编译通过！但 c 没有任何改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序员以为修改了配置，实际上什么都没发生</span></span><br><span class="line"><span class="comment">// 这种 bug 可能潜伏很久</span></span><br></pre></td></tr></table></figure>

<h3 id="返回引用指向已销毁对象（真正危险）"><a href="#返回引用指向已销毁对象（真正危险）" class="headerlink" title="&lt;2&gt;返回引用指向已销毁对象（真正危险）"></a>&lt;2&gt;返回引用指向已销毁对象（真正危险）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data_&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险用法</span></span><br><span class="line"><span class="keyword">auto</span>&amp; ref = <span class="built_in">Container</span>().<span class="built_in">data</span>();  <span class="comment">// 临时对象立即销毁！</span></span><br><span class="line">ref[<span class="number">0</span>] = <span class="number">42</span>;                      <span class="comment">// 💥 未定义行为！悬垂引用</span></span><br></pre></td></tr></table></figure>
<p><strong>加上引用限定符后</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data_&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">data</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> data_; &#125;        <span class="comment">// 左值返回引用</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(data_); &#125;  <span class="comment">// 右值返回值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; ref = <span class="built_in">Container</span>().<span class="built_in">data</span>();  <span class="comment">// ❌ 编译错误！&amp;&amp; 版本返回的是值，不能绑定到 auto&amp;</span></span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">Container</span>().<span class="built_in">data</span>();   <span class="comment">// ✅ 正确，移动出来</span></span><br></pre></td></tr></table></figure>

<h3 id="实际踩坑场景"><a href="#实际踩坑场景" class="headerlink" title="&lt;3&gt; 实际踩坑场景"></a>&lt;3&gt; 实际踩坑场景</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    std::string result_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Builder&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123; </span><br><span class="line">        result_ += s; </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">str</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> result_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用的坑</span></span><br><span class="line">std::string&amp; s = <span class="built_in">Builder</span>().<span class="built_in">append</span>(<span class="string">&quot;a&quot;</span>).<span class="built_in">append</span>(<span class="string">&quot;b&quot;</span>).<span class="built_in">str</span>();  </span><br><span class="line"><span class="comment">// s 是悬垂引用！Builder 临时对象已销毁</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; s;  <span class="comment">// 💥 未定义行为</span></span><br></pre></td></tr></table></figure>

<h2 id="（4）引用限定符使用总结"><a href="#（4）引用限定符使用总结" class="headerlink" title="（4）引用限定符使用总结"></a>（4）引用限定符使用总结</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119160238018.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data_;  <span class="comment">// 大对象</span></span><br><span class="line">    <span class="type">int</span> count_ = <span class="number">0</span>;          <span class="comment">// 小对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 大对象：区分左右值</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">data</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">data</span><span class="params">()</span> <span class="type">const</span>&amp; </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(data_); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小对象：不区分，直接返回拷贝</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++特性</category>
        <category>C++11特性 - 引用限定符（Ref-qualifier）</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>requires</title>
    <url>/2026/01/19/C++/C++%E7%89%B9%E6%80%A7/C++20%E7%89%B9%E6%80%A7/requires/</url>
    <content><![CDATA[<h1 id="1-函数级别的-requires-约束"><a href="#1-函数级别的-requires-约束" class="headerlink" title="1.函数级别的 requires 约束"></a>1.函数级别的 requires 约束</h1><h2 id="（1）核心语法（3种）"><a href="#（1）核心语法（3种）" class="headerlink" title="（1）核心语法（3种）"></a>（1）核心语法（3种）</h2><h3 id="基础格式（直接跟约束表达式）"><a href="#基础格式（直接跟约束表达式）" class="headerlink" title="&lt;1&gt;基础格式（直接跟约束表达式）"></a>&lt;1&gt;基础格式（直接跟约束表达式）</h3><p>这是最常用的写法，适用于普通函数 &#x2F; 模板函数 &#x2F; 成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板函数 + 函数级requires</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">返回值类型 函数名(参数列表) <span class="keyword">requires</span> 编译期布尔表达式 &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的成员函数 + 函数级requires</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    返回值类型 成员函数名(参数列表) <span class="keyword">requires</span> 编译期布尔表达式;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数（非模板）也可加requires（C++20支持，但仅当表达式为true时函数存在）</span></span><br><span class="line">返回值类型 普通函数名(参数列表) <span class="keyword">requires</span> 编译期布尔表达式 &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="精简格式（模板参数列表后-函数级双重约束）"><a href="#精简格式（模板参数列表后-函数级双重约束）" class="headerlink" title="&lt;2&gt;精简格式（模板参数列表后 + 函数级双重约束）"></a>&lt;2&gt;精简格式（模板参数列表后 + 函数级双重约束）</h3><p>若模板本身有约束，可在模板参数后加 requires，函数级再叠加约束（逻辑与）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">requires</span> 约束<span class="number">1</span>  <span class="comment">// 模板级约束</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> <span class="keyword">requires</span> 约束2 </span>&#123;     <span class="comment">// 函数级约束（需同时满足约束1+约束2）</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="括号格式（复杂约束用括号提升可读性）"><a href="#括号格式（复杂约束用括号提升可读性）" class="headerlink" title="&lt;3&gt;括号格式（复杂约束用括号提升可读性）"></a>&lt;3&gt;括号格式（复杂约束用括号提升可读性）</h3><p>多个约束组合时，用括号包裹表达式，逻辑更清晰</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T val)</span> <span class="title">requires</span> <span class="params">(约束<span class="number">1</span>)</span> &amp;&amp; <span class="params">(约束<span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（2）常用的-“编译期布尔表达式”（约束条件）"><a href="#（2）常用的-“编译期布尔表达式”（约束条件）" class="headerlink" title="（2）常用的 “编译期布尔表达式”（约束条件）"></a>（2）常用的 “编译期布尔表达式”（约束条件）</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119161844015.png"></p>
<h2 id="（3）实战基础示例"><a href="#（3）实战基础示例" class="headerlink" title="（3）实战基础示例"></a>（3）实战基础示例</h2><h3 id="模板函数的函数级-requires"><a href="#模板函数的函数级-requires" class="headerlink" title="&lt;1&gt;模板函数的函数级 requires"></a>&lt;1&gt;模板函数的函数级 requires</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束：T必须是算术类型（int/float/double等）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T a, T b)</span> <span class="keyword">requires</span> std::is_arithmetic_v&lt;T&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合法：int是算术类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;  <span class="comment">// 输出30</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合法：double是算术类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">3.14</span>, <span class="number">2.5</span>) &lt;&lt; std::endl;  <span class="comment">// 输出5.64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译报错：std::string不是算术类型，约束不满足</span></span><br><span class="line">    <span class="comment">// std::string s1 = &quot;hello&quot;, s2 = &quot;world&quot;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; sum(s1, s2) &lt;&lt; std::endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类模板成员函数的函数级-requires"><a href="#类模板成员函数的函数级-requires" class="headerlink" title="&lt;2&gt;类模板成员函数的函数级 requires"></a>&lt;2&gt;类模板成员函数的函数级 requires</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wrapper</span>(T val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束：T是void类型时，才允许调用这个无参数print</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">requires</span> std::is_same_v&lt;T, <span class="type">void</span>&gt; </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: void (no data)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束：T不是void且可打印（支持&lt;&lt;），才允许调用这个print</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="title">requires</span> <span class="params">(!std::is_same_v&lt;T, <span class="type">void</span>&gt;)</span> &amp;&amp; </span></span><br><span class="line"><span class="function">        <span class="title">requires</span><span class="params">(std::ostream&amp; os, T val)</span> </span>&#123; os &lt;&lt; val; &#125;  <span class="comment">// 这整个是约束表达式</span></span><br><span class="line">    &#123;  <span class="comment">// 这才是函数体的开始</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// T=void，调用第一个print</span></span><br><span class="line">    Wrapper&lt;<span class="type">void</span>&gt; w1;</span><br><span class="line">    w<span class="number">1.</span><span class="built_in">print</span>();  <span class="comment">// 输出：Value: void (no data)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// T=int，调用第二个print</span></span><br><span class="line">    <span class="function">Wrapper&lt;<span class="type">int</span>&gt; <span class="title">w2</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    w<span class="number">2.</span><span class="built_in">print</span>();  <span class="comment">// 输出：Value: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// T=string，调用第二个print</span></span><br><span class="line">    <span class="function">Wrapper&lt;std::string&gt; <span class="title">w3</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    w<span class="number">3.</span><span class="built_in">print</span>();  <span class="comment">// 输出：Value: hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通函数的函数级-requires（少见但合法）"><a href="#普通函数的函数级-requires（少见但合法）" class="headerlink" title="&lt;3&gt;普通函数的函数级 requires（少见但合法）"></a>&lt;3&gt;普通函数的函数级 requires（少见但合法）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当编译期条件为true时，该函数才存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">requires</span> <span class="params">(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int is 4 bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若当前平台int是4字节，调用成功；否则编译报错</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++特性</category>
        <category>C++20特性 - requires</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>std::expected&lt;T, E&gt;</title>
    <url>/2026/01/19/C++/C++%E7%89%B9%E6%80%A7/C++23%E7%89%B9%E6%80%A7/excepted/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul>
<li><strong>std::expected&lt;T, E&gt;</strong> 是 C++23 标准库提供的带错误处理的返回值类型，定义在 <expected> 头文件中，核心目的是：<ul>
<li>替代传统的 “返回值 + 错误码”“异常” 等错误处理方式，在不抛异常的前提下，优雅地封装 “成功结果” 或 “错误信息”；</li>
<li>强制开发者显式处理错误（避免忽略错误码），同时保持代码的可读性和类型安全。</li>
</ul>
</li>
<li>简单理解：std::expected&lt;T, E&gt; 实例<strong>要么包含一个有效的 T 类型成功值，要么包含一个E 类型的错误值，二者只能存其一</strong>（类似 Rust 的 Result&lt;T, E&gt;）。</li>
</ul>
<h1 id="二、核心语法与基础用法"><a href="#二、核心语法与基础用法" class="headerlink" title="二、核心语法与基础用法"></a>二、核心语法与基础用法</h1><h2 id="1-基础声明与初始化"><a href="#1-基础声明与初始化" class="headerlink" title="1.基础声明与初始化"></a>1.基础声明与初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;expected&gt;</span>   <span class="comment">// 必须包含的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>     <span class="comment">// 示例用：错误类型常用std::string/枚举/自定义错误</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明：T=成功值类型，E=错误类型（推荐E为可拷贝/可移动的类型）</span></span><br><span class="line"><span class="function">std::expected&lt;<span class="type">int</span>, std::string&gt; <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式1：返回成功值（用std::expected构造或std::make_expected）</span></span><br><span class="line"><span class="function">std::expected&lt;<span class="type">int</span>, std::string&gt; <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;  <span class="comment">// 隐式构造：成功值</span></span><br><span class="line">    <span class="comment">// 等价写法：return std::make_expected&lt;int, std::string&gt;(100);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式2：返回错误值（用std::unexpected包裹）</span></span><br><span class="line"><span class="function">std::expected&lt;<span class="type">int</span>, std::string&gt; <span class="title">fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unexpected</span>(<span class="string">&quot;参数错误&quot;</span>);  <span class="comment">// 错误值需用std::unexpected包裹</span></span><br><span class="line">    <span class="comment">// 等价写法：return std::make_unexpected(std::string(&quot;参数错误&quot;));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-核心成员函数（判断-取值）"><a href="#2-核心成员函数（判断-取值）" class="headerlink" title="2.核心成员函数（判断+取值）"></a>2.核心成员函数（判断+取值）</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119173916337.png"></p>
<h2 id="3-基础使用示例"><a href="#3-基础使用示例" class="headerlink" title="3.基础使用示例"></a>3.基础使用示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;expected&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例函数：除法运算，成功返回int，失败返回错误信息</span></span><br><span class="line"><span class="function">std::expected&lt;<span class="type">int</span>, std::string&gt; <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unexpected</span>(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用函数并处理结果</span></span><br><span class="line">    <span class="keyword">auto</span> res1 = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (res<span class="number">1.</span><span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功：&quot;</span> &lt;&lt; res<span class="number">1.</span><span class="built_in">value</span>() &lt;&lt; std::endl;  <span class="comment">// 输出：成功：5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;失败：&quot;</span> &lt;&lt; res<span class="number">1.</span><span class="built_in">error</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> res2 = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 安全取值：失败时返回默认值-1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果：&quot;</span> &lt;&lt; res<span class="number">2.</span><span class="built_in">value_or</span>(<span class="number">-1</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：结果：-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>C++特性</category>
        <category>C++23特性</category>
        <category>std::expected&lt;T, E&gt;</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>1.最长公共子序列(一)</title>
    <url>/2026/01/09/%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h1><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109001047053.png"></p>
<h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h1><h2 id="1-普通版"><a href="#1-普通版" class="headerlink" title="1.普通版"></a>1.普通版</h2><p><strong>时间复杂度和空间复杂度：O(m×n)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> m = s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只存储长度的DP表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充DP表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-空间优化版（滚动数组）"><a href="#2-空间优化版（滚动数组）" class="headerlink" title="2.空间优化版（滚动数组）"></a>2.空间优化版（滚动数组）</h2><p><strong>时间复杂度和空间复杂度：O(m×n)时间 和 O(n)空间）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用一维数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">0</span>;  <span class="comment">// 存储上一轮的dp[j-1]，即左上角元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = dp[j];  <span class="comment">// 暂存当前dp[j]，下一轮将成为新的左上角元素</span></span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = prev + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>]); <span class="comment">// dp[j]此时保存的是dp[i-1][j]，dp[j-1]已更新为dp[i][j-1]</span></span><br><span class="line">            &#125;</span><br><span class="line">            prev = temp;  <span class="comment">// 更新左上角元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="原理解析："><a href="#原理解析：" class="headerlink" title="原理解析："></a>原理解析：</h3><h4 id="1-先看“普通版本”"><a href="#1-先看“普通版本”" class="headerlink" title="1.先看“普通版本”"></a>1.先看“普通版本”</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/7ded7ab8ec9bb8f8d473272ae01f5aa3.jpg"></p>
<ul>
<li>dp[i][j]是我们当前需要求的，由“普通版”可知，它与dp[i-1][j-1]、dp[i][j-1]、dp[i-1][j]有关</li>
<li>由图可知：dp[i-1][j-1]、dp[i][j-1]、dp[i-1][j]分别位于dp[i][j]的“左上角”、“上方”、“左方”</li>
<li>显然：在求第i行dp[i,j]时，只需用到dp[i-1][j-1]、dp[i][j-1]、dp[i-1][j] ——&gt;即“上一行的值”+“dp[i][j-1]”的值 ——&gt;dp为一维数组即可<ul>
<li>为什么上一行的值都需要存储？ 因为要求取第i行每一列</li>
</ul>
</li>
</ul>
<h3 id="2-再看“滚动数组”版本"><a href="#2-再看“滚动数组”版本" class="headerlink" title="2.再看“滚动数组”版本"></a>2.再看“滚动数组”版本</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/9965aa62cf907c149bfafaf73fdf7a58.jpg"><br><strong>为与1中dp区分，这里用DP代替dp</strong></p>
<ul>
<li>我们已知：用一维数组DP[j]存储上一行的值（这种说法并不准确，见下文）</li>
<li>由图+代码实现： prev存储“左上角元素”<ul>
<li>当j&#x3D;1时：没有“左上角元素”，设置为0即可（或者说有(i,0),表示空串,DP[0]&#x3D;0）</li>
<li>当j!&#x3D;1时：显然我们已经可获取dp[i-1][j-1]（pre存储）、dp[i][j-1]（DP[j]存储）,那dp[i-1][j]呢？</li>
</ul>
</li>
<li>当我们在求dp[i][j]时，显然dp[i][j-1]我们已经求取了，我们会将DP[j-1]更新为dp[i][j-1]（见代码）——&gt;故此时DP[j-1]&#x3D;dp[i-1][j] （准确说DP[j-k]都更新了！）——&gt;我想这也是<strong>滚动数组</strong>的由来<ul>
<li>这里也解释了DP[j]存储上一行的值“并不准确”：应该说DP在每一轮开始时，存储了上一行的值</li>
</ul>
</li>
<li>因此在求取dp[i][j]后，DP[j]会被更新为dp[i][j],所以需要用一个temp存储，也将作为下一轮的“左上角元素”，赋予到prev中</li>
<li>至此，结合“代码实现”+“图”应该能够理解整个过程</li>
</ul>
]]></content>
      <categories>
        <category>编程题</category>
        <category>动态规划</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>0.总结</title>
    <url>/2026/01/08/%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%97%E7%AC%A6%E4%B8%B2/0.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="一、核心思考方向"><a href="#一、核心思考方向" class="headerlink" title="一、核心思考方向"></a>一、核心思考方向</h1><h2 id="1-状态定义：dp数组含义"><a href="#1-状态定义：dp数组含义" class="headerlink" title="1.状态定义：dp数组含义"></a>1.状态定义：dp数组含义</h2><p><strong>1.单字符串</strong>：</p>
<ul>
<li>dp[i]<ul>
<li>表示<strong>s的前i个字符</strong>的某种性质</li>
<li>表示<strong>以第i个字符结尾</strong>的某种性质</li>
</ul>
</li>
<li>dp[i][j]<ul>
<li>表示<strong>s[i…j]子串</strong>的某种性质</li>
</ul>
</li>
<li>dp[i][j][k]<ul>
<li>带有<strong>额外限制条件</strong>的字符串问题<br><strong>2.双字符串</strong>：</li>
</ul>
</li>
<li>dp[i][j]<ul>
<li>表示<strong>s1的前i个字符</strong>与<strong>s2的前j个字符</strong>的最优解</li>
</ul>
</li>
<li>dp[i][j][k]<ul>
<li>带有<strong>额外限制条件</strong>的字符串问题</li>
</ul>
</li>
<li>dp[i][j][k][t]<ul>
<li>s1[i..j] 与 s2[k..t]的某种性质</li>
</ul>
</li>
</ul>
<h2 id="2-边界条件：初始化dp数组"><a href="#2-边界条件：初始化dp数组" class="headerlink" title="2.边界条件：初始化dp数组"></a>2.边界条件：初始化dp数组</h2><p>字符串DP的边界通常对应<strong>空串</strong>场景，是<strong>状态转移的起点</strong>,例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> len1=s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> len2=s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[0][j]=0 dp[i][0]=0 都表示其中一个为“空串”，故都设置为0</span></span><br><span class="line"><span class="comment">//dp[i][j]表示s1的前i个字符，s2的前j个字符（从1开始）</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>])&#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-状态转移"><a href="#3-状态转移" class="headerlink" title="3.状态转移"></a>3.状态转移</h2><p>1.<strong>s1&#x3D;[i-1]&#x3D;&#x3D;s2[j-1]</strong>:</p>
<ul>
<li>dp[i][j]&#x3D;opt(dp[i-1][j-1])：opt()表示dp[i-1][j-1]进行某种处理，如dp[i-1][j-1]+1</li>
</ul>
<p>2.<strong>s1[i-1]!&#x3D;s2[j-1]</strong></p>
<ul>
<li>dp[i][j]&#x3D;( opt(dp[i-1][j]) || opt(dp[i][j-1]) || opt(dp[i-1][j-1]) )</li>
</ul>
<h2 id="4-遍历顺序"><a href="#4-遍历顺序" class="headerlink" title="4.遍历顺序"></a>4.遍历顺序</h2><ul>
<li>左上到右下（二维DP典型方向）</li>
<li>斜对角遍历（处理子串或回文相关问题）</li>
<li>从短到长递推（区间DP）</li>
</ul>
<h1 id="二、常见技巧"><a href="#二、常见技巧" class="headerlink" title="二、常见技巧"></a>二、常见技巧</h1><h2 id="1-空间优化"><a href="#1-空间优化" class="headerlink" title="1.空间优化"></a>1.空间优化</h2><ul>
<li><strong>滚动数组</strong>：用两行或一行替代整个二维数组<ul>
<li>例：<a href="/2026/01/09/%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(%E4%B8%80)/" title="1.最长公共子序列(一)">最长公共子序列（一）</a></li>
</ul>
</li>
<li>使用单一数组+临时变量记录左上角值</li>
<li>根据依赖方向调整遍历顺序（如从右到左）</li>
</ul>
<h2 id="2-回溯构建结果"><a href="#2-回溯构建结果" class="headerlink" title="2.回溯构建结果"></a>2.回溯构建结果</h2><ul>
<li>使用DP表<strong>从终点回溯到起点</strong>重建结果<ul>
<li>例：<a href="/2026/01/08/%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(%E4%BA%8C)/" title="2.最长公共子序列(二)">最长公共子序列（二）</a></li>
</ul>
</li>
<li>在DP过程中记录转移来源（路径数组）</li>
</ul>
<h2 id="3-预处理技巧"><a href="#3-预处理技巧" class="headerlink" title="3.预处理技巧"></a>3.预处理技巧</h2><ul>
<li><strong>哈希</strong>或<strong>前缀和</strong>加速子串查询</li>
<li>预先计算特定字符的位置信息</li>
</ul>
<h2 id="4-状态压缩技巧"><a href="#4-状态压缩技巧" class="headerlink" title="4.状态压缩技巧"></a>4.状态压缩技巧</h2><ul>
<li>对于短字符串，可以用<strong>位运算表示状态</strong>，加速DP过程</li>
</ul>
<h2 id="5-递归-记忆化搜索"><a href="#5-递归-记忆化搜索" class="headerlink" title="5.递归+记忆化搜索"></a>5.递归+记忆化搜索</h2><ul>
<li>某些字符串DP问题用自顶向下的记忆化搜索更直观</li>
<li>特别是状态转移复杂或条件多的情况</li>
</ul>
<h2 id="6-回文类问题的特殊处理"><a href="#6-回文类问题的特殊处理" class="headerlink" title="6.回文类问题的特殊处理"></a>6.回文类问题的特殊处理</h2><ul>
<li><strong>中心扩展法结合 DP</strong>：对每个字符 &#x2F; 每两个字符作为中心，向两边扩展，结合 DP 记录已判断的回文子串（避免重复计算）；</li>
<li><strong>Manacher 算法</strong>：线性时间求解最长回文子串（针对 DP 的 O (n²) 优化），核心是利用回文的对称性减少重复判断。</li>
</ul>
]]></content>
      <categories>
        <category>编程题</category>
        <category>动态规划</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>2.最长公共子序列(二)</title>
    <url>/2026/01/08/%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h1><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108234255173.png"></p>
<h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h1><p><strong>涉及技巧：回溯构建结果</strong></p>
<h2 id="1-二维数组dp实现"><a href="#1-二维数组dp实现" class="headerlink" title="1.二维数组dp实现"></a>1.二维数组dp实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">LCS</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> m = s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只存储长度的DP表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充DP表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否存在公共子序列</span></span><br><span class="line">    <span class="keyword">if</span> (dp[m][n] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回溯构建结果</span></span><br><span class="line">    string result;</span><br><span class="line">    <span class="type">int</span> i = m, j = n;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(s1[i - <span class="number">1</span>]);</span><br><span class="line">            i--; j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程题</category>
        <category>动态规划 - 字符串</category>
      </categories>
      <tags>
        <tag>oj</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
</search>
