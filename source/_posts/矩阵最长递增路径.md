---
title: 矩阵最长递增路径(重点)
date: 2026-01-06 22:00:43
tags:
	- oj
	- 笔试
categories: 
	- 编程题
	- 递归/回溯
---

# 题目描述
![题目](/images/2026.1.6-2-oj.png)

# 解析
### 方法1：记忆化搜索 DFS
```cpp
    int row,col;
    int dirs[4][2]={{-1,0},{1,0},{0,-1},{0,1}}; //四个方向

    //dp:记忆数组  matrix[i][j]:当前位置
    int dfs(vector<vector<int>>&matrix,vector<vector<int>>& dp,int i,int j){
        //已经计算过，直接返回——>"剪枝"
        if(dp[i][j]!=0) return dp[i][j];
        dp[i][j]=1; //至少包含自己

        for(auto &it: dirs){
            int ni=i+it[0],nj=j+it[1];
            //分别向4个方向移动
            if (ni >= 0 && ni < row && nj >= 0 && nj < col 
                && matrix[ni][nj] > matrix[i][j]) {
                dp[i][j] = max(dp[i][j], 1 + dfs(matrix, dp, ni, nj));
            }
        }
        return dp[i][j];
    }
    
    int solve(vector<vector<int> >& matrix) {
        // write code here
        row=matrix.size();
        col=matrix.size();
        int res=0;
        vector<vector<int>>dp(row,vector<int>(col,0));
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                //因为是“递增”，所以不会出现循环依赖，不需要考虑visit数组
                res=max(res,dfs(matrix,dp,i,j));
            }
        }
        return res;
    }
```

### 方法2： 思路与1类似（更复杂冗余，但感觉更容易想到）
```cpp
    //val: 当前位置的值  d_r: dest_row  d_c: dest_col
    bool canMove(vector<vector<int>>& matrix,int row,int col,int val,int d_r,int d_c){
        if(d_r<0 || d_r>=row) return false;
        if(d_c<0 || d_c>=col) return false;
        if(matrix[d_r][d_c]<=val) return false;
        return true;
    }
 
    int res=0;
    void func(vector<vector<int>>& matrix,vector<vector<int>>&dp,vector<vector<bool>>&visit,int row,int col,pair<int,int>src,pair<int,int>cur,int pathLong){
        //1.如果dp[c_f][c_s]!=0,则已经求过其最长路径——>“剪枝”
        int c_f=cur.first,c_s=cur.second;
        int s_f=src.first,s_s=src.second;
        if(dp[c_f][c_s]>0){
            pathLong+=dp[c_f][c_s];
            if(pathLong>dp[s_f][s_s]){
                dp[s_f][s_s]=pathLong;
                if(pathLong>res) res=pathLong;
            }
            return;
        }
         
        //2.如果已经访问过了，则直接返回，避免“循环访问”
        if(visit[c_f][c_s]) return;
 
        //3.处理当前位置
        visit[c_f][c_s]=true;
        pathLong+=1; //注意：pathLong初始为0
        if(pathLong>dp[s_f][s_s]) dp[s_f][s_s]=pathLong;
        if(pathLong>res) res=pathLong;
 
        //4.分别向“上下左右”四个方向移动
        int curVal=matrix[c_f][c_s];
        if(canMove(matrix,row,col,curVal,c_f-1,c_s)){
            visit[c_f][c_s]=true;
            cur.first-=1;
            func(matrix,dp,visit,row,col,src,cur,pathLong);
            //回溯
            visit[c_f][c_s]=false;
            cur.first+=1;
        }
        if(canMove(matrix,row,col,curVal,c_f+1,c_s)){
            visit[c_f][c_s]=true; //避免前面的if分支影响
            cur.first+=1;
            func(matrix,dp,visit,row,col,src,cur,pathLong);
            //回溯
            visit[c_f][c_s]=true;
            cur.first-=1;
        }
        if(canMove(matrix,row,col,curVal,c_f,c_s-1)){
            visit[c_f][c_s]=true;
            cur.second-=1;
            //回溯
            func(matrix,dp,visit,row,col,src,cur,pathLong);
            visit[c_f][c_s]=true;
            cur.second+=1;
        }
        if(canMove(matrix,row,col,curVal,c_f,c_s+1)){
            visit[c_f][c_s]=true;
            cur.second+=1;
            func(matrix,dp,visit,row,col,src,cur,pathLong);
            //回溯
            visit[c_f][c_s]=true;
            cur.second-=1;
        }
         
        if(visit[c_f][c_s]) visit[c_f][c_s]=false; //回溯
    }
 
    int solve(vector<vector<int>>& matrix) {
        // write code here
        int row=matrix.size();
        int col=matrix[0].size();
        if(row==1 && col==1) return 1;
        //dp[i][j]: matrix[i][j]的最长递增路径
        vector<vector<int>> dp(row,vector<int>(col,-1));
        vector<vector<bool>> visit(row,vector<bool>(col,false));
         
        //求出以每个位置为起点的最长路径
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                pair<int,int> src{i,j};
                pair<int,int> cur{i,j};
                func(matrix,dp,visit,row,col,src,cur,0);
            }
        }
        return res;
    }
```
**可优化点：**
**- visit数组不需要：因为是“递增”，不会出现“循环访问” ......**
**- 就照着“方法1”去优化吧**
