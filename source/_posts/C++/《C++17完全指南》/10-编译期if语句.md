---
title: 10 编译期if语句
date: 2026-01-07 08:22:50
tags:
    - 笔记
categories:
    - C++
    - 《C++17完全指南》
    - 二、模板特性
    - 10 编译期if语句
---


# 1.概述
1.通过使用语法**if constexpr(...)**，编译器可以计算编译期的条件表达式来**在编译期决定**使用一个if语句
的then的部分还是else的部分。
2.其余部分的代码将会被丢弃，这意味着它们甚至不会被生成。
3.这并不意味着被丢弃的部分完全被忽略，这些部分中的代码也会像没使用的模板一样进行语法检查。
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/2026.1.7_1.png)

**特别强调：被忽略的语句也必须符合正确的语法**
```cpp
template<typename T>
void foo(T t)
{
	if constexpr(std::is_integral_v<T>) {
		if (t > 0) {
			foo(t‐1);// OK
		}
		else{
			undeclared(t); // 如果未被声明且未被丢弃将导致错误
			undeclared(); // 如果未声明将导致错误（即使被丢弃也一样）
			static_assert(false, "no integral"); // 总是会进行断言（即使被丢弃也一样）
		}
	}
}
```
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/2026.1.7_2.png)

# 2.使用编译期if语句
**1.理论上来说：只要条件表达式是编译期的表达式你就可以像使用运行期if一样使用编译期if**
**2.也可以混合使用编译期和运行期的if**
```cpp
#include <type_traits>
#include <limits>

template<typename T>
void foo(T val) {
    if constexpr (std::is_integral_v<std::remove_reference_t<T>>) {
        if (val > 10) {
            if constexpr (std::numeric_limits<char>::is_signed) {
                // char 是有符号的
            }
            else {
                // char 是无符号的
            }
        }
        else {
            // val <= 10
        }
    }
    else {
        // T 不是整型
    }
}

```
**注意:你不能在函数体之外使用if constexpr。因此，你不能使用它来替换预处理器的条件编译(#if / #ifdef)。**

## 2.1 编译期if的注意事项
### 1.编译期if可能影响返回值类型
**下面的代码总能通过编译，但返回值的类型可能会不同：**
```cpp
auto foo(){
	if constexpr(sizeof(int)>4){
		return 42;
	}
	else{
		return 42u;
	}
}
```
- 如果大于4字节，返回42的返回语句将会生效，因此返回值类型是int。
- 否则，返回42u的返回语句将生效，因此返回值类型是unsigned int。

### 2.即使在then部分返回也要考虑else部分
**运行期if有一个模式不能应用于编译期if**
- 如果代码在then和else部分都会返回，那么在运行期if中你可以跳过else部分
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107090515331.png)

## 2.2其他编译期if的示例
### 完美返回泛型值
- 先对返回值进行一些处理，再进行完美转发
- 因为decltype(auto)不能推导
为void（因为void是不完全类型），所以你必须像下面这么写：
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107091404987.png)


