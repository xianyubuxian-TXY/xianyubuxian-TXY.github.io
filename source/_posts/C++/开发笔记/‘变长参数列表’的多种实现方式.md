---
title: ‘变长参数列表’的多种实现方式
date: 2026-01-08 09:19:07
tags:
	- 笔记
categories:
    - C++
    - 开发笔记
    - 功能点
    - ‘变长参数列表’的多种实现方式
---

# 1.实现方式
- **参数类型有限 / 不修改参数 / 想实现简单** → std::initializer_list + std::variant；
- **参数类型多样** → 变参模板 typename... Args（如日志系统、线程池）；
- **需存储 / 修改参数** → std::vector + std::variant；



## 1.std::initializer_list + std::variant 

### (1)std::initializer_list介绍
#### <1>概述
- std::initializer_list 是 C++11 引入的轻量级模板类（头文件 <initializer_list>）
- **核心目标**：实现统一、简洁的 花括号 {} 初始化语法

#### <2>核心本质与特质
- **只读的轻量级视图**：内部仅存储「指向底层数组的指针 + 元素个数」，无内存拷贝，底层数组由编译器管理（只读，无法修改元素）；
- **模板类特性**：需指定元素类型（如 std::initializer_list<int>），支持范围 for、begin()/end() 遍历；
- **可拷贝但无开销**：拷贝仅复制指针和长度，不复制底层数组，生命周期与对象绑定（临时对象在语句结束后销毁）。

#### <3>std::initializer_list的使用（这里主要介绍与'变长参数相关的'）
1.通过 花括号{} 传入参数
2.通过for循环遍历读取值
```cpp
int sum(std::initializer_list<int> nums) {
    int total = 0;
    // 遍历变长参数列表
    for (int n : nums) {
        total += n;
    }
    return total;
}
// 传递不同数量的变长参数
std::cout << "sum(1,2,3) = " << sum({1,2,3}) << std::endl;          // 3个参数，输出：6
std::cout << "sum(10,20,30,40) = " << sum({10,20,30,40}) << std::endl; // 4个参数，输出：100
```

#### <4>关键避坑点
- **元素只读**：无法修改 initializer_list 内的元素（如 il[0] = 10 编译报错）；
- **生命周期陷阱**：不要保存其迭代器 / 指针到函数外部，否则会因底层数组销毁导致悬空指针；
- **空列表支持**：空列表 {} 合法，size() 返回 0，begin() == end()；

#### <5> 与vector的对比图
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108101908382.png)

### (2)std::variant介绍
**参考：**[16.std::variant](https://xianyubuxian-txy.github.io/2026/01/08/16-std-variant/)

### (3)std::initializer_list + std::variant 实现‘变长参数列表’ 实例
**目标：封装sql语句，允许其以（"INSERT INTO user (name, age, score) VALUES (?, ?, ?)",{"张三", 25, 95.5}）形式作为“参数”传递**
- '?'为“占位符”，也就要求原sql中，不可以有冗余的'?'造成干扰（这存在一定的局限性）
```cpp
// 万能盒子：能 NULL/int64/uint64/double/string 五种类型(可自行增加)
using Param = std::variant<std::nullptr_t, int64_t, uint64_t, double, std::string>;

std::string BuildSQL(const std::string& sql, std::initializer_list<Param> params){
    std::string result;
    result.reserve(sql.size()*2);  //预分配空间
    
    auto it = params.begin();  // 修正：parmas → params
    
    for(size_t i = 0; i < sql.size(); ++i){
        if(sql[i] == '?'){
            if(it == params.end()){
                throw std::invalid_argument("Not enough parameters");
            }
            
            //用 std::visit 解析 variant 的实际类型
            std::visit([&](auto&& arg){
                using T = std::decay_t<decltype(arg)>;
                
                // 编译期类型判断（constexpr if，C++17）
                if constexpr(std::is_same_v<T, std::nullptr_t>){
                    result += "NULL";  // NULL 类型直接拼 "NULL"
                } else if constexpr(std::is_same_v<T, std::int64_t>){
                    result += std::to_string(arg);  // 修正：加上std::
                } else if constexpr(std::is_same_v<T, std::uint64_t>){  // 修正：uint64 → uint64_t
                    result += std::to_string(arg);  // 修正：加上std::
                } else if constexpr(std::is_same_v<T, double>){  // 修正：std::double → double
                    result += std::to_string(arg);  // 修正：参数应为arg而非double
                } else if constexpr(std::is_same_v<T, std::string>){
                    result += '\'';  // 修正：缺少分号
                    result += arg;
                    result += '\'';
                }
            }, *it);
            
            ++it;  // 参数迭代器后移
        } else {
            result += sql[i];  // 非占位符，直接拼接字符
        }
    }
    
    if (it != params.end()) {
        throw std::invalid_argument("Too many parameters");  // 参数过多
    }
    
    return result;
}

// 函数声明（接收变长参数列表）
MySQLResult Query(const std::string& sql, std::initializer_list<Param> params);

// 调用者代码（极致简洁）
conn.Query("SELECT * FROM user WHERE name=? AND age=? AND height=?", {"张三", 25, 175});
conn.Execute("INSERT INTO user (name, age) VALUES (?, ?)", {"李四", 30});
```

### (4)优缺点 & 适用场景
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108103335014.png)




## 2.变参模板 template<typename... Args>
**之后再补充**

