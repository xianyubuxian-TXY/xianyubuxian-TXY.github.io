---
title: 模板编程常用技巧
date: 2026-01-07 09:35:46
tags:
	- 笔记
categories:
    - C++
    - 开发笔记
    - 泛型模板编程
---

# 1.编译期if语句
通过使用语法**if constexpr(...)**，编译器可以计算编译期的条件表达式来**在编译期决定**使用一个if语句
的then的部分还是else的部分。
**可参考**：[10 编译期if语句](https://xianyubuxian-txy.github.io/2026/01/07/10-编译期if语句/)

---
# 2.类型萃取（Type Traits） 工具
## 1.概述
**(1)头文件： #include\<type_traits\>**
**(2)功能：提供的编译期类型判断 / 转换工具，核心作用是在模板编程中获取或修改类型的属性，实现编译期决策。**

## 2.类型判断类（判断类型属性）
- 这类萃取工具以 is_xxx 命名，C++17 后提供 is_xxx_v 便捷别名（等价于 is_xxx<T>::value），返回编译期布尔常量。
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107100035470.png)

## 3.std::conditional_t<Condition, T, F> ：编译期条件类型选择工具
### 1.核心作用
- 根据一个**编译期布尔常量**，在两种类型（T 和 F）中选择其一
- 整个选择过程完全发生在编译阶段，不会产生任何运行时开销。
- 如果 Condition 为 true → 最终类型是 T
- 如果 Condition 为 false → 最终类型是 F

### 2.核心要求
- Condition 必须是编译期可确定的布尔值
	- true/false 字面量
	- constexpr 常量
	- static_assert
	- is_same_v、is_integral_v...
	- 等类型萃取的结果，不能是运行时才能确定的变量。

## 4.可调用对象相关类
**用于推导可调用对象（函数、Lambda、仿函数）的属性，是泛型回调、函数包装的核心工具。**
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260107120513290.png)

---
## 5.使用示例
### 连接池模板示例（部分代码）
**1.知识点：**
- if constexpr
- std::is_same_v
- std::conditional_t

**2.功能概述**
- 实现一个“连接池模板”，用于创建mysql、redis连接池
- mysql和redis都有各自的“配置”(通过文件加载)，连接池需要获取对应的配置来进行初始化
- 为获取对应的配置 ——>“连接池模板”需在编译期根据T的实际类型(MySQLConnection / RedisConnection)，获取对应“配置”(MySQLConfig / RedisConfig)
- 获取对应配置后，就可以获取对应的pool_size确定连接池大小，并将“配置”传给“创建连接回调函数”进行连接的创建
**注：个人能力有限，示例代码可能并不是很完美实用，仅作演示**
```cpp
#include <type_traits>
//mysql配置结构体
struct MySQLConfig{
	int pool_size=10;
	...
	int GetPoolSize() const{ return pool_size;}
};
//redis配置结构体
struct RedisConfig{
	int pool_size=5;
	...
	int GetPoolSize() const{ return pool_size;}
};
//全局配置结构体
struct GlobalConfig{
	MySQLConfig mysql;
	RedisConfig redis;
	...
}; 

/*-----------------------泛型连接池模板类部分代码-----------------*/
class MySQLConnection;
class RedisConnection;

template<typename T>
class TemplateConnectionPool{
public:
    using ConnectionPtr=std::unique_ptr<T>;

    //通过嵌套std::conditional_t在编译期确定“配置类型”
    using Config =  std::conditional_t<std::is_same_v<T, MySQLConnection>,MySQLConfig,
                    std::conditional_t<std::is_same_v<T, RedisConnection>,RedisConfig,
                    void>>;
    using ConfigPtr=std::shared_ptr<const Config>;

    TemplateConnectionPool(std::shared_ptr<GlobalConfig> global_config,std::function<ConnectionPtr(const Config&)>func)
    :createConnFunc_(std::move(func))
    {
        if(!global_config){
            throw std::invalid_argument("config is nullptr");
        }

        ExtractSubConfig(global_config); // 提取子配置
        InitPool();	//初始化连接池
    }
private:
	// 提取子配置（封装分支逻辑，便于后续扩展）
    void ExtractSubConfig(const std::shared_ptr<GlobalConfig>global_config){
    	// 编译期判断：如果是MySQL连接类型，提取mysql子配置
        if constexpr(std::is_same_v<T,MySQLConnection>){
            config_=std::make_shared<const Config>(global_config->mysql);
        }
        // 编译期判断：如果是Redis连接类型，提取redis子配置
        else if constexpr(std::is_same_v<T,RedisConnection>){
            config_=std::make_shared<const Config>(global_config->redis);
        }
        // 编译期兜底：非支持类型直接触发编译错误
        else{
            // static_assert(false)会强制编译失败，提示不支持的连接类型
        	// 注：std::is_void_v<T>仅作为占位，核心是触发编译报错
            static_assert(std::is_void_v<T>, "Unsupported connection type, no matching sub-config");
        }
    }

    void InitPool(){
    	//获取池大小
        int poolSize=config_->GetPoolSize();
        for(int i=0;i<poolSize;++i){
        	//将config_传入“回调函数”创建连接
            auto conn=std::move(createConnFunc_(*config_));
            if(!conn){
                throw std::runtime_error("failed to create connection");
            }
            pool_.push_back(std::move(conn));
        }
    }
private:
	std::deque<ConnectionPtr> pool_;	//连接池
	ConfigPtr config_;					//配置
	//创建连接回调函数
    std::function<ConnectionPtr(const Config&)> createConnFunc_;
	...
};
```

# 3.可变参数模板（variadic templates）
## 1.参数包（typename... Args）
### (1)概述
- **Args：一个占位符名字，可以任意取（常见 Args、Ts、Types 等）。**
- **typename... Args：告诉编译器 “这里有零个或多个类型参数，它们集合在一起叫做 Args”**
- **当你实例化模板时，可以给 Args 传入任意个类型：**
```cpp
template<typename... Args>
struct Tuple {};
// 实例化：
Tuple<>                t0;    // Args 为空包
Tuple<int>             t1;    // Args = {int}
Tuple<int, double, char> t3;  // Args = {int, double, char}
```
## 2.函数模板中的可变参数
```cpp
// 定义一个可接收任意类型、任意个参数的函数模板
template<typename... Args>
void logAll(Args&&... args) {
     (std::cout << ... << args) << '\n'; // C++17 折叠表达式
}

// 调用示例
logAll(1, " + ", 2.5, " = ", 3.5);
```
**Args常配合其它库函数使用，这里就不演示“解包”了**

## 3.使用示例
### 线程池“任务提交函数”
**1.本节相关知识点：**
- typename... Args：做可变参数
- std::invoke_result_t：推导返回值类型
```cpp
// submitTask：把 func 和 args 绑定成一个无参的可调用对象，直接打包进 packaged_task
template <typename Func, typename... Args>
auto submitTask(Func&& func, Args&&... args)
    -> std::future<std::invoke_result_t<std::decay_t<Func>,
                                       std::decay_t<Args>...>>
{
    using DecayF    = std::decay_t<Func>;
    using RType     = std::invoke_result_t<DecayF, std::decay_t<Args>...>;

    // 1) 把 func 和 args 全部 decay 后，bind_front 绑定成一个 RType() 可调用对象 （std::bind_front 是 C++20 的特性）
    auto bound = std::bind_front( DecayF(std::forward<Func>(func)),
                                  std::forward<Args>(args)... );

    // 2) 用这个 “无参可调用对象” 构造 packaged_task
    auto taskPtr = std::make_shared<std::packaged_task<RType()>>(std::move(bound));
    auto result  = taskPtr->get_future();

    // 3) 直接在新线程里执行它
    std::thread([taskPtr]() mutable {
        // packaged_task 在调用 operator() 时，
        // 内部会用 std::invoke 特殊处理各种可调用对象
        (*taskPtr)();
    }).detach();

    return result;
}
```
**这里主要想演示一下"typename... Args"、"std::invoke_result_t"的使用场景**


# 4."类型traits映射" 技巧
## 1.核心思路

### (1)声明一个“空”主模板（primary template）
**不给它任何定义**
```cpp
template<typename> 
struct connection_config;  // 只是声明，不定义
```
- 如果有人写 connection_config<SomeType>，而你又没有给出对 SomeType 的特化，编译器就会立刻报“找不到 connection_config<SomeType>::type”的错误，提示“这个类型不受支持”。

### (2)对受支持的类型做显式特化（explicit specialization）
**在特化里定义一个 using type = …;**
```cpp
// 只为 MySQLConnection 提供映射
template<> 
struct connection_config<MySQLConnection> { 
  using type = MySQLConfig; 
};

// 只为 RedisConnection 提供映射
template<> 
struct connection_config<RedisConnection> { 
  using type = RedisConfig; 
};
```
- 这样，connection_config<MySQLConnection>::type 就是 MySQLConfig，而 connection_config<RedisConnection>::type 就是 RedisConfig。

### (3)再用一个 alias template（别名模板）简化写法：
```cpp
template<class T>
using Config_t = typename connection_config<T>::type;
```
**注意：必须使用 typename 告诉编译器connection_config<T>::type是“类型”，否则编译器无法知道它是“类型”还是“变量”**
- 以后在代码里直接写 Config_t<T>，就等同于 connection_config<T>::type，更简洁。

### (4)为什么这么做？
**1.集中管理支持列表**：所有支持的连接类型映射都集中在 connection_config<…> 的特化里，新加一种连接只要加一个特化即可，其他逻辑不用改。
**2.这种模式在 C++ 标准库里也很常见**：比如 std::iterator_traits<Iter>、std::char_traits<Char>、std::common_type<T,U>、std::hash<T> 等，都是“空主模板 + 针对受支持类型的特化 + alias template” 组合的变体。

### (5)实例： 对泛型连接池模板进行一定的优化
```cpp
#include <type_traits>
//mysql配置结构体
struct MySQLConfig{
	int pool_size=10;
	...
	int GetPoolSize() const{ return pool_size;}
};
//redis配置结构体
struct RedisConfig{
	int pool_size=5;
	...
	int GetPoolSize() const{ return pool_size;}
};
//全局配置结构体
struct GlobalConfig{
	MySQLConfig mysql;
	RedisConfig redis;
	...
};

/*-----------------------类型traits映射-------------------------*/
class MySQLConnection;
class RedisConnection;

template<typename>
struct ConnectionConfig;

template<>
struct ConnectionConfig<MySQLConnection>{using type=MySQLConfig;};

template<>
struct ConnectionConfig<RedisConnection>{using type=RedisConfig;};

//typename： 告诉编译器ConnectionConfig<T>::type为类型
template<typename T>
using Config_t= typename ConnectionConfig<T>::type;  

/*-----------------------泛型连接池模板类部分代码-----------------*/
// always_false 模板，用于依赖式 static_assert
template<typename U>
inline constexpr bool always_false = false;

template<typename T>
class TemplateConnectionPool{
public:
    using ConnectionPtr=std::unique_ptr<T>;
    using Config=Config_t<T>;
    using ConfigPtr=std::shared_ptr<const Config>;	
    using CreateFunc=std::function<ConnectionPtr(const Config&)>;

    TemplateConnectionPool(std::shared_ptr<GlobalConfig> global_config,CreateFunc func)
    :createConnFunc_(std::move(func))
    {
        if(!global_config){
            throw std::invalid_argument("config is nullptr");
        }

        ExtractSubConfig(global_config); // 提取子配置
        InitPool();	//初始化连接池
    }
private:
	// 提取子配置（封装分支逻辑，便于后续扩展）
    void ExtractSubConfig(const std::shared_ptr<GlobalConfig>global_config){
    	// 编译期判断：如果是MySQL连接类型，提取mysql子配置
        if constexpr(std::is_same_v<T,MySQLConnection>){
            config_=std::make_shared<const Config>(global_config->mysql);
        }
        // 编译期判断：如果是Redis连接类型，提取redis子配置
        else if constexpr(std::is_same_v<T,RedisConnection>){
            config_=std::make_shared<const Config>(global_config->redis);
        }
        // 编译期兜底：非支持类型直接触发编译错误
        else{
			// 不应该到这里：若没有对应的 connection_config 特化，上面的 using Config 已经报错了
            static_assert(always_false<T>, "Unsupported connection type, no matching sub-config");
        }
    }

    void InitPool(){
    	//获取池大小
        int poolSize=config_->GetPoolSize();
        for(int i=0;i<poolSize;++i){
        	//将config_传入“回调函数”创建连接
            auto conn=std::move(createConnFunc_(*config_));
            if(!conn){
                throw std::runtime_error("failed to create connection");
            }
            pool_.push_back(std::move(conn));
        }
    }
private:
	std::deque<ConnectionPtr> pool_;	//连接池
	ConfigPtr config_;					//配置
	//创建连接回调函数
    CreateFunc createConnFunc_;
	...
};
```

## 2.补充：“只声明主模板,不给出定义 + 特化”
### (1)声明而不定义：不完整类型（incomplete type）
```cpp
template<typename> 
struct ConnectionConfig;  // 这里只有声明，没有定义
```
1.这行代码告诉编译器 “存在一个模版 ConnectionConfig<T>”，但你没有给它任何成员或定义。
2.因此，对于任意 T，ConnectionConfig<T> 都是一个 不完整类型，除非后面有特化（template<> struct ConnectionConfig<Foo> { ... };）给出完整定义。
3.如果用为提供“特化”的类型进行“实例化”——>“报错”

### (2)完全特化
**注：也可以配合“部分特化”，但我暂时未遇到"部分特化"，这里就不描述了**
#### <1>语法：
```cpp
// 主模板（需先声明或定义）
template<typename T>
//struct Foo { /* primary template */ };	//定义
struct Foo;	//声明

// 完全特化：用 template<>，并把所有参数具体化
template<>
struct Foo<int> { /* specialization for int */ };
```
#### <2>语法要点
- **必须写template<>（空模板参数表），然后给出具体参数。**
- **特化体可以与主模板完全不同（成员名/行为可不同）。**
- 完全特化是对某一具体类型的替代定义（不是重载）。
