---
title: 2.最长公共子序列(二)
date: 2026-01-08 23:36:51
tags:
	- oj
	- 笔试
categories:
	- 编程题
	- 动态规划
    - 字符串
---

# 1.题目
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260108234255173.png)

# 2.代码实现
**涉及技巧：回溯构建结果**

## 1.二维数组dp实现
```cpp
    string LCS(string s1, string s2) {
        // write code here
        int m = s1.size();
        int n = s2.size();
        if (m == 0 || n == 0) return "-1";
        
        // 只存储长度的DP表
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        // 检查是否存在公共子序列
        if (dp[m][n] == 0) return "-1";
        
        // 回溯构建结果
        string result;
        int i = m, j = n;
        while (i > 0 && j > 0) {
            if (s1[i - 1] == s2[j - 1]) {
                result.push_back(s1[i - 1]);
                i--; j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }
        reverse(result.begin(), result.end());
        return result;
    }
```

