---
title: 0.总结
date: 2026-01-08 22:53:01
tags:
	- oj
	- 笔试
categories:
	- 编程题
	- 动态规划
	- 字符串
---

# 一、核心思考方向
## 1.状态定义：dp数组含义
**1.单字符串**：
- dp[i]
	- 表示**s的前i个字符**的某种性质
	- 表示**以第i个字符结尾**的某种性质
- dp[i][j]
	- 表示**s[i...j]子串**的某种性质
- dp[i][j][k]
	- 带有**额外限制条件**的字符串问题
**2.双字符串**：
- dp[i][j]
	- 表示**s1的前i个字符**与**s2的前j个字符**的最优解
- dp[i][j][k]
	- 带有**额外限制条件**的字符串问题
- dp[i][j][k][t]
	- s1[i..j] 与 s2[k..t]的某种性质

## 2.边界条件：初始化dp数组
字符串DP的边界通常对应**空串**场景，是**状态转移的起点**,例如：
```cpp

int len1=s1.size();
int len2=s2.size();

//dp[0][j]=0 dp[i][0]=0 都表示其中一个为“空串”，故都设置为0
//dp[i][j]表示s1的前i个字符，s2的前j个字符（从1开始）
vector<vector<int>> dp(len1+1,vector<int>(len2+1,0));
for(int i=1;i<=len1;++i){
	for(int j=1;j<=len2;++j){
		if(s1[i-1]==s2[j-1]){
			......
		}else{
			......
		}
	}
}
```

## 3.状态转移
1.**s1=[i-1]==s2[j-1]**:
- dp[i][j]=opt(dp[i-1][j-1])：opt()表示dp[i-1][j-1]进行某种处理，如dp[i-1][j-1]+1

2.**s1[i-1]!=s2[j-1]**
- dp[i][j]=( opt(dp[i-1][j]) || opt(dp[i][j-1]) || opt(dp[i-1][j-1]) )

## 4.遍历顺序
- 左上到右下（二维DP典型方向）
- 斜对角遍历（处理子串或回文相关问题）
- 从短到长递推（区间DP）

# 二、常见技巧
## 1.空间优化
- **滚动数组**：用两行或一行替代整个二维数组
	- 例：{% post_link 1.最长公共子序列(一) '最长公共子序列（一）' %}
- 使用单一数组+临时变量记录左上角值
- 根据依赖方向调整遍历顺序（如从右到左）

## 2.回溯构建结果
- 使用DP表**从终点回溯到起点**重建结果
	- 例：{% post_link 2.最长公共子序列(二) '最长公共子序列（二）' %}
- 在DP过程中记录转移来源（路径数组）

 
## 3.预处理技巧
- **哈希**或**前缀和**加速子串查询
- 预先计算特定字符的位置信息

## 4.状态压缩技巧
- 对于短字符串，可以用**位运算表示状态**，加速DP过程

## 5.递归+记忆化搜索
- 某些字符串DP问题用自顶向下的记忆化搜索更直观
- 特别是状态转移复杂或条件多的情况

## 6.回文类问题的特殊处理
- **中心扩展法结合 DP**：对每个字符 / 每两个字符作为中心，向两边扩展，结合 DP 记录已判断的回文子串（避免重复计算）；
- **Manacher 算法**：线性时间求解最长回文子串（针对 DP 的 O (n²) 优化），核心是利用回文的对称性减少重复判断。
