---
title: 1.最长公共子序列(一)
date: 2026-01-09 00:06:43
tags:
	- oj
	- 笔试
categories:
	- 编程题
	- 动态规划
	- 字符串
---

# 1.题目
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109001047053.png)

# 2.代码实现
## 1.普通版
**时间复杂度和空间复杂度：O(m×n)**
```cpp
    int LCS(string s1, string s2) {
        // write code here
        int m = s1.size();
        int n = s2.size();
        if (m == 0 || n == 0) return 0;
        
        // 只存储长度的DP表
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
```

## 2.空间优化版（滚动数组）
**时间复杂度和空间复杂度：O(m×n)时间 和 O(n)空间）**
```cpp
int LCS(string s1, string s2) {
    int m = s1.size();
    int n = s2.size();
    if (m == 0 || n == 0) return 0;
    
    // 使用一维数组
    vector<int> dp(n + 1, 0);
    
    for (int i = 1; i <= m; i++) {
        int prev = 0;  // 存储上一轮的dp[j-1]，即左上角元素
        for (int j = 1; j <= n; j++) {
            int temp = dp[j];  // 暂存当前dp[j]，下一轮将成为新的左上角元素
            if (s1[i - 1] == s2[j - 1]) {
                dp[j] = prev + 1;
            } else {
                dp[j] = max(dp[j], dp[j - 1]); // dp[j]此时保存的是dp[i-1][j]，dp[j-1]已更新为dp[i][j-1]
            }
            prev = temp;  // 更新左上角元素
        }
    }
    
    return dp[n];
}

```
### 原理解析：

#### 1.先看“普通版本”
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/7ded7ab8ec9bb8f8d473272ae01f5aa3.jpg)
- dp[i][j]是我们当前需要求的，由“普通版”可知，它与dp[i-1][j-1]、dp[i][j-1]、dp[i-1][j]有关
- 由图可知：dp[i-1][j-1]、dp[i][j-1]、dp[i-1][j]分别位于dp[i][j]的“左上角”、“上方”、“左方”
- 显然：在求第i行dp[i,j]时，只需用到dp[i-1][j-1]、dp[i][j-1]、dp[i-1][j] ——>即“上一行的值”+“dp[i][j-1]”的值 ——>dp为一维数组即可
	- 为什么上一行的值都需要存储？ 因为要求取第i行每一列

### 2.再看“滚动数组”版本
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/9965aa62cf907c149bfafaf73fdf7a58.jpg)
**为与1中dp区分，这里用DP代替dp**
- 我们已知：用一维数组DP[j]存储上一行的值（这种说法并不准确，见下文）
- 由图+代码实现： prev存储“左上角元素”
	- 当j=1时：没有“左上角元素”，设置为0即可（或者说有(i,0),表示空串,DP[0]=0）
	- 当j!=1时：显然我们已经可获取dp[i-1][j-1]（pre存储）、dp[i][j-1]（DP[j]存储）,那dp[i-1][j]呢？
- 当我们在求dp[i][j]时，显然dp[i][j-1]我们已经求取了，我们会将DP[j-1]更新为dp[i][j-1]（见代码）——>故此时DP[j-1]=dp[i-1][j] （准确说DP[j-k]都更新了！）——>我想这也是**滚动数组**的由来
	- 这里也解释了DP[j]存储上一行的值“并不准确”：应该说DP在每一轮开始时，存储了上一行的值
- 因此在求取dp[i][j]后，DP[j]会被更新为dp[i][j],所以需要用一个temp存储，也将作为下一轮的“左上角元素”，赋予到prev中
- 至此，结合“代码实现”+“图”应该能够理解整个过程


