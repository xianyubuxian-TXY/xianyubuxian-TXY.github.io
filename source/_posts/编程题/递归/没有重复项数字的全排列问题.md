---
title: 没有重复项数字的全排列问题
date: 2026-01-02 22:00:22
tags:
	- oj
	- 笔试
categories: 
	- 编程题
	- 递归/回溯
---

# 1.题目描述
![题目描述](/images/没有重复项数字的全排列问题.png)


# 2.问题分析：
	明显的一种想法：
	- 第一个数有n种可能，第二个数有n-1中可能，....,最后一个数
	- 从小到达遍历，每次挑选一个还未被挑选的数，被挑选了的则标记为“被访问状态”
	- 如果用for循环，则需要n层，而明显写不出——>递归此时似乎是很直观的一种选择

# 3.解决方法：递归
## (1) 普通方法
	1.每次从小到达遍历，挑选第一个未被挑选的数字，然后设置为“被访问”状态
	2.注意点：记得回溯
```cpp
//res:存放结果  num:原数组  tmp:存储每次递归的结果  visit:访问数组  floor:递归层数  size:num数组的大小
void find(vector<vector<int>>& res,vector<int>& num,vector<int>tmp,vector<bool>& visit,int floor,int size){
    if(floor==size) res.push_back(tmp); 
    else{
        //每次从0开始遍历所有数字
        for(int i=0;i<size;++i){
            if(visit[i]) continue; //被访问，则跳过
            //tmp[floor]表示存储该层被挑选的数字
            //num[i]未被访问，则加入，并将其在visit中的状态设置为true
            tmp[floor]=num[i];
            visit[i]=true;
            find(res,num,tmp,visit,floor+1,size); //递归进入下一层
            visit[i]=false; //回溯:因为后面的递归仍可挑选num[i]
        }
    }
}

vector<vector<int>> permute(vector<int>& num) {
    // write code here
    vector<vector<int>> res;
    int size=num.size();
    if(size==0) return res;
    else if(size==1)
    {
        res.push_back(num);
        return res;
    }
    else {
        vector<int> tmp(size,-1);
        vector<bool> visit(size,false);
        find(res,num,tmp,visit,0,size);
    }
    return res;
}
```



## (2) 原地交换的回溯 （常见、高效、空间少）
关键解析：
	1.floor表示递归层数，也表示挑选了的个数，从0——>size 依次递增，floor==size表示全部挑选（结束递归）
	2.每一次调用，num[floor]存储当前调用挑选的数字——>通过swap(num[floor],num[i])原地交换实现
	3.因为num是‘引用传递’，且floor递增，故当第floor层执行完swap后，num[0,floor]都是被挑选了的,num[floor+1,size]则还未被挑选（因为1,2...,floor-1都执行了swap）——>这也是为什么每一层都从i=floor开始循环
	4.注意点：因为num是'引用传递'，故递归调用完后，需要'回溯'（交换回来）

```cpp
void dfs(vector<vector<int>>& res,vector<int>& num,int floor,int size){
    if(floor==size) res.push_back(num);
    else{
        for(int i=floor;i<size;++i){
            swap(num[floor],num[i]); //交换后：num[0,floor]都是被选择的了，num[floor+1,size)则是还未被选择的
            dfs(res,num,floor+1,size); //递归：选择下一个
            swap(num[i],num[floor]); //回溯
        }
    }
}

vector<vector<int>> permute(vector<int>& num) {
    // write code here
    vector<vector<int>> res;
    int size=num.size();
    if(size==0) return res;
    else if(size==1)
    {
        res.push_back(num);
        return res;
    }
    else {
        dfs(res,num,0,size);
    }
    return res;
}
```