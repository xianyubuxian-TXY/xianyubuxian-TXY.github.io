---
title: 第二章：丰富的序列
date: 2026-01-06 08:10:10
tags:
	- 笔记
categories:
	- 《流畅的python》
	- 第2章 丰富的序列
---

# 1.内置序列类型概览
## (1)“序列类型”按存放分类
#### 1. 容器序列：list、tuple、collections.deque
- 可存放不同类型的项
- 存放的是所包含对象的引用，对象可以是任意类型

#### 2. 扁平序列：str、bytes、array.array
- 可存放一种简单类型的项
- 在自己的内存空间中存储所含内容的值

![内存简图](/images/2026.1.6_1.png)

## (2)“序列类型”按可变性分类
#### 1. 可变序列：list、collections.deque、bytearray、array.array
- 可变序列继承不可变序列的所有方法，另外还多实现了几个方法

#### 2. 不可变序列：tuple、str、bytes

![简化UML类图](/images/2026.1.6_2.png)  

---
# 2.“列表推导式（listcomps）”和“生成器表达式（genexps）”
- 使用“列表推导式”或“生成器表达式”可以快速构建一个序列
- 代码更容易理解，速度通常更快

## (1)列表推导式（目标：列表）
### <1>基本语法结构： [ expression for item in iterable [if condition] ]
```python
# 例1：无if
>>> symbols = '$¢£¥€¤' 
>>> codes = [ord(symbol) for symbol in symbols] 
>>> codes 
[36, 162, 163, 165, 8364, 164]

# 例2：有if
>>> symbols = '$¢£¥€¤' 
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127] 
>>> beyond_ascii 
[162, 163, 165, 8364, 164] 

# 例3：生成“笛卡尔积”（双循环）
>>> colors = ['black', 'white'] 
>>> sizes = ['S', 'M', 'L'] 
>>> tshirts = [(color, size) for color in colors for size in sizes] 
>>> tshirts 
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), 
    ('white', 'M'), ('white', 'L')]
```

### <2>建议
- 如果你不打算使用生成的列表，那就不要使用列表推导式句法。
- 列表推导式应保持简短，如果超过两行，最好把语句拆开，或者使用传统的 for 循环重写


## (2)生成器表达式（目标：其它序列类型）
### <1>概述
- 生成器表达式的句法跟列表推导式几乎一样，只不过把方括号换成圆括号而已。
- 虽然列表推导式也可以生成元组、数组或其他类型的序列，但是生成器表达式占用的内存更少。

### <2>基本语法：(expression for item in iterable [if condition])
```python
# 例1：构建一个元组
>>> symbols = '$¢£¥€¤' 
>>> tuple(ord(symbol) for symbol in symbols)
(36, 162, 163, 165, 8364, 164) 

# 例2：构建一个数组
>>> import array 
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [36, 162, 163, 165, 8364, 164])

# 例3：生成“笛卡尔积”
>>> colors = ['black', 'white'] 
>>> sizes = ['S', 'M', 'L'] 
>>> for tshirt in (f'{c} {s}' for c in colors for s in sizes): 
...     print(tshirt) 
... 
black S 
black M 
```
- 如果生成器表达式是函数唯一的参数，则不需要额外再使用圆括号括起来。
-  array 构造函数接受两个参数，因此必须在生成器表达式两侧加上圆括号。

## (3)两者对比表
### <1>核心特点对比表
![对比表](/images/2026.1.6_4.png)

### <2>使用场景对比表
![对比表](/images/2026.1.6_3.png)

---
# 3.元组不仅仅是不可变列表
## (1)用作记录
- 用元组存放记录，元组中的一项对应一个字段的数据，项的位置决定数据的意义。
```python
# 洛杉矶国际机场的经纬度。
>>> lax_coordinates = (33.9425, -118.408056)
# 
>>>traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'),('ESP', 'XDA205856')] 

>>> for passport in sorted(traveler_ids): 
		print('%s/%s' % passport)
>>> for country, _ in traveler_ids:  ❻ 
		print(country) 
```
-  % 格式化运算符理解元组结构，把每一项当作不同的字段。
-  for 循环知道如何获取元组中单独的每一项，这叫**“元组拆包”**。这里对第二项不感兴趣，把它赋值给虚拟变量。

## (2)用作不可变列表
#### <1>好处
1.意图清晰：只要在源码中见到元组，就知道它的长度永不可变。
2.性能优越：长度相同的元组和列表，元组占用的内存更少，而且 Python 可对
元组做些优化。
#### <2>注意点：
元组的不可变性仅针对元组中的引用而言。元组中的
引用不可删除、不可替换。倘若引用的是可变对象，改动对象之后，元
组的值也会随之变化。
```python
# 修改 b 中的最后一项，b 和 a 不相等了。
>>> a = (10, 'alpha', [1, 2]) 
>>> b = (10, 'alpha', [1, 2]) 
>>> a == b 
True 
>>> b[-1].append(99) 
>>> a == b 
False 
>>> b 
(10, 'alpha', [1, 2, 99])
```

## (3)列表和元组方法的比较
![比较图](/images/2026.1.6_5.png)
![比较图](/images/2026.1.6_6.png)

---
# 4.序列和可迭代对象拆包
- 拆包的特点是不用我们自己动手通过索引从序列中提取元素，这样就减少了出错的可能。

### <1>并行赋值
```python
>>> lax_coordinates = (33.9425, -118.408056) 
>>> latitude, longitude = lax_coordinates  # 拆包 
>>> latitude 
33.9425 
>>> longitud
``` 

### <2>调用函数时在参数前面加上一个 *
```python
>>> divmod(20, 8) 
(2, 4) 
>>> t = (20, 8) 
>>> divmod(*t) 
(2, 4) 
>>> quotient, remainder = divmod(*t) 
>>> quotient, remainder 
(2, 4)
```

### <3>使用 * 获取余下的项
```python
>>> a, b, *rest = range(5) 
>>> a, b, rest 
(0, 1, [2, 3, 4]) 
```
##### 注： * 前缀只能应用到一个变量上，不过可以是任何位置上的变量。
```python
>>> a, *body, c, d = range(5) 
>>> a, body, c, d 
(0, [1, 2], 3, 4) 
>>> *head, b, c, d = range(5) 
>>> head, b, c, d 
([0, 1], 2, 3, 4)
```

### <4>在函数调用和序列字面量中使用 * 拆包
```python
# 例1：在函数调用中可以多次使用 *
>>> def fun(a, b, c, d, *rest): 
...     return a, b, c, d, rest 
>>> fun(*[1, 2], 3, *range(4, 7)) 
(1, 2, 3, 4, (5, 6))

# 例2：定义列表、元组或集合字面量时，使用 *
>>> *range(4), 4 
(0, 1, 2, 3, 4) 
>>> [*range(4), 4] 
[0, 1, 2, 3, 4] 
>>> {*range(4), 4, *(5, 6, 7)} 
{0, 1, 2, 3, 4, 5, 6, 7}
```

### <5>嵌套拆包
```python
>>>nested_tuple = (("张三", 25), ("李四", 30))
>>>(name1, age1), (name2, age2) = nested_tuple
```

---
# 5.序列模式匹配（match/case）
### 示例1
![图片](/images/2026.1.6_7.png)
![图片](/images/2026.1.6_8.png)
### 示例2
![图片](/images/2026.1.6_9.png)
![图片](/images/2026.1.6_10.png)
### 示例3：as关键字绑定变量
![图片](/images/2026.1.6_11.png)
### 示例4：添加类型信息可以让模式更具体
![图片](/images/2026.1.6_12.png)
### 示例5：*_ 匹配任意数量的项
- 匹配任何以字符串开头、以嵌套两个浮点数的序列结尾的序列
![图片](/images/2026.1.6_13.png)
### 示例6：if语句
![图片](/images/2026.1.6_14.png)

---
# 6.切片
### (1)为什么切片和区间排除最后一项？
![解析](/images/2026.1.6_15.png)
### (2)切片对象slice
#### 1. seq[start:stop:step] 句法 ——>指定步距step，让切片操作跳过部分项。步距也可以是负数，反向返回项。
```python
>>> s = 'bicycle' 
>>> s[::3] 
'bye' 
>>> s[::-1] 
'elcycib' 
>>> s[::-2] 
'eccb'
```
#### 2.命名切片
![示例](/images/2026.1.6_16.png)

### (3)多维切片和省略号
![图片](/images/2026.1.6_17.png)
![图片](/images/2026.1.6_18.png)

### (4)为切片赋值
1.在赋值语句的左侧使用切片表示法，或者作为 del 语句的目标，可以就
地移植、切除或以其他方式修改可变序列。
2.如果赋值目标是一个切片，则右边必须是一个可迭代对象，即使只有
一项
```python
>>> l = list(range(10)) 
>>> l 
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
>>> l[2:5] = [20, 30] 
>>> l 
[0, 1, 20, 30, 5, 6, 7, 8, 9] 
>>> del l[5:7] 
>>> l 
[0, 1, 20, 30, 5, 8, 9] 
>>> l[3::2] = [11, 22] 
>>> l 
[0, 1, 20, 11, 5, 22, 9] 
>>> l[2:5] = 100  ❶ 
Traceback (most recent call last): 
    File "<stdin>", line 1, in <module> 
TypeError: can only assign an iterable 
>>> l[2:5] = [100] 
>>> l 
[0, 1, 100, 22, 9]
```

# 7.使用 + 和 * 处理序列
### (1)概述
1.通常，+ 的两个运算对象必须是同一种序列，而且都不可修改，拼接的结果是一个同类型的新序列。
2.如果想多次拼接同一个序列，可以乘以一个整数
3.+ 和 * 始终创建一个新对象，绝不更改操作数。
```python
>>> l = [1, 2, 3] 
>>> l * 5 
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] 
>>> 5 * 'abcd' 
'abcdabcdabcdabcdabcd'
```
##### 注意：
![图片](/images/2026.1.6_19.png)

### (2)构建嵌套列表
![图片](/images/2026.1.6_20.png)
![图片](/images/2026.1.6_21.png)
**不理解本节所讲的问题或解决方案，没关系——>第 6 章
就是为了阐明引用和可变对象的机制和陷阱而编写的。**

### (3)使用增量赋值运算符处理序列
1.增量赋值运算符 += 和 \*= 的行为差异较大,
2.，本节重点关注增量加法运算符（+=），不过相关概念也
适用于 * = 和其他增量赋值运算符
#### += 运算符
1.背后支持 += 运算符的是特殊方法 \_\_iadd\_\_（就地相加） 
2.如果没有实现 \_\_iadd\_\_，那么 Python 转而调用 \_\_add\_\_
![图片](/images/2026.1.6_22.png)