---
title: 第二章：丰富的序列
date: 2026-01-06 08:10:10
tags:
	- 笔记
categories:
	- Python
	- 《流畅的python》
	- 第2章 丰富的序列
---

# 一、内置序列类型概览
## 1.“序列类型”按存放分类
### （1）容器序列：list、tuple、collections.deque
- 可存放不同类型的项
- 存放的是所包含对象的引用，对象可以是任意类型

### （2）扁平序列：str、bytes、array.array
- 可存放一种简单类型的项
- 在自己的内存空间中存储所含内容的值

![内存简图](/images/2026.1.6_1.png)

## 2.“序列类型”按可变性分类
### （1）可变序列：list、collections.deque、bytearray、array.array
- 可变序列继承不可变序列的所有方法，另外还多实现了几个方法

### （2）不可变序列：tuple、str、bytes

![简化UML类图](/images/2026.1.6_2.png)  

---
# 二、“列表推导式（listcomps）”和“生成器表达式（genexps）”
- 使用“列表推导式”或“生成器表达式”可以快速构建一个序列
- 代码更容易理解，速度通常更快

## 1.列表推导式（目标：列表）
### （1）基本语法结构： [ expression for item in iterable [if condition] ]
```python
# 例1：无if
>>> symbols = '$¢£¥€¤' 
>>> codes = [ord(symbol) for symbol in symbols] 
>>> codes 
[36, 162, 163, 165, 8364, 164]

# 例2：有if
>>> symbols = '$¢£¥€¤' 
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127] 
>>> beyond_ascii 
[162, 163, 165, 8364, 164] 

# 例3：生成“笛卡尔积”（双循环）
>>> colors = ['black', 'white'] 
>>> sizes = ['S', 'M', 'L'] 
>>> tshirts = [(color, size) for color in colors for size in sizes] 
>>> tshirts 
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), 
    ('white', 'M'), ('white', 'L')]
```

### （2）建议
- 如果你不打算使用生成的列表，那就不要使用列表推导式句法。
- 列表推导式应保持简短，如果超过两行，最好把语句拆开，或者使用传统的 for 循环重写


## 2.生成器表达式（目标：其它序列类型）
### （1）概述
- 生成器表达式的句法跟列表推导式几乎一样，只不过把方括号换成圆括号而已。
- 虽然列表推导式也可以生成元组、数组或其他类型的序列，但是生成器表达式占用的内存更少。

### （2）基本语法：(expression for item in iterable [if condition])
```python
# 例1：构建一个元组
>>> symbols = '$¢£¥€¤' 
>>> tuple(ord(symbol) for symbol in symbols)
(36, 162, 163, 165, 8364, 164) 

# 例2：构建一个数组
>>> import array 
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [36, 162, 163, 165, 8364, 164])

# 例3：生成“笛卡尔积”
>>> colors = ['black', 'white'] 
>>> sizes = ['S', 'M', 'L'] 
>>> for tshirt in (f'{c} {s}' for c in colors for s in sizes): 
...     print(tshirt) 
... 
black S 
black M 
```
- 如果生成器表达式是函数唯一的参数，则不需要额外再使用圆括号括起来。
-  array 构造函数接受两个参数，因此必须在生成器表达式两侧加上圆括号。

## 3.两者对比表
### （1）核心特点对比表
![对比表](/images/2026.1.6_4.png)

### （2）使用场景对比表
![对比表](/images/2026.1.6_3.png)

---
# 三、元组不仅仅是不可变列表
## 1.用作记录
- 用元组存放记录，元组中的一项对应一个字段的数据，项的位置决定数据的意义。
```python
# 洛杉矶国际机场的经纬度。
>>> lax_coordinates = (33.9425, -118.408056)
# 
>>>traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'),('ESP', 'XDA205856')] 

>>> for passport in sorted(traveler_ids): 
		print('%s/%s' % passport)
>>> for country, _ in traveler_ids:  ❻ 
		print(country) 
```
-  % 格式化运算符理解元组结构，把每一项当作不同的字段。
-  for 循环知道如何获取元组中单独的每一项，这叫**“元组拆包”**。这里对第二项不感兴趣，把它赋值给虚拟变量。

## 2.用作不可变列表
### （1）好处
1.意图清晰：只要在源码中见到元组，就知道它的长度永不可变。
2.性能优越：长度相同的元组和列表，元组占用的内存更少，而且 Python 可对
元组做些优化。
### （2）注意点：
元组的不可变性仅针对元组中的引用而言。元组中的
引用不可删除、不可替换。倘若引用的是可变对象，改动对象之后，元
组的值也会随之变化。
```python
# 修改 b 中的最后一项，b 和 a 不相等了。
>>> a = (10, 'alpha', [1, 2]) 
>>> b = (10, 'alpha', [1, 2]) 
>>> a == b 
True 
>>> b[-1].append(99) 
>>> a == b 
False 
>>> b 
(10, 'alpha', [1, 2, 99])
```

## 3.列表和元组方法的比较
![比较图](/images/2026.1.6_5.png)
![比较图](/images/2026.1.6_6.png)

---
# 四、序列和可迭代对象拆包
**拆包的特点是不用我们自己动手通过索引从序列中提取元素，这样就减少了出错的可能。**

## 1.并行赋值
```python
>>> lax_coordinates = (33.9425, -118.408056) 
>>> latitude, longitude = lax_coordinates  # 拆包 
>>> latitude 
33.9425 
>>> longitud
``` 

## 2.调用函数时在参数前面加上一个 *
```python
>>> divmod(20, 8) 
(2, 4) 
>>> t = (20, 8) 
>>> divmod(*t) 
(2, 4) 
>>> quotient, remainder = divmod(*t) 
>>> quotient, remainder 
(2, 4)
```

## 3.使用 * 获取余下的项
```python
>>> a, b, *rest = range(5) 
>>> a, b, rest 
(0, 1, [2, 3, 4]) 
```
**注**： * 前缀只能应用到一个变量上，不过可以是任何位置上的变量。
```python
>>> a, *body, c, d = range(5) 
>>> a, body, c, d 
(0, [1, 2], 3, 4) 
>>> *head, b, c, d = range(5) 
>>> head, b, c, d 
([0, 1], 2, 3, 4)
```

## 4.在函数调用和序列字面量中使用 * 拆包
```python
# 例1：在函数调用中可以多次使用 *
>>> def fun(a, b, c, d, *rest): 
...     return a, b, c, d, rest 
>>> fun(*[1, 2], 3, *range(4, 7)) 
(1, 2, 3, 4, (5, 6))

# 例2：定义列表、元组或集合字面量时，使用 *
>>> *range(4), 4 
(0, 1, 2, 3, 4) 
>>> [*range(4), 4] 
[0, 1, 2, 3, 4] 
>>> {*range(4), 4, *(5, 6, 7)} 
{0, 1, 2, 3, 4, 5, 6, 7}
```

## 5.嵌套拆包
```python
>>>nested_tuple = (("张三", 25), ("李四", 30))
>>>(name1, age1), (name2, age2) = nested_tuple
```

---
# 五、序列模式匹配（match/case）
## 1.示例1
![图片](/images/2026.1.6_7.png)
![图片](/images/2026.1.6_8.png)
## 2.示例2
![图片](/images/2026.1.6_9.png)
![图片](/images/2026.1.6_10.png)
## 3.示例3：as关键字绑定变量
![图片](/images/2026.1.6_11.png)
## 4.示例4：添加类型信息可以让模式更具体
![图片](/images/2026.1.6_12.png)
## 5.示例5：*_ 匹配任意数量的项
- 匹配任何以字符串开头、以嵌套两个浮点数的序列结尾的序列
![图片](/images/2026.1.6_13.png)
## 6.示例6：if语句
![图片](/images/2026.1.6_14.png)

---
# 六、切片
## 1.为什么切片和区间排除最后一项？
![解析](/images/2026.1.6_15.png)
## 2.切片对象slice
### （1）seq[start:stop:step] 句法 ——>指定步距step，让切片操作跳过部分项。步距也可以是负数，反向返回项。
```python
>>> s = 'bicycle' 
>>> s[::3] 
'bye' 
>>> s[::-1] 
'elcycib' 
>>> s[::-2] 
'eccb'
```
### （2）命名切片
![示例](/images/2026.1.6_16.png)

### （3）多维切片和省略号
![图片](/images/2026.1.6_17.png)
![图片](/images/2026.1.6_18.png)

### （4）为切片赋值
1.在赋值语句的左侧使用切片表示法，或者作为 del 语句的目标，可以就
地移植、切除或以其他方式修改可变序列。
2.如果赋值目标是一个切片，则右边必须是一个可迭代对象，即使只有
一项
```python
>>> l = list(range(10)) 
>>> l 
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
>>> l[2:5] = [20, 30] 
>>> l 
[0, 1, 20, 30, 5, 6, 7, 8, 9] 
>>> del l[5:7] 
>>> l 
[0, 1, 20, 30, 5, 8, 9] 
>>> l[3::2] = [11, 22] 
>>> l 
[0, 1, 20, 11, 5, 22, 9] 
>>> l[2:5] = 100  ❶ 
Traceback (most recent call last): 
    File "<stdin>", line 1, in <module> 
TypeError: can only assign an iterable 
>>> l[2:5] = [100] 
>>> l 
[0, 1, 100, 22, 9]
```

# 七、使用 + 和 * 处理序列
## 1.概述
1.通常，+ 的两个运算对象必须是同一种序列，而且都不可修改，拼接的结果是一个同类型的新序列。
2.如果想多次拼接同一个序列，可以乘以一个整数
3.+ 和 * 始终创建一个新对象，绝不更改操作数。
```python
>>> l = [1, 2, 3] 
>>> l * 5 
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] 
>>> 5 * 'abcd' 
'abcdabcdabcdabcdabcd'
```
**注意**：
![图片](/images/2026.1.6_19.png)

## 2.构建嵌套列表
![图片](/images/2026.1.6_20.png)
![图片](/images/2026.1.6_21.png)
**不理解本节所讲的问题或解决方案，没关系——>第 6 章
就是为了阐明引用和可变对象的机制和陷阱而编写的。**

## 3.使用增量赋值运算符处理序列
1.增量赋值运算符 += 和 \*= 的行为差异较大,
2.，本节重点关注增量加法运算符（+=），不过相关概念也
适用于 * = 和其他增量赋值运算符
### （1）+= 运算符
1.背后支持 += 运算符的是特殊方法 \_\_iadd\_\_（就地相加） 
2.如果没有实现 \_\_iadd\_\_，那么 Python 转而调用 \_\_add\_\_
![图片](/images/2026.1.6_22.png)

### （2）一个 += 运算符赋值谜题
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109095902220.png)
解析：
- 1.如果t实现了“_iadd_”,则t[2]+=[50,60]后，t[2]还是原来对象的引用，故A正确
- 2.如果t没有实现”_iadd_“,则t[2]+=[50,60]后，t[2]不在是原来对象的引用，违反了”元组中元素引用指向不可变“
	- **注**：这里的不可变，指”引用的指向“不可变，但引用对象本身可变

# 八、list.sort 与 内置函数sorted
**接收者**：被调用的对象本身
**注意**：本节所讲的内容大都适用于一般意义上的序列，不仅限于列表和元
组。

## 1.list.sort
- **“就地排序”列表**：更改接收者本身，不创建副本，返回值为“None”
- **Python API的一个重要约定**：“就地更改对象”的函数或方法应该**返回None**，让调用者清晰地知道接受者已被更改，没有创建对象
	- 例如：random.shuffle(s)函数也有类似的行为：就地混洗可变序列s，返回None
- **“就地更改”的缺点**：不能“级联调用”

## 2.内置函数sorted
- **返回创建新列表**：接收任何可迭代对象作为参数，包括不可变序列和生成器，时钟返回新创建的列表
- 可以级联使用

## 3.两者共同的“行为参数”
**list.sort和sort均接受“两个可选的关键字”参数**
### （1）reverse
- **值为False**：升序返回项（“默认值”）
- **值为True**：降序返回项

### （2）key
- 一个只接受一个参数的函数 ——> 应用到每一个项上，作为**排序依据**，例如：
	- key=str.lower：执行不区分大小写排序（str.lower是一个只接受一个参数的函数）
	- key=len：按字符长度排序各个字符串。
	- **key的默认值**：“恒等函数”，即比较项本身

## 4.使用例子
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109104257243.png)

# 九、当列表不适用时
**list 类型简单灵活，不过，针对具体的需求，或许还有更好的选择。**
- **数组**：处理上百万个浮点值可以节省大量内存
- **deque**：处理需要在列表的两端添加和删除项
- **set**：在较多项数时检查容器中是否存在某一项

## 1.数组
### （1）概述
- 如果一个列表只包含数值，那么使用 array.array 会更高效
- 数组支
持所有可变序列操作（包括 .pop、.insert 和 .extend）
- 数组还
有快速加载项和保存项的方法，例如 .frombytes 和 .tofile
- **不允许向数组中添加与指定类型不同的值**

### （2）使用
**创建array 对象时要提供类型代码，它是一个字母，用来确定底层使用什么 C 类型存储数组中各项。**
- 例如：类型代码 b 对应 C 语言中的 signed char 类型，即取值范围是 \-128\~127 的整数

#### 示例：创建一个含有 1000 万个随机浮点数的数组，把这些浮点数存入文件，再从文件中读取出来。
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109110350348.png)

**补充：**
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109110106804.png)


### （3）list 和 array 的功能对比
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112208269.png)![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112226325.png)![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112243893.png)![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112305765.png)
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109112416245.png)



## 2.memoryview

### （1）概述
- memoryview 类是一种**共享内存**的序列类型
- memoryview 在数据结构
（例如 PIL 图像、SQLite 数据库、NumPy 数组等）之间共享内
存，而不是事先复制。这对大型数据集来说非常重要

### （2）使用示例
**memoryview.cast 方法**：是改
变读写多字节单元的方式，无须移动位。

#### <1>将同一个 6 字节数组处理为不同的视图，分别以 1×6、2×3 和 3×2 矩阵的视图处理 6 字节内存
```python
>>> from array import array 
>>> octets = array('B', range(6))  # 创建B类型（1字节无符号字符）的array数组，元素是0-5，共6字节连续内存
>>> m1 = memoryview(octets)  # 创建octets的内存视图，指向同一块6字节内存，默认一维，格式为'B'
>>> m1.tolist()  # 将内存视图转为列表，直观查看数据
[0, 1, 2, 3, 4, 5] 
>>> m2 = m1.cast('B', [2, 3])  # 零拷贝转换：类型仍为'B'，形状改为2行3列的二维视图（总元素数2*3=6，与原内存字节数匹配）
>>> m2.tolist()  # 二维视图的展示形式：按2行3列排列原数据
[[0, 1, 2], [3, 4, 5]] 
>>> m3 = m1.cast('B', [3, 2])  # 零拷贝转换：类型仍为'B'，形状改为3行2列的二维视图（总元素数3*2=6，匹配原内存字节数）
>>> m3.tolist()  # 二维视图的展示形式：按3行2列排列原数据
[[0, 1], [2, 3], [4, 5]] 
>>> m2[1,1] = 22  # 修改m2视图中「第2行第2列」的元素（对应原内存第4个字节，原数值4），赋值22
>>> m3[1,1] = 33  # 修改m3视图中「第2行第2列」的元素（对应原内存第3个字节，原数值3），赋值33
>>> octets  # 原array数组被同步修改（所有视图指向同一块内存），最终元素为[0,1,2,33,22,5]
array('B', [0, 1, 2, 33, 22, 5])
```

#### <2>　修改一个 16 位整数数组中某一项的字节，改变该项的值
```python
>>> numbers = array.array('h', [-2, -1, 0, 1, 2])  # 创建array数组：类型码'h'对应C的signed short
# 元素为5个整数，总内存5×2=10字节
>>> memv = memoryview(numbers)  # 生成numbers的内存视图memv，指向同一块10字节连续内存，默认格式为'h'（2字节短整型）
>>> len(memv)  # 查看内存视图的元素个数（按'h'类型解读，10字节÷2字节/个=5个）
5 
>>> memv[0] # 按'h'类型读取第0个元素，即原数组的第一个元素-2
-2 
>>> memv_oct = memv.cast('B') # 零拷贝转换：将视图格式转为'B'（1字节无符号字符），原10字节内存被拆分为10个1字节元素解读
>>> memv_oct.tolist() # 按1字节无符号字符展示所有内存：这里是短整型的补码存储（小端序，低字节在前）
# 对应关系（每个短整型拆为2个字节）：
# -2 → 补码0xFFFE → 小端序存储为[254, 255]；-1 → 补码0xFFFF → [255, 255]；0 → 0x0000 → [0, 0]；
#1 → 0x0001 → [1, 0]；2 → 0x0002 → [2, 0]
[254, 255, 255, 255, 0, 0, 1, 0, 2, 0] 
>>> memv_oct[5] = 4 # 修改第5个1字节元素（索引从0开始）：原第5个字节是0（对应原数组第2个元素0的高字节），改为4
# 关键：原数组第2个元素（索引2）是0，对应内存为第4、5字节（索引4=0，索引5=0）；修改索引5为4后，该元素的内存变为[0, 4]（小端序→实际是0x0400）
>>> numbers  # 查看原数组：第2个元素从0变为0x0400对应的十进制数1024，其他元素因内存未被修改保持不变
array('h', [-2, -1, 1024, 1, 2])
```

## 3.Numpy
### (1)概述
- 科学计算经常需要做一些高级数组和矩阵运算，得益于 NumPy，Python成为这一领域的主流语言
- **NumPy** 实现了多维同构数组和矩阵类型，除了存放数值之外，还可以存放用户定义的记录，而且提供了高效的元素层面操作
- 在 NumPy 基础之上编写的 **SciPy** 库提供了许多科学计算算法，从线性代数到数值微积分和统计学，不一而足。

### (2)使用示例
#### <1>NumPy对二维数组做一些基本操作
```python
>>> import numpy as np # 导入numpy库并简写为np（numpy常规用法，方便后续调用）
>>> a = np.arange(12)  # 生成0-11的连续整数数组，默认是1维数组
>>> a 
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]) 
>>> type(a) 
<class 'numpy.ndarray'>  # 查看类型，确认是numpy的数组类型
>>> a.shape  # 查看数组形状：(12,) 表示1维数组，共12个元素
(12,) 
>>> a.shape = 3, 4  # 调整数组形状为3行4列的2维数组（不改变数据，仅改变解读维度）
>>> a 
array([[ 0,  1,  2,  3], 
       [ 4,  5,  6,  7], 
       [ 8,  9, 10, 11]]) 
>>> a[2]  # 取第3行（索引从0开始）的所有元素
array([ 8,  9, 10, 11]) 
>>> a[2, 1]  # 取第3行第2列的元素（行索引2，列索引1）
9 
>>> a[:, 1]  # 取所有行（:表示全部）的第2列元素
array([1, 5, 9]) 
>>> a.transpose()  # 数组转置（行变列、列变行），3行4列转为4行3列
array([[ 0,  4,  8], 
       [ 1,  5,  9], 
       [ 2,  6, 10], 
       [ 3,  7, 11]])
```

#### <2>NumPy的一些高级操作
```python
>>> import numpy  # 导入numpy库（未简写，直接用库名调用）
>>> floats = numpy.loadtxt('floats-10M-lines.txt')  # 从文本文件读取1000万行浮点数，加载为numpy数组（注意：文本读取速度较慢，适合小/中型数据）
>>> floats[-3:]  # 查看数组最后3个元素（验证数据加载正常）
array([ 3016362.69195522,   535281.10514262,  4566560.44373946]) 
>>> floats *= .5  # 数组所有元素原地乘以0.5（numpy广播机制，无需循环，效率高）
>>> floats[-3:]  # 再次查看最后3个元素，确认修改生效
array([ 1508181.34597761,   267640.55257131,  2283280.22186973]) 
>>> from time import perf_counter as pc # 从time模块导入高精度计时器perf_counter，简写为pc（方便计时）
>>> t0 = pc(); floats /= 3; pc() - t0 # 计时：计算数组所有元素原地除以3的耗时，输出耗时（numpy数组运算比Python原生循环快得多）
0.03690556302899495  # 输出结果：耗时约0.037秒（处理1000万浮点数，体现numpy高效性）
>>> numpy.save('floats-10M', floats)  # 将数组以numpy专用二进制格式（.npy）保存到文件（二进制格式读写快、占用空间小，适合大数据）
>>> floats2 = numpy.load('floats-10M.npy', 'r+')  # 以读写模式（r+）加载.npy文件，返回memmap（内存映射）对象（无需将整个大数据载入内存，节省内存）
>>> floats2 *= 6  # 对memmap对象原地乘以6（直接操作磁盘文件中的数据，不占大量内存）
>>> floats2[-3:]  # 查看memmap对象最后3个元素，验证修改生效（memmap对象用法与numpy数组一致）
memmap([ 3016362.69195522,   535281.10514262,  4566560.44373946])
```

## 4.deque(双端队列)
### （1）概述
- collections.deque 类实现一种**线程安全的双端队列**，旨在快速在两端插入和删除项。
- **deque对象可以有界**，即长度固定 ——> 对象填满之后，从一端添加新项，将从另一端丢弃一项。

### （2）使用示例
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109115841494.png)

### （3）list 和 deque 实现的方法对比
![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109120042686.png)![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109120103430.png)![](https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260109120124149.png)

### （4）Python 标准库中的其他包中的队列
#### <1>queue包
- **队列类**：SimpleQueue、Queue、LifoQueue 和 PriorityQueue。
	- 这些类都是**线程安全**的，可在线程之间安全通信
- 除SimpleQueue 之外，其他几个类都可以有界 ——> 为构造函数提供maxsize 参数，设为大于 0 的值。
- **与deque的区别**：不像 deque 那样为了腾出空间而把项丢弃，而是在**队列填满后阻塞插入新项**，等待其他线程从队列中取出一项。
	- 利用这种行为可以限制活动线程的数量。

#### <2>multiprocessing包
- **队列类**：无界的 SimpleQueue 和有界的 Queue
	- 这与 queue包中的队列类非常相似，只不过专门针对进程间通信
- 为任务管理提供了专用的 multiprocessing.JoinableQueue。

#### <3>asyncio
- **队列类**：Queue、LifoQueue、PriorityQueue 和 JoinableQueue
- API 源自 queue 和 multiprocessing 模块中的类，不过为管理异步编程任务而做了修改。

#### <4>heapq
- **队列类**：没有实现任何队列类
- **功能**：提供了heappush 和 heappop 等函数，可把可变序列当作**堆队列**或**优先级队列**使用。