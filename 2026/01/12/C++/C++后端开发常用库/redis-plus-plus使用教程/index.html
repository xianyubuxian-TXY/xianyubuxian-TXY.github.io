<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xianyubuxian-txy.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="附录1：Redis++ 核心场景 附录2：Redis++ 重要机制 附录3：Redis++ 安装教程  一、Redis++概述 1.Redis++ 适配模式介绍 Redis++ 支持多种部署模式的适配，不同模式对应不同的生产场景需求，核心模式如下：   * 单机模式： * 适配小型应用、开发&#x2F;测试环境，直接连接单个Redis节点，部署简单但无高可用保障。     * 生产环境仅推荐用于非核心业务，">
<meta property="og:type" content="article">
<meta property="og:title" content="redis-plus-plus使用教程">
<meta property="og:url" content="https://xianyubuxian-txy.github.io/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="Xianyu">
<meta property="og:description" content="附录1：Redis++ 核心场景 附录2：Redis++ 重要机制 附录3：Redis++ 安装教程  一、Redis++概述 1.Redis++ 适配模式介绍 Redis++ 支持多种部署模式的适配，不同模式对应不同的生产场景需求，核心模式如下：   * 单机模式： * 适配小型应用、开发&#x2F;测试环境，直接连接单个Redis节点，部署简单但无高可用保障。     * 生产环境仅推荐用于非核心业务，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113171238862.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000730301.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000814117.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000348588.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113234947400.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084518210.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084903240.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084633220.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084947303.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084713792.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084746832.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114085208456.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113145948394.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113150625783.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113224050272.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113163903839.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091913625.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091947050.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092102449.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092349865.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092417497.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092451027.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091249622.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091358906.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093548922.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093630371.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093926722.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093942338.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114102612093.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114102827965.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095237003.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095332179.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095437891.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095455051.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114120517753.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114113148877.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114113623553.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114171934666.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143816994.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143840833.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143913218.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114151808620.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114152209995.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170235009.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170102888.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170533657.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114153043892.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114155752421.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114163237592.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114161718422.png">
<meta property="article:published_time" content="2026-01-12T14:15:28.000Z">
<meta property="article:modified_time" content="2026-01-16T16:23:20.106Z">
<meta property="article:author" content="咸鱼">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113171238862.png">


<link rel="canonical" href="https://xianyubuxian-txy.github.io/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xianyubuxian-txy.github.io/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","path":"2026/01/12/C++/C++后端开发常用库/redis-plus-plus使用教程/","title":"redis-plus-plus使用教程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>redis-plus-plus使用教程 | Xianyu</title>
  








  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  




<link rel="dns-prefetch" href="https://waline-beta-black.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Xianyu</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Redis-%E6%A6%82%E8%BF%B0"><span class="nav-text">一、Redis++概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis-%E9%80%82%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.Redis++ 适配模式介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D"><span class="nav-text">2.Redis++核心配置介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE"><span class="nav-text">（1）基础连接配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE"><span class="nav-text">（2）连接池配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%A0%B8%E5%BF%83%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%BC%96%E8%AF%91%E8%A7%84%E8%8C%83"><span class="nav-text">3.核心依赖与编译规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A0%B8%E5%BF%83%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%BC%96%E8%AF%91%E8%A7%84%E8%8C%83"><span class="nav-text">（1）核心依赖与编译规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89CMake-%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90"><span class="nav-text">（2）CMake 项目集成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="nav-text">（3）连接配置示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%8F%90%E7%A4%BA%E4%BA%8B%E9%A1%B9"><span class="nav-text">二、官方文档提示事项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Connection%E8%BF%9E%E6%8E%A5"><span class="nav-text">1.Connection连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%8D%E7%94%A8-Redis-%E5%AF%B9%E8%B1%A1"><span class="nav-text">（1）尽可能复用 Redis 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6"><span class="nav-text">（2）自动重连机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E2%80%9C%E9%98%BB%E5%A1%9E%E5%91%BD%E4%BB%A4%E2%80%9D%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">（3）“阻塞命令”的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">（4）连接池的懒加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89URI-%E5%8F%82%E6%95%B0%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%88%E8%A6%81%E6%B1%82%E5%85%A8%E5%B0%8F%E5%86%99%EF%BC%89"><span class="nav-text">（5）URI 参数区分大小写（要求全小写）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89Pipeline-Transaction-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（6）Pipeline &#x2F; Transaction 注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89Subscriber-%E8%AE%A2%E9%98%85%E8%80%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（7）Subscriber 订阅者注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89Redis-Cluster-%E9%9B%86%E7%BE%A4%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（8）Redis Cluster 集群注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%889%EF%BC%89%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（9）异步接口注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">（10）异常处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">三、配置结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ConnectionOptions%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">1.ConnectionOptions结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ConnectionPoolOptions%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">2.ConnectionPoolOptions结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SentinelOptions%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">3.SentinelOptions结构体</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Redis-%E7%B1%BB%EF%BC%88%E5%8D%95%E6%9C%BA-%E4%B8%BB%E4%BB%8E-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%A0%B8%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%89"><span class="nav-text">四、Redis 类（单机&#x2F;主从&#x2F;哨兵模式核心客户端）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.Redis类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Redis%E7%B1%BB%E7%9A%84%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">（1）Redis类的关键实现细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%93%8D%E4%BD%9C%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="nav-text">（2）数据类型 &amp; 操作对照表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89key%E3%80%81%E7%AE%A1%E9%81%93%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%AD%89%E5%8A%9F%E8%83%BD"><span class="nav-text">（3）key、管道、事务、发布订阅等功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis%E7%B1%BB-%E9%80%82%E9%85%8D%E2%80%9C%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E2%80%9D"><span class="nav-text">2.Redis类 适配“单机模式”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BB%8B%E7%BB%8D"><span class="nav-text">（1）介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">（2）代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis%E7%B1%BB-%E9%80%82%E9%85%8D%E2%80%9C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E2%80%9D"><span class="nav-text">3.Redis类 适配“主从复制模式”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">（1）介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">（2）代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Redis%E7%B1%BB-%E9%80%82%E9%85%8D%E2%80%9C%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E2%80%9D"><span class="nav-text">4.Redis类 适配“哨兵模式”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BB%8B%E7%BB%8D-2"><span class="nav-text">（1）介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">（2）代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E2%80%9C%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E2%80%9D%EF%BC%9F"><span class="nav-text">（3）为什么需要“哨兵模式”？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-text">&lt;1&gt;核心问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">&lt;2&gt;哨兵模式的解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%88%E7%AE%80%E8%A6%81%E7%89%88%EF%BC%89"><span class="nav-text">&lt;3&gt;Redis++ 的实现细节（简要版）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E2%80%9D-vs-%E2%80%9C%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E2%80%9D"><span class="nav-text">&lt;4&gt;“主从复制模式” vs “哨兵模式”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%81%EF%BC%81"><span class="nav-text">5.注意事项！！</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Sentinel"><span class="nav-text">五、Sentinel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Sentinel%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="nav-text">1.Sentinel类的职责</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Sentinel%E7%B1%BB%E7%9A%84%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">2.Sentinel类的关键实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Sentinel-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">3.Sentinel 类的使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA-Sentinel-%E5%AF%B9%E8%B1%A1"><span class="nav-text">（1）创建 Sentinel 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%80%9A%E8%BF%87-Sentinel-%E5%88%9B%E5%BB%BA-Redis-%E8%BF%9E%E6%8E%A5"><span class="nav-text">（2）通过 Sentinel 创建 Redis 连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81RedisCluster%EF%BC%88%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%89"><span class="nav-text">六、RedisCluster（集群模式客户端）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RedisCluster%E7%B1%BB-%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-text">1.RedisCluster类 的构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">（1）构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">&lt;1&gt;基本构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URL%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">&lt;2&gt;URL构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9"><span class="nav-text">（2）配置选项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConnectionOptions%EF%BC%88%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="nav-text">&lt;1&gt;ConnectionOptions（连接配置）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConnectionPoolOptions%EF%BC%88%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="nav-text">&lt;2&gt;ConnectionPoolOptions（连接池配置）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ClusterOptions%EF%BC%88%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="nav-text">&lt;3&gt;ClusterOptions（集群配置）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">（3）创建实例的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-URI%EF%BC%88%E6%9C%80%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-text">&lt;1&gt;使用 URI（最简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E9%85%8D%E7%BD%AE%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">&lt;2&gt;标准配置（推荐）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE"><span class="nav-text">&lt;3&gt;完整配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-RedisCluster%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">2.RedisCluster的连接机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Role-MASTER-%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="nav-text">（1）Role::MASTER 模式（默认）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%8B%93%E6%89%91%EF%BC%88%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E4%B8%BB%E8%8A%82%E7%82%B9%EF%BC%89"><span class="nav-text">&lt;1&gt;连接拓扑（连接所有主节点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Role-MASTER-%E8%A6%81%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E4%B8%BB%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="nav-text">&lt;2&gt;为什么 Role::MASTER 要连接所有主节点？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A01%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E5%AD%98%E5%82%A8"><span class="nav-text">原因1：数据分片存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A02%EF%BC%9A%E5%86%99%E6%93%8D%E4%BD%9C%E5%BF%85%E9%A1%BB%E5%88%B0%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="nav-text">原因2：写操作必须到主节点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Role-SLAVE-%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%BF%9E%E6%8E%A5%E6%AF%8F%E4%B8%AA%E4%B8%BB%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E4%BB%8E%E8%8A%82%E7%82%B9%EF%BC%89"><span class="nav-text">（2）Role::SLAVE 模式（连接每个主节点的一个随机从节点）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%8B%93%E6%89%91"><span class="nav-text">&lt;1&gt;连接拓扑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Role-SLAVE-%E8%A6%81%E8%BF%9E%E6%8E%A5%E6%AF%8F%E4%B8%AA%E4%B8%BB%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E4%BB%8E%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="nav-text">&lt;2&gt;为什么 Role::SLAVE 要连接每个主节点的一个随机从节点？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A01-%E4%BF%9D%E6%8C%81%E6%A7%BD%E4%BD%8D%E8%A6%86%E7%9B%96"><span class="nav-text">原因1:保持槽位覆盖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A02%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">原因2：负载均衡</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E4%BB%8E%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="nav-text">为什么不是所有从节点？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E2%80%9CRole-MASTER-%E6%A8%A1%E5%BC%8F%E2%80%9D-vs-%E2%80%9CRole-SLAVE-%E6%A8%A1%E5%BC%8F%E2%80%9D"><span class="nav-text">（3）“Role::MASTER 模式” vs “Role::SLAVE 模式”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%B8%B8%E8%A7%81%E8%AF%AF%E8%A7%A3"><span class="nav-text">（4）常见误解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-RedisCluster%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">3.RedisCluster类的注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E5%8F%91%E9%80%81%E2%80%9C%E6%97%A0key%E5%8F%82%E6%95%B0%E7%9A%84%E5%91%BD%E4%BB%A4%E2%80%9D"><span class="nav-text">（1）无法直接发送“无key参数的命令”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">&lt;1&gt;问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">&lt;2&gt;解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9CRedisCluster%E2%80%9D-vs-%E2%80%9CRedisCluster-redis-%E2%80%9D"><span class="nav-text">&lt;3&gt;“RedisCluster” vs “RedisCluster::redis()”</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81Redis-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%91%E9%80%81"><span class="nav-text">七、Redis++ 命令的发送</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%91%BD%E4%BB%A4%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">1.命令调用方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="nav-text">2.参数类型详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AF%A6%E8%A7%A3"><span class="nav-text">3.返回值详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-bool-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">4.bool 返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Optional-%E5%A4%84%E7%90%86-NULL-%E5%9B%9E%E5%A4%8D"><span class="nav-text">5.Optional 处理 NULL 回复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Variant-%E5%A4%84%E7%90%86%E5%A4%9A%E7%B1%BB%E5%9E%8B%E5%9B%9E%E5%A4%8D%EF%BC%88C-17%EF%BC%89"><span class="nav-text">6. Variant 处理多类型回复（C++17）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%BE%93%E5%87%BA%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E-STL-%E5%AE%B9%E5%99%A8"><span class="nav-text">7.输出迭代器与 STL 容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">8.各种参数类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%90%84%E7%A7%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-text">9.各种返回值类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81Redis-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">八、Redis++ 的异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis-%E7%9A%84Exception"><span class="nav-text">1.Redis++的Exception</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BC%82%E5%B8%B8%E5%90%8E%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81"><span class="nav-text">2.异常后的对象状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF"><span class="nav-text">3.异常处理模板</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81Redis-command%EF%BC%88Redis-%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="nav-text">九、Redis::command（Redis++ 通用命令接口）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">1.基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%9B%B4%E6%8E%A5%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">（1）直接指定返回类型（推荐）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%81%B5%E6%B4%BB"><span class="nav-text">（2）参数类型灵活</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%87%8D%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">2.重要注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%A4%9A%E8%AF%8D%E5%91%BD%E4%BB%A4%E5%BF%85%E9%A1%BB%E5%88%86%E5%BC%80%E4%BC%A0%E9%80%92"><span class="nav-text">（1）多词命令必须分开传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%9B%BA%E5%AE%9A%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">（2）返回类型不固定时的处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81Redis-Pub-Sub%EF%BC%88%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%EF%BC%89"><span class="nav-text">十、Redis++ Pub&#x2F;Sub（发布&#x2F;订阅）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Publish-%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF"><span class="nav-text">2.Publish 发布消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Subscriber-%E8%AE%A2%E9%98%85"><span class="nav-text">3.Subscriber 订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BASubscriber%E5%AF%B9%E8%B1%A1"><span class="nav-text">（1）创建Subscriber对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Subscriber%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">（2）Subscriber的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A2%E9%98%85%E9%A2%91%E9%81%93%E5%92%8C%E6%A8%A1%E5%BC%8F"><span class="nav-text">&lt;1&gt;订阅频道和模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Subscriber%E7%B1%BB-%E6%8E%A5%E6%94%B6%E7%9A%846%E7%A7%8D%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-text">&lt;2&gt; Subscriber类 接收的6种消息类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%88%E5%A4%84%E7%90%866%E7%A7%8D%E6%B6%88%E6%81%AF%EF%BC%89"><span class="nav-text">&lt;3&gt;设置回调函数（处理6种消息）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#consume-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="nav-text">&lt;4&gt;consume 消费消息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%EF%BC%89consume%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9"><span class="nav-text">1）consume函数执行特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%EF%BC%89%E4%B8%8D%E5%B8%A6%E8%B6%85%E6%97%B6%E7%9A%84%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%AE%BE%E4%B8%BA0%E6%AF%AB%E7%A7%92%EF%BC%89"><span class="nav-text">2）不带超时的模式（设为0毫秒）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%EF%BC%89%E5%B8%A6%E8%B6%85%E6%97%B6%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-text">3）带超时的模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%EF%BC%89%E6%B6%88%E6%81%AF%E6%B5%81%E5%90%91%E5%AE%8C%E6%95%B4%E5%9B%BE%E7%A4%BA"><span class="nav-text">4）消息流向完整图示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="nav-text">&lt;5&gt;完整示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Subscriber-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（3）Subscriber 使用注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">&lt;1&gt;非线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E5%AE%9AException%E5%90%8E%E4%B8%8D%E5%8F%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">&lt;2&gt;特定Exception后不可复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#consume%E6%B6%88%E8%B4%B9%E6%98%AF%E2%80%9C%E9%98%BB%E5%A1%9E%E7%9A%84%E2%80%9D"><span class="nav-text">&lt;3&gt;consume消费是“阻塞的”</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Redis-Pipeline%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89"><span class="nav-text">十一、Redis++ Pipeline（管道）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BAPipeline"><span class="nav-text">2.创建Pipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%80%9A%E8%BF%87pipeline%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4"><span class="nav-text">3.通过pipeline发送命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%A7%A3%E6%9E%90pipeline%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-text">4.解析pipeline执行结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%BF%9E%E6%8E%A5%E5%BD%92%E8%BF%98%E6%9C%BA%E5%88%B6"><span class="nav-text">5.连接归还机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">（1）两种创建方式的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E2%80%9D%E5%BD%92%E8%BF%98%E8%BF%9E%E6%8E%A5%E2%80%9D%E5%8F%AA%E5%AF%B9%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%A8%A1%E5%BC%8F%E6%9C%89%E6%84%8F%E4%B9%89"><span class="nav-text">（2）”归还连接”只对连接池模式有意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E2%80%9D%E5%BD%92%E8%BF%98%E2%80%9D%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89"><span class="nav-text">（3）”归还”的具体含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89-%E4%B8%BA%E4%BB%80%E4%B9%88%E2%80%9D%E5%BD%92%E8%BF%98%E2%80%9D%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-text">（4） 为什么”归还”很重要？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%BD%92%E8%BF%98%E4%B9%8B%E5%90%8E%E5%86%8D%E6%AC%A1%E8%A7%A6%E5%8F%91%E5%91%A2%EF%BC%9F"><span class="nav-text">（5）归还之后再次触发呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-pipeline-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">6.pipeline 使用注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%89%B9%E5%AE%9AException%E5%90%8E%E4%B8%8D%E5%8F%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">（1）特定Exception后不可复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">（2）非线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E8%80%8C%E4%B8%8D%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9E%E6%8E%A5"><span class="nav-text">5.创建管道而不创建新连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%88%9B%E5%BB%BApipeline%E5%AF%B9%E8%B1%A1%EF%BC%88%E6%9C%89%E6%AD%BB%E9%94%81%E9%A3%8E%E9%99%A9%EF%BC%89"><span class="nav-text">（1）用连接池中的连接创建pipeline对象（有死锁风险）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%AD%BB%E9%94%81%E9%A3%8E%E9%99%A9"><span class="nav-text">（2）死锁风险</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">（3）最佳实践</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81Redis-Transaction%EF%BC%88%E4%BA%8B%E5%8A%A1%EF%BC%89"><span class="nav-text">十二、Redis++ Transaction（事务）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0-2"><span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BATransaction"><span class="nav-text">2.创建Transaction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%BB%98%E8%AE%A4%E6%96%B9%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-text">（1）默认方式（创建新连接）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%BF%9E%E6%8E%A5%E5%88%9B%E5%BB%BA%EF%BC%88%E6%9C%89%E6%AD%BB%E9%94%81%E9%A3%8E%E9%99%A9%EF%BC%89"><span class="nav-text">（2）使用连接池连接创建（有死锁风险）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E5%8C%96%E4%BA%8B%E5%8A%A1%EF%BC%88%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%EF%BC%89"><span class="nav-text">（3）创建管道化事务（性能更好）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Transaction%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">3.Transaction的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4"><span class="nav-text">（1）发送命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1"><span class="nav-text">（2）执行事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%A7%A3%E6%9E%90%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-text">（3）解析事务执行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E7%AE%A1%E9%81%93%E4%BA%8B%E5%8A%A1%EF%BC%88Piped-Transaction%EF%BC%89"><span class="nav-text">（4）管道事务（Piped Transaction）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-WATCH-%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88CAS-%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-text">4. WATCH 乐观锁（CAS 机制）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-WATCH%EF%BC%9F"><span class="nav-text">（1）为什么需要 WATCH？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89WATCH-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">（2）WATCH 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Watch%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">（3）Watch的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">&lt;1&gt;概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-WATCH-%E7%9A%84%E5%85%B3%E9%94%AE"><span class="nav-text">&lt;2&gt;使用 WATCH 的关键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WATCH-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%EF%BC%88CAS-%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-text">&lt;3&gt;WATCH 完整示例（CAS 实现）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E4%BD%86%E4%B8%8D%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9E%E6%8E%A5"><span class="nav-text">5.创建事务但不创建新连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%86%85%E8%BF%9E%E6%8E%A5%E5%88%9B%E5%BB%BATransaction"><span class="nav-text">（1）使用连接池内连接创建Transaction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">（2）使用连接池连接的最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%BF%9E%E6%8E%A5%E5%BD%92%E8%BF%98%E6%9C%BA%E5%88%B6"><span class="nav-text">6.连接归还机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Transaction-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">7.Transaction 使用注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%89%B9%E5%AE%9AException%E5%90%8E%E4%B8%8D%E5%8F%AF%E5%A4%8D%E7%94%A8-1"><span class="nav-text">（1）特定Exception后不可复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-1"><span class="nav-text">（2）非线程安全</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%951%EF%BC%9ARedis-%E6%A0%B8%E5%BF%83%E5%9C%BA%E6%99%AF"><span class="nav-text">附录1：Redis++ 核心场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BC%93%E5%AD%98%E5%9C%BA%E6%99%AF%EF%BC%88%E6%9C%80%E6%A0%B8%E5%BF%83%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="nav-text">1.缓存场景（最核心场景）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">（1）适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">（2）核心优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E7%94%9F%E4%BA%A7%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%81%EF%BC%89"><span class="nav-text">（3）生产实现要点（重点！）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%9C%BA%E6%99%AF"><span class="nav-text">2.分布式锁场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-text">（1）适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF-1"><span class="nav-text">（2）核心优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E7%94%9F%E4%BA%A7%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9"><span class="nav-text">（3）生产实现要点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%952%EF%BC%9ARedis-%E9%87%8D%E8%A6%81%E6%9C%BA%E5%88%B6"><span class="nav-text">附录2：Redis++ 重要机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis-%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%EF%BC%88%E9%9D%9E%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-text">1.Redis++ 的心跳机制（非自己实现）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BB%8B%E7%BB%8D-3"><span class="nav-text">（1）介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%97%B6%E9%97%B4%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">（2）时间流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF-%E2%86%94-Redis-%E4%BA%A4%E4%BA%92%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-text">（3）客户端 ↔ Redis 交互示意图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%953%EF%BC%9ARedis-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B"><span class="nav-text">附录3：Redis++ 安装教程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BE%BF%E6%8D%B7%E5%AE%89%E8%A3%85"><span class="nav-text">1.便捷安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%99%AE%E9%80%9A%E5%AE%89%E8%A3%85"><span class="nav-text">2.普通安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F"><span class="nav-text">3.验证安装是否成功</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F"><span class="nav-text">（1）验证安装是否成功</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-text">（2）查看当前安装的版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Redis-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%EF%BC%88%E5%88%87%E6%8D%A2%EF%BC%89"><span class="nav-text">4.Redis++版本升级（切换）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%A0%E9%99%A4Redis"><span class="nav-text">5.删除Redis++</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="咸鱼"
      src="/images/xianyu.jpg">
  <p class="site-author-name" itemprop="name">咸鱼</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xianyubuxian-TXY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xianyubuxian-TXY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianyubuxian-txy.github.io/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/xianyu.jpg">
      <meta itemprop="name" content="咸鱼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xianyu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="redis-plus-plus使用教程 | Xianyu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis-plus-plus使用教程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2026-01-12 22:15:28" itemprop="dateCreated datePublished" datetime="2026-01-12T22:15:28+08:00">2026-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-17 00:23:20" itemprop="dateModified" datetime="2026-01-17T00:23:20+08:00">2026-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">C++后端开发库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BA%93/redis-plus-plus/" itemprop="url" rel="index"><span itemprop="name">redis-plus-plus</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:04</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><a href="#use">附录1：Redis++ 核心场景</a><br><a href="#mechanism">附录2：Redis++ 重要机制</a><br><a href="#install">附录3：Redis++ 安装教程</a></p>
<h1 id="一、Redis-概述"><a href="#一、Redis-概述" class="headerlink" title="一、Redis++概述"></a>一、Redis++概述</h1><h2 id="1-Redis-适配模式介绍"><a href="#1-Redis-适配模式介绍" class="headerlink" title="1.Redis++ 适配模式介绍"></a>1.Redis++ 适配模式介绍</h2><p>Redis++ 支持多种部署模式的适配，不同模式对应不同的生产场景需求，核心模式如下：</p>
<ul>
<li><strong>单机模式</strong>：<ul>
<li>适配小型应用、开发&#x2F;测试环境，直接连接单个Redis节点，部署简单但无高可用保障。</li>
<li>生产环境仅推荐用于<strong>非核心业务</strong>，需配合数据备份策略使用。​</li>
</ul>
</li>
<li><strong>主从模式</strong>：<ul>
<li>适配<strong>读多写少</strong>的生产场景</li>
<li>包含一个主节点（写入）和多个从节点（读取）</li>
<li>Redis++可通过配置指定读请求路由到从节点，提升读吞吐量，主从故障切换需依赖哨兵或手动操作。​</li>
</ul>
</li>
<li><strong>哨兵模式</strong>：<ul>
<li>在<strong>主从模式基础上</strong>增加哨兵节点，负责监控主从节点健康状态</li>
<li>当主节点故障时自动完成故障切换，保障高可用性</li>
<li>Redis++通过连接哨兵节点获取主从信息，无需手动维护节点地址。​</li>
</ul>
</li>
<li><strong>集群模式（Cluster）</strong>：<ul>
<li>适配<strong>海量数据、高并发</strong>的核心生产场景，将数据分片存储在多个主节点，每个主节点对应多个从节点。</li>
<li>Redis++提供RedisCluster客户端，自动适配数据分片、节点发现和故障切换，API与单机模式兼容，生产可无缝切换。</li>
</ul>
</li>
</ul>
<p><strong>注意！！</strong>：</p>
<ul>
<li>主从复制、哨兵模式、集群模式都是<strong>由“Redis服务端”手动配置</strong></li>
<li>Redis++是Redis客户端库<ul>
<li><strong>不负责配置</strong>“主从复制”、“哨兵模式”、“集群模式”</li>
<li>只负责<strong>连接到Redis服务器</strong></li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113171238862.png"></li>
</ul>
<h2 id="2-Redis-核心配置介绍"><a href="#2-Redis-核心配置介绍" class="headerlink" title="2.Redis++核心配置介绍"></a>2.Redis++核心配置介绍</h2><p>Redis++的配置核心围绕<strong>连接参数</strong>和<strong>池化参数</strong>，不同模式的配置略有差异</p>
<h3 id="（1）基础连接配置"><a href="#（1）基础连接配置" class="headerlink" title="（1）基础连接配置"></a>（1）基础连接配置</h3><ul>
<li><p><strong>host&#x2F;port</strong>：</p>
<ul>
<li>Redis节点的<strong>ip地址 和 端口port</strong><ul>
<li>单机模式：填写单个节点信息</li>
<li>集群&#x2F;哨兵模式：填写任意一个节点（客户端自动发现其他节点）</li>
</ul>
</li>
<li>生产环境建议使用内网IP或域名，避免公网传输风险。</li>
</ul>
</li>
<li><p><strong>password</strong>：</p>
<ul>
<li><strong>Redis访问密码</strong>，防未授权访问</li>
<li><strong>生产环境必须强制设置</strong>：<ul>
<li>长度建议不小于8位</li>
<li>包含字母、数字和特殊字符</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>db</strong>：</p>
<ul>
<li><strong>Redis逻辑数据库编号</strong>（0-15默认）</li>
<li>生产环境建议按业务模块隔离数据库<ul>
<li>例如用户模块用db1、订单模块用db2，避免键名冲突和数据混乱。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>socket_timeout</strong>：</p>
<ul>
<li><strong>套接字读写超时时间</strong></li>
<li>生产环境建议设置500ms-1s，避免因网络阻塞导致应用线程挂起。</li>
</ul>
</li>
<li><p><strong>connect_timeout</strong>：</p>
<ul>
<li><strong>连接建立超时时间</strong></li>
<li>生产环境建议设置1s-2s，防止因Redis节点故障导致连接等待过久。</li>
</ul>
</li>
</ul>
<h3 id="（2）连接池配置"><a href="#（2）连接池配置" class="headerlink" title="（2）连接池配置"></a>（2）连接池配置</h3><ul>
<li><p><strong>size</strong>：</p>
<ul>
<li><strong>连接池大小</strong></li>
<li>需根据业务QPS调整，生产环境建议20-50个连接（高QPS场景可增至100）<ul>
<li>连接过多：导致Redis资源耗尽</li>
<li>连接过少：导致请求排队。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>wait_timeout</strong>：</p>
<ul>
<li><strong>获取连接的等待超时时间</strong></li>
<li>生产环境建议设置200-500ms，超时后抛出异常，避免应用线程无限等待连接。</li>
</ul>
</li>
<li><p><strong>connection_lifetime</strong>：</p>
<ul>
<li><strong>连接最大生存时间</strong></li>
<li>生产环境建议设置5-10分钟，自动关闭长时间空闲的连接，避免无效连接占用资源。</li>
</ul>
</li>
</ul>
<h2 id="3-核心依赖与编译规范"><a href="#3-核心依赖与编译规范" class="headerlink" title="3.核心依赖与编译规范"></a>3.核心依赖与编译规范</h2><h3 id="（1）核心依赖与编译规范"><a href="#（1）核心依赖与编译规范" class="headerlink" title="（1）核心依赖与编译规范"></a>（1）核心依赖与编译规范</h3><ul>
<li><strong>编译选项</strong>：<ul>
<li>必须指定 -std&#x3D;c++17</li>
<li>链接 -lredis++ -lhiredis -pthread（线程库）；</li>
</ul>
</li>
<li><strong>编译优化</strong>：<ul>
<li>添加 -O2 提升性能</li>
<li>-Wall -Werror 严格检查代码；</li>
</ul>
</li>
<li><strong>头文件</strong>：<ul>
<li>#include &lt;sw&#x2F;redis++&#x2F;redis++.h&gt;（核心）</li>
<li>#include &lt;sw&#x2F;redis++&#x2F;cluster.h&gt;（集群）。</li>
</ul>
</li>
</ul>
<h3 id="（2）CMake-项目集成"><a href="#（2）CMake-项目集成" class="headerlink" title="（2）CMake 项目集成"></a>（2）CMake 项目集成</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyRedisProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 1. 设置 C++ 标准（必须与 redis++ 编译时一致） ============</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 2. 查找 hiredis 库 ============</span></span><br><span class="line"><span class="keyword">find_path</span>(HIREDIS_HEADER hiredis)</span><br><span class="line"><span class="keyword">find_library</span>(HIREDIS_LIB hiredis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 3. 查找 redis++ 库 ============</span></span><br><span class="line"><span class="comment"># 注意：这里是 sw，不是 redis++</span></span><br><span class="line"><span class="keyword">find_path</span>(REDIS_PLUS_PLUS_HEADER sw)</span><br><span class="line"><span class="keyword">find_library</span>(REDIS_PLUS_PLUS_LIB redis++)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 4. 创建可执行文件 ============</span></span><br><span class="line"><span class="keyword">add_executable</span>(myapp main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 5. 添加头文件路径 ============</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(myapp PRIVATE </span><br><span class="line">    <span class="variable">$&#123;HIREDIS_HEADER&#125;</span></span><br><span class="line">    <span class="variable">$&#123;REDIS_PLUS_PLUS_HEADER&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============ 6. 链接库 ============</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp PRIVATE</span><br><span class="line">    <span class="variable">$&#123;REDIS_PLUS_PLUS_LIB&#125;</span></span><br><span class="line">    <span class="variable">$&#123;HIREDIS_LIB&#125;</span></span><br><span class="line">    pthread  <span class="comment"># 必须链接线程库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="（3）连接配置示例"><a href="#（3）连接配置示例" class="headerlink" title="（3）连接配置示例"></a>（3）连接配置示例</h3><ul>
<li>生产环境<strong>禁止使用单连接</strong>，必须用<strong>连接池</strong></li>
<li>同时添加超时、密码等生产必备配置</li>
<li><strong>注</strong>：<ul>
<li>如果业务需要，可在业务层添加“<strong>手动重试封装</strong>”</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="comment">// Redis 连接创建函数（带连接池）</span></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function">Redis <span class="title">create_prod_redis_conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 基础连接配置</span></span><br><span class="line">    ConnectionOptions opts;</span><br><span class="line">    opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    opts.port = <span class="number">6379</span>;</span><br><span class="line">    opts.password = <span class="string">&quot;your_redis_pwd&quot;</span>;  <span class="comment">// 无密码则注释掉</span></span><br><span class="line">    opts.db = <span class="number">0</span>;</span><br><span class="line">    opts.socket_timeout = chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">    opts.connect_timeout = chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 注意：redis++ 默认会自动重连，无需手动配置重连参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接池配置</span></span><br><span class="line">    ConnectionPoolOptions pool_opts;</span><br><span class="line">    pool_opts.size = <span class="number">20</span>;</span><br><span class="line">    pool_opts.wait_timeout = chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line">    pool_opts.connection_lifetime = chrono::<span class="built_in">minutes</span>(<span class="number">5</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Redis</span>(opts, pool_opts);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Redis 连接失败：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Redis 初始化失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="comment">// 带重试的执行封装（解决重连问题）</span></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">redis_exec_with_retry</span><span class="params">(Redis&amp; redis, Func&amp;&amp; func, <span class="type">int</span> max_retry = <span class="number">3</span>)</span> </span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(func(redis))</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_retry; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">func</span>(redis);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp; e) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Redis 超时，重试 &quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; max_retry &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (i == max_retry - <span class="number">1</span>) <span class="keyword">throw</span>;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> IoError&amp; e) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Redis IO 错误，重试 &quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; max_retry &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (i == max_retry - <span class="number">1</span>) <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span> * (i + <span class="number">1</span>)));  <span class="comment">// 退避</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Redis 重试耗尽&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_usage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> redis = <span class="built_in">create_prod_redis_conn</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通调用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;操作失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带重试的调用</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">redis_exec_with_retry</span>(redis, [](Redis&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> r.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、官方文档提示事项"><a href="#二、官方文档提示事项" class="headerlink" title="二、官方文档提示事项"></a>二、官方文档提示事项</h1><p><strong>建议先阅读之后的小节，这里放在前面是为了“强调它的重要性”</strong></p>
<h2 id="1-Connection连接"><a href="#1-Connection连接" class="headerlink" title="1.Connection连接"></a>1.Connection连接</h2><h3 id="（1）尽可能复用-Redis-对象"><a href="#（1）尽可能复用-Redis-对象" class="headerlink" title="（1）尽可能复用 Redis 对象"></a>（1）尽可能复用 Redis 对象</h3><ul>
<li><strong>你应该尽可能复用 Redis 对象</strong><ul>
<li>因为<strong>创建 Redis 对象的开销并不小</strong>，因为它会创建到 Redis 服务器的新连接。</li>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000730301.png"></li>
</ul>
</li>
<li><strong>Redis对象是多线程安全的</strong><ul>
<li>你可以在多个线程中共享同一个 Redis 对象。</li>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000814117.png"></li>
</ul>
</li>
</ul>
<h3 id="（2）自动重连机制"><a href="#（2）自动重连机制" class="headerlink" title="（2）自动重连机制"></a>（2）自动重连机制</h3><ul>
<li>Redis 类维护一个连接到 Redis 服务器的连接池。<ul>
<li>如果连接断开，Redis 会<strong>自动重新连接</strong>到 Redis 服务器。</li>
</ul>
</li>
<li><strong>不需要手动检查 Redis 对象是否成功连接到服务器</strong><ul>
<li>如果 Redis 无法创建到 Redis 服务器的连接，或者连接在某个时刻断开，当你尝试发送命令时，它会<strong>抛出 Error 类型的异常</strong></li>
<li><strong>即使你收到异常（即连接断开），你也不需要创建新的 Redis 对象！！</strong><ul>
<li>你可以复用同一个 Redis 对象继续发送命令，Redis 对象会自动尝试重连服务器。</li>
<li>如果重连成功，它会发送命令到服务器；</li>
<li>否则，它会再次抛出异常。</li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114000348588.png"></li>
</ul>
</li>
</ul>
<h3 id="（3）“阻塞命令”的使用"><a href="#（3）“阻塞命令”的使用" class="headerlink" title="（3）“阻塞命令”的使用"></a>（3）“阻塞命令”的使用</h3><ul>
<li>当使用<strong>阻塞命令</strong>时，socket_timeout <strong>必须大于阻塞命令的超时时间</strong>，否则会导致误报超时和数据丢失。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113234947400.png"></li>
</ul>
</li>
</ul>
<h3 id="（4）连接池的懒加载机制"><a href="#（4）连接池的懒加载机制" class="headerlink" title="（4）连接池的懒加载机制"></a>（4）连接池的懒加载机制</h3><ul>
<li>连接池中的连接是**懒加载（延迟创建）**的<ul>
<li>当连接池初始化时（即 Redis 构造函数执行时），Redis 不会立即连接到服务器</li>
<li>只有在你尝试<strong>发送命令时才会建立连接</strong><ul>
<li>通过这种方式，我们可以<strong>避免不必要的连接</strong></li>
</ul>
</li>
<li>因此，如果连接池大小设置为 5，但实际最大并发连接数只有 3，那么连接池中实际只会有 3 个连接。</li>
</ul>
</li>
</ul>
<h3 id="（5）URI-参数区分大小写（要求全小写）"><a href="#（5）URI-参数区分大小写（要求全小写）" class="headerlink" title="（5）URI 参数区分大小写（要求全小写）"></a>（5）URI 参数区分大小写（要求全小写）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：全小写</span></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1:6379?socket_timeout=100ms&amp;keep_alive=true&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：大小写混用</span></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1:6379?Socket_Timeout=100ms&quot;</span>);  <span class="comment">// 无法识别</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）Pipeline-Transaction-注意事项"><a href="#（6）Pipeline-Transaction-注意事项" class="headerlink" title="（6）Pipeline &#x2F; Transaction 注意事项"></a>（6）Pipeline &#x2F; Transaction 注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084518210.png"></p>
<h3 id="（7）Subscriber-订阅者注意事项"><a href="#（7）Subscriber-订阅者注意事项" class="headerlink" title="（7）Subscriber 订阅者注意事项"></a>（7）Subscriber 订阅者注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084903240.png"></p>
<h3 id="（8）Redis-Cluster-集群注意事项"><a href="#（8）Redis-Cluster-集群注意事项" class="headerlink" title="（8）Redis Cluster 集群注意事项"></a>（8）Redis Cluster 集群注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084633220.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084947303.png"></p>
<h3 id="（9）异步接口注意事项"><a href="#（9）异步接口注意事项" class="headerlink" title="（9）异步接口注意事项"></a>（9）异步接口注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084713792.png"></p>
<h3 id="（10）异常处理"><a href="#（10）异常处理" class="headerlink" title="（10）异常处理"></a>（10）异常处理</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114084746832.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114085208456.png"></p>
<h1 id="三、配置结构体"><a href="#三、配置结构体" class="headerlink" title="三、配置结构体"></a>三、配置结构体</h1><p><a id="ConnectionOptions"></a></p>
<h2 id="1-ConnectionOptions结构体"><a href="#1-ConnectionOptions结构体" class="headerlink" title="1.ConnectionOptions结构体"></a>1.ConnectionOptions结构体</h2><ul>
<li><strong>注</strong>：内部成员变量顺序我做了调整，其它都未改动</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnectionOptions</span> &#123;</span><br><span class="line">    <span class="comment">// ============ 默认构造/拷贝/移动/析构 ============</span></span><br><span class="line">    <span class="built_in">ConnectionOptions</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ConnectionOptions</span>(<span class="type">const</span> ConnectionOptions &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ConnectionOptions&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionOptions &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ConnectionOptions</span>(ConnectionOptions &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ConnectionOptions&amp; <span class="keyword">operator</span>=(ConnectionOptions &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConnectionOptions</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 连接目标 ============</span></span><br><span class="line">    ConnectionType type = ConnectionType::TCP;  <span class="comment">// 连接类型: TCP 或 UNIX</span></span><br><span class="line">    std::string host;                           <span class="comment">// Redis 服务器ip地址 (TCP模式)</span></span><br><span class="line">    <span class="type">int</span> port = <span class="number">6379</span>;                            <span class="comment">// 端口号 (TCP模式)</span></span><br><span class="line">    std::string path;                           <span class="comment">// Unix Socket 路径 (UNIX模式)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 认证相关 ============</span></span><br><span class="line">    std::string user = <span class="string">&quot;default&quot;</span>;               <span class="comment">// ACL 用户名 (Redis 6.0+ 支持)</span></span><br><span class="line">    std::string password;                       <span class="comment">// 认证密码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 数据库选择 ============</span></span><br><span class="line">    <span class="type">int</span> db = <span class="number">0</span>;                                 <span class="comment">// 数据库索引 (0-15)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 超时设置 ============</span></span><br><span class="line">    std::chrono::milliseconds connect_timeout&#123;<span class="number">0</span>&#125;;  <span class="comment">// 连接超时 (0=系统默认)</span></span><br><span class="line">    std::chrono::milliseconds socket_timeout&#123;<span class="number">0</span>&#125;;   <span class="comment">// 读写超时 (0=无限等待)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ TCP 保活 ============</span></span><br><span class="line">    <span class="type">bool</span> keep_alive = <span class="literal">false</span>;                    <span class="comment">// 是否启用 TCP KeepAlive（心跳机制）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> REDIS_PLUS_PLUS_HAS_redisEnableKeepAliveWithInterval</span></span><br><span class="line">    std::chrono::seconds keep_alive_s&#123;<span class="number">0</span>&#125;;       <span class="comment">// KeepAlive 探测（心跳）间隔 (需要 hiredis 支持)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ TLS/SSL ============</span></span><br><span class="line">    tls::TlsOptions tls;                        <span class="comment">// TLS 加密配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 协议版本 ============</span></span><br><span class="line">    <span class="type">int</span> resp = <span class="number">2</span>;                               <span class="comment">// RESP 协议版本 (2 或 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 连接名称 ============</span></span><br><span class="line">    std::string name;                           <span class="comment">// CLIENT SETNAME 设置的连接名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 集群专用（与我们无关，不用看） ============</span></span><br><span class="line">    <span class="comment">// 是否允许从 Redis Cluster 的从节点（slave/replica）读取数据。</span></span><br><span class="line">    <span class="comment">// 客户端不应手动设置，RedisCluster 类会自动管理这个标志（未来可能移除）</span></span><br><span class="line">    <span class="type">bool</span> readonly = <span class="literal">false</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部使用，返回服务器信息字符串</span></span><br><span class="line">    std::string _server_info() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>keep_alive 和 keep_alive_s 的关系</strong></p>
<ul>
<li>keep_alive &#x3D; true 但 keep_alive_s &#x3D; 0 时，使用系统默认的 KeepAlive 间隔（通常是 7200 秒）</li>
<li>若要自定义间隔，需要 hiredis 版本支持 redisEnableKeepAliveWithInterval</li>
</ul>
<p><a id="ConnectionPoolOptions"></a></p>
<h2 id="2-ConnectionPoolOptions结构体"><a href="#2-ConnectionPoolOptions结构体" class="headerlink" title="2.ConnectionPoolOptions结构体"></a>2.ConnectionPoolOptions结构体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnectionPoolOptions</span> &#123;</span><br><span class="line">    <span class="comment">// 连接池最大连接数</span></span><br><span class="line">    std::<span class="type">size_t</span> size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接时的最大等待时间</span></span><br><span class="line">    <span class="comment">// 当连接池耗尽时，调用者最多阻塞等待这么久</span></span><br><span class="line">    <span class="comment">// 0 = 无限等待（不推荐，可能导致线程死锁）</span></span><br><span class="line">    std::chrono::milliseconds wait_timeout&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接的最大存活时间</span></span><br><span class="line">    <span class="comment">// 超过此时间的连接会被销毁并重建</span></span><br><span class="line">    <span class="comment">// 用于防止长连接腐化、应对服务端重启等场景</span></span><br><span class="line">    <span class="comment">// 0 = 永不过期</span></span><br><span class="line">    std::chrono::milliseconds connection_lifetime&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接的最大空闲时间</span></span><br><span class="line">    <span class="comment">// 超过此时间未被使用的连接会被回收</span></span><br><span class="line">    <span class="comment">// 用于释放闲置资源、避免空闲连接被防火墙/代理断开</span></span><br><span class="line">    <span class="comment">// 0 = 不回收空闲连接</span></span><br><span class="line">    std::chrono::milliseconds connection_idle_time&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a id="SentinelOptions"></a></p>
<h2 id="3-SentinelOptions结构体"><a href="#3-SentinelOptions结构体" class="headerlink" title="3.SentinelOptions结构体"></a>3.SentinelOptions结构体</h2><ul>
<li><strong>注</strong>：内部成员变量顺序我做了调整，其它都未改动</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SentinelOptions</span> &#123;</span><br><span class="line">    <span class="comment">/// 哨兵节点列表：每个元素为&lt;哨兵节点IP/域名, 哨兵端口&gt;</span></span><br><span class="line">    <span class="comment">/// 示例：&#123;&#123;&quot;127.0.0.1&quot;, 26379&#125;, &#123;&quot;127.0.0.1&quot;, 26380&#125;&#125;</span></span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, <span class="type">int</span>&gt;&gt; nodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 连接哨兵节点的超时时间，默认100毫秒</span></span><br><span class="line">    <span class="comment">/// 超过该时间未建立连接则视为连接失败</span></span><br><span class="line">    std::chrono::milliseconds connect_timeout&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 与哨兵节点通信的Socket超时时间，默认100毫秒</span></span><br><span class="line">    <span class="comment">/// 超过该时间未收到哨兵响应则视为通信失败</span></span><br><span class="line">    std::chrono::milliseconds socket_timeout&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 连接哨兵失败后的重试间隔，默认100毫秒</span></span><br><span class="line">    std::chrono::milliseconds retry_interval&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 连接哨兵的最大重试次数，默认2次</span></span><br><span class="line">    <span class="comment">/// 达到该次数仍失败则整体连接流程终止</span></span><br><span class="line">    std::<span class="type">size_t</span> max_retry = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 哨兵认证的用户名，默认值为&quot;default&quot;（Redis 6.0+ 新增的ACL用户认证）</span></span><br><span class="line">    std::string user = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 哨兵认证的密码（如果哨兵节点配置了密码验证，需填写此项）</span></span><br><span class="line">    std::string password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 是否启用TCP Keep-Alive机制，默认true</span></span><br><span class="line">    <span class="comment">/// 作用：检测无效的连接，避免长时间空闲的连接被断开</span></span><br><span class="line">    <span class="type">bool</span> keep_alive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// TLS/SSL连接配置选项（如果哨兵节点启用了TLS加密，需配置此项）</span></span><br><span class="line">    tls::TlsOptions tls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 指定与哨兵通信使用的Redis RESP协议版本，默认2（RESP2）</span></span><br><span class="line">    <span class="comment">/// 可选值：2（RESP2）、3（RESP3），需与哨兵节点的协议版本匹配</span></span><br><span class="line">    <span class="type">int</span> resp = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、Redis-类（单机-主从-哨兵模式核心客户端）"><a href="#四、Redis-类（单机-主从-哨兵模式核心客户端）" class="headerlink" title="四、Redis 类（单机&#x2F;主从&#x2F;哨兵模式核心客户端）"></a>四、Redis 类（单机&#x2F;主从&#x2F;哨兵模式核心客户端）</h1><ul>
<li>作为 Redis++ 最基础且核心的“<strong>客户端类</strong>”，封装了所有 Redis 原生命令的调用接口</li>
<li>支持<strong>单机、主从、哨兵</strong>三种部署模式的连接与操作，是生产环境中最常用的类</li>
</ul>
<p><strong>注！！</strong>：单机、主从、哨兵等部署模式都是<strong>由“服务端”配置</strong>，Redis类只负责连接到已存在的部署模式</p>
<h2 id="1-Redis类介绍"><a href="#1-Redis类介绍" class="headerlink" title="1.Redis类介绍"></a>1.Redis类介绍</h2><h3 id="（1）Redis类的关键实现细节"><a href="#（1）Redis类的关键实现细节" class="headerlink" title="（1）Redis类的关键实现细节"></a>（1）Redis类的关键实现细节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Redis</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 基础构造：通过连接选项 + 连接池选项初始化（最常用）</span></span><br><span class="line">    <span class="comment">/// @param connection_opts 连接选项</span></span><br><span class="line">    <span class="comment">/// @param pool_opts 连接池选项</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Redis</span><span class="params">(<span class="type">const</span> ConnectionOptions &amp;connection_opts,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> ConnectionPoolOptions &amp;pool_opts = &#123;&#125;)</span></span></span><br><span class="line"><span class="function">                	:_pool(std::make_shared&lt;ConnectionPool&gt;(pool_opts, connection_opts)) </span></span><br><span class="line"><span class="function">                	&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 简化构造：通过 URI 字符串直接初始化（快速配置场景）</span></span><br><span class="line">    <span class="comment">/// @brief 用 URI 字符串构造 Redis 实例（简化配置，无需手动组装 ConnectionOptions）</span></span><br><span class="line">    <span class="comment">/// @param uri URI 格式说明：</span></span><br><span class="line">    <span class="comment">///     - TCP 连接：tcp://[[username:]password@]host[:port][/db]</span></span><br><span class="line">    <span class="comment">///         - 示例：&quot;tcp://127.0.0.1&quot;、&quot;tcp://user:pass@127.0.0.1:6379/0&quot;（连接 0 号库）</span></span><br><span class="line">    <span class="comment">///     - Unix 套接字连接：unix://[[username:]password@]path-to-unix-domain-socket[/db]</span></span><br><span class="line">    <span class="comment">///         - 示例：&quot;unix:///tmp/redis.sock&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Redis</span><span class="params">(<span class="type">const</span> std::string &amp;uri)</span> : Redis(Uri(uri)) &#123;</span>&#125;  <span class="comment">// 内部转发给 Uri 解析后的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 哨兵模式构造：通过 Redis Sentinel 自动发现节点（高可用场景）</span></span><br><span class="line">    <span class="comment">/// @brief 基于 Redis 哨兵模式构造 Redis 实例（自动获取主从节点信息，支持故障自动切换）</span></span><br><span class="line">    <span class="comment">/// @param sentinel Sentinel 实例的智能指针（用于与哨兵集群通信）</span></span><br><span class="line">    <span class="comment">/// @param master_name 主节点名称（哨兵集群监控的主节点标识）</span></span><br><span class="line">    <span class="comment">/// @param role 连接角色：</span></span><br><span class="line">    <span class="comment">///     - Role::MASTER: 连接主节点（用于写操作）</span></span><br><span class="line">    <span class="comment">///     - Role::SLAVE: 连接从节点（用于读操作，实现读写分离）</span></span><br><span class="line">    <span class="comment">/// @param connection_opts 连接选项（同基础构造，可配置 KeepAlive 等）</span></span><br><span class="line">    <span class="comment">/// @param pool_opts 连接池选项（同基础构造，默认使用默认配置）</span></span><br><span class="line">    <span class="built_in">Redis</span>(<span class="type">const</span> std::shared_ptr&lt;Sentinel&gt; &amp;sentinel,</span><br><span class="line">          <span class="type">const</span> std::string &amp;master_name,</span><br><span class="line">          Role role,</span><br><span class="line">          <span class="type">const</span> ConnectionOptions &amp;connection_opts,</span><br><span class="line">          <span class="type">const</span> ConnectionPoolOptions &amp;pool_opts = &#123;&#125;)</span><br><span class="line">          : _pool(std::<span class="built_in">make_shared</span>&lt;ConnectionPool&gt;(<span class="built_in">SimpleSentinel</span>(sentinel, master_name, role),</span><br><span class="line">                                                   pool_opts,</span><br><span class="line">                                                   connection_opts)) </span><br><span class="line">          &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Redis</span>(<span class="type">const</span> Redis &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Redis&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Redis &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Redis</span>(Redis &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Redis&amp; <span class="keyword">operator</span>=(Redis &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;ConnectionPool&gt; _pool;  <span class="comment">// 核心成员：连接池智能指针（管理 Redis 连接）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（2）数据类型-操作对照表"><a href="#（2）数据类型-操作对照表" class="headerlink" title="（2）数据类型 &amp; 操作对照表"></a>（2）数据类型 &amp; 操作对照表</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113145948394.png"></p>
<h3 id="（3）key、管道、事务、发布订阅等功能"><a href="#（3）key、管道、事务、发布订阅等功能" class="headerlink" title="（3）key、管道、事务、发布订阅等功能"></a>（3）key、管道、事务、发布订阅等功能</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113150625783.png"></p>
<h2 id="2-Redis类-适配“单机模式”"><a href="#2-Redis类-适配“单机模式”" class="headerlink" title="2.Redis类 适配“单机模式”"></a>2.Redis类 适配“单机模式”</h2><h3 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li>Redis类直接连接单个Redis节点，部署简单但无高可用保障</li>
<li><strong>服务端部署！！</strong>：<ul>
<li>Linux上安装Redis后，直接启动即可</li>
</ul>
</li>
</ul>
<h3 id="（2）代码实现"><a href="#（2）代码实现" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h3><p><a href="#ConnectionOptions">ConnectionOptions结构体</a><br><a href="#ConnectionPoolOptions">ConnectionPoolOptions结构体</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(Redis &amp;redis, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            std::string key = <span class="string">&quot;key_&quot;</span> + std::<span class="built_in">to_string</span>(id) + <span class="string">&quot;_&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">            redis.<span class="built_in">set</span>(key, <span class="string">&quot;value_&quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (val) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error &amp;e) &#123;</span><br><span class="line">        <span class="comment">// ✅ 线程内部捕获异常</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;✗ 线程 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; 错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConnectionOptions conn_opts;</span><br><span class="line">    conn_opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    conn_opts.port = <span class="number">6379</span>;</span><br><span class="line">    conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    ConnectionPoolOptions pool_opts;</span><br><span class="line">    pool_opts.size = <span class="number">5</span>;</span><br><span class="line">    pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    pool_opts.connection_lifetime = std::chrono::<span class="built_in">minutes</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 Redis 对象（可能失败） </span></span><br><span class="line">    std::unique_ptr&lt;Redis&gt; redis;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redis = std::<span class="built_in">make_unique</span>&lt;Redis&gt;(conn_opts, pool_opts);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✓ Redis 连接成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;✗ Redis 连接失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 连接失败，直接退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(*redis), i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;✓ 所有线程完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Redis类-适配“主从复制模式”"><a href="#3-Redis类-适配“主从复制模式”" class="headerlink" title="3.Redis类 适配“主从复制模式”"></a>3.Redis类 适配“主从复制模式”</h2><h3 id="（1）介绍-1"><a href="#（1）介绍-1" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li>适配读多写少的生产场景，包含一个主节点（写入）和多个从节点（读取）</li>
<li>分别创建Redis类，按“单机模式“连接方式分别连接“主节点、从节点”即可（通过<strong>ip：port</strong>）</li>
<li><strong>服务端部署！！</strong>：<ul>
<li>服务端需<strong>手动“配置主从”</strong></li>
</ul>
</li>
</ul>
<h3 id="（2）代码实现-1"><a href="#（2）代码实现-1" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h3><p><a href="#ConnectionOptions">ConnectionOptions结构体</a><br><a href="#ConnectionPoolOptions">ConnectionPoolOptions结构体</a><br><strong>假设主从复制模式配置如下</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 主节点</span><br><span class="line">127.0.0.1：6370</span><br><span class="line"></span><br><span class="line"># 从节点1</span><br><span class="line">127.0.0.1：6380</span><br><span class="line"></span><br><span class="line"># 从节点2</span><br><span class="line">127.0.0.1:6381</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ==================== 配置参数 ====================</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主节点配置</span></span><br><span class="line">        std::string master_host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> master_port = <span class="number">6379</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从节点配置</span></span><br><span class="line">        std::vector&lt;std::pair&lt;std::string, <span class="type">int</span>&gt;&gt; slaves = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>&#125;,  <span class="comment">// 从节点1</span></span><br><span class="line">            &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6381</span>&#125;   <span class="comment">// 从节点2</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        std::string password = <span class="string">&quot;&quot;</span>;  <span class="comment">// 如果有密码，填写在这里</span></span><br><span class="line">        <span class="type">size_t</span> pool_size = <span class="number">3</span>;       <span class="comment">// 连接池大小</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ==================== 1. 连接主节点 ====================</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;=== 连接主节点 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        ConnectionOptions master_opts;</span><br><span class="line">        master_opts.host = master_host;</span><br><span class="line">        master_opts.port = master_port;</span><br><span class="line">        master_opts.password = password;</span><br><span class="line">        master_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">        master_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        ConnectionPoolOptions pool_opts;</span><br><span class="line">        pool_opts.size = pool_size;</span><br><span class="line">        pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> master = <span class="built_in">Redis</span>(master_opts, pool_opts);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;✓ 主节点连接成功：&quot;</span> &lt;&lt; master_host &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; master_port &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ==================== 2. 连接从节点 ====================</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n=== 连接从节点 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        std::vector&lt;Redis&gt; slave_clients;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [host, port] : slaves) &#123;</span><br><span class="line">            ConnectionOptions slave_opts;</span><br><span class="line">            slave_opts.host = host;</span><br><span class="line">            slave_opts.port = port;</span><br><span class="line">            slave_opts.password = password;</span><br><span class="line">            slave_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">            slave_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">            </span><br><span class="line">            slave_clients.<span class="built_in">emplace_back</span>(<span class="built_in">Redis</span>(slave_opts, pool_opts));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;✓ 从节点连接成功：&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Redis类-适配“哨兵模式”"><a href="#4-Redis类-适配“哨兵模式”" class="headerlink" title="4.Redis类 适配“哨兵模式”"></a>4.Redis类 适配“哨兵模式”</h2><h3 id="（1）介绍-2"><a href="#（1）介绍-2" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li>“哨兵模式”为Redis提供了高可用性，但相较于前两中模式，要复杂一点</li>
<li>“哨兵模式”需要用到“<strong>Sentinel类</strong>”（哨兵类）</li>
<li><strong>服务端部署！！</strong>：<ul>
<li>服务端需手动**“配置主从”**（<strong>哨兵模式的基础</strong>）</li>
<li>服务器序手动创建“<strong>哨兵节点</strong>”</li>
</ul>
</li>
</ul>
<h3 id="（2）代码实现-2"><a href="#（2）代码实现-2" class="headerlink" title="（2）代码实现"></a>（2）代码实现</h3><p><a href="#ConnectionOptions">ConnectionOptions结构体</a><br><a href="#ConnectionPoolOptions">ConnectionPoolOptions结构体</a><br><strong>推荐先看</strong>：<a href="#Sentinel">Sentinel类</a><br><strong>假设哨兵模式配置如下</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 主节点</span><br><span class="line">127.0.0.1：6370</span><br><span class="line"></span><br><span class="line"># 从节点</span><br><span class="line">127.0.0.1：6380</span><br><span class="line">127.0.0.1：6381</span><br><span class="line"></span><br><span class="line"># 哨兵节点</span><br><span class="line">127.0.0.1：9000</span><br><span class="line">127.0.0.1：9001</span><br><span class="line">127.0.0.1：9002</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 1. 哨兵配置 ============</span></span><br><span class="line">    SentinelOptions sentinel_opts;</span><br><span class="line">    sentinel_opts.nodes = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9001</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9002</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    sentinel_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    sentinel_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> sentinel = std::<span class="built_in">make_shared</span>&lt;Sentinel&gt;(sentinel_opts);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============ 2. 连接配置 ============</span></span><br><span class="line">    ConnectionOptions conn_opts;</span><br><span class="line">    conn_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    ConnectionPoolOptions pool_opts;</span><br><span class="line">    pool_opts.size = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============ 3. 创建主节点 ============</span></span><br><span class="line">    <span class="keyword">auto</span> master = <span class="built_in">Redis</span>(sentinel, </span><br><span class="line">                        <span class="string">&quot;mymaster&quot;</span>,  	<span class="comment">// 这是在哨兵配置文件中定义的主节点名称</span></span><br><span class="line">                        Role::MASTER,   <span class="comment">// 角色</span></span><br><span class="line">                        conn_opts, </span><br><span class="line">                        pool_opts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============ 4. 创建从节点 ============</span></span><br><span class="line">    <span class="keyword">auto</span> slave = <span class="built_in">Redis</span>(sentinel, </span><br><span class="line">                        <span class="string">&quot;mymaster&quot;</span>, 	<span class="comment">// 这是在哨兵配置文件中定义的主节点名称</span></span><br><span class="line">                        Role::SLAVE, 	<span class="comment">// 角色</span></span><br><span class="line">                        conn_opts, </span><br><span class="line">                        pool_opts);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;✅ 从节点连接成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>不需要手动指定“主节点”、“从节点”的ip:port</strong><ul>
<li>节点的分配都有“<strong>Sentinel类</strong>”（哨兵类）完成</li>
</ul>
</li>
</ul>
<h3 id="（3）为什么需要“哨兵模式”？"><a href="#（3）为什么需要“哨兵模式”？" class="headerlink" title="（3）为什么需要“哨兵模式”？"></a>（3）为什么需要“哨兵模式”？</h3><h4 id="核心问题"><a href="#核心问题" class="headerlink" title="&lt;1&gt;核心问题"></a>&lt;1&gt;核心问题</h4><p><strong>❌ 主从复制模式的致命缺陷</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">主从复制模式 = 手动管理 + 单点故障</span><br><span class="line"></span><br><span class="line">客户端连接：</span><br><span class="line">master_redis = <span class="built_in">Redis</span>(<span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">slave_redis  = <span class="built_in">Redis</span>(<span class="string">&quot;127.0.0.1:6380&quot;</span>)</span><br><span class="line"></span><br><span class="line">问题<span class="number">1</span>：主节点宕机</span><br><span class="line">→ master_redis 连接失效</span><br><span class="line">→ 抛出异常：Connection refused</span><br><span class="line">→ 写操作全部失败</span><br><span class="line">→ 需要人工介入：</span><br><span class="line">   <span class="number">1.</span> 手动提升从节点（SLAVEOF NO ONE）</span><br><span class="line">   <span class="number">2.</span> 修改代码中的主节点地址</span><br><span class="line">   <span class="number">3.</span> 重启应用程序</span><br><span class="line"></span><br><span class="line">问题<span class="number">2</span>：从节点宕机</span><br><span class="line">→ slave_redis 连接失效</span><br><span class="line">→ 抛出异常：Connection refused</span><br><span class="line">→ 读操作失败</span><br><span class="line">→ 需要人工切换到其他从节点</span><br></pre></td></tr></table></figure>

<p><strong>核心矛盾</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">客户端 <span class="code">`Redis`</span> 对象 = 静态连接（固定 <span class="code">`IP:Port`</span>）</span><br><span class="line">服务端节点状态   = 动态变化（宕机/切换/新增）</span><br><span class="line"></span><br><span class="line">→ 两者无法自动同步</span><br><span class="line">→ 需要人工干预</span><br><span class="line">→ 高可用性差</span><br></pre></td></tr></table></figure>

<h4 id="哨兵模式的解决方案"><a href="#哨兵模式的解决方案" class="headerlink" title="&lt;2&gt;哨兵模式的解决方案"></a>&lt;2&gt;哨兵模式的解决方案</h4><p><strong>核心思想</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引入中间层：Sentinel</span><br><span class="line">作用：动态感知节点变化，自动更新客户端连接</span><br></pre></td></tr></table></figure>
<p><strong>框架设计</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">传统模式（静态连接）：</span><br><span class="line">应用程序 → Redis 对象 → 固定节点 (<span class="code">`127.0.0.1:6379`</span>)</span><br><span class="line"><span class="code">              ↓ 节点宕机</span></span><br><span class="line"><span class="code">         连接失效，抛出异常</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">哨兵模式（动态连接）：</span><br><span class="line">应用程序 → Sentinel → 哨兵集群 (监控节点状态)</span><br><span class="line"><span class="code">              ↓                  ↓</span></span><br><span class="line"><span class="code">         Redis 对象 ←─── 动态获取可用节点</span></span><br><span class="line"><span class="code">              ↓</span></span><br><span class="line"><span class="code">         当前主节点 (`127.0.0.1:6379`)</span></span><br><span class="line"><span class="code">              ↓ 主节点宕机</span></span><br><span class="line"><span class="code">         哨兵检测 → 选举新主节点 (`127.0.0.1:6380`)</span></span><br><span class="line"><span class="code">              ↓</span></span><br><span class="line"><span class="code">         Sentinel 自动通知 Redis 对象</span></span><br><span class="line"><span class="code">              ↓</span></span><br><span class="line"><span class="code">         Redis 对象自动重连新主节点</span></span><br><span class="line"><span class="code">              ↓</span></span><br><span class="line"><span class="code">         应用程序无感知，继续正常工作</span></span><br></pre></td></tr></table></figure>
<h4 id="Redis-的实现细节（简要版）"><a href="#Redis-的实现细节（简要版）" class="headerlink" title="&lt;3&gt;Redis++ 的实现细节（简要版）"></a>&lt;3&gt;Redis++ 的实现细节（简要版）</h4><ol>
<li><strong>传统模式</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 静态连接</span></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主节点宕机</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">// → 抛出异常：Connection refused</span></span><br><span class="line"><span class="comment">// → 无法自动恢复</span></span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>Redis 对象只知道创建时的固定地址</li>
<li>节点变化时，无法自动更新连接</li>
<li>需要手动修改代码并重启</li>
</ul>
<ol start="2">
<li><strong>哨兵模式（Sentinel + Redis）</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 动态连接</span></span><br><span class="line">SentinelOptions sentinel_opts;</span><br><span class="line">sentinel_opts.nodes = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26379</span>&#125;,  <span class="comment">// 哨兵1</span></span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26380</span>&#125;,  <span class="comment">// 哨兵2</span></span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26381</span>&#125;   <span class="comment">// 哨兵3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> sentinel = std::<span class="built_in">make_shared</span>&lt;Sentinel&gt;(sentinel_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接配置</span></span><br><span class="line">ConnectionOptions conn_opts;</span><br><span class="line">conn_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Sentinel 创建 Redis 对象</span></span><br><span class="line">    <span class="keyword">auto</span> master = <span class="built_in">Redis</span>(sentinel, </span><br><span class="line">        <span class="string">&quot;mymaster&quot;</span>,      <span class="comment">// 这是在哨兵配置文件中定义的主节点名称</span></span><br><span class="line">        Role::MASTER,   <span class="comment">// 角色</span></span><br><span class="line">        conn_opts, </span><br><span class="line">        pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部机制：</span></span><br><span class="line"><span class="comment">// 1. Redis 对象持有 Sentinel 的引用</span></span><br><span class="line"><span class="comment">// 2. 发现连接失效时，调用 Sentinel 查询新主节点</span></span><br><span class="line"><span class="comment">// 3. 自动重连新主节点</span></span><br><span class="line"><span class="comment">// 4. 重试失败的操作</span></span><br></pre></td></tr></table></figure>
<p><strong>内部流程</strong>（伪代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Redis</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Sentinel&gt; sentinel_;  <span class="comment">// 持有 Sentinel 引用</span></span><br><span class="line">    std::string master_name_;</span><br><span class="line">    Connection* conn_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过 Sentinel 创建</span></span><br><span class="line">    <span class="built_in">Redis</span>(std::shared_ptr&lt;Sentinel&gt; sentinel, </span><br><span class="line">          <span class="type">const</span> std::string&amp; master_name) </span><br><span class="line">        : <span class="built_in">sentinel_</span>(sentinel), <span class="built_in">master_name_</span>(master_name) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始连接</span></span><br><span class="line">        <span class="keyword">auto</span> [host, port] = sentinel_-&gt;<span class="built_in">getMasterAddr</span>(master_name_);</span><br><span class="line">        conn_ = <span class="built_in">connect</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn_-&gt;<span class="built_in">send</span>(<span class="string">&quot;SET&quot;</span>, key, value);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> ConnectionError&amp; e) &#123;</span><br><span class="line">            <span class="comment">// 连接失效，自动重连</span></span><br><span class="line">            <span class="built_in">reconnect</span>();</span><br><span class="line">            <span class="comment">// 重试操作</span></span><br><span class="line">            conn_-&gt;<span class="built_in">send</span>(<span class="string">&quot;SET&quot;</span>, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动重连</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 Sentinel 查询新主节点</span></span><br><span class="line">        <span class="keyword">auto</span> [host, port] = sentinel_-&gt;<span class="built_in">getMasterAddr</span>(master_name_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 销毁旧连接</span></span><br><span class="line">        <span class="keyword">delete</span> conn_;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重连新主节点</span></span><br><span class="line">        conn_ = <span class="built_in">connect</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="“主从复制模式”-vs-“哨兵模式”"><a href="#“主从复制模式”-vs-“哨兵模式”" class="headerlink" title="&lt;4&gt;“主从复制模式” vs “哨兵模式”"></a>&lt;4&gt;“主从复制模式” vs “哨兵模式”</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113224050272.png"></p>
<h2 id="5-注意事项！！"><a href="#5-注意事项！！" class="headerlink" title="5.注意事项！！"></a>5.注意事项！！</h2><ul>
<li><p>Redis 类对象是<strong>线程安全</strong>的，生产环境可全局共享一个实例（基于连接池实现线程隔离），无需每个线程创建单独对象；</p>
</li>
<li><p>所有Redis命令调用可能会抛出sw::redis::Error异常，应当捕获并妥善处理（如重连、告警、日志记录等）；</p>
</li>
<li><p>哨兵模式下，只需在 conn_opts.host 填写任意一个哨兵节点地址，客户端会自动发现主从节点；</p>
</li>
<li><p>避免长时间持有 Redis 对象的引用，使用完毕后及时释放，让连接池回收连接。</p>
</li>
</ul>
<p><a id="Sentinel"></a></p>
<h1 id="五、Sentinel"><a href="#五、Sentinel" class="headerlink" title="五、Sentinel"></a>五、Sentinel</h1><p>Sentinel 类是 Redis++ 中专门用于与 <strong>Redis Sentinel 哨兵集群</strong> 通信的组件，功能：</p>
<ul>
<li>服务发现 <ul>
<li>从哨兵集群获取当前主库&#x2F;从库的地址</li>
</ul>
</li>
<li>故障透明 <ul>
<li>故障切换时<strong>自动获取新主库地址</strong></li>
</ul>
</li>
<li>连接中介 <ul>
<li>作为 Redis 对象和实际 Redis 实例之间的桥梁</li>
</ul>
</li>
</ul>
<h2 id="1-Sentinel类的职责"><a href="#1-Sentinel类的职责" class="headerlink" title="1.Sentinel类的职责"></a>1.Sentinel类的职责</h2><ul>
<li><strong>使用 Role::MASTER</strong>：<ul>
<li>redis-plus-plus <strong>总是连接到当前的master</strong>（即使发生故障切换）。</li>
<li>每次 redis-plus-plus 需要“为master创建一个新的连接”，或者“连接断开并且需要重新连接到master”时<ul>
<li>redis-plus-plus 会向 Redis Sentinel 询问master地址，并连接到当前的master。</li>
</ul>
</li>
<li><strong>发生故障切换</strong><ul>
<li>redis-plus-plus 可以自动获取新master的地址，并<strong>刷新底层连接池中的所有连地址接（连接到新的master）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用 Role::SLAVE</strong><ul>
<li>redis-plus-plus <strong>总是连接到slave</strong>。</li>
<li>一个主节点可能有多个slave，redis-plus-plus 会<strong>随机选一个并连接到它</strong><ul>
<li><strong>底层连接池中的所有连接都连接到同一个slave</strong></li>
</ul>
</li>
<li><strong>如果连接断开，且该slave仍为活体</strong><ul>
<li>redis-plus-plus 将重新连接该从属实例</li>
</ul>
</li>
<li><strong>如果该salve宕机，或者被提升为master</strong><ul>
<li>redis-plus-plus 会随机连接到另一个slave。</li>
<li>如果没有活着的slave，它会抛出例外。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-Sentinel类的关键实现细节"><a href="#2-Sentinel类的关键实现细节" class="headerlink" title="2.Sentinel类的关键实现细节"></a>2.Sentinel类的关键实现细节</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sentinel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sentinel</span><span class="params">(<span class="type">const</span> SentinelOptions &amp;sentinel_opts)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sentinel</span>(<span class="type">const</span> Sentinel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Sentinel&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sentinel &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sentinel</span>(Sentinel &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Sentinel&amp; <span class="keyword">operator</span>=(Sentinel &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Sentinel</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h2 id="3-Sentinel-类的使用方式"><a href="#3-Sentinel-类的使用方式" class="headerlink" title="3.Sentinel 类的使用方式"></a>3.Sentinel 类的使用方式</h2><p><a href="#SentinelOptions">SentinelOptions结构体</a></p>
<h3 id="（1）创建-Sentinel-对象"><a href="#（1）创建-Sentinel-对象" class="headerlink" title="（1）创建 Sentinel 对象"></a>（1）创建 Sentinel 对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"><span class="comment">// 配置哨兵选项</span></span><br><span class="line">SentinelOptions sentinel_opts;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【必需】哨兵节点列表（至少配置一个，建议三个以上保证高可用）</span></span><br><span class="line">sentinel_opts.nodes = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26379</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26380</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26381</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【可选】连接哨兵的超时时间，默认 100ms ——&gt;注：不能为0</span></span><br><span class="line">sentinel_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【可选】请求/响应超时时间，默认 100ms  ——&gt;注：不能为0</span></span><br><span class="line">sentinel_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Sentinel 共享指针（必须用 shared_ptr）</span></span><br><span class="line"><span class="keyword">auto</span> sentinel = std::<span class="built_in">make_shared</span>&lt;Sentinel&gt;(sentinel_opts);</span><br></pre></td></tr></table></figure>

<h3 id="（2）通过-Sentinel-创建-Redis-连接"><a href="#（2）通过-Sentinel-创建-Redis-连接" class="headerlink" title="（2）通过 Sentinel 创建 Redis 连接"></a>（2）通过 Sentinel 创建 Redis 连接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =============== 1.创建哨兵 ===============</span></span><br><span class="line"><span class="comment">// 配置哨兵选项</span></span><br><span class="line">SentinelOptions sentinel_opts;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【必需】哨兵节点列表（至少配置一个，建议三个以上保证高可用）</span></span><br><span class="line">sentinel_opts.nodes = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26379</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26380</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26381</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【可选】连接哨兵的超时时间，默认 100ms ——&gt;注：不能为0</span></span><br><span class="line">sentinel_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【可选】请求/响应超时时间，默认 100ms  ——&gt;注：不能为0</span></span><br><span class="line">sentinel_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Sentinel 共享指针（必须用 shared_ptr）</span></span><br><span class="line"><span class="keyword">auto</span> sentinel = std::<span class="built_in">make_shared</span>&lt;Sentinel&gt;(sentinel_opts);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============== 2.创建Redis连接配置 ===============</span></span><br><span class="line"><span class="comment">// 连接配置</span></span><br><span class="line">ConnectionOptions conn_opts;</span><br><span class="line">conn_opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">conn_opts.port = <span class="number">6379</span>;</span><br><span class="line">conn_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);   <span class="comment">// 必须设置！不能为 0</span></span><br><span class="line">conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);    <span class="comment">// 必须设置！不能为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池配置</span></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">5</span>;  <span class="comment">// 连接池大小：5个连接</span></span><br><span class="line">pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);  <span class="comment">// 等待连接超时</span></span><br><span class="line">pool_opts.connection_lifetime = std::chrono::<span class="built_in">minutes</span>(<span class="number">10</span>); <span class="comment">// 连接生命周期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============== 3.创建Redis主节点 ===============</span></span><br><span class="line"><span class="comment">// 创建连接主库的 Redis 对象</span></span><br><span class="line"><span class="keyword">auto</span> master = <span class="built_in">Redis</span>(sentinel,</span><br><span class="line">                    <span class="string">&quot;mymaster&quot;</span>,	 	<span class="comment">// Name of master node</span></span><br><span class="line">                    Role::MASTER, 	<span class="comment">// 角色</span></span><br><span class="line">                    conn_opts, </span><br><span class="line">                    pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =============== 3.创建Redis从节点 ===============</span></span><br><span class="line"><span class="comment">// 创建连接从库的 Redis 对象</span></span><br><span class="line"><span class="keyword">auto</span> slave = <span class="built_in">Redis</span>(sentinel, </span><br><span class="line">                   <span class="string">&quot;mymaster&quot;</span>,		<span class="comment">// Name of master node </span></span><br><span class="line">                   Role::SLAVE, 	<span class="comment">// 角色</span></span><br><span class="line">                   conn_opts, </span><br><span class="line">                   pool_opts);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>不需要手动指定“主节点&#x2F;从节点”的ip：port</strong>，由Sentinel自动分配</li>
</ul>
<h1 id="六、RedisCluster（集群模式客户端）"><a href="#六、RedisCluster（集群模式客户端）" class="headerlink" title="六、RedisCluster（集群模式客户端）"></a>六、RedisCluster（集群模式客户端）</h1><ul>
<li>RedisCluster类是集群模式下“客户端”连接“服务端”的句柄，向服务端发送请求<ul>
<li>redis-plus-plus 客户端库<strong>不负责创建集群</strong>，它只负责<strong>连接到已存在的集群</strong>。</li>
</ul>
</li>
<li><strong>接口与 Redis 类类似！！</strong></li>
</ul>
<h2 id="1-RedisCluster类-的构造"><a href="#1-RedisCluster类-的构造" class="headerlink" title="1.RedisCluster类 的构造"></a>1.RedisCluster类 的构造</h2><h3 id="（1）构造函数"><a href="#（1）构造函数" class="headerlink" title="（1）构造函数"></a>（1）构造函数</h3><h4 id="基本构造函数"><a href="#基本构造函数" class="headerlink" title="&lt;1&gt;基本构造函数"></a>&lt;1&gt;基本构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RedisCluster</span>(<span class="type">const</span> ConnectionOptions &amp;connection_opts,</span><br><span class="line">             <span class="type">const</span> ConnectionPoolOptions &amp;pool_opts = &#123;&#125;,    <span class="comment">//默认为每个主节点维护单一连接</span></span><br><span class="line">             Role role = Role::MASTER,</span><br><span class="line">             <span class="type">const</span> ClusterOptions &amp;cluster_opts = &#123;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260113163903839.png"></p>
<h4 id="URL构造函数"><a href="#URL构造函数" class="headerlink" title="&lt;2&gt;URL构造函数"></a>&lt;2&gt;URL构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如： &quot;tcp://127.0.0.1&quot; or &quot;tcp://127.0.0.1:6379&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">RedisCluster</span><span class="params">(<span class="type">const</span> std::string &amp;uri)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>限制</strong>：</p>
<ul>
<li>❌ 无法指定密码</li>
<li>❌ 只能使用默认连接池配置（size&#x3D;1）</li>
</ul>
<h3 id="（2）配置选项"><a href="#（2）配置选项" class="headerlink" title="（2）配置选项"></a>（2）配置选项</h3><h4 id="ConnectionOptions（连接配置）"><a href="#ConnectionOptions（连接配置）" class="headerlink" title="&lt;1&gt;ConnectionOptions（连接配置）"></a>&lt;1&gt;ConnectionOptions（连接配置）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">connection_options.host = <span class="string">&quot;127.0.0.1&quot;</span>;  <span class="comment">// 必需：任意一个主节点</span></span><br><span class="line">connection_options.port = <span class="number">7000</span>;         <span class="comment">// 可选：默认 6379</span></span><br><span class="line">connection_options.password = <span class="string">&quot;auth&quot;</span>;   <span class="comment">// 可选：集群密码（所有节点相同）</span></span><br><span class="line">connection_options.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">connection_options.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">connection_options.keep_alive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 集群模式下被忽略</span></span><br><span class="line">connection_options.db = <span class="number">0</span>;  <span class="comment">// Redis Cluster 不支持多数据库</span></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ul>
<li><p>⚠️ 只能使用 TCP 连接，<strong>不支持 Unix Domain Socket</strong></p>
</li>
<li><p>⚠️ 所有节点<strong>必须使用相同的密码</strong></p>
</li>
<li><p>⚠️ db 参数被忽略（集群不支持多数据库）</p>
</li>
</ul>
<p><strong>自动发现机制</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">只需配置一个主节点</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">RedisCluster 发送 CLUSTER SLOTS 命令</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">自动获取所有节点信息并建立连接</span><br></pre></td></tr></table></figure>

<h4 id="ConnectionPoolOptions（连接池配置）"><a href="#ConnectionPoolOptions（连接池配置）" class="headerlink" title="&lt;2&gt;ConnectionPoolOptions（连接池配置）"></a>&lt;2&gt;ConnectionPoolOptions（连接池配置）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line">pool_options.size = <span class="number">3</span>;  <span class="comment">// 每个节点的连接数</span></span><br><span class="line">pool_options.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">pool_options.connection_lifetime = std::chrono::<span class="built_in">minutes</span>(<span class="number">10</span>);</span><br><span class="line">pool_options.connection_idle_time = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>工作原理</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设集群有 3 个主节点，且pool_options.size = 3</span><br><span class="line"></span><br><span class="line">节点1 (127.0.0.1:7000) → 连接池 [conn1, conn2, conn3]</span><br><span class="line">节点2 (127.0.0.1:7001) → 连接池 [conn1, conn2, conn3]</span><br><span class="line">节点3 (127.0.0.1:7002) → 连接池 [conn1, conn2, conn3]</span><br><span class="line"></span><br><span class="line">总连接数 = 3 节点 × 3 连接 = 9 个连接</span><br></pre></td></tr></table></figure>

<h4 id="ClusterOptions（集群配置）"><a href="#ClusterOptions（集群配置）" class="headerlink" title="&lt;3&gt;ClusterOptions（集群配置）"></a>&lt;3&gt;ClusterOptions（集群配置）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ClusterOptions</span> &#123;</span><br><span class="line">    <span class="comment">//刷新“槽位-节点”映射的时间</span></span><br><span class="line">    std::chrono::milliseconds slot_map_refresh_interval = std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：</p>
<ul>
<li><p>🔄 定期刷新槽位-节点映射（默认 10 秒）</p>
</li>
<li><p>🔄 同时刷新节点列表（自动发现新节点&#x2F;移除下线节点）</p>
</li>
</ul>
<p><strong>刷新触发条件</strong>：</p>
<ol>
<li><p>定时刷新：每 10 秒（可配置）</p>
</li>
<li><p>错误触发：收到 MOVED&#x2F;ASK 重定向时立即刷新</p>
</li>
</ol>
<h3 id="（3）创建实例的方式"><a href="#（3）创建实例的方式" class="headerlink" title="（3）创建实例的方式"></a>（3）创建实例的方式</h3><h4 id="使用-URI（最简单）"><a href="#使用-URI（最简单）" class="headerlink" title="&lt;1&gt;使用 URI（最简单）"></a>&lt;1&gt;使用 URI（最简单）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只指定一个节点，自动发现其他节点</span></span><br><span class="line"><span class="keyword">auto</span> redis = sw::redis::<span class="built_in">RedisCluster</span>(<span class="string">&quot;tcp://127.0.0.1:7000&quot;</span>);</span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：代码简洁<br><strong>缺点</strong>：无法配置密码、连接池大小</p>
<h4 id="标准配置（推荐）"><a href="#标准配置（推荐）" class="headerlink" title="&lt;2&gt;标准配置（推荐）"></a>&lt;2&gt;标准配置（推荐）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 连接配置（任意一个主节点）</span></span><br><span class="line">ConnectionOptions conn_opts;</span><br><span class="line">conn_opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">conn_opts.port = <span class="number">7000</span>;</span><br><span class="line">conn_opts.password = <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line">conn_opts.connect_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">conn_opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 连接池配置（每个节点 3 个连接）</span></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line">pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 RedisCluster</span></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">RedisCluster</span>(conn_opts, pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="完整配置"><a href="#完整配置" class="headerlink" title="&lt;3&gt;完整配置"></a>&lt;3&gt;完整配置</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions conn_opts;</span><br><span class="line">conn_opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">conn_opts.port = <span class="number">7000</span>;</span><br><span class="line">conn_opts.password = <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">ClusterOptions cluster_opts;</span><br><span class="line">cluster_opts.slot_map_refresh_interval = std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">RedisCluster</span>(</span><br><span class="line">    conn_opts, </span><br><span class="line">    pool_opts, </span><br><span class="line">    Role::MASTER,      <span class="comment">// 访问主节点</span></span><br><span class="line">    cluster_opts</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="2-RedisCluster的连接机制"><a href="#2-RedisCluster的连接机制" class="headerlink" title="2.RedisCluster的连接机制"></a>2.RedisCluster的连接机制</h2><h3 id="（1）Role-MASTER-模式（默认）"><a href="#（1）Role-MASTER-模式（默认）" class="headerlink" title="（1）Role::MASTER 模式（默认）"></a>（1）Role::MASTER 模式（默认）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">RedisCluster</span>(conn_opts, pool_opts, Role::MASTER);</span><br></pre></td></tr></table></figure>
<h4 id="连接拓扑（连接所有主节点）"><a href="#连接拓扑（连接所有主节点）" class="headerlink" title="&lt;1&gt;连接拓扑（连接所有主节点）"></a>&lt;1&gt;连接拓扑（连接所有主节点）</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Redis 集群：</span><br><span class="line">┌─────────┐     ┌─────────┐     ┌─────────┐</span><br><span class="line">│ 主节点1 │     │ 主节点2 │     │ 主节点3 │</span><br><span class="line">│  :7000  │     │  :7001  │     │  :7002  │</span><br><span class="line">└────┬────┘     └────┬────┘     └────┬────┘</span><br><span class="line"><span class="code">     │               │               │</span></span><br><span class="line"><span class="code">   从节点         从节点          从节点</span></span><br><span class="line"><span class="code">   :7003          :7004          :7005</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">客户端连接：</span><br><span class="line">┌──────────┐</span><br><span class="line">│ 客户端   │</span><br><span class="line">└────┬─────┘</span><br><span class="line"><span class="code">     ├─────直连─────→ 主节点1 (:7000) [连接池 3个连接]</span></span><br><span class="line"><span class="code">     ├─────直连─────→ 主节点2 (:7001) [连接池 3个连接]</span></span><br><span class="line"><span class="code">     └─────直连─────→ 主节点3 (:7002) [连接池 3个连接]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：Role::MASTER 连接<strong>所有</strong>主节点！！</li>
</ul>
<h4 id="为什么-Role-MASTER-要连接所有主节点？"><a href="#为什么-Role-MASTER-要连接所有主节点？" class="headerlink" title="&lt;2&gt;为什么 Role::MASTER 要连接所有主节点？"></a>&lt;2&gt;为什么 Role::MASTER 要连接所有主节点？</h4><ul>
<li><strong>redis集群是对redis的水平扩容</strong>：<ul>
<li>即启动N个redis节点，将整个数据分布存储在这个<strong>N个节点</strong>中，每个节<br>点<strong>存储总数据的1&#x2F;N</strong></li>
</ul>
</li>
</ul>
<h5 id="原因1：数据分片存储"><a href="#原因1：数据分片存储" class="headerlink" title="原因1：数据分片存储"></a>原因1：数据分片存储</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091913625.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091947050.png"></p>
<h5 id="原因2：写操作必须到主节点"><a href="#原因2：写操作必须到主节点" class="headerlink" title="原因2：写操作必须到主节点"></a>原因2：写操作必须到主节点</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092102449.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单主节点设计：</span><br><span class="line">请求 → 主节点1 → MOVED → 重定向 → 主节点2/3</span><br><span class="line">           ↓ 每次都要重定向</span><br><span class="line">      性能损失：额外的网络往返</span><br><span class="line"></span><br><span class="line">多主节点设计：</span><br><span class="line">请求 → 计算槽位 → 直接找到正确节点 → 立即返回</span><br><span class="line">           ↓ 零重定向</span><br><span class="line">      性能最优：一次网络往返</span><br></pre></td></tr></table></figure>

<h3 id="（2）Role-SLAVE-模式（连接每个主节点的一个随机从节点）"><a href="#（2）Role-SLAVE-模式（连接每个主节点的一个随机从节点）" class="headerlink" title="（2）Role::SLAVE 模式（连接每个主节点的一个随机从节点）"></a>（2）Role::SLAVE 模式（连接每个主节点的一个随机从节点）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">RedisCluster</span>(conn_opts, pool_opts, Role::SLAVE);</span><br></pre></td></tr></table></figure>

<h4 id="连接拓扑"><a href="#连接拓扑" class="headerlink" title="&lt;1&gt;连接拓扑"></a>&lt;1&gt;连接拓扑</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Redis 集群：</span><br><span class="line">┌─────────┐     ┌─────────┐     ┌─────────┐</span><br><span class="line">│ 主节点1 │     │ 主节点2 │     │ 主节点3 │</span><br><span class="line">│  :7000  │     │  :7001  │     │  :7002  │</span><br><span class="line">└────┬────┘     └────┬────┘     └────┬────┘</span><br><span class="line"><span class="code">     │               │               │</span></span><br><span class="line"><span class="code">   从节点1a        从节点2a        从节点3a</span></span><br><span class="line"><span class="code">   :7003          :7004          :7005</span></span><br><span class="line"><span class="code">     │               │</span></span><br><span class="line"><span class="code">   从节点1b        从节点2b</span></span><br><span class="line"><span class="code">   :7006          :7007</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">客户端连接（Role::SLAVE 模式）：</span><br><span class="line">┌──────────┐</span><br><span class="line">│ 客户端   │</span><br><span class="line">└────┬─────┘</span><br><span class="line"><span class="code">     ├─────直连─────→ 从节点1a (:7003) [连接池 3个连接]</span></span><br><span class="line"><span class="code">     │                ↑ 随机选择主节点1的一个从节点</span></span><br><span class="line"><span class="code">     │</span></span><br><span class="line"><span class="code">     ├─────直连─────→ 从节点2a (:7004) [连接池 3个连接]</span></span><br><span class="line"><span class="code">     │                ↑ 随机选择主节点2的一个从节点</span></span><br><span class="line"><span class="code">     │</span></span><br><span class="line"><span class="code">     └─────直连─────→ 从节点3a (:7005) [连接池 3个连接]</span></span><br><span class="line"><span class="code">                      ↑ 随机选择主节点3的一个从节点</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：Role::SLAVE 连接每个主节点的一个随机从节点</p>
<h4 id="为什么-Role-SLAVE-要连接每个主节点的一个随机从节点？"><a href="#为什么-Role-SLAVE-要连接每个主节点的一个随机从节点？" class="headerlink" title="&lt;2&gt;为什么 Role::SLAVE 要连接每个主节点的一个随机从节点？"></a>&lt;2&gt;为什么 Role::SLAVE 要连接每个主节点的一个随机从节点？</h4><h5 id="原因1-保持槽位覆盖"><a href="#原因1-保持槽位覆盖" class="headerlink" title="原因1:保持槽位覆盖"></a>原因1:保持槽位覆盖</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092349865.png"></p>
<h5 id="原因2：负载均衡"><a href="#原因2：负载均衡" class="headerlink" title="原因2：负载均衡"></a>原因2：负载均衡</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092417497.png"></p>
<h5 id="为什么不是所有从节点？"><a href="#为什么不是所有从节点？" class="headerlink" title="为什么不是所有从节点？"></a>为什么不是所有从节点？</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114092451027.png"></p>
<h3 id="（3）“Role-MASTER-模式”-vs-“Role-SLAVE-模式”"><a href="#（3）“Role-MASTER-模式”-vs-“Role-SLAVE-模式”" class="headerlink" title="（3）“Role::MASTER 模式” vs “Role::SLAVE 模式”"></a>（3）“Role::MASTER 模式” vs “Role::SLAVE 模式”</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091249622.png"></p>
<h3 id="（4）常见误解"><a href="#（4）常见误解" class="headerlink" title="（4）常见误解"></a>（4）常见误解</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114091358906.png"></p>
<h2 id="3-RedisCluster类的注意事项"><a href="#3-RedisCluster类的注意事项" class="headerlink" title="3.RedisCluster类的注意事项"></a>3.RedisCluster类的注意事项</h2><h3 id="（1）无法直接发送“无key参数的命令”"><a href="#（1）无法直接发送“无key参数的命令”" class="headerlink" title="（1）无法直接发送“无key参数的命令”"></a>（1）无法直接发送“无key参数的命令”</h3><p>RedisCluster 对象确实可以发送大多数请求，但“key参数命令”无法直接发送</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="&lt;1&gt;问题"></a>&lt;1&gt;问题</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093548922.png"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="&lt;2&gt;解决方案"></a>&lt;2&gt;解决方案</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093630371.png"></p>
<h4 id="“RedisCluster”-vs-“RedisCluster-redis-”"><a href="#“RedisCluster”-vs-“RedisCluster-redis-”" class="headerlink" title="&lt;3&gt;“RedisCluster” vs “RedisCluster::redis()”"></a>&lt;3&gt;“RedisCluster” vs “RedisCluster::redis()”</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093926722.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114093942338.png"></p>
<p><strong>注意</strong>：</p>
<ul>
<li>RedisCluster::redis() 返回的 Redis 对象不是线程安全的</li>
<li>一旦抛出异常，必须销毁并重新创建</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⚠️ 重要：返回的 Redis 对象不是线程安全的！</span></span><br><span class="line"><span class="keyword">auto</span> r = redis_cluster.<span class="built_in">redis</span>(<span class="string">&quot;hash-tag&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 如果抛出异常，必须销毁并重新创建</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    r.<span class="built_in">command</span>(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// r 不再可用，必须重建</span></span><br><span class="line">    r = redis_cluster.<span class="built_in">redis</span>(<span class="string">&quot;hash-tag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、Redis-命令的发送"><a href="#七、Redis-命令的发送" class="headerlink" title="七、Redis++ 命令的发送"></a>七、Redis++ 命令的发送</h1><h2 id="1-命令调用方式"><a href="#1-命令调用方式" class="headerlink" title="1.命令调用方式"></a>1.命令调用方式</h2><p>Redis++ 为每个 Redis 命令提供同名（小写）方法，支持多种重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DEL 命令的 3 种重载</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::del</span><span class="params">(<span class="type">const</span> StringView &amp;key)</span></span>;                    <span class="comment">// 单个 key</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input&gt;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::del</span><span class="params">(Input first, Input last)</span></span>;                  <span class="comment">// 迭代器范围</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Redis::del</span><span class="params">(std::initializer_list&lt;T&gt; il)</span></span>;              <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure>

<h2 id="2-参数类型详解"><a href="#2-参数类型详解" class="headerlink" title="2.参数类型详解"></a>2.参数类型详解</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114102612093.png"></p>
<p><strong>StringView 详解</strong>:<br>	- C++17 下 StringView 就是 <strong>std::string_view</strong> 的别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringView 兼容多种字符串类型</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);                          <span class="comment">// C 风格字符串</span></span><br><span class="line"></span><br><span class="line">std::string key = <span class="string">&quot;key&quot;</span>, val = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">redis.<span class="built_in">set</span>(key, val);                                <span class="comment">// std::string</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; data = &#123;...&#125;;</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="built_in">StringView</span>(data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()));  <span class="comment">// 避免拷贝大数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-返回值详解"><a href="#3-返回值详解" class="headerlink" title="3.返回值详解"></a>3.返回值详解</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114102827965.png"></p>
<h2 id="4-bool-返回值"><a href="#4-bool-返回值" class="headerlink" title="4.bool 返回值"></a>4.bool 返回值</h2><ul>
<li>某些方法的返回类型为bool，例如 EXPIRE、HSET</li>
<li><strong>千万不要用返回值来检查命令是否成功发送到 Redis 服务器！！</strong>：<ul>
<li><strong>如果方法返回 false</strong>：<ul>
<li>并不意味着 Redis 未能将命令发送到服务器。相反，这意味着 Redis 服务器返回一个整数回复 ，且回复值为 0。</li>
</ul>
</li>
<li><strong>如果方法返回为真</strong>：<ul>
<li>意味着 Redis 服务器返回的是整数回复 ，且回复值为 1</li>
</ul>
</li>
</ul>
</li>
<li>如果 Redis 未能向服务器发送命令，就<strong>会抛出 Error 类型的异常</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⚠️ 重要：bool 返回值不代表命令是否发送成功！</span></span><br><span class="line"><span class="comment">// true  = Redis 返回整数 1</span></span><br><span class="line"><span class="comment">// false = Redis 返回整数 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="built_in">expire</span>(<span class="string">&quot;key&quot;</span>, <span class="built_in">seconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">    <span class="comment">// 返回 1：超时设置成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 0：key 不存在（不是发送失败！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="built_in">setnx</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 返回 1：key 不存在，设置成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 0：key 已存在，设置失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 💡 命令发送失败会抛异常，不会返回 false</span></span><br></pre></td></tr></table></figure>

<h2 id="5-Optional-处理-NULL-回复"><a href="#5-Optional-处理-NULL-回复" class="headerlink" title="5.Optional 处理 NULL 回复"></a>5.Optional 处理 NULL 回复</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET 可能返回 NULL（key 不存在）</span></span><br><span class="line">OptionalString val = redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;       <span class="comment">// 解引用获取值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key 不存在&quot;</span> &lt;&lt; std::endl; <span class="comment">// NULL 回复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MGET 返回多个 Optional</span></span><br><span class="line">std::vector&lt;OptionalString&gt; values;</span><br><span class="line">redis.<span class="built_in">mget</span>(&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>&#125;, std::<span class="built_in">back_inserter</span>(values));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : values) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v) &#123;</span><br><span class="line">        std::cout &lt;&lt; *v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用 Optional 类型别名</span></span><br><span class="line"><span class="keyword">using</span> OptionalString = Optional&lt;std::string&gt;;</span><br><span class="line"><span class="keyword">using</span> OptionalLongLong = Optional&lt;<span class="type">long</span> <span class="type">long</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> OptionalDouble = Optional&lt;<span class="type">double</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> OptionalStringPair = Optional&lt;std::pair&lt;std::string, std::string&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="6-Variant-处理多类型回复（C-17）"><a href="#6-Variant-处理多类型回复（C-17）" class="headerlink" title="6. Variant 处理多类型回复（C++17）"></a>6. Variant 处理多类型回复（C++17）</h2><ul>
<li>如果<strong>回复类型不同</strong>，<strong>std::variant</strong> 是个不错的回复类型选择</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MEMORY STATS 返回混合类型</span></span><br><span class="line"><span class="comment">// 值可能是 long long、double 或嵌套 map</span></span><br><span class="line"><span class="keyword">using</span> Var = Variant&lt;<span class="type">double</span>, <span class="type">long</span> <span class="type">long</span>, std::unordered_map&lt;std::string, <span class="type">long</span> <span class="type">long</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = redis.command&lt;std::unordered_map&lt;std::string, Var&gt;&gt;(<span class="string">&quot;memory&quot;</span>, <span class="string">&quot;stats&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">double</span>&gt;(value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⚠️ Variant 的限制</strong>：</p>
<ul>
<li><strong>Variant 的类型参数不能有重复的项</strong>（Redis++ 库限制）<ul>
<li>例如 Variant&lt;double, long long, double&gt; 无法工作。</li>
</ul>
</li>
<li><strong>double 必须放在 std::string 之前</strong>：<ul>
<li>因为 double 回复实际是字符串格式</li>
<li>在解析变体时，我们尝试将回复解析为第一个匹配的类型，由左到右的类型参数指定</li>
<li>如果 double 放在 std::string 之后，回复总是会解析成 std::string</li>
</ul>
</li>
</ul>
<h2 id="7-输出迭代器与-STL-容器"><a href="#7-输出迭代器与-STL-容器" class="headerlink" title="7.输出迭代器与 STL 容器"></a>7.输出迭代器与 STL 容器</h2><ul>
<li>使用<strong>command通用命令接口</strong>时，你也可以把它解析成 STL 容器，而不是解析输出的回复。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用输出迭代器</span></span><br><span class="line">std::vector&lt;std::string&gt; members;</span><br><span class="line">redis.<span class="built_in">lrange</span>(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(members));</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; hash;</span><br><span class="line">redis.<span class="built_in">hgetall</span>(<span class="string">&quot;hash&quot;</span>, std::<span class="built_in">inserter</span>(hash, hash.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接返回 STL 容器（通用命令接口）</span></span><br><span class="line"><span class="keyword">auto</span> config = redis.command&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="8-各种参数类型"><a href="#8-各种参数类型" class="headerlink" title="8.各种参数类型"></a>8.各种参数类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ***** StringView 类型的参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式通过 C 风格字符串构造 StringView</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式通过 std::string 构造 StringView</span></span><br><span class="line"><span class="function">std::string <span class="title">key</span><span class="params">(<span class="string">&quot;key&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">val</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line">redis.<span class="built_in">set</span>(key, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式传递 StringView 作为参数</span></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; large_data;</span><br><span class="line"><span class="comment">// 避免数据拷贝</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="built_in">StringView</span>(large_data.<span class="built_in">data</span>(), large_data.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** long long 类型的参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于索引参数</span></span><br><span class="line">redis.<span class="built_in">bitcount</span>(key, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于数值参数</span></span><br><span class="line">redis.<span class="built_in">incrby</span>(<span class="string">&quot;num&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** double 类型的参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于分数（score）参数</span></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;m1&quot;</span>, <span class="number">2.5</span>);</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;m2&quot;</span>, <span class="number">3.5</span>);</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;m3&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于（经度，纬度）坐标参数</span></span><br><span class="line">redis.<span class="built_in">geoadd</span>(<span class="string">&quot;geo&quot;</span>, std::<span class="built_in">make_tuple</span>(<span class="string">&quot;member&quot;</span>, <span class="number">13.5</span>, <span class="number">15.6</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 时间相关参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">expire</span>(key, <span class="built_in">seconds</span>(<span class="number">1000</span>)); <span class="comment">// 设置过期时间为 1000 秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> tp = <span class="built_in">time_point_cast</span>&lt;seconds&gt;(system_clock::<span class="built_in">now</span>() + <span class="built_in">seconds</span>(<span class="number">100</span>));</span><br><span class="line">redis.<span class="built_in">expireat</span>(key, tp); <span class="comment">// 设置指定时间点过期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 命令的一些可选参数 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="built_in">set</span>(key, <span class="string">&quot;value&quot;</span>, <span class="built_in">milliseconds</span>(<span class="number">100</span>), UpdateType::NOT_EXIST)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;set 操作成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">linsert</span>(<span class="string">&quot;list&quot;</span>, InsertPosition::BEFORE, <span class="string">&quot;pivot&quot;</span>, <span class="string">&quot;val&quot;</span>); <span class="comment">// 在指定元素前插入值</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (-无穷, +无穷) 区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>, UnboundedInterval&lt;<span class="type">double</span>&gt;&#123;&#125;, std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, 6] 闭区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">BoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">6</span>, BoundType::CLOSED),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3, 6] 左开右闭区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">BoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">6</span>, BoundType::LEFT_OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3, 6) 开区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">BoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">6</span>, BoundType::OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, 6) 左闭右开区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">BoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">6</span>, BoundType::RIGHT_OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, +无穷) 左闭右无界区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">LeftBoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, BoundType::RIGHT_OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3, +无穷) 左开右无界区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">LeftBoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, BoundType::OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (-无穷, 6] 左无界右闭区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">RightBoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">6</span>, BoundType::LEFT_OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (-无穷, 6) 左无界右开区间</span></span><br><span class="line">redis.<span class="built_in">zrangebyscore</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    <span class="built_in">RightBoundedInterval</span>&lt;<span class="type">double</span>&gt;(<span class="number">6</span>, BoundType::OPEN),</span><br><span class="line">    std::<span class="built_in">back_inserter</span>(res));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 迭代器对参数 *****</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; kvs = &#123;&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;, &#123;<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>&#125;, &#123;<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>&#125;&#125;;</span><br><span class="line">redis.<span class="built_in">mset</span>(kvs.<span class="built_in">begin</span>(), kvs.<span class="built_in">end</span>()); <span class="comment">// 批量设置键值对</span></span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; kv_map = &#123;&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;, &#123;<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>&#125;, &#123;<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>&#125;&#125;;</span><br><span class="line">redis.<span class="built_in">mset</span>(kv_map.<span class="built_in">begin</span>(), kv_map.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; str_map = &#123;&#123;<span class="string">&quot;f1&quot;</span>, <span class="string">&quot;v1&quot;</span>&#125;, &#123;<span class="string">&quot;f2&quot;</span>, <span class="string">&quot;v2&quot;</span>&#125;, &#123;<span class="string">&quot;f3&quot;</span>, <span class="string">&quot;v3&quot;</span>&#125;&#125;;</span><br><span class="line">redis.<span class="built_in">hmset</span>(<span class="string">&quot;hash&quot;</span>, str_map.<span class="built_in">begin</span>(), str_map.<span class="built_in">end</span>()); <span class="comment">// 批量设置哈希字段</span></span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">double</span>&gt; score_map = &#123;&#123;<span class="string">&quot;m1&quot;</span>, <span class="number">20</span>&#125;, &#123;<span class="string">&quot;m2&quot;</span>, <span class="number">12.5</span>&#125;, &#123;<span class="string">&quot;m3&quot;</span>, <span class="number">3.14</span>&#125;&#125;;</span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>, score_map.<span class="built_in">begin</span>(), score_map.<span class="built_in">end</span>()); <span class="comment">// 批量添加有序集合元素</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; keys = &#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>&#125;;</span><br><span class="line">redis.<span class="built_in">del</span>(keys.<span class="built_in">begin</span>(), keys.<span class="built_in">end</span>()); <span class="comment">// 批量删除键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** initializer_list 类型的参数 *****</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">mset</span>(&#123;</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>),</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>),</span><br><span class="line">    std::<span class="built_in">make_pair</span>(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">&#125;); <span class="comment">// 用初始化列表批量设置键值对</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">hmset</span>(<span class="string">&quot;hash&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;f1&quot;</span>, <span class="string">&quot;v1&quot;</span>),</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;f2&quot;</span>, <span class="string">&quot;v2&quot;</span>),</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;f3&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">    &#125;); <span class="comment">// 用初始化列表批量设置哈希字段</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">zadd</span>(<span class="string">&quot;zset&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;m1&quot;</span>, <span class="number">20.0</span>),</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;m2&quot;</span>, <span class="number">34.5</span>),</span><br><span class="line">        std::<span class="built_in">make_pair</span>(<span class="string">&quot;m3&quot;</span>, <span class="number">23.4</span>)</span><br><span class="line">    &#125;); <span class="comment">// 用初始化列表批量添加有序集合元素</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">del</span>(&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>&#125;); <span class="comment">// 用初始化列表批量删除键</span></span><br></pre></td></tr></table></figure>

<h2 id="9-各种返回值类型"><a href="#9-各种返回值类型" class="headerlink" title="9.各种返回值类型"></a>9.各种返回值类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ***** 返回值为 void 类型 *****</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 std::string 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> info = redis.<span class="built_in">info</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 bool 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!redis.<span class="built_in">expire</span>(<span class="string">&quot;nonexistent&quot;</span>, std::chrono::<span class="built_in">seconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;键不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="built_in">setnx</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;set 操作成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 long long 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> len = redis.<span class="built_in">strlen</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> num = redis.<span class="built_in">del</span>(&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line">num = redis.<span class="built_in">incr</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 double 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> real = redis.<span class="built_in">incrbyfloat</span>(<span class="string">&quot;b&quot;</span>, <span class="number">23.4</span>);</span><br><span class="line">real = redis.<span class="built_in">hincrbyfloat</span>(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="number">34.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 Optional&lt;std::string&gt;（即 OptionalString）类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> os = redis.<span class="built_in">get</span>(<span class="string">&quot;kk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (os) &#123;</span><br><span class="line">    std::cout &lt;&lt; *os &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;键不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">os = redis.<span class="built_in">spop</span>(<span class="string">&quot;set&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (os) &#123;</span><br><span class="line">    std::cout &lt;&lt; *os &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;集合为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 Optional&lt;long long&gt;（即 OptionalLongLong）类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> oll = redis.<span class="built_in">zrank</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;mem&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (oll) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排名为 &quot;</span> &lt;&lt; *oll &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;成员不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 Optional&lt;double&gt;（即 OptionalDouble）类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ob = redis.<span class="built_in">zscore</span>(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;m1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ob) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;分数为 &quot;</span> &lt;&lt; *ob &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;成员不存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 返回值为 Optional&lt;pair&lt;string, string&gt;&gt; 类型 *****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> op = redis.<span class="built_in">blpop</span>(&#123;<span class="string">&quot;list1&quot;</span>, <span class="string">&quot;list2&quot;</span>&#125;, std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">if</span> (op) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;键为 &quot;</span> &lt;&lt; op-&gt;first &lt;&lt; <span class="string">&quot;，值为 &quot;</span> &lt;&lt; op-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;超时&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 输出迭代器接收返回值 *****</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;OptionalString&gt; os_vec;</span><br><span class="line">redis.<span class="built_in">mget</span>(&#123;<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>&#125;, std::<span class="built_in">back_inserter</span>(os_vec));</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; s_vec;</span><br><span class="line">redis.<span class="built_in">lrange</span>(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>, std::<span class="built_in">back_inserter</span>(s_vec));</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; hash;</span><br><span class="line">redis.<span class="built_in">hgetall</span>(<span class="string">&quot;hash&quot;</span>, std::<span class="built_in">inserter</span>(hash, hash.<span class="built_in">end</span>()));</span><br><span class="line"><span class="comment">// 也可以将结果保存到字符串键值对的向量中</span></span><br><span class="line">std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; hash_vec;</span><br><span class="line">redis.<span class="built_in">hgetall</span>(<span class="string">&quot;hash&quot;</span>, std::<span class="built_in">back_inserter</span>(hash_vec));</span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;std::string&gt; str_set;</span><br><span class="line">redis.<span class="built_in">smembers</span>(<span class="string">&quot;s1&quot;</span>, std::<span class="built_in">inserter</span>(str_set, str_set.<span class="built_in">end</span>()));</span><br><span class="line"><span class="comment">// 也可以将结果保存到字符串向量中</span></span><br><span class="line">s_vec.<span class="built_in">clear</span>();</span><br><span class="line">redis.<span class="built_in">smembers</span>(<span class="string">&quot;s1&quot;</span>, std::<span class="built_in">back_inserter</span>(s_vec));</span><br></pre></td></tr></table></figure>

<h1 id="八、Redis-的异常处理"><a href="#八、Redis-的异常处理" class="headerlink" title="八、Redis++ 的异常处理"></a>八、Redis++ 的异常处理</h1><h2 id="1-Redis-的Exception"><a href="#1-Redis-的Exception" class="headerlink" title="1.Redis++的Exception"></a>1.Redis++的Exception</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::exception</span><br><span class="line">    └── sw::redis::Error              // 基类：所有 Redis++ 异常的父类</span><br><span class="line">            ├── IoError               // IO 错误（连接相关）</span><br><span class="line">            │       └── TimeoutError  // 超时错误（读写超时）</span><br><span class="line">            ├── ClosedError           // 服务器关闭连接</span><br><span class="line">            ├── ProtoError            // 协议错误（命令/回复无效）</span><br><span class="line">            ├── OomError              // hiredis 内存不足</span><br><span class="line">            ├── ReplyError            // Redis 返回错误回复</span><br><span class="line">            └── WatchError            // WATCH 的 key 被修改</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095237003.png"><br><strong>注意！！</strong>：</p>
<ul>
<li><strong>NULL REPLY 不是异常</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095332179.png"></li>
</ul>
<h2 id="2-异常后的对象状态"><a href="#2-异常后的对象状态" class="headerlink" title="2.异常后的对象状态"></a>2.异常后的对象状态</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095437891.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114095455051.png"></p>
<h2 id="3-异常处理模板"><a href="#3-异常处理模板" class="headerlink" title="3.异常处理模板"></a>3.异常处理模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_redis_operation</span><span class="params">(Redis&amp; redis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redis.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 超时：可重试</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;超时: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> ReplyError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// Redis 返回错误（如类型错误）：检查业务逻辑</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Redis 错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> IoError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// IO 错误：连接问题，自动重连</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;IO 错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 其他 Redis++ 错误</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// redis 对象仍然可用，下次调用会自动重连</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九、Redis-command（Redis-通用命令接口）"><a href="#九、Redis-command（Redis-通用命令接口）" class="headerlink" title="九、Redis::command（Redis++ 通用命令接口）"></a>九、Redis::command（Redis++ 通用命令接口）</h1><p>Redis++ 无法为所有 Redis 命令提供内置方法，Redis::command 允许你发送<strong>任意 Redis 命令</strong></p>
<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h2><h3 id="（1）直接指定返回类型（推荐）"><a href="#（1）直接指定返回类型（推荐）" class="headerlink" title="（1）直接指定返回类型（推荐）"></a>（1）直接指定返回类型（推荐）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无返回值的命令</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;my-connection&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串（可能为空）</span></span><br><span class="line"><span class="keyword">auto</span> val = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;getname&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回整数</span></span><br><span class="line"><span class="keyword">auto</span> num = redis.<span class="built_in">command</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="string">&quot;incrby&quot;</span>, <span class="string">&quot;counter&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回浮点数</span></span><br><span class="line"><span class="keyword">auto</span> real = redis.<span class="built_in">command</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;incrbyfloat&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="number">2.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组 - 方式1：使用输出迭代器</span></span><br><span class="line">std::vector&lt;OptionalString&gt; result;</span><br><span class="line">redis.<span class="built_in">command</span>(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>, std::<span class="built_in">back_inserter</span>(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组 - 方式2：直接解析为容器</span></span><br><span class="line"><span class="keyword">auto</span> result2 = redis.command&lt;std::vector&lt;OptionalString&gt;&gt;(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="（2）参数类型灵活"><a href="#（2）参数类型灵活" class="headerlink" title="（2）参数类型灵活"></a>（2）参数类型灵活</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 类没有内置的 *CLIENT SETNAME* 方法。</span></span><br><span class="line"><span class="comment">// 不过，你可以使用 Redis::command 手动发送该命令。</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> val = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;getname&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：以下代码仅作示例使用。实际上，Redis 已为</span></span><br><span class="line"><span class="comment">// 下述命令提供了内置方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令参数可以是字符串类型。</span></span><br><span class="line"><span class="comment">// 注意：对于 SET 命令，返回值并非始终为 void 类型，后续会详细说明。</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令参数可以是字符串和整数的组合。</span></span><br><span class="line"><span class="keyword">auto</span> num = redis.<span class="built_in">command</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="string">&quot;incrby&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数也可以是双精度浮点型（double）。</span></span><br><span class="line"><span class="keyword">auto</span> real = redis.<span class="built_in">command</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;incrbyfloat&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="number">2.3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至命令中的键（key）也可以是算术类型。</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;set&quot;</span>, <span class="number">100</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">val = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;get&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果命令返回元素数组。</span></span><br><span class="line">std::vector&lt;OptionalString&gt; result;</span><br><span class="line">redis.<span class="built_in">command</span>(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>, std::<span class="built_in">back_inserter</span>(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接解析为 vector 容器。</span></span><br><span class="line">result = redis.command&lt;std::vector&lt;OptionalString&gt;&gt;(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令参数可以是字符串范围（迭代器）。</span></span><br><span class="line"><span class="keyword">auto</span> set_cmd_strs = &#123;<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>&#125;;</span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(set_cmd_strs.<span class="built_in">begin</span>(), set_cmd_strs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> get_cmd_strs = &#123;<span class="string">&quot;get&quot;</span>, <span class="string">&quot;key&quot;</span>&#125;;</span><br><span class="line">val = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(get_cmd_strs.<span class="built_in">begin</span>(), get_cmd_strs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回的是元素数组。</span></span><br><span class="line">result.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">auto</span> mget_cmd_strs = &#123;<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>&#125;;</span><br><span class="line">redis.<span class="built_in">command</span>(mget_cmd_strs.<span class="built_in">begin</span>(), mget_cmd_strs.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(result));</span><br></pre></td></tr></table></figure>
<h2 id="2-重要注意事项"><a href="#2-重要注意事项" class="headerlink" title="2.重要注意事项"></a>2.重要注意事项</h2><h3 id="（1）多词命令必须分开传递"><a href="#（1）多词命令必须分开传递" class="headerlink" title="（1）多词命令必须分开传递"></a>（1）多词命令必须分开传递</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：分开传递</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;cluster&quot;</span>, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;maxmemory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误：合并为一个字符串</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;client setname&quot;</span>, <span class="string">&quot;name&quot;</span>);  <span class="comment">// 失败！</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）返回类型不固定时的处理"><a href="#（2）返回类型不固定时的处理" class="headerlink" title="（2）返回类型不固定时的处理"></a>（2）返回类型不固定时的处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：使用 OptionalString 处理可能的 NULL</span></span><br><span class="line"><span class="keyword">auto</span> r = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">    <span class="comment">// 返回 &quot;OK&quot;，设置成功</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;设置成功: &quot;</span> &lt;&lt; *r &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 NULL，key 已存在，设置失败</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key 已存在，设置失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：使用 ReplyUPtr 手动解析</span></span><br><span class="line"><span class="keyword">auto</span> reply = redis.<span class="built_in">command</span>(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_NIL) &#123;</span><br><span class="line">    <span class="comment">// NULL 回复，设置失败</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key 已存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_STATUS) &#123;</span><br><span class="line">    <span class="comment">// 状态回复 &quot;OK&quot;，设置成功</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;设置成功: &quot;</span> &lt;&lt; reply-&gt;str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：封装成 bool（模拟内置 set() 的行为）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">set_if_not_exist</span><span class="params">(Redis&amp; redis, <span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;set&quot;</span>, key, val, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> r.<span class="built_in">has_value</span>();  <span class="comment">// 有值 = 成功，空 = 失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用封装函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set_if_not_exist</span>(redis, <span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;myval&quot;</span>)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;设置成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key 已存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>常见陷阱</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⚠️ SET 命令的返回类型不是固定的！</span></span><br><span class="line"><span class="comment">// 普通 SET → 返回 &quot;OK&quot;（Status Reply）</span></span><br><span class="line"><span class="comment">// SET ... NX → 可能返回 NULL（key 已存在时）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 可能出错</span></span><br><span class="line">redis.<span class="built_in">command</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;NX&quot;</span>);  <span class="comment">// NX 失败时无法判断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确处理</span></span><br><span class="line"><span class="keyword">auto</span> result = redis.<span class="built_in">command</span>&lt;OptionalString&gt;(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>, <span class="string">&quot;NX&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 设置成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// key 已存在，设置失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="十、Redis-Pub-Sub（发布-订阅）"><a href="#十、Redis-Pub-Sub（发布-订阅）" class="headerlink" title="十、Redis++ Pub&#x2F;Sub（发布&#x2F;订阅）"></a>十、Redis++ Pub&#x2F;Sub（发布&#x2F;订阅）</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>你可以使用 <strong>Redis::publish方法</strong> 向频道（channels）发布消息<ul>
<li>Redis 会从底层连接池中<strong>随机选择</strong>一个连接，并通过该连接发布消息</li>
<li>因此，你发布的两条消息可能会使用两个不同的连接</li>
</ul>
</li>
<li>当你通过一个连接<strong>订阅某个频道</strong>时，发布到<strong>该频道的所有消息</strong>都会通过这个连接回传给客户端<ul>
<li>Redis 类中并<strong>没有Redis::subscribe方法</strong>：<ul>
<li>你可以调用 <strong>Redis::subscriber方法</strong> 创建一个 Subscriber（订阅者）对象，该对象会单独维护一个与 Redis 服务器的连接</li>
<li>这个底层连接是 <strong>新建的连接</strong>，<strong>“并非”从连接池中选取</strong>，且该新连接会 <strong>“沿用”原 Redis 对象的 ConnectionOptions（连接配置）</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">发布者                          Redis 服务器                      订阅者</span><br><span class="line">┌─────────┐                    ┌─────────────┐                 ┌─────────────┐</span><br><span class="line">│  Redis  │  ──<span class="built_in">publish</span>()──►   │             │  ──推送消息──►  │ Subscriber  │</span><br><span class="line">│ 对象    │                    │   Channel   │                 │ (独立连接)  │</span><br><span class="line">│(连接池) │                    │             │                 │             │</span><br><span class="line">└─────────┘                    └─────────────┘                 └─────────────┘</span><br><span class="line">   │                                                                  │</span><br><span class="line">   │ 随机选择连接发布                                          新建独立连接</span><br><span class="line">   └──────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>📊 速查表<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114120517753.png"></p>
<h2 id="2-Publish-发布消息"><a href="#2-Publish-发布消息" class="headerlink" title="2.Publish 发布消息"></a>2.Publish 发布消息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向频道发布消息（从连接池随机选择连接）</span></span><br><span class="line">redis.<span class="built_in">publish</span>(<span class="string">&quot;channel1&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">redis.<span class="built_in">publish</span>(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;breaking news!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：收到消息的订阅者数量</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> receivers = redis.<span class="built_in">publish</span>(<span class="string">&quot;channel1&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;收到消息的订阅者: &quot;</span> &lt;&lt; receivers &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="3-Subscriber-订阅"><a href="#3-Subscriber-订阅" class="headerlink" title="3.Subscriber 订阅"></a>3.Subscriber 订阅</h2><h3 id="（1）创建Subscriber对象"><a href="#（1）创建Subscriber对象" class="headerlink" title="（1）创建Subscriber对象"></a>（1）创建Subscriber对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建订阅者（新建独立连接，不使用连接池）</span></span><br><span class="line"><span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br></pre></td></tr></table></figure>
<p><strong>注意！！：</strong></p>
<ul>
<li>如果你想有<strong>不同的连接选项</strong>，比如不同频道的 ConnectionOptions::socket_timeout ，你应该创建带有不同连接选项的 Redis 对象，然后你可以用这些 Redis 对象创建订阅对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 频道1：100ms 超时</span></span><br><span class="line">ConnectionOptions opts1;</span><br><span class="line">opts<span class="number">1.</span>host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts<span class="number">1.</span>port = <span class="number">6379</span>;</span><br><span class="line">opts<span class="number">1.</span>socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">auto</span> redis1 = <span class="built_in">Redis</span>(opts1);</span><br><span class="line"><span class="keyword">auto</span> sub1 = redis<span class="number">1.</span><span class="built_in">subscriber</span>();  <span class="comment">// 继承 100ms 超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 频道2：300ms 超时</span></span><br><span class="line">ConnectionOptions opts2;</span><br><span class="line">opts<span class="number">2.</span>host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts<span class="number">2.</span>port = <span class="number">6379</span>;</span><br><span class="line">opts<span class="number">2.</span>socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">auto</span> redis2 = <span class="built_in">Redis</span>(opts2);</span><br><span class="line"><span class="keyword">auto</span> sub2 = redis<span class="number">2.</span><span class="built_in">subscriber</span>();  <span class="comment">// 继承 300ms 超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意⚠️：虽然创建了两个 Redis 对象，但没有性能损失</span></span><br><span class="line"><span class="comment">// 因为 Redis 对象是懒加载的，只有调用 subscriber() 时才创建连接</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）Subscriber的使用"><a href="#（2）Subscriber的使用" class="headerlink" title="（2）Subscriber的使用"></a>（2）Subscriber的使用</h3><h3 id="订阅频道和模式"><a href="#订阅频道和模式" class="headerlink" title="&lt;1&gt;订阅频道和模式"></a>&lt;1&gt;订阅频道和模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅单个频道</span></span><br><span class="line">sub.<span class="built_in">subscribe</span>(<span class="string">&quot;channel1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅多个频道</span></span><br><span class="line">sub.<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;channel2&quot;</span>, <span class="string">&quot;channel3&quot;</span>, <span class="string">&quot;channel4&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅模式（支持通配符）</span></span><br><span class="line">sub.<span class="built_in">psubscribe</span>(<span class="string">&quot;news:*&quot;</span>);      <span class="comment">// 匹配 news:sports, news:tech 等</span></span><br><span class="line">sub.<span class="built_in">psubscribe</span>(<span class="string">&quot;user:*:msg&quot;</span>);  <span class="comment">// 匹配 user:123:msg, user:456:msg 等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">sub.<span class="built_in">unsubscribe</span>(<span class="string">&quot;channel1&quot;</span>);</span><br><span class="line">sub.<span class="built_in">unsubscribe</span>(&#123;<span class="string">&quot;channel2&quot;</span>, <span class="string">&quot;channel3&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅模式</span></span><br><span class="line">sub.<span class="built_in">punsubscribe</span>(<span class="string">&quot;news:*&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消所有订阅（无参数）</span></span><br><span class="line">sub.<span class="built_in">unsubscribe</span>();   <span class="comment">// 取消所有频道订阅</span></span><br><span class="line">sub.<span class="built_in">punsubscribe</span>();  <span class="comment">// 取消所有模式订阅</span></span><br></pre></td></tr></table></figure>

<h4 id="Subscriber类-接收的6种消息类型"><a href="#Subscriber类-接收的6种消息类型" class="headerlink" title="&lt;2&gt; Subscriber类 接收的6种消息类型"></a>&lt;2&gt; Subscriber类 接收的6种消息类型</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114113148877.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114113623553.png"></p>
<ul>
<li>Subscriber 类是所有订阅消息（6 种类型）的<strong>唯一接收主体</strong></li>
<li>Subscriber类 通过消费方法（如 consume()）主动获取消息，且接收过程为<strong>阻塞式</strong><ul>
<li>调用 consume() 后会<strong>一直等待，直到有消息到达或超时</strong></li>
<li>这也是为什么 Subscriber 对象需要独占一个连接（<strong>不从连接池取</strong>）、且<strong>不建议多线程</strong>共用的原因。</li>
</ul>
</li>
</ul>
<h4 id="设置回调函数（处理6种消息）"><a href="#设置回调函数（处理6种消息）" class="headerlink" title="&lt;3&gt;设置回调函数（处理6种消息）"></a>&lt;3&gt;设置回调函数（处理6种消息）</h4><p><strong>为处理Subscriber类接收的6种消息，可以在 Subscriber 上设置“回调函数”</strong></p>
<ul>
<li><p><strong>Subscriber::on_message(MsgCallback)</strong>：</p>
<ul>
<li><strong>功能</strong>：<ul>
<li>为 MESSAGE 类型消息设置回调函数</li>
</ul>
</li>
<li><strong>回调接口定义</strong>：<ul>
<li>void (std::string channel, std::string msg)  </li>
<li>参数说明：<br>  - channel：消息所属频道<br>  - msg：实际消息内容</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Subscriber::on_pmessage(PatternMsgCallback)</strong>：</p>
<ul>
<li><strong>功能</strong><ul>
<li>为 PMESSAGE 类型消息设置回调函数</li>
</ul>
</li>
<li><strong>回调接口定义</strong>：<ul>
<li>void (std::string pattern, std::string channel, std::string msg) </li>
<li>参数说明：<br>  - pattern： 匹配的频道模式<br>  - channel：消息实际所属频道<br>  - msg：实际消息内容）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Subscriber::on_meta(MetaCallback)</strong>：</p>
<ul>
<li><strong>功能</strong>：<ul>
<li>为元消息（META MESSAGE）类型设置回调函数</li>
</ul>
</li>
<li><strong>回调接口定义</strong>：<ul>
<li>void (Subscriber::MsgType type, OptionalString channel, long long num)  </li>
<li>参数说明：<br>  - type：消息类型枚举<br>      - Subscriber::MsgType::SUBSCRIBE<br>      - Subscriber::MsgType::UNSUBSCRIBE<br>      - Subscriber::MsgType::PSUBSCRIBE<br>      - Subscriber::MsgType::PUNSUBSCRIBE<br>      - Subscriber::MsgType::MESSAGE（不会触发）<br>      - Subscriber::MsgType::PMESSAGE（不会触发）<br>  - channel：频道&#x2F;模式名称（OptionalString 类型，即可选字符串）<br>      - 若未订阅任何频道&#x2F;模式，且调用无参数的 unsubscribe&#x2F;punsubscribe（即取消所有订阅）时，该参数为 null；<br>  - num：当前仍处于订阅状态的频道&#x2F;模式总数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1️⃣ 普通消息回调（MESSAGE 类型）</span></span><br><span class="line">sub.<span class="built_in">on_message</span>([](std::string channel, std::string msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;频道 [&quot;</span> &lt;&lt; channel &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ✅ 可以安全地 move 这些参数</span></span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(channel), std::<span class="built_in">move</span>(msg));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 模式消息回调（PMESSAGE 类型）</span></span><br><span class="line">sub.<span class="built_in">on_pmessage</span>([](std::string pattern, std::string channel, std::string msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;模式 [&quot;</span> &lt;&lt; pattern &lt;&lt; <span class="string">&quot;] 频道 [&quot;</span> &lt;&lt; channel &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3️⃣ 元消息回调（SUBSCRIBE/UNSUBSCRIBE 等）</span></span><br><span class="line">sub.<span class="built_in">on_meta</span>([](Subscriber::MsgType type, OptionalString channel, <span class="type">long</span> <span class="type">long</span> num) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> Subscriber::MsgType::SUBSCRIBE:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;已订阅: &quot;</span> &lt;&lt; *channel &lt;&lt; <span class="string">&quot;, 当前订阅数: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Subscriber::MsgType::UNSUBSCRIBE:</span><br><span class="line">            <span class="keyword">if</span> (channel) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;已取消订阅: &quot;</span> &lt;&lt; *channel &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;已取消所有订阅&quot;</span> &lt;&lt; std::endl;  <span class="comment">// channel 可能为空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Subscriber::MsgType::PSUBSCRIBE:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;已订阅模式: &quot;</span> &lt;&lt; *channel &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Subscriber::MsgType::PUNSUBSCRIBE:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;已取消订阅模式&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="consume-消费消息"><a href="#consume-消费消息" class="headerlink" title="&lt;4&gt;consume 消费消息"></a>&lt;4&gt;consume 消费消息</h4><h5 id="1）consume函数执行特点"><a href="#1）consume函数执行特点" class="headerlink" title="1）consume函数执行特点"></a>1）consume函数执行特点</h5><ul>
<li>可以调用 <strong>Subscriber::consume方法</strong>，<strong>消费</strong>发布到该订阅者已订阅的频道 &#x2F; 模式的消息</li>
<li>Subscriber::consume 会<strong>阻塞等待</strong>底层连接传来消息：<ul>
<li>若达到 ConnectionOptions::socket_timeout 设定的超时时间，且无任何消息传入该连接<ul>
<li>Subscriber::consume 会<strong>抛出 TimeoutError 异常</strong>；</li>
</ul>
</li>
<li>若 ConnectionOptions::socket_timeout 设为 0 毫秒<ul>
<li>Subscriber::consume 会<strong>一直阻塞，直到接收到消息为止</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>接收到消息后，Subscriber::consume 会<strong>根据消息类型调用“对应的回调函数”处理消息</strong><ul>
<li>如果你未为某类消息设置回调函数，Subscriber::consume 会消费（读取）该消息并<strong>直接丢弃</strong></li>
<li>即 Subscriber::consume <strong>不会执行回调，直接返回</strong></li>
</ul>
</li>
<li>调用 consume() 后会<strong>一直等待，直到有消息到达或超时</strong>：<ul>
<li>这也是为什么 Subscriber 对象需要独占一个连接（不从连接池选取）、且不建议多线程共用的原因。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114171934666.png"></li>
</ul>
</li>
</ul>
<h5 id="2）不带超时的模式（设为0毫秒）"><a href="#2）不带超时的模式（设为0毫秒）" class="headerlink" title="2）不带超时的模式（设为0毫秒）"></a>2）不带超时的模式（设为0毫秒）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line"></span><br><span class="line">sub.<span class="built_in">on_message</span>([](std::string channel, std::string msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; channel &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sub.<span class="built_in">subscribe</span>(<span class="string">&quot;channel1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费消息（阻塞等待）</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sub.<span class="built_in">consume</span>();  <span class="comment">// 阻塞直到收到消息</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; err) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3）带超时的模式"><a href="#3）带超时的模式" class="headerlink" title="3）带超时的模式"></a>3）带超时的模式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置超时</span></span><br><span class="line">ConnectionOptions opts;</span><br><span class="line">opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts.port = <span class="number">6379</span>;</span><br><span class="line">opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);  <span class="comment">// 1秒超时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts);</span><br><span class="line"><span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line"></span><br><span class="line">sub.<span class="built_in">on_message</span>([](std::string channel, std::string msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; channel &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sub.<span class="built_in">subscribe</span>(<span class="string">&quot;channel1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sub.<span class="built_in">consume</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 超时不是错误，继续等待</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;等待消息中...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> ReplyError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// Redis 返回错误，可以继续使用 sub</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Redis 错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        <span class="comment">// ⚠️ 其他错误：必须销毁并重建 Subscriber</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;严重错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4）消息流向完整图示"><a href="#4）消息流向完整图示" class="headerlink" title="4）消息流向完整图示"></a>4）消息流向完整图示</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143816994.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143840833.png"></p>
<h4 id="完整示例"><a href="#完整示例" class="headerlink" title="&lt;5&gt;完整示例"></a>&lt;5&gt;完整示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sw::redis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConnectionOptions opts;</span><br><span class="line">        opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        opts.port = <span class="number">6379</span>;</span><br><span class="line">        opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts);</span><br><span class="line">        <span class="keyword">auto</span> sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置所有回调</span></span><br><span class="line">        sub.<span class="built_in">on_message</span>([](std::string channel, std::string msg) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[MESSAGE] &quot;</span> &lt;&lt; channel &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        sub.<span class="built_in">on_pmessage</span>([](std::string pattern, std::string channel, std::string msg) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[PMESSAGE] &quot;</span> &lt;&lt; pattern &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; channel &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        sub.<span class="built_in">on_meta</span>([](Subscriber::MsgType type, OptionalString channel, <span class="type">long</span> <span class="type">long</span> num) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[META] 类型=&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(type) </span><br><span class="line">                      &lt;&lt; <span class="string">&quot;, 频道=&quot;</span> &lt;&lt; (channel ? *channel : <span class="string">&quot;null&quot;</span>)</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;, 数量=&quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅</span></span><br><span class="line">        sub.<span class="built_in">subscribe</span>(<span class="string">&quot;chat&quot;</span>);</span><br><span class="line">        sub.<span class="built_in">psubscribe</span>(<span class="string">&quot;news:*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费循环</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开始监听消息...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sub.<span class="built_in">consume</span>();</span><br><span class="line">            &#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp;) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）Subscriber-使用注意事项"><a href="#（3）Subscriber-使用注意事项" class="headerlink" title="（3）Subscriber 使用注意事项"></a>（3）Subscriber 使用注意事项</h3><h4 id="非线程安全"><a href="#非线程安全" class="headerlink" title="&lt;1&gt;非线程安全"></a>&lt;1&gt;非线程安全</h4><ul>
<li><strong>Subscriber</strong>（订阅者）对象是 <strong>非线程安全</strong>的。如果你希望在多线程环境中调用其成员函数，需要<strong>手动实现线程间的同步</strong></li>
</ul>
<h4 id="特定Exception后不可复用"><a href="#特定Exception后不可复用" class="headerlink" title="&lt;2&gt;特定Exception后不可复用"></a>&lt;2&gt;特定Exception后不可复用</h4><ul>
<li>如果 <strong>Subscriber（订阅者）对象</strong>的任意方法抛出了**“非”** ReplyError（回复错误）或 TimeoutError（超时错误）类型的异常，那么该对象<strong>将无法再继续使用</strong>。此时你<strong>必须销毁</strong>这个 Subscriber 对象，并<strong>重新创建</strong>一个新的实例。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sub.<span class="built_in">consume</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> TimeoutError&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ✅ 可以继续使用 sub</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> ReplyError&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ✅ 可以继续使用 sub</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ❌ 必须销毁并重建 sub</span></span><br><span class="line">    sub = redis.<span class="built_in">subscriber</span>();</span><br><span class="line">    sub.<span class="built_in">on_message</span>(...);  <span class="comment">// 重新设置回调</span></span><br><span class="line">    sub.<span class="built_in">subscribe</span>(<span class="string">&quot;channel1&quot;</span>);  <span class="comment">// 重新订阅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114143913218.png"></p>
<h4 id="consume消费是“阻塞的”"><a href="#consume消费是“阻塞的”" class="headerlink" title="&lt;3&gt;consume消费是“阻塞的”"></a>&lt;3&gt;consume消费是“阻塞的”</h4><ul>
<li>调用 consume() 后会<strong>一直等待，直到有消息到达或超时</strong></li>
<li>这也是为什么 Subscriber 对象需要独占一个连接（<strong>不从连接池取</strong>）、且<strong>不建议多线程</strong>共用的原因。</li>
</ul>
<h1 id="十一、Redis-Pipeline（管道）"><a href="#十一、Redis-Pipeline（管道）" class="headerlink" title="十一、Redis++ Pipeline（管道）"></a>十一、Redis++ Pipeline（管道）</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>Pipeline 用于减少 RTT（往返时间），<strong>加速 Redis 查询</strong>。</li>
<li>通过将多个命令<strong>批量发送</strong>，一次性获取所有回复，避免每个命令都等待网络往返。</li>
</ul>
<h2 id="2-创建Pipeline"><a href="#2-创建Pipeline" class="headerlink" title="2.创建Pipeline"></a>2.创建Pipeline</h2><ul>
<li>可以通过 <code>Redis::pipeline</code> 方法创建一个pipeline，它会返回一个<strong>pipeline对象</strong></li>
<li>通过 <code>Redis::pipeline</code> 方法会创建的pipeline，是一个<strong>新的Redis服务连接</strong>，而不是直接使用连接池中的连接<ul>
<li>该连接与连接池中其它连接拥有相同的<code>ConnectionOptions</code></li>
</ul>
</li>
<li><strong>最好尽可能复用同一个“pipeline对象”！！</strong><ul>
<li>因为创建一个管道对象并不便宜，因为它会创建一个新的连接</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>();</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong></p>
<ul>
<li>创建pipeline是，可以直接从连接池获取连接而不创建新连接</li>
<li><a href="#pipeline_from_pool">用连接池中连接创建pipeline</a> <ul>
<li>⚠️ 此方式有死锁风险</li>
</ul>
</li>
</ul>
<h2 id="3-通过pipeline发送命令"><a href="#3-通过pipeline发送命令" class="headerlink" title="3.通过pipeline发送命令"></a>3.通过pipeline发送命令</h2><ul>
<li>通过 Pipeline 对象发送 Redis 命令 和 Redis 类一样。</li>
<li><strong>Pipeline 的设计</strong>:<ul>
<li>先批量添加命令，再一次性执行并获取结果</li>
</ul>
</li>
<li><strong>链式调用</strong>：<ul>
<li><strong>功能</strong>：<ul>
<li><strong>将命令批量添加到pipeline中</strong>（未发送！）</li>
</ul>
</li>
<li>通过“Pipeline对象”调用方法，不会直接返回响应，而是<strong>返回 Pipeline 对象本身</strong>，这样你就可以<strong>链式调用</strong>这些方法</li>
</ul>
</li>
<li><strong><code>Pipeline::exec</code>方法</strong>：<ul>
<li><strong>功能</strong>：<ul>
<li><strong>将pipeline中所有已缓存的命令发送到Redis，并返回批量执行的结果</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Pipeline::discard</code>方法</strong>：<ul>
<li><strong>功能</strong>：<ul>
<li><strong>丢弃pipeline中所有缓存的命令</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 方式1：添加与执行链式调用 ===================</span></span><br><span class="line"><span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">    .<span class="built_in">rpush</span>(<span class="string">&quot;list&quot;</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .<span class="built_in">hset</span>(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;field&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">    .<span class="built_in">command</span>(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;app&quot;</span>)</span><br><span class="line">    .<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 方式2： 添加与执行分开调用 ===================</span></span><br><span class="line"><span class="comment">// 链式调用：添加多个命令（还未执行）</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">    .<span class="built_in">rpush</span>(<span class="string">&quot;list&quot;</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .<span class="built_in">hset</span>(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;field&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">    .<span class="built_in">command</span>(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;app&quot;</span>);  <span class="comment">// 通用命令接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 exec() 发送命令并获取回复</span></span><br><span class="line"><span class="keyword">auto</span> replies = pipe.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 丢弃管道中的命令 ===================</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">discard</span>();</span><br></pre></td></tr></table></figure>
<p><strong>exec() 执行流程</strong></p>
<ul>
<li>发送所有已缓存的命令到 Redis</li>
<li>接收所有命令的回复</li>
<li>返回 <code>QueuedReplies</code>对象</li>
</ul>
<p><a id="parse_pipeline_result"></a></p>
<h2 id="4-解析pipeline执行结果"><a href="#4-解析pipeline执行结果" class="headerlink" title="4.解析pipeline执行结果"></a>4.解析pipeline执行结果</h2><ul>
<li>Pipeline::exec 返回一个 <code>QueuedReplylies</code>对象，该对象包含所有发送到 Redis 命令的回复</li>
<li>通过 <code>QueuedReplies::get</code> 方法来获取并解析回复</li>
<li><code>ueuedReplies</code> 提供 3 种 get() 方法：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114151808620.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114152209995.png"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)      <span class="comment">// 0: SET → bool</span></span><br><span class="line">                   .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)        <span class="comment">// 1: INCR → long long</span></span><br><span class="line">                   .<span class="built_in">lrange</span>(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>)  <span class="comment">// 2: LRANGE → vector</span></span><br><span class="line">                   .<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>)             <span class="comment">// 3: GET → OptionalString</span></span><br><span class="line">                   .<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析各个回复</span></span><br><span class="line"><span class="type">bool</span> set_ok = replies.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="number">0</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> counter = replies.<span class="built_in">get</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; list_items;</span><br><span class="line">replies.<span class="built_in">get</span>(<span class="number">2</span>, std::<span class="built_in">back_inserter</span>(list_items));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = replies.<span class="built_in">get</span>&lt;OptionalString&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="return_mechanism"></a></p>
<h2 id="5-连接归还机制"><a href="#5-连接归还机制" class="headerlink" title="5.连接归还机制"></a>5.连接归还机制</h2><ul>
<li>当pipeline执行exec、discard、对象析构、抛出异常时，会归还连接（主要针对“连接池”模式）<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170235009.png"></li>
</ul>
<h3 id="（1）两种创建方式的区别"><a href="#（1）两种创建方式的区别" class="headerlink" title="（1）两种创建方式的区别"></a>（1）两种创建方式的区别</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：默认创建（新建连接）</span></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>();        <span class="comment">// 创建新连接，不从连接池取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：使用连接池</span></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);   <span class="comment">// 从连接池借用连接</span></span><br></pre></td></tr></table></figure>
<h3 id="（2）”归还连接”只对连接池模式有意义"><a href="#（2）”归还连接”只对连接池模式有意义" class="headerlink" title="（2）”归还连接”只对连接池模式有意义"></a>（2）”归还连接”只对连接池模式有意义</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170102888.png"></p>
<h3 id="（3）”归还”的具体含义"><a href="#（3）”归还”的具体含义" class="headerlink" title="（3）”归还”的具体含义"></a>（3）”归还”的具体含义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;  <span class="comment">// 连接池有 3 个连接</span></span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(opts, pool_opts)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用连接池模式创建 Pipeline</span></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时：Pipeline 从连接池&quot;借走&quot;了一个连接</span></span><br><span class="line"><span class="comment">// 连接池状态：[连接1][连接2][ 空 ]  ← 只剩 2 个可用</span></span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 exec()</span></span><br><span class="line"><span class="keyword">auto</span> replies = pipe.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// exec() 完成后：连接&quot;归还&quot;到连接池</span></span><br><span class="line"><span class="comment">// 连接池状态：[连接1][连接2][连接3]  ← 恢复 3 个可用</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）-为什么”归还”很重要？"><a href="#（4）-为什么”归还”很重要？" class="headerlink" title="（4） 为什么”归还”很重要？"></a>（4） 为什么”归还”很重要？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接池只有 3 个连接</span></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(opts, pool_opts)</span></span>;  <span class="comment">// pool_opts.size = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe1 = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 借走连接 #1</span></span><br><span class="line"><span class="keyword">auto</span> pipe2 = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 借走连接 #2</span></span><br><span class="line"><span class="keyword">auto</span> pipe3 = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 借走连接 #3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池已空！</span></span><br><span class="line"></span><br><span class="line">pipe<span class="number">1.</span><span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">pipe<span class="number">2.</span><span class="built_in">set</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">pipe<span class="number">3.</span><span class="built_in">set</span>(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 这里会阻塞或超时！因为连接池没有可用连接</span></span><br><span class="line">redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);  <span class="comment">// 等待连接...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须先执行 exec() 归还连接</span></span><br><span class="line">pipe<span class="number">1.</span><span class="built_in">exec</span>();  <span class="comment">// 归还连接 #1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 现在可以了</span></span><br><span class="line">redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);  <span class="comment">// 获取到连接 #1</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）归还之后再次触发呢？"><a href="#（5）归还之后再次触发呢？" class="headerlink" title="（5）归还之后再次触发呢？"></a>（5）归还之后再次触发呢？</h3><ul>
<li>归还连接后，Pipeline对象仍然存在，可以继续使用！</li>
<li>调用 exec() 或 discard() 后：<ul>
<li>连接被归还到连接池</li>
<li>下次调用命令时，会重新从连接池借用连接</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(opts, pool_opts)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 从连接池借用连接 #1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一批命令</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>).<span class="built_in">set</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> replies1 = pipe.<span class="built_in">exec</span>();  <span class="comment">// 执行后，连接 #1 归还到池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ Pipeline 对象仍可使用！</span></span><br><span class="line"><span class="comment">// 第二批命令（会重新从连接池借用连接，可能是 #1，也可能是 #2、#3）</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> replies2 = pipe.<span class="built_in">exec</span>();  <span class="comment">// 执行后，连接再次归还</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 可以一直这样复用</span></span><br><span class="line">pipe.<span class="built_in">get</span>(<span class="string">&quot;k1&quot;</span>).<span class="built_in">get</span>(<span class="string">&quot;k2&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> replies3 = pipe.<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114170533657.png"></p>
<h2 id="6-pipeline-使用注意事项"><a href="#6-pipeline-使用注意事项" class="headerlink" title="6.pipeline 使用注意事项"></a>6.pipeline 使用注意事项</h2><h3 id="（1）特定Exception后不可复用"><a href="#（1）特定Exception后不可复用" class="headerlink" title="（1）特定Exception后不可复用"></a>（1）特定Exception后不可复用</h3><ul>
<li>如果pipeline的任何方法抛出除 ReplyError 以外的异常， 管道对象将进入无效状态<ul>
<li>不能再使用它了，只能摧毁该物体，然后创建一个新的</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;n&quot;</span>).<span class="built_in">exec</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> ReplyError&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ✅ ReplyError：Pipeline 仍可使用</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Redis 返回错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// ❌ 其他异常：Pipeline 进入无效状态，必须销毁重建</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;严重错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    pipe = redis.<span class="built_in">pipeline</span>();  <span class="comment">// 重新创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114153043892.png"></p>
<h3 id="（2）非线程安全"><a href="#（2）非线程安全" class="headerlink" title="（2）非线程安全"></a>（2）非线程安全</h3><ul>
<li>Pipeline <strong>不是线程安全</strong>的</li>
<li>如果你想在多线程环境中调用其成员函数，就需要在线程间手动同步</li>
</ul>
<p><a id="pipeline_from_pool"></a></p>
<h2 id="5-创建管道而不创建新连接"><a href="#5-创建管道而不创建新连接" class="headerlink" title="5.创建管道而不创建新连接"></a>5.创建管道而不创建新连接</h2><h3 id="（1）用连接池中的连接创建pipeline对象（有死锁风险）"><a href="#（1）用连接池中的连接创建pipeline对象（有死锁风险）" class="headerlink" title="（1）用连接池中的连接创建pipeline对象（有死锁风险）"></a>（1）用连接池中的连接创建pipeline对象（有死锁风险）</h3><ul>
<li>可以创建一个带有底层连接池连接的管道对象，这样调用 Redis::pipeline 方法可以便宜得多（因为它不需要新建连接）</li>
<li><strong>Pipeline pipeline(bool new_connection &#x3D; true)</strong><ul>
<li>如果 new_connection 为假， 管道对象将与底层池的连接创建。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 false，从连接池获取连接</span></span><br><span class="line"><span class="comment">//⚠️在这种情况下，你必须非常小心，否则可能会表现不佳甚至死锁</span></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><a id="dead_lock"></a></p>
<h3 id="（2）死锁风险"><a href="#（2）死锁风险" class="headerlink" title="（2）死锁风险"></a>（2）死锁风险</h3><ul>
<li>当你用 Pipeline 对象执行命令时，它会保留连接，直到调用 Pipeline::exec、Pipeline::discard 或 Pipeline 的 destructor<ul>
<li>如果 Pipeline 的任何方法抛出异常 ，连接也会被释放</li>
</ul>
</li>
<li>如果管道对象长时间保持连接，其他 Redis 方法可能无法从底层池获取连接。</li>
</ul>
<p><strong>死锁示例（❌ 错误用法）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认只有 1 个连接，wait_timeout = 0（永久等待）</span></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);  <span class="comment">// 从连接池取连接</span></span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val&quot;</span>);  <span class="comment">// 占用连接</span></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val&quot;</span>);  <span class="comment">// 继续占用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 死锁！连接池为空，Redis::get 永久阻塞</span></span><br><span class="line">redis.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);  <span class="comment">// 等待连接池，但 pipe 还没释放</span></span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">exec</span>();  <span class="comment">// 永远执行不到</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）最佳实践"><a href="#（3）最佳实践" class="headerlink" title="（3）最佳实践"></a>（3）最佳实践</h3><ul>
<li>始终将 ConnectionPoolOptions::wait_timeout 设置为大于 0 毫秒<ul>
<li>即当连接池为空时，避免调用者永久阻塞</li>
</ul>
</li>
<li>最好将 Pipeline 相关代码放在代码块作用域内</li>
<li>避免在 Pipeline 方法调用之间执行耗时操作</li>
<li>尽量将 Pipeline 方法与 Pipeline::exec 链式调用在同一条语句中</li>
</ul>
<p>✅ 正确用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions opts;</span><br><span class="line">opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts.port = <span class="number">6379</span>;</span><br><span class="line">opts.socket_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ✅ 最佳实践1： ConnectionPoolOptions::wait_timeout &gt; 0ms</span></span><br><span class="line">pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts, pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 最佳实践2：使用块作用域</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//✅ 最佳实践3：避免在 Pipeline 方法调用之间执行耗时操作</span></span><br><span class="line">    <span class="comment">// ❌ 不要在这里做耗时操作！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>).<span class="built_in">set</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>).<span class="built_in">exec</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exec() 完成后，连接自动归还</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 最佳实践4：链式调用一气呵成</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">auto</span> replies = pipe.<span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>)</span><br><span class="line">                       .<span class="built_in">set</span>(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>)</span><br><span class="line">                       .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">                       .<span class="built_in">exec</span>();  <span class="comment">// 立即发送并释放连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 这种操作（复用连接池连接创建 Pipeline）开销极低</span></span><br><span class="line">    <span class="keyword">auto</span> pipe = redis.<span class="built_in">pipeline</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从底层连接池获取连接并持有</span></span><br><span class="line">    pipe.<span class="built_in">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使未调用 Pipeline::exec 或 Pipeline::discard（即pipeline还缓存有命令）</span></span><br><span class="line">    <span class="comment">// 当 Pipeline 对象析构时，连接也会被自动归还到连接池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二、Redis-Transaction（事务）"><a href="#十二、Redis-Transaction（事务）" class="headerlink" title="十二、Redis++ Transaction（事务）"></a>十二、Redis++ Transaction（事务）</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h2><p>Transaction 用于确保多个命令<strong>原子性执行</strong>——要么全部成功，要么全部不执行。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114155752421.png"></p>
<ul>
<li>前面提过，Redis是线程安全的，为减小开销，尽量复用同一个Redis ——&gt; 这也就可能导致一个线程通过Redis执行多个命令时，其它线程也通过同一个Redis执行命令，从而导致被打断</li>
</ul>
<h2 id="2-创建Transaction"><a href="#2-创建Transaction" class="headerlink" title="2.创建Transaction"></a>2.创建Transaction</h2><h3 id="（1）默认方式（创建新连接）"><a href="#（1）默认方式（创建新连接）" class="headerlink" title="（1）默认方式（创建新连接）"></a>（1）默认方式（创建新连接）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事务（默认创建新连接，不从连接池取）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>();</span><br></pre></td></tr></table></figure>
<p>⚠️ 注意：默认创建 Transaction 开销较大（需要新建连接），应尽量复用。</p>
<h3 id="（2）使用连接池连接创建（有死锁风险）"><a href="#（2）使用连接池连接创建（有死锁风险）" class="headerlink" title="（2）使用连接池连接创建（有死锁风险）"></a>（2）使用连接池连接创建（有死锁风险）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数说明：transaction(piped, new_connection)</span></span><br><span class="line"><span class="comment">// piped = false（非管道模式），new_connection = false（从连接池取）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="（3）创建管道化事务（性能更好）"><a href="#（3）创建管道化事务（性能更好）" class="headerlink" title="（3）创建管道化事务（性能更好）"></a>（3）创建管道化事务（性能更好）</h3><p><a href="#pipeline_transaction">管带事务</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// piped = true，命令通过 Pipeline 发送，减少 RTT</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用连接池 + 管道 () （有死锁风险）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-Transaction的使用"><a href="#3-Transaction的使用" class="headerlink" title="3.Transaction的使用"></a>3.Transaction的使用</h2><h3 id="（1）发送命令"><a href="#（1）发送命令" class="headerlink" title="（1）发送命令"></a>（1）发送命令</h3><p>Transaction 与 Pipeline 接口完全相同，支持链式调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">  .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">  .<span class="built_in">lpush</span>(<span class="string">&quot;list&quot;</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">  .<span class="built_in">hset</span>(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;field&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">  .<span class="built_in">command</span>(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;setname&quot;</span>, <span class="string">&quot;app&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>📌 你不需要向 Redis 发送多重命令。 交易会自动帮你完成这件事。</p>
<h3 id="（2）执行事务"><a href="#（2）执行事务" class="headerlink" title="（2）执行事务"></a>（2）执行事务</h3><ul>
<li>当你调用 Transaction::exec 时，你会明确要求 Redis 执行那些排队命令，并返回回复<ul>
<li>否则，这些命令不会被执行</li>
</ul>
</li>
<li>你可以调用 Transaction::discard 来丢弃执行，也就是说不会执行任何命令。</li>
</ul>
<p><strong>调用 exec() 执行</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：先发送，再执行</span></span><br><span class="line">tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> replies = tx.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：链式调用（推荐）</span></span><br><span class="line"><span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>).<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure>

<p><strong>放弃事务</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">incr</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">tx.<span class="built_in">discard</span>();  <span class="comment">// 放弃执行，所有命令都不会执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）解析事务执行结果"><a href="#（3）解析事务执行结果" class="headerlink" title="（3）解析事务执行结果"></a>（3）解析事务执行结果</h3><p>与 Pipeline 完全相同：<a href="#parse_pipeline_result">解析回复</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>)      <span class="comment">// 0: SET → bool</span></span><br><span class="line">                 .<span class="built_in">incr</span>(<span class="string">&quot;counter&quot;</span>)        <span class="comment">// 1: INCR → long long</span></span><br><span class="line">                 .<span class="built_in">lrange</span>(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>)  <span class="comment">// 2: LRANGE → vector</span></span><br><span class="line">                 .<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="type">bool</span> set_ok = replies.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="number">0</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> counter = replies.<span class="built_in">get</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; items;</span><br><span class="line">replies.<span class="built_in">get</span>(<span class="number">2</span>, std::<span class="built_in">back_inserter</span>(items));</span><br></pre></td></tr></table></figure>

<p><a id="pipeline_transaction"></a></p>
<h3 id="（4）管道事务（Piped-Transaction）"><a href="#（4）管道事务（Piped-Transaction）" class="headerlink" title="（4）管道事务（Piped Transaction）"></a>（4）管道事务（Piped Transaction）</h3><p>通常，一个事务会发送多条指令，为了提升性能，可以在pipeline中发送这些命令</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a piped transaction</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过这种piped transaction，所有命令都会通过pipeline发送到 Redis。</li>
</ul>
<h2 id="4-WATCH-乐观锁（CAS-机制）"><a href="#4-WATCH-乐观锁（CAS-机制）" class="headerlink" title="4. WATCH 乐观锁（CAS 机制）"></a>4. WATCH 乐观锁（CAS 机制）</h2><h3 id="（1）为什么需要-WATCH？"><a href="#（1）为什么需要-WATCH？" class="headerlink" title="（1）为什么需要 WATCH？"></a>（1）为什么需要 WATCH？</h3><p><strong>Transacation 并不安全于线程</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">场景：两个客户端同时对 counter 加 1</span><br><span class="line"></span><br><span class="line">客户端A（事务1）              客户端B （事务2）</span><br><span class="line">────────                    ────────</span><br><span class="line">GET counter → 10            GET counter → 10</span><br><span class="line">new<span class="emphasis">_counter = 10 + 1        new_</span>counter = 10 + 1</span><br><span class="line">SET counter new<span class="emphasis">_counter     SET counter new_</span>counter</span><br><span class="line"></span><br><span class="line">结果：counter = 11（错误！应该是 12）</span><br></pre></td></tr></table></figure>
<h3 id="（2）WATCH-的作用"><a href="#（2）WATCH-的作用" class="headerlink" title="（2）WATCH 的作用"></a>（2）WATCH 的作用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端A（事务1）              客户端B（事务2）</span><br><span class="line">────────                    ────────</span><br><span class="line">WATCH counter  //监视 counter 是否被修改</span><br><span class="line">GET counter → 10</span><br><span class="line"><span class="code">                            SET counter 20（修改了 counter）</span></span><br><span class="line"><span class="code">MULTI    //开启事务</span></span><br><span class="line"><span class="code">SET counter </span></span><br><span class="line"><span class="code">EXEC → 失败！（因为 counter 被修改）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">→ 客户端A 重试整个流程</span><br></pre></td></tr></table></figure>

<h3 id="（3）Watch的使用"><a href="#（3）Watch的使用" class="headerlink" title="（3）Watch的使用"></a>（3）Watch的使用</h3><h4 id="概述"><a href="#概述" class="headerlink" title="&lt;1&gt;概述"></a>&lt;1&gt;概述</h4><ul>
<li><strong>WATCH 命令必须与该交易在同一连接中发送</strong></li>
<li>通常在 WATCH 命令之后，我们还需要发送其他命令<ul>
<li>如：<strong>执行事务前从 Redis 获取数据</strong></li>
</ul>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WATCH key           // 监听指定的 key</span><br><span class="line">val = GET key       // 获取该 key 对应的 value</span><br><span class="line">new<span class="emphasis">_val = val + 1   // 对 value 执行自增操作</span></span><br><span class="line"><span class="emphasis">MULTI               // 开启事务</span></span><br><span class="line"><span class="emphasis">SET key new_</span>val     // 仅当该 key 的值未被其他客户端修改时，才执行此赋值操作</span><br><span class="line">EXEC                // 尝试执行事务</span><br><span class="line"><span class="code">                    // 若监听期间 val 已被修改，整个事务不会执行</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114163237592.png"></p>
<h4 id="使用-WATCH-的关键"><a href="#使用-WATCH-的关键" class="headerlink" title="&lt;2&gt;使用 WATCH 的关键"></a>&lt;2&gt;使用 WATCH 的关键</h4><ul>
<li>使用 Transaction 对象时，你无法获得命令的结果，直到整个事务完成。</li>
<li>相反，你需要从事务对象创建一个 Redis 对象。创建的 Redis 对象与事务对象<strong>共享连接</strong></li>
<li>有了这个创建的 Redis 对象，你可以向 Redis 服务器发送 WATCH 命令和其他 Redis 命令，并立即获得结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建共享连接的 Redis 对象</span></span><br><span class="line"><span class="keyword">auto</span> r = tx.<span class="built_in">redis</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// r 和 tx 使用同一个连接</span></span><br><span class="line">r.<span class="built_in">watch</span>(<span class="string">&quot;key&quot;</span>);           <span class="comment">// 在共享连接上执行 WATCH</span></span><br><span class="line"><span class="keyword">auto</span> val = r.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);  <span class="comment">// 可以立即获取结果</span></span><br><span class="line">tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, new_val).<span class="built_in">exec</span>();  <span class="comment">// 在同一连接上执行事务</span></span><br></pre></td></tr></table></figure>

<h4 id="WATCH-完整示例（CAS-实现）"><a href="#WATCH-完整示例（CAS-实现）" class="headerlink" title="&lt;3&gt;WATCH 完整示例（CAS 实现）"></a>&lt;3&gt;WATCH 完整示例（CAS 实现）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(<span class="string">&quot;tcp://127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在循环外创建 Transaction（避免重复创建连接）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 WATCH 的 key 可能被其他客户端修改，需要重试</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建共享连接的 Redis 对象</span></span><br><span class="line">        <span class="keyword">auto</span> r = tx.<span class="built_in">redis</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 监视 key</span></span><br><span class="line">        r.<span class="built_in">watch</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前值</span></span><br><span class="line">        <span class="keyword">auto</span> val = r.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="type">int</span> num = val ? std::<span class="built_in">stoi</span>(*val) : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算新值</span></span><br><span class="line">        ++num;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行事务</span></span><br><span class="line">        <span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, std::<span class="built_in">to_string</span>(num)).<span class="built_in">exec</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 成功！验证并退出循环</span></span><br><span class="line">        <span class="built_in">assert</span>(replies.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; replies.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="number">0</span>) == <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> WatchError&amp; e) &#123;</span><br><span class="line">        <span class="comment">// key 被其他客户端修改，重试</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 其他错误，Transaction 已失效</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-创建事务但不创建新连接"><a href="#5-创建事务但不创建新连接" class="headerlink" title="5.创建事务但不创建新连接"></a>5.创建事务但不创建新连接</h2><h3 id="（1）使用连接池内连接创建Transaction"><a href="#（1）使用连接池内连接创建Transaction" class="headerlink" title="（1）使用连接池内连接创建Transaction"></a>（1）使用连接池内连接创建Transaction</h3><ul>
<li>事实上，可以创建一个带有底层连接池连接的事务对象，这样调用 Redis::transaction 方法会便宜得多（因为不需要新建连接）。</li>
<li>Redis::transaction 的原型:<ul>
<li><code>Transaction transaction(bool piped = false, bool new_connection = true);</code><ul>
<li>如果 new_connection 为假， 交易对象将通过底层池的连接创建</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions connection_options;</span><br><span class="line">ConnectionPoolOptions pool_options;</span><br><span class="line"></span><br><span class="line"><span class="function">Redis <span class="title">redis</span><span class="params">(connection_options, pool_options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个事务（Transaction），但不新建连接。</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>不过，在这种情况下，你必须非常小心<ul>
<li>否则：<strong>可能会表现不佳甚至死锁!!</strong></li>
</ul>
</li>
</ul>
<p><strong>参考</strong>：<a href="#dead_lock">pipeline的死锁风险</a></p>
<h3 id="（2）使用连接池连接的最佳实践"><a href="#（2）使用连接池连接的最佳实践" class="headerlink" title="（2）使用连接池连接的最佳实践"></a>（2）使用连接池连接的最佳实践</h3><ul>
<li>限制 由Transaction::Redis创建的Redis对象的 作用域（生命周期）<ul>
<li>即尽快销毁Redis对象。</li>
</ul>
</li>
</ul>
<p><strong>⚠️ 特别注意</strong>：tx.redis() 创建的对象会持有连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts, pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Transaction 对象，且不新建连接（复用连接池中的现有连接）</span></span><br><span class="line"><span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 注：第一个 false = 不使用 Pipeline 模式执行事务；第二个 false = 不新建连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Redis 对象，共享同一个连接</span></span><br><span class="line"><span class="keyword">auto</span> r = tx.<span class="built_in">redis</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他业务代码（⚠️ 若此处有耗时操作，会长期占用连接，导致连接池耗尽）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute the transaction.</span></span><br><span class="line"><span class="comment">// 执行事务（提交事务队列中的所有命令）</span></span><br><span class="line"><span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>).<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管已调用 Transaction::exec 执行事务，但连接并未归还到连接池</span></span><br><span class="line"><span class="comment">// 原因：由 tx.redis() 创建的 Redis 对象（即变量 r）仍持有该连接</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 正确用法</strong>：确保 r 和 tx 都尽快销毁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ConnectionOptions opts;</span><br><span class="line">opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">opts.port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">ConnectionPoolOptions pool_opts;</span><br><span class="line">pool_opts.size = <span class="number">3</span>;</span><br><span class="line">pool_opts.wait_timeout = std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);  <span class="comment">// ⚠️ 必须 &gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> redis = <span class="built_in">Redis</span>(opts, pool_opts);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ✅ 在循环内创建 Transaction（使用连接池，开销很小）</span></span><br><span class="line">        <span class="keyword">auto</span> tx = redis.<span class="built_in">transaction</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ✅ r 和 tx 在同一作用域，同时销毁</span></span><br><span class="line">        <span class="keyword">auto</span> r = tx.<span class="built_in">redis</span>();</span><br><span class="line">        </span><br><span class="line">        r.<span class="built_in">watch</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> val = r.<span class="built_in">get</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="type">int</span> num = val ? std::<span class="built_in">stoi</span>(*val) : <span class="number">0</span>;</span><br><span class="line">        ++num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> replies = tx.<span class="built_in">set</span>(<span class="string">&quot;key&quot;</span>, std::<span class="built_in">to_string</span>(num)).<span class="built_in">exec</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">assert</span>(replies.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; replies.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ✅ 离开作用域时，r 和 tx 都销毁，连接归还</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> WatchError&amp;) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> Error&amp;) &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-连接归还机制"><a href="#6-连接归还机制" class="headerlink" title="6.连接归还机制"></a>6.连接归还机制</h2><p><strong>参考</strong>：<a href="#return_mechanism">pipeline的连接归还机制</a></p>
<h2 id="7-Transaction-使用注意事项"><a href="#7-Transaction-使用注意事项" class="headerlink" title="7.Transaction 使用注意事项"></a>7.Transaction 使用注意事项</h2><h3 id="（1）特定Exception后不可复用-1"><a href="#（1）特定Exception后不可复用-1" class="headerlink" title="（1）特定Exception后不可复用"></a>（1）特定Exception后不可复用</h3><ul>
<li>如果事务的任何方法抛出除 WatchError 或 ReplyError 以外的异常， 事务对象将进入无效状态<ul>
<li>你不能再使用它，只能摧毁该物体并创建一个新的<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260114161718422.png"></li>
</ul>
</li>
</ul>
<h3 id="（2）非线程安全-1"><a href="#（2）非线程安全-1" class="headerlink" title="（2）非线程安全"></a>（2）非线程安全</h3><ul>
<li>Transacation 并不安全于线程。</li>
<li>如果你想在多线程环境中调用其成员函数，就需要在线程间手动同步。</li>
</ul>
<p><a id="use"></a></p>
<h1 id="附录1：Redis-核心场景"><a href="#附录1：Redis-核心场景" class="headerlink" title="附录1：Redis++ 核心场景"></a>附录1：Redis++ 核心场景</h1><h2 id="1-缓存场景（最核心场景）"><a href="#1-缓存场景（最核心场景）" class="headerlink" title="1.缓存场景（最核心场景）"></a>1.缓存场景（最核心场景）</h2><h3 id="（1）适用场景"><a href="#（1）适用场景" class="headerlink" title="（1）适用场景"></a>（1）适用场景</h3><p>用户信息缓存、商品详情缓存、接口结果缓存、热点数据加速访问等，核心目标是减轻数据库压力，提升接口响应速度。</p>
<h3 id="（2）核心优势"><a href="#（2）核心优势" class="headerlink" title="（2）核心优势"></a>（2）核心优势</h3><ul>
<li>Redis 基于内存操作，响应速度快（毫秒级）；</li>
<li>Redis++ 提供丰富的缓存操作 API，支持过期时间设置、批量操作，配合<strong>连接池</strong>可高效支撑高并发缓存访问。</li>
</ul>
<h3 id="（3）生产实现要点（重点！）"><a href="#（3）生产实现要点（重点！）" class="headerlink" title="（3）生产实现要点（重点！）"></a>（3）生产实现要点（重点！）</h3><ul>
<li><strong>缓存key命名规范</strong>：<ul>
<li>采用“ <strong>业务模块:数据类型:唯一标识</strong> ”格式<ul>
<li>如： goods:detail:10086，避免键名冲突</li>
</ul>
</li>
</ul>
</li>
<li><strong>过期策略</strong>：<ul>
<li>必须设置合理的过期时间<ul>
<li>如：热点商品30分钟、用户token24小时</li>
<li>避免内存泄漏：Redis 内存持续增长且无法被有效回收，最终导致内存耗尽</li>
<li>可通过 <strong>set(key, val, expire)</strong> 实现</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存更新</strong>：<ul>
<li>采用“更新数据库+更新缓存”或“先删缓存+后更数据库”策略，避免缓存与数据库数据不一致；</li>
<li>高并发场景推荐“先删缓存+延迟双删”；</li>
</ul>
</li>
<li><strong>缓存异常防护</strong>：<ul>
<li><strong>缓存穿透</strong>（缓存和数据库均无数据）<ul>
<li>可<strong>设置空值缓存</strong>（短期过期）</li>
</ul>
</li>
<li><strong>缓存击穿</strong>（热点key过期瞬间高并发）<ul>
<li>可使用<strong>互斥锁</strong>或<strong>热点key永不过期</strong></li>
</ul>
</li>
<li><strong>缓存雪崩</strong>（大量key同时过期）<ul>
<li>可设置<strong>过期时间随机偏移</strong>（如基础过期30分钟+随机0-5分钟）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 UUID</span></span><br><span class="line"><span class="function">std::string <span class="title">generate_uuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::random_device rd;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="type">static</span> std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* hex = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    std::string uuid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        uuid += hex[<span class="built_in">dis</span>(gen)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">get_goods_detail_cache_safe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Redis&amp; redis, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; goods_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> max_retries = <span class="number">5</span>  <span class="comment">// ✅ 添加重试次数限制</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string cache_key = <span class="string">&quot;goods:detail:&quot;</span> + goods_id;</span><br><span class="line">    <span class="type">const</span> std::string lock_key = <span class="string">&quot;lock:goods:&quot;</span> + goods_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 查缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(cache_key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (*val == <span class="string">&quot;__EMPTY__&quot;</span>) ? std::<span class="literal">nullopt</span> : val;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2. 尝试获取锁</span></span><br><span class="line">    std::string lock_value = <span class="built_in">generate_uuid</span>();  <span class="comment">// ✅ 唯一标识</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> got_lock = redis.<span class="built_in">set</span>(</span><br><span class="line">        lock_key, </span><br><span class="line">        lock_value,  <span class="comment">// ✅ 用 UUID 防止误删</span></span><br><span class="line">        std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>), </span><br><span class="line">        sw::redis::UpdateType::NOT_EXIST</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (got_lock) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 双重检查（可能其他线程已写入）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(cache_key)) &#123;</span><br><span class="line">                redis.<span class="built_in">del</span>(lock_key);  <span class="comment">// ✅ 释放锁</span></span><br><span class="line">                <span class="keyword">return</span> (*val == <span class="string">&quot;__EMPTY__&quot;</span>) ? std::<span class="literal">nullopt</span> : val;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 查数据库</span></span><br><span class="line">            std::string db_val = <span class="built_in">query_goods_detail_from_db</span>(goods_id);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (db_val.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                redis.<span class="built_in">set</span>(cache_key, <span class="string">&quot;__EMPTY__&quot;</span>, std::chrono::<span class="built_in">minutes</span>(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redis.<span class="built_in">set</span>(cache_key, db_val, std::chrono::<span class="built_in">minutes</span>(<span class="number">30</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ✅ 安全释放锁（Lua 脚本，原子操作）</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* lua_script = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">                if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">                    return redis.call(&quot;del&quot;, KEYS[1])</span></span><br><span class="line"><span class="string">                else</span></span><br><span class="line"><span class="string">                    return 0</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string">            )&quot;</span>;</span><br><span class="line">            redis.<span class="built_in">eval</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(lua_script, &#123;lock_key&#125;, &#123;lock_value&#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> db_val.<span class="built_in">empty</span>() ? std::<span class="literal">nullopt</span> : std::optional&#123;db_val&#125;;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// ✅ 异常时也要释放锁</span></span><br><span class="line">            redis.<span class="built_in">eval</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(</span><br><span class="line">                <span class="string">R&quot;(if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then </span></span><br><span class="line"><span class="string">                     return redis.call(&quot;del&quot;, KEYS[1]) </span></span><br><span class="line"><span class="string">                   else </span></span><br><span class="line"><span class="string">                     return 0 </span></span><br><span class="line"><span class="string">                   end)&quot;</span>,</span><br><span class="line">                &#123;lock_key&#125;, &#123;lock_value&#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ✅ 改用循环代替递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_retries; ++i) &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再次查缓存（可能已被其他线程写入）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> val = redis.<span class="built_in">get</span>(cache_key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (*val == <span class="string">&quot;__EMPTY__&quot;</span>) ? std::<span class="literal">nullopt</span> : val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ✅ 超过重试次数，直接查数据库（降级）</span></span><br><span class="line">        std::string db_val = <span class="built_in">query_goods_detail_from_db</span>(goods_id);</span><br><span class="line">        <span class="keyword">return</span> db_val.<span class="built_in">empty</span>() ? std::<span class="literal">nullopt</span> : std::optional&#123;db_val&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-分布式锁场景"><a href="#2-分布式锁场景" class="headerlink" title="2.分布式锁场景"></a>2.分布式锁场景</h2><h3 id="（1）适用场景-1"><a href="#（1）适用场景-1" class="headerlink" title="（1）适用场景"></a>（1）适用场景</h3><p>秒杀活动、分布式事务、跨服务资源竞争、避免重复提交等，核心目标是保证分布式环境下资源访问的原子性。</p>
<h3 id="（2）核心优势-1"><a href="#（2）核心优势-1" class="headerlink" title="（2）核心优势"></a>（2）核心优势</h3><ul>
<li>Redis 单线程特性保证锁操作的原子性；</li>
<li>Redis++ 支持 Lua 脚本，可将“加锁+过期”、“解锁+验证持有者”等逻辑封装为原子操作，避免锁漏洞。</li>
</ul>
<h3 id="（3）生产实现要点"><a href="#（3）生产实现要点" class="headerlink" title="（3）生产实现要点"></a>（3）生产实现要点</h3><ul>
<li><p><strong>锁标识唯一性</strong>：</p>
<ul>
<li>每个锁持有者需携带唯一标识（如 UUID+线程ID），避免误解锁其他线程的锁；</li>
</ul>
</li>
<li><p><strong>锁过期机制</strong>：</p>
<ul>
<li>必须设置锁过期时间，<strong>防止持有者崩溃导致锁永久占用</strong><ul>
<li>可通过 <strong>Lua 脚本</strong>原子设置“NX+EX”；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>锁续约</strong>：</p>
<ul>
<li>如果业务逻辑执行时间可能超过锁过期时间，需启动后台线程定期续约（如每10秒续期20秒）；</li>
</ul>
</li>
<li><p><strong>解锁原子性</strong>：</p>
<ul>
<li>通过 Lua 脚本先验证锁持有者，再删除锁，避免锁过期后误删其他线程的锁。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedLock</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Redis&amp; redis_;</span><br><span class="line">    string lock_key_;      <span class="comment">// 锁的 key，如 &quot;lock:order:12345&quot;</span></span><br><span class="line">    string lock_val_;      <span class="comment">// 锁的唯一标识，用于验证持有者身份</span></span><br><span class="line">    <span class="type">int</span> expire_seconds_;   <span class="comment">// 锁过期时间（防止持有者崩溃导致死锁）</span></span><br><span class="line">    </span><br><span class="line">    atomic&lt;<span class="type">bool</span>&gt; holding_&#123;<span class="literal">false</span>&#125;;  <span class="comment">// 原子标志：当前是否持有锁（线程安全）</span></span><br><span class="line">    thread renew_thread_;          <span class="comment">// 后台续约线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line">    <span class="comment">// 续约循环：防止业务执行时间超过锁过期时间导致锁被抢</span></span><br><span class="line">    <span class="comment">// ═══════════════════════════════════════════════════════════</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renew_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Lua 脚本：原子操作 - 先验证是自己的锁，再续期</span></span><br><span class="line">        <span class="comment">// 避免续期了别人的锁（锁已过期被其他进程抢走的情况）</span></span><br><span class="line">        <span class="type">const</span> string renew_script = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">            if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">                return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 续约频率：过期时间的 1/3（如30秒过期，每10秒续约一次）</span></span><br><span class="line">        <span class="comment">// 留足安全边际，避免网络延迟导致锁意外过期</span></span><br><span class="line">        <span class="type">int</span> sleep_ms = (expire_seconds_ * <span class="number">1000</span>) / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (holding_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(sleep_ms));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 双重检查：sleep 期间可能已经 unlock 了</span></span><br><span class="line">            <span class="keyword">if</span> (!holding_.<span class="built_in">load</span>()) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> result = redis_.<span class="built_in">eval</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(</span><br><span class="line">                    renew_script,</span><br><span class="line">                    &#123;lock_key_&#125;,</span><br><span class="line">                    &#123;lock_val_, <span class="built_in">to_string</span>(expire_seconds_)&#125;</span><br><span class="line">                );</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// result == 0 说明锁已不属于自己（被抢或过期）</span></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                    holding_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="built_in">catch</span> (<span class="type">const</span> sw::redis::Error&amp; e) &#123;</span><br><span class="line">                <span class="comment">// 网络异常 → 保守处理：认为锁已丢失</span></span><br><span class="line">                <span class="comment">// 防止脑裂：宁可放弃锁，也不能两个进程同时认为自己持有锁</span></span><br><span class="line">                holding_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DistributedLock</span>(Redis&amp; redis, <span class="type">const</span> string&amp; key, <span class="type">int</span> expire_sec = <span class="number">30</span>)</span><br><span class="line">        : <span class="built_in">redis_</span>(redis), <span class="built_in">lock_key_</span>(key), <span class="built_in">expire_seconds_</span>(expire_sec) &#123;</span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="comment">// 锁标识必须全局唯一：UUID + 线程ID</span></span><br><span class="line">        <span class="comment">// 作用：解锁时验证身份，防止 A 误删 B 的锁</span></span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        lock_val_ = <span class="built_in">generate_uuid</span>() + <span class="string">&quot;:&quot;</span> + <span class="built_in">to_string</span>(this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">        <span class="comment">// 注意：generate_uuid() 需要自行实现，可使用 boost::uuid 或其他 UUID 库</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RAII：析构时自动释放锁</span></span><br><span class="line">    ~<span class="built_in">DistributedLock</span>() &#123;</span><br><span class="line">        <span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="comment">// SET key value EX seconds NX（原子操作）</span></span><br><span class="line">        <span class="comment">// NX = 仅当 key 不存在时才设置（互斥保证）</span></span><br><span class="line">        <span class="comment">// EX = 设置过期时间（防死锁保证）</span></span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="type">bool</span> acquired = redis_.<span class="built_in">set</span>(</span><br><span class="line">            lock_key_, </span><br><span class="line">            lock_val_,</span><br><span class="line">            chrono::<span class="built_in">seconds</span>(expire_seconds_),</span><br><span class="line">            sw::redis::UpdateType::NOT_EXIST  <span class="comment">// NX 语义</span></span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">            holding_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 启动后台续约线程，保证长任务不丢锁</span></span><br><span class="line">            renew_thread_ = <span class="built_in">thread</span>(&amp;DistributedLock::renew_loop, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> acquired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="comment">// exchange(false) 原子地：读取旧值 + 设置新值</span></span><br><span class="line">        <span class="comment">// 返回 false 说明之前就是 false，已经释放过了（幂等）</span></span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="keyword">if</span> (!holding_.<span class="built_in">exchange</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 必须等续约线程退出，否则可能：</span></span><br><span class="line">        <span class="comment">// 1. 续约线程还在跑，访问已析构的对象 → 崩溃</span></span><br><span class="line">        <span class="comment">// 2. 刚解锁又被续约 → 逻辑错误</span></span><br><span class="line">        <span class="keyword">if</span> (renew_thread_.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            renew_thread_.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="comment">// Lua 脚本原子解锁：验证 + 删除</span></span><br><span class="line">        <span class="comment">// 必须验证！场景：</span></span><br><span class="line">        <span class="comment">//   1. A 加锁成功，锁过期时间 30s</span></span><br><span class="line">        <span class="comment">//   2. A 业务卡了 35s，锁已自动过期</span></span><br><span class="line">        <span class="comment">//   3. B 抢到锁，开始执行业务</span></span><br><span class="line">        <span class="comment">//   4. A 终于执行完，调用 DEL 删锁 → 删掉了 B 的锁！</span></span><br><span class="line">        <span class="comment">// 用 Lua 脚本保证&quot;验证+删除&quot;原子性</span></span><br><span class="line">        <span class="comment">// ═══════════════════════════════════════════════════════</span></span><br><span class="line">        <span class="type">const</span> string unlock_script = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">            if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">                return redis.call(&#x27;del&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redis_.<span class="built_in">eval</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(unlock_script, &#123;lock_key_&#125;, &#123;lock_val_&#125;);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 解锁失败也没关系，锁会自动过期</span></span><br><span class="line">            <span class="comment">// 这是分布式锁的&quot;最终安全性&quot;保证</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_holding</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holding_.<span class="built_in">load</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;distributed_lock.hpp&quot;</span> <span class="comment">// 包含上述DistributedLock类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">generate_uuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简单实现，实际应使用标准UUID库</span></span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;uuid-&quot;</span> + std::<span class="built_in">to_string</span>(counter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接Redis</span></span><br><span class="line">    sw::<span class="function">redis::Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建分布式锁</span></span><br><span class="line">    <span class="type">const</span> std::string lockKey = <span class="string">&quot;lock:order:12345&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">DistributedLock <span class="title">lock</span><span class="params">(redis, lockKey, <span class="number">30</span>)</span></span>; <span class="comment">// 30秒过期时间</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lock.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取锁成功，执行业务逻辑...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟耗时业务逻辑</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">15</span>));</span><br><span class="line">            </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;业务逻辑执行完毕&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 锁会在作用域结束时自动释放</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取锁失败，资源被占用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 离开作用域，锁自动释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a id="mechanism"></a></p>
<h1 id="附录2：Redis-重要机制"><a href="#附录2：Redis-重要机制" class="headerlink" title="附录2：Redis++ 重要机制"></a>附录2：Redis++ 重要机制</h1><h2 id="1-Redis-的心跳机制（非自己实现）"><a href="#1-Redis-的心跳机制（非自己实现）" class="headerlink" title="1.Redis++ 的心跳机制（非自己实现）"></a>1.Redis++ 的心跳机制（非自己实现）</h2><h3 id="（1）介绍-3"><a href="#（1）介绍-3" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><ul>
<li><strong>心跳机制</strong>:<ul>
<li>是一种定期发送探测信号来确认通信双方是否存活的技术。</li>
</ul>
</li>
<li><strong>Redis++ 的心跳机制</strong>：<ul>
<li><strong>本质</strong>：<ul>
<li>直接启用了 <strong>Linux 内核的 TCP KeepAlive 机制</strong>。</li>
<li><strong>Redis++ 没有自己实现心跳逻辑</strong>，完全依赖操作系统内核的 TCP KeepAlive，这也是最高效的方式（零应用层开销）</li>
</ul>
</li>
<li><a href="/2026/01/13/Linux/TCP_IP%E7%9B%B8%E5%85%B3/TCP%20KeepAlive%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" title="TCP KeepAlive 心跳机制">TCP的心跳机制</a></li>
</ul>
</li>
</ul>
<h3 id="（2）时间流程图"><a href="#（2）时间流程图" class="headerlink" title="（2）时间流程图"></a>（2）时间流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">时间 ─────────────────────────────────────────────────────────────────────────▶</span><br><span class="line"></span><br><span class="line">[最后数据交互]</span><br><span class="line">      │</span><br><span class="line">      │◀─────── 第1阶段：长等待 ───────▶│◀───── 第2阶段：短间隔探测 ─────▶ │</span><br><span class="line">      │     tcp_keepalive_time          │     tcp_keepalive_intvl         │</span><br><span class="line">      │         = 7200s (2小时)         │         = 75s × 9次              |</span><br><span class="line">      │                                 │                                  │</span><br><span class="line">      │         （空闲，不探测）          │  💓──75s──💓──75s──...──💓     │</span><br><span class="line">      │                                 │  #1      #2          #9          │</span><br><span class="line">      │                                 │                                  │</span><br><span class="line">      └─────────────────────────────────┴──────────────────────────────────┘</span><br><span class="line">                                        │</span><br><span class="line">                                        ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                              最终判定逻辑                                    │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│  ✅ 任意探测收到 ACK → 重置计时器，回到第1阶段                                │</span><br><span class="line">│  ❌ 连续9次无响应    → 判定连接死亡，关闭连接                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">总检测时间 = 7200s + 75s × 9 = 7875s ≈ 2小时11分钟</span><br></pre></td></tr></table></figure>

<h3 id="（3）客户端-↔-Redis-交互示意图"><a href="#（3）客户端-↔-Redis-交互示意图" class="headerlink" title="（3）客户端 ↔ Redis 交互示意图"></a>（3）客户端 ↔ Redis 交互示意图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐                                                         ┌─────────────┐</span><br><span class="line">│  Redis++    │                                                         │   Redis     │</span><br><span class="line">│  Client     │                                                         │  Server     │</span><br><span class="line">└──────┬──────┘                                                         └──────┬──────┘</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │ [业务数据交互] → 最后一次数据收发完成 → 连接进入空闲状态                  │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │────────────────────────── 等待 7200s ────────────────────────────────────│</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  💓 发送第1个 Keepalive 探测包                                       │</span><br><span class="line">       │───────────────────────────────────────────────────────────────────────▶│</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │◀───────────────────────────────────────────────────────────────────────│</span><br><span class="line">       │       ✅ 收到 ACK → 重置计时器 → 回到空闲等待（最优路径）                │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  ❌ 未收到 ACK → 等待 75s                                              │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  💓 发送第2个 Keepalive 探测包                                       │</span><br><span class="line">       │───────────────────────────────────────────────────────────────────────▶│</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │◀───────────────────────────────────────────────────────────────────────│</span><br><span class="line">       │       ✅ 收到 ACK → 重置计时器 → 回到空闲等待                          │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  ... 重复探测逻辑，最多发送 9 次探测包 ...                              │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  💓 发送第9个 Keepalive 探测包（最后一次）                              │</span><br><span class="line">       │───────────────────────────────────────────────────────────────────────▶│</span><br><span class="line">       │                                                                       │</span><br><span class="line">       │  ❌ 仍未收到 ACK → 判定连接失效 → 关闭当前连接 → 触发应用层重连逻辑        │</span><br><span class="line">       │                                                                       │</span><br><span class="line">       ▼                                                                       ▼</span><br></pre></td></tr></table></figure>


<p><a id="install"></a></p>
<h1 id="附录3：Redis-安装教程"><a href="#附录3：Redis-安装教程" class="headerlink" title="附录3：Redis++ 安装教程"></a>附录3：Redis++ 安装教程</h1><h2 id="1-便捷安装"><a href="#1-便捷安装" class="headerlink" title="1.便捷安装"></a>1.便捷安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装 hiredis（底层依赖）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install libhiredis-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 redis-plus-plus</span></span><br><span class="line"><span class="built_in">cd</span> ~/thirdparty    <span class="comment"># 切换到你自己的安装目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sewenew/redis-plus-plus.git</span><br><span class="line"><span class="built_in">cd</span> redis-plus-plus</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">         -DCMAKE_CXX_STANDARD=17 \</span><br><span class="line">         -DHIREDIS_LIB=/usr/local/lib/libhiredis.so</span><br><span class="line"></span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>
<p><strong>如果安装失败，可尝试下面的方法</strong></p>
<h2 id="2-普通安装"><a href="#2-普通安装" class="headerlink" title="2.普通安装"></a>2.普通安装</h2><p><strong>安装 hiredis</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install -y build-essential git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆并编译 hiredis</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/redis/hiredis.git</span><br><span class="line"><span class="built_in">cd</span> hiredis</span><br><span class="line">make &amp;&amp; <span class="built_in">sudo</span> make install</span><br><span class="line"><span class="built_in">sudo</span> ldconfig  <span class="comment"># 更新动态库缓存</span></span><br></pre></td></tr></table></figure>

<p><strong>安装Redis++</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆 Redis++ 源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sewenew/redis-plus-plus.git</span><br><span class="line"><span class="built_in">cd</span> redis-plus-plus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有可用版本</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到你想要的版本（以1.3.15为例）（可选）</span></span><br><span class="line"><span class="comment"># git checkout version</span></span><br><span class="line">git checkout 1.3.15</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置编译选项</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">      -DREDIS_PLUS_PLUS_BUILD_TEST=OFF \</span><br><span class="line">      -DREDIS_PLUS_PLUS_BUILD_STATIC=OFF \</span><br><span class="line">      -DREDIS_PLUS_PLUS_BUILD_SHARED=ON \</span><br><span class="line">      -DREDIS_PLUS_PLUS_CXX_STANDARD=17 \</span><br><span class="line">      ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译（使用多核加速）</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新动态链接库缓存</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>

<h2 id="3-验证安装是否成功"><a href="#3-验证安装是否成功" class="headerlink" title="3.验证安装是否成功"></a>3.验证安装是否成功</h2><h3 id="（1）验证安装是否成功"><a href="#（1）验证安装是否成功" class="headerlink" title="（1）验证安装是否成功"></a>（1）验证安装是否成功</h3><ol>
<li>检查库文件是否存在</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 redis-plus-plus 库</span></span><br><span class="line"><span class="built_in">ls</span> /usr/local/lib/libredis++.so</span><br><span class="line"><span class="comment"># 检查 hiredis 库</span></span><br><span class="line"><span class="built_in">ls</span> /usr/local/lib/libhiredis.so</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开启Redis服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> redis-server</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写简单测试代码（如 test_redis.cpp）:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sw::redis::ConnectionOptions opts;</span><br><span class="line">    opts.host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    sw::<span class="function">redis::Redis <span class="title">redis</span><span class="params">(opts)</span></span>;</span><br><span class="line">    </span><br><span class="line">    redis.<span class="built_in">set</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> it = redis.<span class="built_in">get</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 注意 *it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(nil)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="4">
<li>编译并运行测试代码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ test_redis.cpp -o test_redis -lredis++ -lhiredis -std=c++17</span><br><span class="line"></span><br><span class="line">./test_redis</span><br></pre></td></tr></table></figure>

<h3 id="（2）查看当前安装的版本"><a href="#（2）查看当前安装的版本" class="headerlink" title="（2）查看当前安装的版本"></a>（2）查看当前安装的版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /usr/local/include/sw/redis++/version.h</span><br></pre></td></tr></table></figure>
<p><strong>可以看到</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> VERSION_MAJOR = <span class="number">1</span>;   <span class="comment">// 主版本</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> VERSION_MINOR = <span class="number">3</span>;   <span class="comment">// 次版本</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> VERSION_PATCH = <span class="number">15</span>;  <span class="comment">// 补丁版本</span></span><br><span class="line"><span class="comment">// 当前版本：1.3.15 </span></span><br></pre></td></tr></table></figure>

<h3 id="4-Redis-版本升级（切换）"><a href="#4-Redis-版本升级（切换）" class="headerlink" title="4.Redis++版本升级（切换）"></a>4.Redis++版本升级（切换）</h3><p>以我的安装目录“~&#x2F;thirdparty&#x2F;redis-plus-plus”为例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/thirdparty/redis-plus-plus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理旧的构建</span></span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到最新稳定版</span></span><br><span class="line">git checkout 1.3.15</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">      -DREDIS_PLUS_PLUS_CXX_STANDARD=17 \</span><br><span class="line">      ..</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>

<h3 id="5-删除Redis"><a href="#5-删除Redis" class="headerlink" title="5.删除Redis++"></a>5.删除Redis++</h3><p>如果安装失败，可通过下述方式清理Redis++文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ========== 1. 清理 Redis++ 库文件 ==========</span></span><br><span class="line"><span class="comment"># 删除动态库文件（包括软链接）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/libredis++.so</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/libredis++.so.*</span><br><span class="line"><span class="comment"># 删除静态库文件（若有）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/libredis++.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 2. 清理 Redis++ CMake 配置文件 ==========</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/lib/cmake/redis++</span><br><span class="line"><span class="comment"># 删除 pkg-config 配置（若有）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /usr/local/lib/pkgconfig/redis++.pc</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 3. 清理 Redis++ 头文件 ==========</span></span><br><span class="line"><span class="comment"># 核心头文件目录（包含 StringView 定义）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/include/sw/redis++</span><br><span class="line"><span class="comment"># 若存在 sw 空目录，可一并删除（可选）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rmdir</span> /usr/local/include/sw 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 4. 刷新系统动态库缓存 ==========</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 5. 验证清理结果（可选） ==========</span></span><br><span class="line"><span class="comment"># 若以下命令均无输出，说明清理完成</span></span><br><span class="line">find /usr/local/lib -name <span class="string">&quot;libredis++*&quot;</span></span><br><span class="line">find /usr/local/include -name <span class="string">&quot;redis++&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 6. 删除Redis++目录 ==============</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf redis-plus-plus/</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="咸鱼 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="咸鱼 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>咸鱼
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://xianyubuxian-txy.github.io/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" title="redis-plus-plus使用教程">https://xianyubuxian-txy.github.io/2026/01/12/C++/C++后端开发常用库/redis-plus-plus使用教程/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2026/01/12/Markdown/Markdown%E7%9B%B8%E5%85%B3/" rel="prev" title="Markdown语法笔记">
                  <i class="fa fa-angle-left"></i> Markdown语法笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2026/01/13/Linux/TCP_IP%E7%9B%B8%E5%85%B3/TCP%20KeepAlive%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" rel="next" title="TCP KeepAlive 心跳机制">
                  TCP KeepAlive 心跳机制 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">咸鱼</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">177k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:49</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/xianyubuxian-TXY" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline-beta-black.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2026/01/12/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/redis-plus-plus%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
