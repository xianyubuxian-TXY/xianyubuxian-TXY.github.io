<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xianyubuxian-txy.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、Kafka介绍 Kafka 是一款分布式、高吞吐量、高可靠性的分布式事件流平台（原定位为：分布式消息队列），基于发布&#x2F;订阅模式，主要用于处理实时数据管道、流处理、数据集成等场景，能够高效地收集、存储和分发大规模的实时数据流。   1.应用场景  * 消息队列：替代传统消息队列（如 RabbitMQ），实现服务间的异步通信、解耦和削峰填谷（如秒杀场景的流量缓冲）。  * 实时数据管道：在分布式系">
<meta property="og:type" content="article">
<meta property="og:title" content="kafka使用教程">
<meta property="og:url" content="https://xianyubuxian-txy.github.io/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="Xianyu">
<meta property="og:description" content="一、Kafka介绍 Kafka 是一款分布式、高吞吐量、高可靠性的分布式事件流平台（原定位为：分布式消息队列），基于发布&#x2F;订阅模式，主要用于处理实时数据管道、流处理、数据集成等场景，能够高效地收集、存储和分发大规模的实时数据流。   1.应用场景  * 消息队列：替代传统消息队列（如 RabbitMQ），实现服务间的异步通信、解耦和削峰填谷（如秒杀场景的流量缓冲）。  * 实时数据管道：在分布式系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115205205304.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115161939911.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115161159031.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115163026489.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115164615280.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115164736803.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115204712186.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115213709054.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115213729718.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116100012806.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116161810771.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116161420955.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116211851723.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116154712623.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116155332043.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103143018.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103427689.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103455545.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103734641.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116203247930.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116205721363.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116221010502.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117113059844.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112530324.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112653492.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112755227.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112844123.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117114455324.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116110908752.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116224028039.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117160922667.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117161830580.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117163118116.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117163442568.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116144249346.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116144611415.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116153411714.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116151134440.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116151233728.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119095109007.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119095142663.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116155332043.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118103329248.png">
<meta property="article:published_time" content="2026-01-15T07:56:39.000Z">
<meta property="article:modified_time" content="2026-01-19T01:51:50.945Z">
<meta property="article:author" content="咸鱼">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115205205304.png">


<link rel="canonical" href="https://xianyubuxian-txy.github.io/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xianyubuxian-txy.github.io/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","path":"2026/01/15/C++/C++后端开发常用库/kafka使用教程/","title":"kafka使用教程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>kafka使用教程 | Xianyu</title>
  








  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  




<link rel="dns-prefetch" href="https://waline-beta-black.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Xianyu</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Kafka%E4%BB%8B%E7%BB%8D"><span class="nav-text">一、Kafka介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1.应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-kafka%E4%BD%9C%E4%B8%BA%E2%80%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%9D"><span class="nav-text">2.kafka作为“消息队列”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81kafka%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">（1）为什么需要kafka，它的作用是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%AF%B9%E6%AF%94"><span class="nav-text">&lt;1&gt;工作流程图对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94%EF%BC%88%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%EF%BC%89"><span class="nav-text">&lt;2&gt;完整的流程对比（场景：用户注册）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%EF%BC%89%E5%89%8D%E6%99%AF%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D"><span class="nav-text">1）前景知识介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B2%A1%E6%9C%89Kafka%EF%BC%88%E4%BC%A0%E7%BB%9F%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="nav-text">2)没有Kafka（传统同步）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9C%89-Kafka%EF%BC%88%E5%BC%82%E6%AD%A5%E8%A7%A3%E8%80%A6%EF%BC%89"><span class="nav-text">3)有 Kafka（异步解耦）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81kafka%E3%80%81%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E6%9C%8D%E5%8A%A1-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">&lt;3&gt;后台服务器、kafka、后台任务服务 三者的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9Ckafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%9D-vs-%E2%80%9C%E8%BF%9B%E7%A8%8B%E6%B1%A0-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%80%9D"><span class="nav-text">&lt;4&gt;“kafka消息队列” vs “进程池&#x2F;线程池”</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81kafka-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">二、kafka 核心概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81librdkafka%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88C-2-13-0%EF%BC%89"><span class="nav-text">三、librdkafka的使用（C++ 2.13.0）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Producer-%E4%B8%8E-Consumer-%E4%BD%BF%E7%94%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">1.Producer 与 Consumer 使用概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Producer%E3%80%81kafka%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81Consumer%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">（1）Producer、kafka服务器、Consumer三者的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%B1%BB%E5%B1%82%E6%AC%A1%E6%80%BB%E8%A7%88"><span class="nav-text">（2）类层次总览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Producer%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">（3）Producer的使用流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Consumer%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">（4）Consumer的使用流程图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Conf%E7%B1%BB%EF%BC%88%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%89"><span class="nav-text">2.Conf类（配置类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Conf%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（1）Conf类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Conf%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">（2）Conf类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-RdKafka-Conf"><span class="nav-text">&lt;1&gt;创建 RdKafka::Conf</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%EF%BC%89%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA"><span class="nav-text">1）使用智能指针直接创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%EF%BC%89%E5%B0%81%E8%A3%85%E4%B8%BA%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="nav-text">2）封装为工厂函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%EF%BC%89%E4%B8%8D%E4%BD%BF%E7%94%A8%E2%80%9C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E2%80%9D%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%81%EF%BC%89"><span class="nav-text">3）不使用“智能指针”（不推荐！）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE-RdKafka-Conf"><span class="nav-text">&lt;2&gt;设置 RdKafka::Conf</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%EF%BC%89%E7%94%9F%E4%BA%A7%E8%80%85%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="nav-text">1）生产者常用配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%EF%BC%89%E6%B6%88%E8%B4%B9%E8%80%85%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="nav-text">2）消费者常用配置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-TopicPartition%E7%B1%BB%EF%BC%88%E4%B8%BB%E9%A2%98%E5%88%86%E5%8C%BA%E7%B1%BB%EF%BC%89"><span class="nav-text">3.TopicPartition类（主题分区类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89TopicPartition%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）TopicPartition类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E7%BB%93%E5%90%88%E6%A0%B8%E5%BF%83-API%EF%BC%89"><span class="nav-text">（3）典型使用场景（结合核心 API）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%88%86%E9%85%8D%E5%88%86%E5%8C%BA"><span class="nav-text">&lt;1&gt; 手动分配分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%81%8F%E7%A7%BB%E9%87%8F%E6%B6%88%E8%B4%B9"><span class="nav-text">&lt;2&gt;指定偏移量消费</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E6%8C%87%E5%AE%9A-offset"><span class="nav-text">&lt;3&gt;手动提交指定 offset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA"><span class="nav-text">&lt;4&gt;批量操作所有分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#destroy-%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">&lt;5&gt;destroy() 的使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E6%A0%B8%E5%BF%83%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%89"><span class="nav-text">（4）内存管理（核心注意事项）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%A0%B8%E5%BF%83%E6%98%93%E9%94%99%E7%82%B9%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">（5）核心易错点与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%93%E9%94%99%E7%82%B9"><span class="nav-text">&lt;1&gt;易错点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Headers%E7%B1%BB%EF%BC%88%E6%B6%88%E6%81%AF%E5%A4%B4%E7%B1%BB%EF%BC%89"><span class="nav-text">4.Headers类（消息头类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-1"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-1"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Headers%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）Headers类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">（3）使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%86%99%E5%85%A5-Headers-%E7%A4%BA%E4%BE%8B"><span class="nav-text">&lt;1&gt;生产者写入 Headers 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E8%AF%BB%E5%8F%96-Headers-%E7%A4%BA%E4%BE%8B"><span class="nav-text">&lt;2&gt;消费者读取 Headers 示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（4）核心注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Handle%E7%B1%BB%EF%BC%88%E5%8F%A5%E6%9F%84%E5%9F%BA%E7%B1%BB%EF%BC%89"><span class="nav-text">5.Handle类（句柄基类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-2"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-2"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Handle-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）Handle 类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（3）核心特性与注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Producer%E7%B1%BB%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85%E7%B1%BB%EF%BC%89"><span class="nav-text">6.Producer类（生产者类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-3"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-3"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-3"><span class="nav-text">&lt;2&gt;核心定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-text">&lt;3&gt;继承关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Producer%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）Producer类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE"><span class="nav-text">（3）核心配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">（4）使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B%EF%BC%88%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%A6%96%E9%80%89%EF%BC%89"><span class="nav-text">&lt;1&gt;异步发送示例（生产环境首选）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B%EF%BC%88%E7%89%B9%E6%AE%8A%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-text">&lt;2&gt;同步发送示例（特殊场景使用）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（5）关键注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-KafkaConsumer%E7%B1%BB%EF%BC%88%E6%B6%88%E8%B4%B9%E8%80%85%E7%B1%BB%EF%BC%89"><span class="nav-text">7.KafkaConsumer类（消费者类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-4"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-4"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-4"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89KafkaConsumer%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）KafkaConsumer类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE-1"><span class="nav-text">（3）核心配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">（4）使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%B6%88%E8%B4%B9%E7%A4%BA%E4%BE%8B%EF%BC%88%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="nav-text">&lt;1&gt;基础消费示例（消费者组模式，最常用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E5%81%8F%E7%A7%BB%E9%87%8F%E7%A4%BA%E4%BE%8B%EF%BC%88%E7%B2%BE%E7%A1%AE%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="nav-text">&lt;2&gt;手动提交偏移量示例（精确控制）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%EF%BC%89"><span class="nav-text">&lt;3&gt; 手动分区分配示例（不使用消费者组）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Seek-%E8%B7%B3%E8%BD%AC%E5%81%8F%E7%A7%BB%E9%87%8F%E7%A4%BA%E4%BE%8B"><span class="nav-text">&lt;4&gt;Seek 跳转偏移量示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E4%BD%9C%E5%BC%8F-Rebalance-%E7%A4%BA%E4%BE%8B%EF%BC%88COOPERATIVE-%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-text">&lt;5&gt;协作式 Rebalance 示例（COOPERATIVE 协议）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%AF%B9%E6%AF%94%E5%9B%BE"><span class="nav-text">（5）对比图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#KafkaConsumer-vs-Producer"><span class="nav-text">&lt;1&gt;KafkaConsumer vs Producer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscribe-vs-assign"><span class="nav-text">&lt;2&gt;subscribe vs assign</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（6）关键注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-RdKafka-Message%E7%B1%BB%EF%BC%88%E6%B6%88%E6%81%AF%E7%B1%BB%EF%BC%89"><span class="nav-text">8.RdKafka::Message类（消息类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-5"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-5"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-5"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Message%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）Message类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%A0%81-ErrorCode"><span class="nav-text">（3）常见错误码 ErrorCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">（4）使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%8E%A5%E6%94%B6%E5%B9%B6%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%EF%BC%88%E6%A0%B8%E5%BF%83%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="nav-text">&lt;1&gt;消费者接收并处理消息（核心场景）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%90%8E%E5%A4%84%E7%90%86%E5%9B%9E%E8%B0%83%EF%BC%88%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%EF%BC%89"><span class="nav-text">&lt;2&gt;生产者发送消息后处理回调（异步发送）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（5）核心特性与注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81"><span class="nav-text">&lt;1&gt;核心特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%93%E9%94%99%E7%82%B9%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">&lt;2&gt;易错点与最佳实践</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-ErrorCode%E6%9E%9A%E4%B8%BE%EF%BC%88%E9%94%99%E8%AF%AF%E7%A0%81%E6%9E%9A%E4%B8%BE%EF%BC%89"><span class="nav-text">9.ErrorCode枚举（错误码枚举）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-6"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-6"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-6"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%A0%B8%E5%BF%83%E5%88%86%E7%B1%BB%EF%BC%88%E6%8C%89%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="nav-text">（2）核心分类（按业务场景）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E9%94%99%E8%AF%AF%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="nav-text">（3）核心错误码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%80%9A%E7%94%A8%E9%94%99%E8%AF%AF%E7%A0%81%EF%BC%88%E6%89%80%E6%9C%89%E5%9C%BA%E6%99%AF%E5%BF%85%E7%9F%A5%EF%BC%89"><span class="nav-text">&lt;1&gt;基础通用错误码（所有场景必知）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%A0%B8%E5%BF%83%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-text">&lt;2&gt;生产者核心错误码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%A0%B8%E5%BF%83%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-text">&lt;3&gt;消费者核心错误码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90-%E9%9B%86%E7%BE%A4%E6%A0%B8%E5%BF%83%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-text">&lt;4&gt; 权限&#x2F;集群核心错误码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-text">（4）核心注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-Error%E7%B1%BB%EF%BC%88%E9%94%99%E8%AF%AF%E7%B1%BB%EF%BC%89"><span class="nav-text">10.Error类（错误类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-7"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-7"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-7"><span class="nav-text">&lt;2&gt;核心定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E-ErrorCode-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="nav-text">&lt;3&gt;与 ErrorCode 的核心区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Error%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）Error类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">（3）使用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="nav-text">（4）核心注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-MessageTimestamp%E7%B1%BB%EF%BC%88%E6%97%B6%E9%97%B4%E6%88%B3%E7%B1%BB%EF%BC%89"><span class="nav-text">11.MessageTimestamp类（时间戳类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-8"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-8"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-8"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89MessageTimestamp%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）MessageTimestamp类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">（3）使用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（4）注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-RdKafka-xxxCb%E5%9B%9E%E8%B0%83%E7%B1%BB"><span class="nav-text">12.RdKafka::xxxCb回调类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89DeliveryReportCb%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85%E6%8A%95%E9%80%92%E7%BB%93%E6%9E%9C%E5%9B%9E%E8%B0%83%EF%BC%89"><span class="nav-text">（1）DeliveryReportCb（生产者投递结果回调）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">&lt;1&gt;定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">&lt;2&gt;使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89EventCb%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%95%E5%B1%82%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%EF%BC%89"><span class="nav-text">（2）EventCb（客户端底层事件回调）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-text">&lt;1&gt;定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">&lt;2&gt;使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89RebalanceCb%EF%BC%88%E6%B6%88%E8%B4%B9%E8%80%85%E9%87%8D%E5%B9%B3%E8%A1%A1%E5%9B%9E%E8%B0%83%EF%BC%89"><span class="nav-text">（3）RebalanceCb（消费者重平衡回调）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-text">&lt;1&gt;定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2"><span class="nav-text">&lt;2&gt;使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89OffsetCommitCb%EF%BC%88%E6%B6%88%E8%B4%B9%E8%80%85-Offset-%E6%8F%90%E4%BA%A4%E7%BB%93%E6%9E%9C%E5%9B%9E%E8%B0%83%EF%BC%89"><span class="nav-text">（4）OffsetCommitCb（消费者 Offset 提交结果回调）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="nav-text">&lt;1&gt;定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3"><span class="nav-text">&lt;2&gt;使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%9B%9E%E8%B0%83%E7%B1%BB%E9%80%9A%E7%94%A8%E8%A7%84%E5%88%99%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">（5）回调类通用规则与注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E9%80%9A%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-text">&lt;1&gt;核心通用规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%A2%91%E6%98%93%E9%94%99%E7%82%B9"><span class="nav-text">&lt;2&gt;高频易错点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-Topic%E7%B1%BB%EF%BC%88%E4%B8%BB%E9%A2%98%E7%B1%BB%EF%BC%89"><span class="nav-text">13.Topic类（主题类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-9"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-9"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-9"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Topic%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）Topic类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3"><span class="nav-text">（3）使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Producer-%E5%88%9B%E5%BB%BA-Topic-%E5%8F%A5%E6%9F%84%E5%B9%B6%E6%9F%A5%E8%AF%A2%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">&lt;1&gt;Producer 创建 Topic 句柄并查询元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consumer-%E4%BD%BF%E7%94%A8-Topic-%E5%81%8F%E7%A7%BB%E9%87%8F%E5%B8%B8%E9%87%8F%E6%8E%A7%E5%88%B6%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%BD%AE"><span class="nav-text">&lt;2&gt; Consumer 使用 Topic 偏移量常量控制消费位置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-text">（4）注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-Queue%E7%B1%BB%EF%BC%88%E9%98%9F%E5%88%97%E7%B1%BB%EF%BC%89"><span class="nav-text">14.Queue类（队列类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A6%82%E8%BF%B0-10"><span class="nav-text">（1）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-10"><span class="nav-text">&lt;1&gt;作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D-10"><span class="nav-text">&lt;2&gt;核心定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Queue%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）Queue类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-4"><span class="nav-text">（3）使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97%E5%B9%B6%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="nav-text">&lt;1&gt;基础用法 - 创建队列并消费消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E9%98%9F%E5%88%97-%E5%B9%B6%E8%A1%8C%E6%B6%88%E8%B4%B9%E4%B8%8D%E5%90%8C%E5%88%86%E5%8C%BA"><span class="nav-text">&lt;2&gt;分区队列 - 并行消费不同分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E8%BD%AC%E5%8F%91-%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-text">&lt;3&gt;队列转发 - 合并多个队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO-%E4%BA%8B%E4%BB%B6%E9%9B%86%E6%88%90-%E4%B8%8E-epoll-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-text">&lt;4&gt;IO 事件集成 - 与 epoll 配合使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="nav-text">（4）注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%951%EF%BC%9A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="nav-text">附录1：常用配置项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Global%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B1%E7%94%A8%EF%BC%89"><span class="nav-text">1.Global通用配置（生产者&#x2F;消费者共用）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%85%B3%E9%94%AE%E9%85%8D%E7%BD%AE"><span class="nav-text">（1）关键配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3%EF%BC%88%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%EF%BC%89"><span class="nav-text">（2）网络与连接相关（网络优化）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3%EF%BC%88%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%EF%BC%89"><span class="nav-text">（3）安全认证相关（生产环境）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%85%83%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3"><span class="nav-text">（4）元数据相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%93%E7%94%A8"><span class="nav-text">2.生产者专用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%93%E7%94%A8"><span class="nav-text">3.消费者专用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Cb%E5%9B%9E%E8%B0%83%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="nav-text">4.Cb回调配置项</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="咸鱼"
      src="/images/xianyu.jpg">
  <p class="site-author-name" itemprop="name">咸鱼</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xianyubuxian-TXY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xianyubuxian-TXY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianyubuxian-txy.github.io/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/xianyu.jpg">
      <meta itemprop="name" content="咸鱼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xianyu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="kafka使用教程 | Xianyu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          kafka使用教程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2026-01-15 15:56:39" itemprop="dateCreated datePublished" datetime="2026-01-15T15:56:39+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-19 09:51:50" itemprop="dateModified" datetime="2026-01-19T09:51:50+08:00">2026-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">C++后端开发库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BA%93/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:26</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、Kafka介绍"><a href="#一、Kafka介绍" class="headerlink" title="一、Kafka介绍"></a>一、Kafka介绍</h1><p>Kafka 是一款分布式、高吞吐量、高可靠性的<strong>分布式事件流平台</strong>（原定位为：<strong>分布式消息队列</strong>），基于<strong>发布&#x2F;订阅模式</strong>，主要用于处理实时数据管道、流处理、数据集成等场景，能够高效地收集、存储和分发大规模的实时数据流。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115205205304.png"></p>
<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h2><ul>
<li><strong>消息队列</strong>：替代传统消息队列（如 RabbitMQ），实现服务间的异步通信、解耦和削峰填谷（如秒杀场景的流量缓冲）。</li>
<li><strong>实时数据管道</strong>：在分布式系统间构建数据传输通道，实现不同系统（如数据库、缓存、业务系统）之间的实时数据同步。</li>
<li><strong>日志收集</strong>：集中收集分布式系统的日志数据（如 ELK 架构中的日志传输环节），便于日志分析和故障排查。</li>
<li><strong>流处理</strong>：作为流处理框架（如 Flink、Spark Streaming）的数据源和数据Sink，支撑实时计算场景（如实时监控、实时报表、风控预警）。</li>
<li><strong>事件溯源</strong>：记录系统中的关键事件，支持业务状态回溯和历史数据审计。</li>
</ul>
<h2 id="2-kafka作为“消息队列”"><a href="#2-kafka作为“消息队列”" class="headerlink" title="2.kafka作为“消息队列”"></a>2.kafka作为“消息队列”</h2><h3 id="（1）为什么需要kafka，它的作用是什么？"><a href="#（1）为什么需要kafka，它的作用是什么？" class="headerlink" title="（1）为什么需要kafka，它的作用是什么？"></a>（1）为什么需要kafka，它的作用是什么？</h3><p>下面我将以“<strong>用户注册场景</strong>”为例，简要讲解为什么要引入kafka作为消息队列，它作为工作流程的哪一个环节，如何使用。</p>
<h4 id="工作流程图对比"><a href="#工作流程图对比" class="headerlink" title="&lt;1&gt;工作流程图对比"></a>&lt;1&gt;工作流程图对比</h4><ul>
<li><p><strong>1.没有使用Kafka或任何任务队列的传统同步处理流程图</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115161939911.png"></p>
</li>
<li><p><strong>2.使用kafka的异步处理流程图</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115161159031.png"></p>
</li>
</ul>
<p><strong>看到这，敏锐的人可能想到：“不使用kafka，用多线程异步处理不是也可以吗？” 是的，也是可以的，但使用kafka有很多优势，这个之后在介绍。</strong></p>
<h4 id="完整的流程对比（场景：用户注册）"><a href="#完整的流程对比（场景：用户注册）" class="headerlink" title="&lt;2&gt;完整的流程对比（场景：用户注册）"></a>&lt;2&gt;完整的流程对比（场景：用户注册）</h4><h5 id="1）前景知识介绍"><a href="#1）前景知识介绍" class="headerlink" title="1）前景知识介绍"></a>1）前景知识介绍</h5><ul>
<li><strong>用户注册的“核心业务”</strong>：<ul>
<li>向数据库中插入新注册的用户信息（这里其实就“注册成功了！”）</li>
</ul>
</li>
<li><strong>用户注册的“附加业务”</strong>：<ul>
<li>发送邮件到注册用户的邮箱提示注册成功</li>
<li>注册成功后，返回后台数据用于渲染前端页面（如：现实中你注册成功时，显示“3s 跳转页面”，就是前端在等待后端数据进行渲染）</li>
<li>给你一些“信息提示”（如：在购物平台，提示你有优惠券可领）</li>
<li>…</li>
</ul>
</li>
<li>不同平台&#x2F;软件用户注册的“附加业务”各有不同，单“核心业务”都是在“向数据库插入新注册用户的信息”，插入成功其实就代表“注册成功”了，“附加业务”即使没有也可以。</li>
</ul>
<h5 id="2-没有Kafka（传统同步）"><a href="#2-没有Kafka（传统同步）" class="headerlink" title="2)没有Kafka（传统同步）"></a>2)没有Kafka（传统同步）</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115163026489.png"><br><strong>问题</strong>：</p>
<ul>
<li>❌ 用户等待 3+ 秒才看到响应（延迟高）</li>
<li>❌ 任一个环节出现问题（如：邮件服务挂了），注册失败（可靠性较低）</li>
<li>❌ 高并发时，线程全部阻塞“附加业务”上，“附加业务”是主要的“性能瓶颈”</li>
</ul>
<p><strong>再次提示</strong>：这里虽然也可以将“附加业务”再次用异步线程处理，但我们先不讨论它。</p>
<h5 id="3-有-Kafka（异步解耦）"><a href="#3-有-Kafka（异步解耦）" class="headerlink" title="3)有 Kafka（异步解耦）"></a>3)有 Kafka（异步解耦）</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115164615280.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115164736803.png"></p>
<p><a id="P1"></a></p>
<h4 id="后台服务器、kafka、后台任务服务-三者的关系"><a href="#后台服务器、kafka、后台任务服务-三者的关系" class="headerlink" title="&lt;3&gt;后台服务器、kafka、后台任务服务 三者的关系"></a>&lt;3&gt;后台服务器、kafka、后台任务服务 三者的关系</h4><ul>
<li><strong>类比进程池</strong>：<ul>
<li><strong>后台服务器</strong> ——&gt; <strong>master进程</strong></li>
<li><strong>kafka</strong>    ——&gt; <strong>任务队列</strong></li>
<li><strong>后台任务服务</strong> ——&gt; <strong>worker工作进程</strong></li>
</ul>
</li>
<li>客户端发送请求到达“后台服务器”（类比master进程）时，后台服务器完成“核心业务”（如：将新用户数据插入数据库），并将“附加业务”请求（高耗时）发送到kafka消息队列（类比任务队列）中，然后立即向前端回复执行结果。“后台任务服务”（类比worker进程）则不断从kafka的消息队列中取出“附加业务”请求进行处理<ul>
<li><strong>解耦了“核心业务”与“附加业务”，从而使“后台服务器”可以快速响应前端请求</strong></li>
</ul>
</li>
</ul>
<h4 id="“kafka消息队列”-vs-“进程池-线程池”"><a href="#“kafka消息队列”-vs-“进程池-线程池”" class="headerlink" title="&lt;4&gt;“kafka消息队列” vs “进程池&#x2F;线程池”"></a>&lt;4&gt;“kafka消息队列” vs “进程池&#x2F;线程池”</h4><p>从前面可以知道，使用kafka的模式与Reactor模式很像，但kafka模式有很多优点：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115204712186.png"></p>
<h1 id="二、kafka-核心概念"><a href="#二、kafka-核心概念" class="headerlink" title="二、kafka 核心概念"></a>二、kafka 核心概念</h1><p><strong>推荐阅读《Apache Kafka实战》了解详情</strong><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115213709054.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260115213729718.png"></p>
<p><strong>message格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                            消息头部 (message header)                      │</span><br><span class="line">├────────┬──────┬──────┬──────────┬──────────┬─────────┬──────────┬─────────┤</span><br><span class="line">│ CRC    │版本号 │ 属性 │ 时间戳   │ Key 长度 │ Key     │ Value 长度│ Value   │</span><br><span class="line">│ 4B     │ 1B   │ 1B   │ 8B       │ 4B       │ k bytes │ 4B       │ v bytes │</span><br><span class="line">└────────┴──────┴──────┴──────────┴──────────┴─────────┴──────────┴─────────┘</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>key</strong>：消息键，在对消息进行partition时使用 ——&gt;决定消息被存储在 该 Topic 的哪个 Partition。</li>
<li><strong>Value</strong>：消息体，消息的实际数据。</li>
<li><strong>Timestamp</strong>：消息发送时间戳。</li>
<li>每个消息由 <strong>&lt;topic,partition,offset&gt;三元组 唯一标识</strong></li>
</ul>
<h1 id="三、librdkafka的使用（C-2-13-0）"><a href="#三、librdkafka的使用（C-2-13-0）" class="headerlink" title="三、librdkafka的使用（C++ 2.13.0）"></a>三、librdkafka的使用（C++ 2.13.0）</h1><h2 id="1-Producer-与-Consumer-使用概述"><a href="#1-Producer-与-Consumer-使用概述" class="headerlink" title="1.Producer 与 Consumer 使用概述"></a>1.Producer 与 Consumer 使用概述</h2><h3 id="（1）Producer、kafka服务器、Consumer三者的关系"><a href="#（1）Producer、kafka服务器、Consumer三者的关系" class="headerlink" title="（1）Producer、kafka服务器、Consumer三者的关系"></a>（1）Producer、kafka服务器、Consumer三者的关系</h3><ul>
<li><strong>Producer</strong>（消息生产者）：<ul>
<li><strong>后台服务器</strong> 连接 kafka服务器的句柄 ——&gt;根据 “topic,partition” 向kafka服务器中写入消息</li>
</ul>
</li>
<li><strong>Consumer</strong>（消息消费者）：<ul>
<li><strong>后台任务服务</strong> 连接 kafka服务器的句柄 ——&gt; 根据 “&lt;topic,partition,offset&gt;” 从kafka中消费消息</li>
</ul>
</li>
<li>无论是<strong>Producer</strong>还是<strong>Consumer</strong>，都是<strong>kafka的客户端</strong>，kafka的服务器是两者的中介</li>
</ul>
<p><strong>如果对“后台服务器”、“后台任务服务”不了解</strong>，参考<a href="#P1">后台服务器、kafka、后台任务服务 三者的关系</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                          Kafka 架构角色                                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌─────────────────┐                         ┌─────────────────┐      │</span><br><span class="line">│   │    Producer     │                         │    Consumer     │      │</span><br><span class="line">│   │   (消息生产者)   │                         │   (消息消费者)   │      │</span><br><span class="line">│   │                 │                         │                 │      │</span><br><span class="line">│   │  后台服务器     │                         │  后台任务服务    │      │</span><br><span class="line">│   │  连接 Kafka 句柄 │                         │  连接 Kafka 句柄 │      │</span><br><span class="line">│   └────────┬────────┘                         └────────▲────────┘      │</span><br><span class="line">│            │                                           │               │</span><br><span class="line">│            │  写入消息                        消费消息  │               │</span><br><span class="line">│            │  &lt;topic, partition&gt;    &lt;topic, partition, offset&gt;         │</span><br><span class="line">│            │                                           │               │</span><br><span class="line">│            ▼                                           │               │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────┐      │</span><br><span class="line">│   │                      Kafka Server                           │      │</span><br><span class="line">│   │                       (中介/Broker)                          │      │</span><br><span class="line">│   │                                                             │      │</span><br><span class="line">│   │    ┌─────────┐    ┌─────────┐    ┌─────────┐               │      │</span><br><span class="line">│   │    │ Topic A │    │ Topic B │    │ Topic C │    ...        │      │</span><br><span class="line">│   │    │ ┌─────┐ │    │ ┌─────┐ │    │ ┌─────┐ │               │      │</span><br><span class="line">│   │    │ │ P0  │ │    │ │ P0  │ │    │ │ P0  │ │               │      │</span><br><span class="line">│   │    │ │ P1  │ │    │ │ P1  │ │    │ │ P1  │ │               │      │</span><br><span class="line">│   │    │ │ P2  │ │    │ │ P2  │ │    │ │ P2  │ │               │      │</span><br><span class="line">│   │    │ └─────┘ │    │ └─────┘ │    │ └─────┘ │               │      │</span><br><span class="line">│   │    └─────────┘    └─────────┘    └─────────┘               │      │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────┘      │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ※ Producer 和 Consumer 都是 Kafka 的客户端                           │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐         ┌──────────────┐         ┌──────────────┐</span><br><span class="line">│   Producer   │  ────►  │    Kafka     │  ────►  │   Consumer   │</span><br><span class="line">│  (后台服务器) │  写入    │   Server     │  消费    │ (后台任务服务) │</span><br><span class="line">└──────────────┘         │   (Broker)   │         └──────────────┘</span><br><span class="line">                         └──────────────┘</span><br><span class="line">                         </span><br><span class="line">写入定位：topic + partition</span><br><span class="line">消费定位：topic + partition + offset</span><br></pre></td></tr></table></figure>

<h3 id="（2）类层次总览"><a href="#（2）类层次总览" class="headerlink" title="（2）类层次总览"></a>（2）类层次总览</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        librdkafka C++ 类层次结构                             │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                             │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                         基础配置层                                   │   │</span><br><span class="line">│  │   ┌────────┐    ┌────────────────┐    ┌──────────────────────┐     │   │</span><br><span class="line">│  │   │  Conf  │    │  TopicPartition │    │      Headers        │     │   │</span><br><span class="line">│  │   └────────┘    └────────────────┘    └──────────────────────┘     │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                    │                                        │</span><br><span class="line">│                                    ▼                                        │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                          核心句柄层                                  │   │</span><br><span class="line">│  │                      ┌──────────────┐                               │   │</span><br><span class="line">│  │                      │    Handle    │ (抽象基类)                    │   │</span><br><span class="line">│  │                      └──────┬───────┘                               │   │</span><br><span class="line">│  │               ┌─────────────┴─────────────┐                         │   │</span><br><span class="line">│  │               ▼                           ▼                         │   │</span><br><span class="line">│  │        ┌──────────────┐           ┌───────────────┐                 │   │</span><br><span class="line">│  │        │   Producer   │           │ KafkaConsumer │                 │   │</span><br><span class="line">│  │        └──────────────┘           └───────────────┘                 │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                    │                                        │</span><br><span class="line">│                                    ▼                                        │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                          消息数据层                                  │   │</span><br><span class="line">│  │   ┌──────────┐    ┌──────────────────┐    ┌────────────────────┐   │   │</span><br><span class="line">│  │   │ Message  │    │ MessageTimestamp │    │       Error        │   │   │</span><br><span class="line">│  │   └──────────┘    └──────────────────┘    └────────────────────┘   │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                    │                                        │</span><br><span class="line">│                                    ▼                                        │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                          回调接口层                                  │   │</span><br><span class="line">│  │  ┌─────────────────┐ ┌─────────────┐ ┌─────────────┐ ┌───────────┐ │   │</span><br><span class="line">│  │  │DeliveryReportCb │ │ RebalanceCb │ │OffsetCommit │ │  EventCb  │ │   │</span><br><span class="line">│  │  │                 │ │             │ │     Cb      │ │           │ │   │</span><br><span class="line">│  │  └─────────────────┘ └─────────────┘ └─────────────┘ └───────────┘ │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                    │                                        │</span><br><span class="line">│                                    ▼                                        │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                          高级功能层                                  │   │</span><br><span class="line">│  │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌─────────────┐  │   │</span><br><span class="line">│  │   │ Metadata │    │  Queue   │    │  Topic   │    │ AdminClient │  │   │</span><br><span class="line">│  │   └──────────┘    └──────────┘    └──────────┘    └─────────────┘  │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                                                             │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（3）Producer的使用流程图"><a href="#（3）Producer的使用流程图" class="headerlink" title="（3）Producer的使用流程图"></a>（3）Producer的使用流程图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         初始化阶段                                       │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐    ┌───────────────────┐    ┌────────────────┐ │</span><br><span class="line">│   │    创建 Conf      │───→│    设置参数       │───→│   注册回调     │ │</span><br><span class="line">│   │   (全局配置)      │    │  bootstrap.servers│    │                │ │</span><br><span class="line">│   │                   │    │  acks, retries 等 │    │ DeliveryReport │ │</span><br><span class="line">│   │ ┌───────────────┐ │    └───────────────────┘    │      Cb        │ │</span><br><span class="line">│   │ │  <span class="built_in">Conf</span> (GLOBAL)│ │                             │    EventCb     │ │</span><br><span class="line">│   │ └───────────────┘ │                             └───────┬────────┘ │</span><br><span class="line">│   └───────────────────┘                                     │          │</span><br><span class="line">│                                                             ▼          │</span><br><span class="line">│                                                 ┌───────────────────┐  │</span><br><span class="line">│                                                 │  创建 Producer    │  │</span><br><span class="line">│                                                 │ Producer::<span class="built_in">create</span>()│  │</span><br><span class="line">│                                                 │                   │  │</span><br><span class="line">│                                                 │ ┌───────────────┐ │  │</span><br><span class="line">│                                                 │ │   Producer    │ │  │</span><br><span class="line">│                                                 │ └───────────────┘ │  │</span><br><span class="line">│                                                 └─────────┬─────────┘  │</span><br><span class="line">└───────────────────────────────────────────────────────────┼─────────────┘</span><br><span class="line">                                                            │</span><br><span class="line">                                                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         生产阶段（循环）                                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐    ┌───────────────────┐    ┌────────────────┐ │</span><br><span class="line">│   │    构造消息       │───→│    <span class="built_in">produce</span>()      │───→│    <span class="built_in">poll</span>()      │ │</span><br><span class="line">│   │  topic/key/value  │    │   放入内部队列    │    │   触发回调     │ │</span><br><span class="line">│   │                   │    │                   │    │   处理事件     │ │</span><br><span class="line">│   │ ┌───────────────┐ │    │ ┌───────────────┐ │    └───────┬────────┘ │</span><br><span class="line">│   │ │    Topic      │ │    │ │   Producer    │ │            │        ◄─┐</span><br><span class="line">│   │ │    Headers    │ │    │ │   ::<span class="built_in">produce</span>() │ │            │          │</span><br><span class="line">│   │ └───────────────┘ │    │ └───────────────┘ │            │          │</span><br><span class="line">│   └───────────────────┘    └───────────────────┘            │          │</span><br><span class="line">│                                                             │          │</span><br><span class="line">│            ┌────────────────────────────────────────────────┘          │</span><br><span class="line">│            │                                                           │</span><br><span class="line">│            │    ┌─────────────────────────────────────────┐            │</span><br><span class="line">│            │    │  回调触发时涉及的类：                    │            │</span><br><span class="line">│            │    │  ┌─────────┐  ┌─────────┐  ┌─────────┐  │            │</span><br><span class="line">│            │    │  │ Message │  │  Event  │  │ErrorCode│  │            │</span><br><span class="line">│            │    │  └─────────┘  └─────────┘  └─────────┘  │            │</span><br><span class="line">│            │    └─────────────────────────────────────────┘            │</span><br><span class="line">│            │                                                           │</span><br><span class="line">│            └───────────────────────────────────────────────────────────┘</span><br><span class="line">│                                            (持续生产则循环)              │</span><br><span class="line">└───────────────────────────────────────────────────────────┬─────────────┘</span><br><span class="line">                                                            │</span><br><span class="line">                                                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         清理阶段                                         │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐         ┌───────────────────┐                  │</span><br><span class="line">│   │     <span class="built_in">flush</span>()       │────────→│  <span class="keyword">delete</span> producer  │                  │</span><br><span class="line">│   │   等待队列清空    │         │                   │                  │</span><br><span class="line">│   │                   │         │ ┌───────────────┐ │                  │</span><br><span class="line">│   │ ┌───────────────┐ │         │ │   Producer    │ │                  │</span><br><span class="line">│   │ │   Producer    │ │         │ │   (销毁)      │ │                  │</span><br><span class="line">│   │ │   ::<span class="built_in">flush</span>()   │ │         │ └───────────────┘ │                  │</span><br><span class="line">│   │ └───────────────┘ │         └───────────────────┘                  │</span><br><span class="line">│   └───────────────────┘                                                │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（4）Consumer的使用流程图"><a href="#（4）Consumer的使用流程图" class="headerlink" title="（4）Consumer的使用流程图"></a>（4）Consumer的使用流程图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         初始化阶段                                       │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐    ┌───────────────────┐    ┌────────────────┐ │</span><br><span class="line">│   │    创建 Conf      │───→│    设置参数       │───→│   注册回调     │ │</span><br><span class="line">│   │   (全局配置)      │    │  bootstrap.servers│    │                │ │</span><br><span class="line">│   │                   │    │  group.<span class="built_in">id</span> (必需)  │    │  RebalanceCb   │ │</span><br><span class="line">│   │ ┌───────────────┐ │    │  <span class="keyword">auto</span>.offset.reset│    │OffsetCommitCb  │ │</span><br><span class="line">│   │ │  <span class="built_in">Conf</span> (GLOBAL)│ │    │  enable.<span class="keyword">auto</span>.     │    │    EventCb     │ │</span><br><span class="line">│   │ └───────────────┘ │    │      commit 等    │    └───────┬────────┘ │</span><br><span class="line">│   └───────────────────┘    └───────────────────┘            │          │</span><br><span class="line">│                                                             ▼          │</span><br><span class="line">│                                                 ┌───────────────────┐  │</span><br><span class="line">│                                                 │ 创建 KafkaConsumer│  │</span><br><span class="line">│                                                 │ KafkaConsumer::   │  │</span><br><span class="line">│                                                 │    <span class="built_in">create</span>()       │  │</span><br><span class="line">│                                                 │ ┌───────────────┐ │  │</span><br><span class="line">│                                                 │ │ KafkaConsumer │ │  │</span><br><span class="line">│                                                 │ └───────────────┘ │  │</span><br><span class="line">│                                                 └─────────┬─────────┘  │</span><br><span class="line">└───────────────────────────────────────────────────────────┼─────────────┘</span><br><span class="line">                                                            │</span><br><span class="line">                                                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         订阅阶段                                         │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────┐  │</span><br><span class="line">│   │                       两种订阅方式（二选一）                      |  |</span><br><span class="line">    |               用于确定从哪个（topic，partition）获取消息           │  │</span><br><span class="line">│   ├─────────────────────────────────┬───────────────────────────────┤  │</span><br><span class="line">│   │                                 │                               │  │</span><br><span class="line">│   │   ┌───────────────────────┐     │     ┌───────────────────────┐ │  │</span><br><span class="line">│   │   │    <span class="built_in">subscribe</span>()        │     │     │    <span class="built_in">assign</span>()           │ │  │</span><br><span class="line">│   │   │    订阅主题列表       │     │     │    手动分配分区       │ │  │</span><br><span class="line">│   │   │                       │     │     │                       │ │  │</span><br><span class="line">│   │   │ ┌───────────────────┐ │     │     │ ┌───────────────────┐ │ │  │</span><br><span class="line">│   │   │ │ vector&lt;string&gt;    │ │     │     │ │ TopicPartition    │ │ │  │</span><br><span class="line">│   │   │ │ &#123;<span class="string">&quot;topic1&quot;</span>,<span class="string">&quot;topic2&quot;</span>&#125;│ │     │     │ │ (topic, partition)│ │ │  │</span><br><span class="line">│   │   │ └───────────────────┘ │     │     │ └───────────────────┘ │ │  │</span><br><span class="line">│   │   │                       │     │     │                       │ │  │</span><br><span class="line">│   │   │ ✓ 自动负载均衡       │     │     │ ✗ 无自动负载均衡     │ │  │</span><br><span class="line">│   │   │ ✓ 触发 RebalanceCb   │     │     │ ✗ 不触发 RebalanceCb │ │  │</span><br><span class="line">│   │   └───────────────────────┘     │     └───────────────────────┘ │  │</span><br><span class="line">│   │                                 │                               │  │</span><br><span class="line">│   └─────────────────────────────────┴───────────────────────────────┘  │</span><br><span class="line">│                                                                         │</span><br><span class="line">└───────────────────────────────────────────────────────────┬─────────────┘</span><br><span class="line">                                                            │</span><br><span class="line">                                                            ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         消费阶段（循环）                                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐    ┌───────────────────┐    ┌────────────────┐ │</span><br><span class="line">│   │    <span class="built_in">consume</span>()      │───→│    处理消息       │───→│   提交 offset  │ │</span><br><span class="line">│   │   拉取消息(阻塞)  │    │   业务逻辑处理    │    │  (可选手动)    │ │</span><br><span class="line">│   │                   │    │                   │    │ 用于确定下次读取的位置│ │</span><br><span class="line">│   │ ┌───────────────┐ │    │ ┌───────────────┐ │    │ ┌────────────┐ │ │</span><br><span class="line">│   │ │ KafkaConsumer │ │    │ │    Message    │ │    │ │<span class="built_in">commitSync</span>()│ │ │</span><br><span class="line">│   │ │  ::<span class="built_in">consume</span>()  │ │    │ │  (返回消息)   │ │    │ │   或       │ │ │</span><br><span class="line">│   │ └───────────────┘ │    │ └───────────────┘ │    │ │commitAsync│ │ │</span><br><span class="line">│   └───────────────────┘    └───────────────────┘    │ └────────────┘ │ │</span><br><span class="line">│            ▲                                        └───────┬────────┘ │</span><br><span class="line">│            │                                                │          │</span><br><span class="line">│            │         ┌──────────────────────────────────────┘          │</span><br><span class="line">│            │         │                                                 │</span><br><span class="line">│            │         ▼                                                 │</span><br><span class="line">│            │    ┌─────────────────────────────────────────────────┐   │</span><br><span class="line">│            │    │  消费过程中涉及的类：                             │   │</span><br><span class="line">│            │    │  ┌─────────┐  ┌───────────────┐  ┌───────────┐  │   │</span><br><span class="line">│            │    │  │ Message │  │TopicPartition │  │  Headers  │  │   │</span><br><span class="line">│            │    │  │ payload │  │ offset 管理   │  │ (消息头)  │  │   │</span><br><span class="line">│            │    │  │ key     │  └───────────────┘  └───────────┘  │   │</span><br><span class="line">│            │    │  │ offset  │                                    │   │</span><br><span class="line">│            │    │  └─────────┘                                    │   │</span><br><span class="line">│            │    └─────────────────────────────────────────────────┘   │</span><br><span class="line">│            │                                                           │</span><br><span class="line">│            └───────────────────────────────────────────────────────────┘</span><br><span class="line">│                                            (持续消费则循环)              │</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────┐  │</span><br><span class="line">│   │                    重平衡触发时                                   │  │</span><br><span class="line">│   │                                                                  │  │</span><br><span class="line">│   │   消费者加入/离开组 ───→ RebalanceCb 触发 ───→ 重新分配分区     │  │</span><br><span class="line">│   │                                                                  │  │</span><br><span class="line">│   │   ┌─────────────────────────────────────────────────────────┐   │  │</span><br><span class="line">│   │   │  ERR__ASSIGN_PARTITIONS  →  <span class="built_in">assign</span>() / incremental_assign│   │  │</span><br><span class="line">│   │   │  ERR__REVOKE_PARTITIONS  →  <span class="built_in">unassign</span>() / incremental_    │   │  │</span><br><span class="line">│   │   │                             <span class="built_in">unassign</span>()                   │   │  │</span><br><span class="line">│   │   └─────────────────────────────────────────────────────────┘   │  │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────────┘  │</span><br><span class="line">│                                                                         │</span><br><span class="line">└───────────────────────────────────────────────────────────────────────┬─┘</span><br><span class="line">                                                                        │</span><br><span class="line">                                                                        ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         清理阶段                                         │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                         │</span><br><span class="line">│   ┌───────────────────┐         ┌───────────────────┐                  │</span><br><span class="line">│   │     <span class="built_in">close</span>()       │────────→│ <span class="keyword">delete</span> consumer   │                  │</span><br><span class="line">│   │   关闭消费者      │         │                   │                  │</span><br><span class="line">│   │                   │         │ ┌───────────────┐ │                  │</span><br><span class="line">│   │ ┌───────────────┐ │         │ │ KafkaConsumer │ │                  │</span><br><span class="line">│   │ │ KafkaConsumer │ │         │ │   (销毁)      │ │                  │</span><br><span class="line">│   │ │   ::<span class="built_in">close</span>()   │ │         │ └───────────────┘ │                  │</span><br><span class="line">│   │ └───────────────┘ │         └───────────────────┘                  │</span><br><span class="line">│   │                   │                                                │</span><br><span class="line">│   │ • 提交最终offset  │                                                │</span><br><span class="line">│   │ • 离开消费者组    │                                                │</span><br><span class="line">│   │ • 触发重平衡      │                                                │</span><br><span class="line">│   └───────────────────┘                                                │</span><br><span class="line">│                                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-Conf类（配置类）"><a href="#2-Conf类（配置类）" class="headerlink" title="2.Conf类（配置类）"></a>2.Conf类（配置类）</h2><p>dKafka::Conf 是 librdkafka 中<strong>配置管理的核心类</strong>，用于统一管理 Kafka 客户端（生产者 &#x2F; 消费者）的<strong>全局配置</strong>、<strong>主题级配置</strong>，是创建生产者 &#x2F; 消费者实例的基础。<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116100012806.png"></p>
<h3 id="（1）Conf类的定义"><a href="#（1）Conf类的定义" class="headerlink" title="（1）Conf类的定义"></a>（1）Conf类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Conf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 配置类型</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ConfType</span> &#123;</span><br><span class="line">        CONF_GLOBAL, <span class="comment">// 全局配置</span></span><br><span class="line">        CONF_TOPIC   <span class="comment">// Topic配置</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set() 返回码</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ConfResult</span> &#123;</span><br><span class="line">        CONF_UNKNOWN = <span class="number">-2</span>, <span class="comment">// 未知属性</span></span><br><span class="line">        CONF_INVALID = <span class="number">-1</span>, <span class="comment">// 无效值</span></span><br><span class="line">        CONF_OK      = <span class="number">0</span>   <span class="comment">// 成功</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建配置对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Conf *<span class="title">create</span><span class="params">(ConfType type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Conf</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * @brief 设置字符串类型的配置属性</span></span><br><span class="line"><span class="comment">       * @param name 配置属性名称</span></span><br><span class="line"><span class="comment">       * @param value 配置值</span></span><br><span class="line"><span class="comment">       * @param errstr 错误时返回的错误描述</span></span><br><span class="line"><span class="comment">       * @return 配置结果码</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> std::string &amp;value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认 Topic 配置 (name = &quot;default_topic_conf&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> Conf *topic_conf, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===================================== 设置回调函数配置 =================================================</span></span><br><span class="line">    <span class="comment">/*    1.参数：</span></span><br><span class="line"><span class="comment">            - name：配置名（固定）</span></span><br><span class="line"><span class="comment">                - 特征很明显，如DeliveryReportCb *dr_cb ——&gt; name：&quot;dr_cb&quot;</span></span><br><span class="line"><span class="comment">            - xxxCb：回调对象（成员函数：回调函数）</span></span><br><span class="line"><span class="comment">            - errstr：错误时返回的错误描述</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.返回值：</span></span><br><span class="line"><span class="comment">            - ConfResult：配置结果码（见上）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  1.DeliveryReportCb - 消息投递报告回调（⭐⭐⭐⭐⭐ 极高（生产者常用））</span></span><br><span class="line"><span class="comment">            - 功能：生产者发送消息后，通知消息是否成功投递到 Broker </span></span><br><span class="line"><span class="comment">            - 使用场景：确认消息发送成功/失败，处理发送失败的重试逻辑*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, DeliveryReportCb *dr_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2.EventCb - 事件回调（⭐⭐⭐⭐⭐ 极高（生产者/消费者都常用））</span></span><br><span class="line"><span class="comment">            - 功能：接收 Kafka 客户端的各种事件（错误、统计信息、日志、限流等）</span></span><br><span class="line"><span class="comment">            - 使用场景：监控连接状态、记录错误日志、获取统计数据*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, EventCb *event_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*    3.RebalanceCb - 消费者重平衡回调</span></span><br><span class="line"><span class="comment">            - 功能：消费者组发生分区重新分配时触发（成员加入/离开）（⭐⭐⭐⭐ 高（消费者组常用））</span></span><br><span class="line"><span class="comment">            - 使用场景：在重平衡前保存 offset、释放资源；重平衡后初始化状态*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, RebalanceCb *rebalance_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    4.OffsetCommitCb - 偏移量提交回调（⭐⭐⭐ 中等（需要精确控制 offset 时使用））</span></span><br><span class="line"><span class="comment">            - 功能：offset 提交完成后的通知（成功或失败）</span></span><br><span class="line"><span class="comment">            - 使用场景：确认 offset 提交状态，处理提交失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, OffsetCommitCb *cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    5.PartitionerCb - 自定义分区器回调（⭐⭐⭐ 中等（默认分区器够用时不需要））</span></span><br><span class="line"><span class="comment">            - 功能：自定义消息路由到哪个分区的逻辑</span></span><br><span class="line"><span class="comment">            - 使用场景：需要特殊分区策略（如按业务 ID 分区、地理位置分区）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, PartitionerCb *partitioner_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*    6.ConsumeCb - 消息消费回调（⭐⭐⭐ 中等（通常直接用 poll() 更常见））</span></span><br><span class="line"><span class="comment">        - 功能：消费到消息时的回调处理</span></span><br><span class="line"><span class="comment">        - 使用场景：回调式消费模式（替代 poll 循环）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, ConsumeCb *consume_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面使用频率较低，就不详细注释了</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, OAuthBearerTokenRefreshCb *cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">//令牌刷新回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, SslCertificateVerifyCb *cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">//SSL 证书验证回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, SocketCb *socket_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">//Socket 创建回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, OpenCb *open_cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">//文件打开回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set</span><span class="params">(<span class="type">const</span> std::string &amp;name, PartitionerKeyPointerCb *cb, std::string &amp;errstr)</span> </span>= <span class="number">0</span>; <span class="comment">// 键指针分区器回调</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 SSL 证书/密钥</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set_ssl_cert</span><span class="params">(RdKafka::CertificateType cert_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RdKafka::CertificateEncoding cert_enc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> <span class="type">void</span> *buffer, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询字符串配置值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(<span class="type">const</span> std::string &amp;name, std::string &amp;value)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 获取回调函数 ==========</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(DeliveryReportCb *&amp;dr_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(OAuthBearerTokenRefreshCb *&amp;cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(EventCb *&amp;event_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(PartitionerCb *&amp;partitioner_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(PartitionerKeyPointerCb *&amp;cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(SocketCb *&amp;socket_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(OpenCb *&amp;open_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(RebalanceCb *&amp;rebalance_cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(OffsetCommitCb *&amp;cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">get</span><span class="params">(SslCertificateVerifyCb *&amp;cb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出所有配置 (name, value) 列表</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::list&lt;std::string&gt; *<span class="title">dump</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取底层 C 句柄（不推荐直接使用）</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">struct</span> <span class="title class_">rd_kafka_conf_s</span> *<span class="built_in">c_ptr_global</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">struct</span> <span class="title class_">rd_kafka_topic_conf_s</span> *<span class="built_in">c_ptr_topic</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 SSL 引擎回调数据</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">set_engine_callback_data</span><span class="params">(<span class="type">void</span> *value, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 SASL 专用队列</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConfResult <span class="title">enable_sasl_queue</span><span class="params">(<span class="type">bool</span> enable, std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（2）Conf类的使用"><a href="#（2）Conf类的使用" class="headerlink" title="（2）Conf类的使用"></a>（2）Conf类的使用</h3><h4 id="创建-RdKafka-Conf"><a href="#创建-RdKafka-Conf" class="headerlink" title="&lt;1&gt;创建 RdKafka::Conf"></a>&lt;1&gt;创建 RdKafka::Conf</h4><ul>
<li>RdKafka::Conf 的创建非常简单，使用<strong>静态工厂方法 create()</strong></li>
<li><strong>推荐</strong>：使用“智能指针”自动管理内存，避免手动 delete</li>
</ul>
<h5 id="1）使用智能指针直接创建"><a href="#1）使用智能指针直接创建" class="headerlink" title="1）使用智能指针直接创建"></a>1）使用智能指针直接创建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ==================== 1. 使用 unique_ptr 创建全局配置 ====================</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">global_conf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        RdKafka::Conf::create(RdKafka::Conf::CONF_GLOBAL)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!global_conf) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建全局配置失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;全局配置创建成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== 2. 使用 unique_ptr 创建 Topic 配置 ====================</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">topic_conf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        RdKafka::Conf::create(RdKafka::Conf::CONF_TOPIC)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!topic_conf) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建 Topic 配置失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Topic 配置创建成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）封装为工厂函数"><a href="#2）封装为工厂函数" class="headerlink" title="2）封装为工厂函数"></a>2）封装为工厂函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数：创建全局配置</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">createGlobalConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;RdKafka::Conf&gt;(</span><br><span class="line">        RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数：创建 Topic 配置</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">createTopicConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;RdKafka::Conf&gt;(</span><br><span class="line">        RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_TOPIC)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> global_conf = <span class="built_in">createGlobalConf</span>();</span><br><span class="line">    <span class="keyword">auto</span> topic_conf = <span class="built_in">createTopicConf</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!global_conf || !topic_conf) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;配置创建失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;配置创建并设置成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3）不使用“智能指针”（不推荐！）"><a href="#3）不使用“智能指针”（不推荐！）" class="headerlink" title="3）不使用“智能指针”（不推荐！）"></a>3）不使用“智能指针”（不推荐！）</h5><p>在“RdKafka::Conf类的结构”部分可知：create返回 “裸指针”，所以需要“<strong>手动释放资源</strong>”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ==================== 1. 创建配置（裸指针） ====================</span></span><br><span class="line">    RdKafka::Conf *global_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    RdKafka::Conf *topic_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_TOPIC);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须检查是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (!global_conf || !topic_conf) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;配置创建失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// ⚠️ 问题1：如果一个成功一个失败，需要处理部分释放</span></span><br><span class="line">        <span class="keyword">delete</span> global_conf;  <span class="comment">// 可能是 nullptr，但 delete nullptr 是安全的</span></span><br><span class="line">        <span class="keyword">delete</span> topic_conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设置-RdKafka-Conf"><a href="#设置-RdKafka-Conf" class="headerlink" title="&lt;2&gt;设置 RdKafka::Conf"></a>&lt;2&gt;设置 RdKafka::Conf</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer 最小配置</span></span><br><span class="line">RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;dr_cb&quot;</span>, &amp;delivery_cb, errstr);  <span class="comment">// 投递回调</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer 最小配置</span></span><br><span class="line">RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;my-consumer-group&quot;</span>, errstr);</span><br><span class="line">conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>, errstr);</span><br></pre></td></tr></table></figure>
<p><strong>实战使用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Kafka配置构建器（Builder模式）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KafkaConfBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">KafkaConfBuilder</span><span class="params">(RdKafka::Conf::ConfType type = RdKafka::Conf::CONF_GLOBAL)</span> </span></span><br><span class="line"><span class="function">        : conf_(RdKafka::Conf::create(type)) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!conf_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;RdKafka::Conf create failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">KafkaConfBuilder</span>(<span class="type">const</span> KafkaConfBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    KafkaConfBuilder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> KafkaConfBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许移动</span></span><br><span class="line">    <span class="built_in">KafkaConfBuilder</span>(KafkaConfBuilder&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    KafkaConfBuilder&amp; <span class="keyword">operator</span>=(KafkaConfBuilder&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置字符串类型配置项</span></span><br><span class="line"><span class="comment">     * @param key 配置键名</span></span><br><span class="line"><span class="comment">     * @param value 配置值</span></span><br><span class="line"><span class="comment">     * @return 当前Builder引用（支持链式调用）</span></span><br><span class="line"><span class="comment">     * @throws std::runtime_error 配置失败时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">KafkaConfBuilder&amp; <span class="title">set</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        std::string errstr;</span><br><span class="line">        <span class="keyword">if</span> (conf_-&gt;<span class="built_in">set</span>(key, value, errstr) != RdKafka::Conf::CONF_OK) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Kafka Conf [&quot;</span> + key + <span class="string">&quot;] error: &quot;</span> + errstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置回调对象</span></span><br><span class="line"><span class="comment">     * @tparam T 回调类型（如 RdKafka::DeliveryReportCb*）</span></span><br><span class="line"><span class="comment">     * @param key 配置键名（如 &quot;dr_cb&quot;）</span></span><br><span class="line"><span class="comment">     * @param cb 回调对象指针</span></span><br><span class="line"><span class="comment">     * @return 当前Builder引用</span></span><br><span class="line"><span class="comment">     * @throws std::runtime_error 配置失败时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    KafkaConfBuilder&amp; <span class="title">setCallback</span><span class="params">(<span class="type">const</span> std::string&amp; key, T* cb)</span> </span>&#123;</span><br><span class="line">        std::string errstr;</span><br><span class="line">        <span class="keyword">if</span> (conf_-&gt;<span class="built_in">set</span>(key, cb, errstr) != RdKafka::Conf::CONF_OK) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Kafka Conf [&quot;</span> + key + <span class="string">&quot;] error: &quot;</span> + errstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构建并返回配置对象</span></span><br><span class="line"><span class="comment">     * @return 配置对象的unique_ptr（所有权转移）</span></span><br><span class="line"><span class="comment">     * @note 调用后当前Builder失效，不可再使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;RdKafka::Conf&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(conf_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检查Builder是否有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conf_ != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;RdKafka::Conf&gt; conf_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 使用示例 ====================</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> producer_conf = <span class="built_in">KafkaConfBuilder</span>()</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;my-producer&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;batch.size&quot;</span>, <span class="string">&quot;16384&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;linger.ms&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">            .<span class="built_in">build</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> consumer_conf = <span class="built_in">KafkaConfBuilder</span>()</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;my-consumer-group&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;my-consumer&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line">            .<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>)</span><br><span class="line">            .<span class="built_in">build</span>();</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;配置创建成功！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>“回调类”参考</strong>：<a href="#cb">回调类</a></p>
<h5 id="1）生产者常用配置"><a href="#1）生产者常用配置" class="headerlink" title="1）生产者常用配置"></a>1）生产者常用配置</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116161810771.png"></p>
<h5 id="2）消费者常用配置"><a href="#2）消费者常用配置" class="headerlink" title="2）消费者常用配置"></a>2）消费者常用配置</h5><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116161420955.png"></p>
<p>想了解更多配置项，<strong>参考</strong>：<a href="#config">附录1：常用配置项</a></p>
<h2 id="3-TopicPartition类（主题分区类）"><a href="#3-TopicPartition类（主题分区类）" class="headerlink" title="3.TopicPartition类（主题分区类）"></a>3.TopicPartition类（主题分区类）</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用"><a href="#作用" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>封装**&lt;topic, partition, offset&gt;**三元组的核心类</li>
<li>客户端与 Kafka 集群交互「<strong>分区级操作</strong>」的基础载体</li>
<li>所有和「<strong>指定分区、控制消费位置、提交偏移量</strong>」相关的操作都依赖该类</li>
</ul>
<h4 id="核心定位"><a href="#核心定位" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>元数据载体</strong>：<ul>
<li>本质是存储「主题名（string）、分区号（int）、偏移量（int64_t）」的轻量级类，仅记录 “要操作的目标分区 + 位置”，<strong>不包含任何集群交互逻辑</strong>；</li>
</ul>
</li>
<li><strong>操作桥梁</strong>：<ul>
<li>作为 assign()（手动分配分区）、commitSync()&#x2F;commitAsync()（提交 offset）、seek()（重置消费位置）等核心 API 的入参 &#x2F; 返回值，是<strong>客户端向 Kafka 传递 “分区操作指令” 的标准化格式</strong>；</li>
</ul>
</li>
<li><strong>无状态特性</strong>：<ul>
<li>该类对象仅存储静态元数据，不关联 Kafka 连接状态，<strong>修改对象属性（如 offset）仅影响本地，需调用 API 才能同步到集群</strong>。</li>
</ul>
</li>
</ul>
<h3 id="（2）TopicPartition类的定义"><a href="#（2）TopicPartition类的定义" class="headerlink" title="（2）TopicPartition类的定义"></a>（2）TopicPartition类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> TopicPartition &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//==================== 高频使用（必用） ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建 topic+partition 关联对象（无 offset）</span></span><br><span class="line"><span class="comment">     * 需使用 delete 释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> TopicPartition *<span class="title">create</span><span class="params">(<span class="type">const</span> std::string &amp;topic, <span class="type">int</span> partition)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建 topic+partition+offset 关联对象</span></span><br><span class="line"><span class="comment">     * 需使用 delete 释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> TopicPartition *<span class="title">create</span><span class="params">(<span class="type">const</span> std::string &amp;topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int64_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string &amp;<span class="title">topic</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;    <span class="comment">// 获取 topic 名</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">partition</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;               <span class="comment">// 获取分区 ID</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;              <span class="comment">// 获取 offset</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================== 中频使用（常用） ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions)</span></span>;  <span class="comment">// 批量销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">err</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;               <span class="comment">// 获取错误码</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_offset</span><span class="params">(<span class="type">int64_t</span> offset)</span> </span>= <span class="number">0</span>;     <span class="comment">// 设置 offset</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TopicPartition</span>() = <span class="number">0</span>;                   <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================== 低频使用（高级场景） ====================</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">get_leader_epoch</span><span class="params">()</span> </span>= <span class="number">0</span>;          <span class="comment">// 获取 leader epoch</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_leader_epoch</span><span class="params">(<span class="type">int32_t</span> leader_epoch)</span> </span>= <span class="number">0</span>;  <span class="comment">//设置 leader epoch</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================== 极少使用（特殊场景） ====================</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">get_metadata</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 获取分区元数据</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_metadata</span><span class="params">(std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; &amp;metadata)</span> </span>= <span class="number">0</span>; <span class="comment">// 设置分区元数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊 offset 常量（按使用频率）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> OFFSET_STORED    = <span class="number">-1000</span>; <span class="comment">// ★★★ 最常用：从上次提交位置继续</span></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> OFFSET_END       = <span class="number">-1</span>;    <span class="comment">// ★★  常用：只消费新消息</span></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> OFFSET_BEGINNING = <span class="number">-2</span>;    <span class="comment">// ★★  常用：从头消费所有消息</span></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> OFFSET_INVALID   = <span class="number">-1001</span>; <span class="comment">// ★   少用：表示无效状态</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116211851723.png"></p>
<h3 id="（3）典型使用场景（结合核心-API）"><a href="#（3）典型使用场景（结合核心-API）" class="headerlink" title="（3）典型使用场景（结合核心 API）"></a>（3）典型使用场景（结合核心 API）</h3><h4 id="手动分配分区"><a href="#手动分配分区" class="headerlink" title="&lt;1&gt; 手动分配分区"></a>&lt;1&gt; 手动分配分区</h4><p>无需指定偏移量，仅关联「主题 + 分区」，依赖 auto.offset.reset 配置确定消费位置：    </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">1</span>));</span><br><span class="line">consumer-&gt;<span class="built_in">assign</span>(partitions); <span class="comment">// 仅指定要消费的分区</span></span><br></pre></td></tr></table></figure>

<h4 id="指定偏移量消费"><a href="#指定偏移量消费" class="headerlink" title="&lt;2&gt;指定偏移量消费"></a>&lt;2&gt;指定偏移量消费</h4><p>创建时指定偏移量，重置消费位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 topic1-0 分区的第 100 条消息开始消费</span></span><br><span class="line">RdKafka::TopicPartition *tp = RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">consumer-&gt;<span class="built_in">seek</span>(tp, <span class="number">5000</span>); <span class="comment">// 5000ms 超时时间</span></span><br><span class="line"><span class="keyword">delete</span> tp;</span><br></pre></td></tr></table></figure>

<h4 id="手动提交指定-offset"><a href="#手动提交指定-offset" class="headerlink" title="&lt;3&gt;手动提交指定 offset"></a>&lt;3&gt;手动提交指定 offset</h4><p>修改对象偏移量后提交，实现精准的 offset 管理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">partitions[<span class="number">0</span>]-&gt;<span class="built_in">set_offset</span>(<span class="number">200</span>); <span class="comment">// 提交 topic1-0 的 offset=200</span></span><br><span class="line">consumer-&gt;<span class="built_in">commitSync</span>(partitions); <span class="comment">// 同步提交</span></span><br></pre></td></tr></table></figure>

<h4 id="批量操作所有分区"><a href="#批量操作所有分区" class="headerlink" title="&lt;4&gt;批量操作所有分区"></a>&lt;4&gt;批量操作所有分区</h4><p>使用 partition&#x3D;-1 代表主题的所有分区：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交 topic1 所有分区的 offset=300</span></span><br><span class="line">RdKafka::TopicPartition *tp = RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">-1</span>, <span class="number">300</span>);</span><br><span class="line">consumer-&gt;<span class="built_in">commitSync</span>(&#123;tp&#125;);</span><br><span class="line"><span class="keyword">delete</span> tp;</span><br></pre></td></tr></table></figure>

<h4 id="destroy-的使用示例"><a href="#destroy-的使用示例" class="headerlink" title="&lt;5&gt;destroy() 的使用示例"></a>&lt;5&gt;destroy() 的使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量创建</span></span><br><span class="line">std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">1</span>));</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic2&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 使用完毕后 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：手动逐个删除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : partitions) </span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">partitions.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：使用 destroy() 一次性销毁并清空（推荐）</span></span><br><span class="line">RdKafka::TopicPartition::<span class="built_in">destroy</span>(partitions);  <span class="comment">// 删除所有元素 + 清空 vector</span></span><br><span class="line"><span class="comment">// 此时 partitions.size() == 0，且原指针已被 delete</span></span><br><span class="line"><span class="comment">// ❌ 不能再访问 partitions 中的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）内存管理（核心注意事项）"><a href="#（4）内存管理（核心注意事项）" class="headerlink" title="（4）内存管理（核心注意事项）"></a>（4）内存管理（核心注意事项）</h3><p><strong>必须释放资源</strong>：</p>
<ul>
<li>create 方法返回的是动态分配的裸指针，未释放会导致内存泄漏，推荐两种方式：<ul>
<li>手动 delete（基础方式）</li>
<li>封装智能指针（生产环境推荐）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动 delete</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : partitions) &#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>; <span class="comment">// 避免野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用智能指针</span></span><br><span class="line"><span class="keyword">using</span> TopicPartitionPtr = std::unique_ptr&lt;RdKafka::TopicPartition&gt;;</span><br><span class="line"><span class="function">TopicPartitionPtr <span class="title">tp</span><span class="params">(RdKafka::TopicPartition::create(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// 自动释放，无需手动 delete</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）核心易错点与最佳实践"><a href="#（5）核心易错点与最佳实践" class="headerlink" title="（5）核心易错点与最佳实践"></a>（5）核心易错点与最佳实践</h3><h4 id="易错点"><a href="#易错点" class="headerlink" title="&lt;1&gt;易错点"></a>&lt;1&gt;易错点</h4><ul>
<li><strong>混淆「客户端对象创建」和「集群物理创建」</strong>：<ul>
<li>TopicPartition::create 仅创建<strong>本地对象</strong>，不会在 Kafka 集群创建主题 &#x2F; 分区；</li>
</ul>
</li>
<li><strong>忽略内存释放</strong>：<ul>
<li>生产环境需严格管理 TopicPartition 指针，<strong>建议封装智能指针</strong>；</li>
</ul>
</li>
<li><strong>偏移量设置后未调用 API</strong>：<ul>
<li><strong>修改 offset 仅改本地值</strong>，需调用 commitSync()&#x2F;seek() 等 API 才能同步到集群；</li>
</ul>
</li>
<li><strong>分区号越界</strong>：<ul>
<li>指定的分区号超出主题实际分区数，会导致 assign()&#x2F;commitSync() 返回 ERR_UNKNOWN_PARTITION 错误。</li>
</ul>
</li>
</ul>
<h2 id="4-Headers类（消息头类）"><a href="#4-Headers类（消息头类）" class="headerlink" title="4.Headers类（消息头类）"></a>4.Headers类（消息头类）</h2><h3 id="（1）概述-1"><a href="#（1）概述-1" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Headers 是 librdkafka 中<strong>封装 Kafka 消息头（Header）的核心类</strong><ul>
<li>用于为消息附<strong>加键值对</strong>形式的元数据（如业务标识、追踪 ID、消息类型等）</li>
<li>是消息内容之外的 “<strong>辅助信息载体</strong>”，不影响消息的分区路由，仅用于业务侧的消息溯源、过滤、扩展。</li>
</ul>
</li>
</ul>
<h4 id="核心定位-1"><a href="#核心定位-1" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>元数据扩展</strong>：<ul>
<li><strong>弥补 Kafka 消息 Key&#x2F;Value 仅能存储业务数据的不足</strong></li>
<li>支持附加多组键值对元数据（如 trace-id: 123456、msg-type: order）；</li>
</ul>
</li>
<li><strong>可写 &#x2F; 只读特性</strong>：<ul>
<li>生产者侧可创建并写入 Headers</li>
<li>消费者侧仅能读取 Headers（<strong>消息一旦发送，Headers 不可修改</strong>）；</li>
</ul>
</li>
<li><strong>轻量级设计</strong>：<ul>
<li>Headers 存储的是字符串键值对，<strong>建议仅存放轻量元数据</strong>（避免增大消息体积）。</li>
</ul>
</li>
<li><strong>跨系统兼容</strong>：<ul>
<li>消息头是 Kafka 协议标准特性，可与其他 Kafka 客户端（如 Java、Python）互通，便于多语言系统协作；</li>
</ul>
</li>
</ul>
<h3 id="（2）Headers类的定义"><a href="#（2）Headers类的定义" class="headerlink" title="（2）Headers类的定义"></a>（2）Headers类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Headers &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Headers</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 单个 Header 对象（键值对 + 错误码）</span></span><br><span class="line"><span class="comment">     * @remark 不支持动态分配（new）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Header</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @brief 构造 Header</span></span><br><span class="line"><span class="comment">         * @param key    Header 的键（字符串）</span></span><br><span class="line"><span class="comment">         * @param value  Header 的值（二进制，可为 NULL）</span></span><br><span class="line"><span class="comment">         * @param value_size  值的字节长度</span></span><br><span class="line"><span class="comment">         * @remark key 和 value 会被复制</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">Header</span>(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> value_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @brief 构造 Header（带错误码）</span></span><br><span class="line"><span class="comment">         * @param key    Header 的键</span></span><br><span class="line"><span class="comment">         * @param value  Header 的值</span></span><br><span class="line"><span class="comment">         * @param value_size  值的字节长度</span></span><br><span class="line"><span class="comment">         * @param err    错误码（用于 get_last() 内部构造失败结果）</span></span><br><span class="line"><span class="comment">         * @remark 若 err != ERR_NO_ERROR，value 和 value_size 字段未定义</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">Header</span>(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> value_size, </span><br><span class="line">               <span class="type">const</span> RdKafka::ErrorCode err);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Header</span>(<span class="type">const</span> Header &amp;other);              <span class="comment">// 拷贝构造</span></span><br><span class="line">        Header &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Header &amp;other);   <span class="comment">// 赋值运算符</span></span><br><span class="line">        ~<span class="built_in">Header</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">key</span><span class="params">()</span> <span class="type">const</span></span>;                  <span class="comment">// 获取键名</span></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">void</span> *<span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 获取二进制值（可能为 NULL）</span></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">value_string</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">// 获取值并转为 C 字符串（可能为 NULL）</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">value_size</span><span class="params">()</span> <span class="type">const</span></span>;                <span class="comment">// 获取值的字节长度</span></span><br><span class="line">        <span class="function">RdKafka::ErrorCode <span class="title">err</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// 获取错误码（通常为 ERR_NO_ERROR）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">char</span> *<span class="title">copy_value</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> value_size)</span></span>;</span><br><span class="line">        std::string key_;</span><br><span class="line">        RdKafka::ErrorCode err_;</span><br><span class="line">        <span class="type">char</span> *value_;</span><br><span class="line">        <span class="type">size_t</span> value_size_;</span><br><span class="line">        <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;               <span class="comment">// 禁止动态分配</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建空的 Headers 对象</span></span><br><span class="line"><span class="comment">     * @returns 空 Headers 列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Headers *<span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从 std::vector 创建 Headers 对象</span></span><br><span class="line"><span class="comment">     * @param headers  Header 向量（会被复制，非引用）</span></span><br><span class="line"><span class="comment">     * @returns Headers 列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Headers *<span class="title">create</span><span class="params">(<span class="type">const</span> std::vector&lt;Header&gt; &amp;headers)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加 Header（二进制值）</span></span><br><span class="line"><span class="comment">     * @param key    键名</span></span><br><span class="line"><span class="comment">     * @param value  二进制值（可为 NULL）</span></span><br><span class="line"><span class="comment">     * @param value_size  值的字节长度</span></span><br><span class="line"><span class="comment">     * @returns 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">add</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> value_size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加 Header（字符串值，便捷方法）</span></span><br><span class="line"><span class="comment">     * @param key    键名</span></span><br><span class="line"><span class="comment">     * @param value  字符串值</span></span><br><span class="line"><span class="comment">     * @returns 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">add</span><span class="params">(<span class="type">const</span> std::string &amp;key, <span class="type">const</span> std::string &amp;value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加 Header（复制已有 Header 对象）</span></span><br><span class="line"><span class="comment">     * @param header  要复制的 Header</span></span><br><span class="line"><span class="comment">     * @returns 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">add</span><span class="params">(<span class="type">const</span> Header &amp;header)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 移除指定 key 的所有 Header</span></span><br><span class="line"><span class="comment">     * @param key  要移除的键名</span></span><br><span class="line"><span class="comment">     * @returns 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">remove</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取指定 key 的所有 Header</span></span><br><span class="line"><span class="comment">     * @param key  键名</span></span><br><span class="line"><span class="comment">     * @returns 包含所有匹配 Header 的向量（支持重复 key）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;Header&gt; <span class="title">get</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取指定 key 的最后一个 Header</span></span><br><span class="line"><span class="comment">     * @param key  键名</span></span><br><span class="line"><span class="comment">     * @returns 找到则返回 Header，未找到则返回 err=ERR__NOENT 的 Header</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Header <span class="title">get_last</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取所有 Header</span></span><br><span class="line"><span class="comment">     * @returns 包含所有 Header 的向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;Header&gt; <span class="title">get_all</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取 Header 数量</span></span><br><span class="line"><span class="comment">     * @returns Header 个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）使用示例"><a href="#（3）使用示例" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><h4 id="生产者写入-Headers-示例"><a href="#生产者写入-Headers-示例" class="headerlink" title="&lt;1&gt;生产者写入 Headers 示例"></a>&lt;1&gt;生产者写入 Headers 示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 Headers 对象</span></span><br><span class="line">RdKafka::Headers *headers = RdKafka::Headers::<span class="built_in">create</span>();</span><br><span class="line"><span class="keyword">if</span> (!headers) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;创建 Headers 失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加键值对（支持多组）</span></span><br><span class="line">headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;trace-id&quot;</span>, <span class="string">&quot;trace-789012&quot;</span>);              <span class="comment">// 字符串重载（推荐）</span></span><br><span class="line">headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;msg-type&quot;</span>, <span class="string">&quot;payment&quot;</span>);                   <span class="comment">// 字符串重载</span></span><br><span class="line">headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;timestamp&quot;</span>, std::<span class="built_in">to_string</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>)));  <span class="comment">// 字符串重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用二进制形式</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* binary_data = <span class="string">&quot;binary-value&quot;</span>;</span><br><span class="line">headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;binary-key&quot;</span>, binary_data, <span class="built_in">strlen</span>(binary_data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 发送消息时附加 Headers</span></span><br><span class="line">std::string payload = <span class="string">&quot;order-payload&quot;</span>;</span><br><span class="line">std::string key = <span class="string">&quot;order-key&quot;</span>;</span><br><span class="line">RdKafka::ErrorCode err = producer-&gt;<span class="built_in">produce</span>(</span><br><span class="line">    <span class="string">&quot;my-topic&quot;</span>,</span><br><span class="line">    RdKafka::Topic::PARTITION_UA,</span><br><span class="line">    RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">    (<span class="type">void</span>*)payload.<span class="built_in">data</span>(), <span class="number">13</span>,</span><br><span class="line">    key.<span class="built_in">data</span>(), <span class="number">9</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    headers,    <span class="comment">// 附加消息头</span></span><br><span class="line">    <span class="literal">nullptr</span>     <span class="comment">// opaque</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;发送失败：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> headers;  <span class="comment">// ⚠️ produce() 失败时需手动释放</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// ⚠️ produce() 成功后，headers 所有权转移给 librdkafka，无需手动 delete</span></span><br></pre></td></tr></table></figure>

<h4 id="消费者读取-Headers-示例"><a href="#消费者读取-Headers-示例" class="headerlink" title="&lt;2&gt;消费者读取 Headers 示例"></a>&lt;2&gt;消费者读取 Headers 示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费消息并读取 Headers</span></span><br><span class="line">RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (!msg || msg-&gt;<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">delete</span> msg;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取消息的 Headers 对象（无 Headers 则返回 nullptr）</span></span><br><span class="line">RdKafka::Headers *headers = msg-&gt;<span class="built_in">headers</span>();</span><br><span class="line"><span class="keyword">if</span> (headers) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;消息头数量：&quot;</span> &lt;&lt; headers-&gt;<span class="built_in">size</span>() &lt;&lt; std::endl;  <span class="comment">// ✅ 用 size()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 读取指定 key 的所有值（支持重复 key）</span></span><br><span class="line">    std::vector&lt;RdKafka::Headers::Header&gt; trace_headers = headers-&gt;<span class="built_in">get</span>(<span class="string">&quot;trace-id&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; h : trace_headers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h.<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;trace-id：&quot;</span> &lt;&lt; h.<span class="built_in">value_string</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 读取指定 key 的最后一个值</span></span><br><span class="line">    RdKafka::Headers::Header last_trace = headers-&gt;<span class="built_in">get_last</span>(<span class="string">&quot;trace-id&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (last_trace.<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个 trace-id：&quot;</span> &lt;&lt; last_trace.<span class="built_in">value_string</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到 trace-id&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 遍历所有 Headers</span></span><br><span class="line">    std::vector&lt;RdKafka::Headers::Header&gt; all_headers = headers-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; all_headers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; h = all_headers[i];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Header[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]：&quot;</span> &lt;&lt; h.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (h.<span class="built_in">value</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; h.<span class="built_in">value_string</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;(null)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;该消息无消息头&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> msg;</span><br></pre></td></tr></table></figure>

<h3 id="（4）核心注意事项"><a href="#（4）核心注意事项" class="headerlink" title="（4）核心注意事项"></a>（4）核心注意事项</h3><ul>
<li><strong>内存管理</strong>：<ul>
<li><strong>生产者侧</strong>：create() 创建的 Headers<ul>
<li>若 produce() <strong>成功</strong>：则所有权转移给 librdkafka，<strong>无需手动释放</strong>；</li>
<li>若 produce() <strong>失败</strong>：则<strong>需手动 delete</strong>；</li>
</ul>
</li>
<li><strong>消费者</strong>侧从 msg-&gt;headers() 获取的 Headers 由 Message 对象管理<ul>
<li><strong>无需手动释放</strong>（释放 Message 时自动释放）；</li>
</ul>
</li>
</ul>
</li>
<li><strong>空值处理</strong>：<ul>
<li>Header 的 Value 可以为空（value&#x3D;nullptr，value_len&#x3D;0），需在读取时判断 val 是否为 nullptr；</li>
</ul>
</li>
<li><strong>get_last() 错误处理</strong>：<ul>
<li>未找到时返回 err&#x3D;ERR__NOENT 的 Header，需检查 h.err() 后再使用 value()；</li>
</ul>
</li>
<li><strong>性能影响</strong>：<ul>
<li>Headers 会增加消息体积，建议单条消息的 Headers 总大小不超过 1KB，避免影响吞吐量。</li>
</ul>
</li>
</ul>
<h2 id="5-Handle类（句柄基类）"><a href="#5-Handle类（句柄基类）" class="headerlink" title="5.Handle类（句柄基类）"></a>5.Handle类（句柄基类）</h2><h3 id="（1）概述-2"><a href="#（1）概述-2" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Handle 是 librdkafka 中<strong>生产者和消费者客户端</strong>（Producer &#x2F; Consumer &#x2F; KafkaConsumer）<strong>的抽象基类</strong><ul>
<li><strong>定义了客户端的通用能力</strong>（事件轮询（poll）、元数据&#x2F;偏移量查询、流控（pause&#x2F;resume）、集群信息获取等），是整个 librdkafka 客户端的 “基础骨架”</li>
<li><strong>生产者和消费者客户端</strong>（如 Producer、Consumer、KafkaConsumer）均继承自 Handle，因此<strong>具备统一的基础行为</strong>。</li>
</ul>
</li>
</ul>
<h4 id="核心定位-2"><a href="#核心定位-2" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>抽象通用能力</strong>：<ul>
<li>提取生产者、消费者的共性操作（如配置获取、错误码转换、资源销毁），避免代码冗余；</li>
</ul>
</li>
<li><strong>生命周期管理</strong>：<ul>
<li>定义客户端的创建 &#x2F; 销毁规范，统一管理与 Kafka 集群的连接资源；</li>
</ul>
</li>
<li><strong>状态与配置统一</strong>：<ul>
<li>提供全局的配置查询、错误处理、日志相关接口，保证不同客户端的使用体验一致；</li>
</ul>
</li>
<li><strong>纯抽象类特性</strong>：<ul>
<li>Handle 包含纯虚函数，无法直接实例化，仅能通过子类（Producer&#x2F;Consumer&#x2F;KafkaConsumer）使用其接口。</li>
</ul>
</li>
</ul>
<h3 id="（2）Handle-类的定义"><a href="#（2）Handle-类的定义" class="headerlink" title="（2）Handle 类的定义"></a>（2）Handle 类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Handle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handle</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第一梯队】几乎每个应用都会用到</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 轮询事件</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间（毫秒）</span></span><br><span class="line"><span class="comment">         - 0：非阻塞，立即返回（处理已就绪的事件）</span></span><br><span class="line"><span class="comment">         - 大于0：最多等待 timeout_ms 毫秒，有事件则提前返回 （推荐：100 ~ 1000）</span></span><br><span class="line"><span class="comment">         - -1：无限阻塞，直到有事件发生</span></span><br><span class="line"><span class="comment">     * @returns 处理的事件数量</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 触发已注册的回调函数（如 DeliveryCb、EventCb）</span></span><br><span class="line"><span class="comment">         - 1. 检查内部事件队列</span></span><br><span class="line"><span class="comment">         - 2. 如果有待处理事件 → 触发对应回调 → 立即返回</span></span><br><span class="line"><span class="comment">         - 3. 如果没有事件 → 等待最多 timeout 毫秒</span></span><br><span class="line"><span class="comment">         - 4. 返回本次处理的事件数量</span></span><br><span class="line"><span class="comment">     * @warning 禁止在 KafkaConsumer 中使用，应使用 consume() 代替</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取客户端名称</span></span><br><span class="line"><span class="comment">     * @returns 客户端名称字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取待发送/待确认的消息队列长度</span></span><br><span class="line"><span class="comment">     * @returns 队列中的消息数量</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 常用于优雅关闭时等待所有消息发送完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">outq_len</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第二梯队】元数据与偏移量查询（常用）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从 Broker 请求元数据</span></span><br><span class="line"><span class="comment">     * @param all_topics   true=请求所有 Topic，false=仅本地已知 Topic</span></span><br><span class="line"><span class="comment">     * @param only_rkt     仅请求指定 Topic 的元数据（可为 NULL）</span></span><br><span class="line"><span class="comment">     * @param metadatap    [out] 元数据结果指针，需用 delete 释放</span></span><br><span class="line"><span class="comment">     * @param timeout_ms   超时时间（毫秒）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，ERR__TIMED_OUT 超时，其他为错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">metadata</span><span class="params">(<span class="type">bool</span> all_topics,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Topic *only_rkt,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Metadata **metadatap,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 查询分区的水位偏移量（从 Broker 实时查询）</span></span><br><span class="line"><span class="comment">     * @param topic      Topic 名称</span></span><br><span class="line"><span class="comment">     * @param partition  分区号</span></span><br><span class="line"><span class="comment">     * @param low        [out] 最低偏移量（最早消息）</span></span><br><span class="line"><span class="comment">     * @param high       [out] 最高偏移量（最新消息）</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，其他为错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">query_watermark_offsets</span><span class="params">(<span class="type">const</span> std::string &amp;topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int64_t</span> *low,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int64_t</span> *high,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取缓存的分区水位偏移量（本地缓存，不请求 Broker）</span></span><br><span class="line"><span class="comment">     * @param topic      Topic 名称</span></span><br><span class="line"><span class="comment">     * @param partition  分区号</span></span><br><span class="line"><span class="comment">     * @param low        [out] 最低偏移量</span></span><br><span class="line"><span class="comment">     * @param high       [out] 最高偏移量</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，其他为错误码</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅适用于活跃的消费者实例</span></span><br><span class="line"><span class="comment">     * @remark 无缓存时返回 OFFSET_INVALID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">get_watermark_offsets</span><span class="params">(<span class="type">const</span> std::string &amp;topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int64_t</span> *low,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int64_t</span> *high)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 根据时间戳查找偏移量</span></span><br><span class="line"><span class="comment">     * @param offsets    [in/out] TopicPartition 列表，输入 offset 字段为时间戳，</span></span><br><span class="line"><span class="comment">     *                   输出 offset 字段为对应偏移量</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功（可能有部分分区失败，需检查各分区的 err()）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 时间戳为毫秒级 Unix 时间戳（UTC）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">offsetsForTimes</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;offsets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第三梯队】流控与集群信息</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 暂停指定分区的生产/消费</span></span><br><span class="line"><span class="comment">     * @param partitions 分区列表，每个分区的结果会写入其 err() 字段</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">pause</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 恢复指定分区的生产/消费</span></span><br><span class="line"><span class="comment">     * @param partitions 分区列表，每个分区的结果会写入其 err() 字段</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">resume</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取 Kafka 集群 ID</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 无缓存时的最大等待时间，0=非阻塞</span></span><br><span class="line"><span class="comment">     * @returns 集群 ID 字符串，失败返回空字符串</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 要求 Broker 版本 &gt;= 0.10.0 且 api.version.request=true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">clusterid</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前 Controller Broker 的 ID</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 无缓存时的最大等待时间</span></span><br><span class="line"><span class="comment">     * @returns Controller ID，失败返回 -1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 要求 Broker 版本 &gt;= 0.10.0 且 api.version.request=true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">controllerid</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取消费者的组成员 ID</span></span><br><span class="line"><span class="comment">     * @returns 成员 ID，非组成员时返回空字符串</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅适用于高级消费者（KafkaConsumer）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">memberid</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第四梯队】队列管理与回调控制</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取指定分区的 Fetch 队列</span></span><br><span class="line"><span class="comment">     * @param partition 分区对象</span></span><br><span class="line"><span class="comment">     * @returns 队列指针，失败返回 NULL</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅适用于消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Queue *<span class="title">get_partition_queue</span><span class="params">(<span class="type">const</span> TopicPartition *partition)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 将日志转发到指定队列</span></span><br><span class="line"><span class="comment">     * @param queue 目标队列，NULL 表示转发到主队列</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 需同时设置配置项 log.queue=true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">set_log_queue</span><span class="params">(Queue *queue)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取后台线程队列</span></span><br><span class="line"><span class="comment">     * @returns 后台队列指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Queue *<span class="title">get_background_queue</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 取消当前的回调分发（立即从 poll/consume 返回）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 只能在 librdkafka 回调函数内部调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">yield</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第五梯队】错误处理与认证（特定场景）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取首个致命错误</span></span><br><span class="line"><span class="comment">     * @param errstr [out] 错误描述字符串</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 表示无致命错误，其他为错误码</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 主要用于幂等生产者的错误检测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">fatal_error</span><span class="params">(std::string &amp;errstr)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置 SASL PLAIN/SCRAM 认证凭据</span></span><br><span class="line"><span class="comment">     * @param username 用户名</span></span><br><span class="line"><span class="comment">     * @param password 密码</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 新凭据在下次认证时生效，不会断开现有连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">sasl_set_credentials</span><span class="params">(<span class="type">const</span> std::string &amp;username,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> std::string &amp;password)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 设置 SASL/OAUTHBEARER Token</span></span><br><span class="line"><span class="comment">     * @param token_value      Token 值（通常为 JWS 格式）</span></span><br><span class="line"><span class="comment">     * @param md_lifetime_ms   Token 过期时间（毫秒级 Unix 时间戳）</span></span><br><span class="line"><span class="comment">     * @param md_principal_name Kafka Principal 名称</span></span><br><span class="line"><span class="comment">     * @param extensions       扩展键值对列表（key1, value1, key2, value2...）</span></span><br><span class="line"><span class="comment">     * @param errstr           [out] 错误描述</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，ERR__INVALID_ARG 参数错误，</span></span><br><span class="line"><span class="comment">     *          ERR__NOT_IMPLEMENTED 不支持，ERR__STATE 未配置 OAUTHBEARER</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">oauthbearer_set_token</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string &amp;token_value,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> md_lifetime_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string &amp;md_principal_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::list&lt;std::string&gt; &amp;extensions,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 标记 SASL/OAUTHBEARER Token 刷新失败</span></span><br><span class="line"><span class="comment">     * @param errstr 失败原因描述</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">oauthbearer_set_token_failure</span><span class="params">(<span class="type">const</span> std::string &amp;errstr)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 在后台线程启用 SASL OAUTHBEARER 刷新回调</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 适用于不定期调用 poll() 的应用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">sasl_background_callbacks_enable</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取 SASL 回调队列</span></span><br><span class="line"><span class="comment">     * @returns 队列指针，未启用时返回 NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Queue *<span class="title">get_sasl_queue</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第六梯队】底层操作（高级用法）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取底层 C 语言句柄</span></span><br><span class="line"><span class="comment">     * @returns rd_kafka_t* 指针</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @warning 不推荐直接调用 C API，无官方支持</span></span><br><span class="line"><span class="comment">     * @remark 需在 rdkafkacpp.h 之前包含 rdkafka.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">struct</span> <span class="title class_">rd_kafka_s</span> *<span class="built_in">c_ptr</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 使用 librdkafka 的分配器申请内存</span></span><br><span class="line"><span class="comment">     * @param size 字节数</span></span><br><span class="line"><span class="comment">     * @returns 内存指针</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须使用 mem_free() 释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">mem_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 释放 librdkafka 返回的内存</span></span><br><span class="line"><span class="comment">     * @param ptr 内存指针</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅用于 API 明确说明需使用此函数释放的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）核心特性与注意事项"><a href="#（3）核心特性与注意事项" class="headerlink" title="（3）核心特性与注意事项"></a>（3）核心特性与注意事项</h3><ul>
<li><strong>继承关系</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RdKafka::Handle（抽象基类）</span><br><span class="line">├─ RdKafka::Producer          <span class="comment">// 生产者</span></span><br><span class="line">├─ RdKafka::Consumer          <span class="comment">// 低级消费者（Simple Consumer，很少用）</span></span><br><span class="line">└─ RdKafka::KafkaConsumer     <span class="comment">// 高级消费者（High-Level Consumer，90%+用它）</span></span><br><span class="line"></span><br><span class="line">RdKafka::AdminClient          <span class="comment">// 管理客户端（独立，不继承 Handle）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>资源管理</strong>：</p>
<ul>
<li>客户端实例由 Conf::create() + Producer&#x2F;KafkaConsumer::create() 创建</li>
<li>必须通过 delete 释放</li>
</ul>
</li>
<li><p>Handle 内部管理与 Broker 的连接池、IO 线程、定时器，销毁时会自动清理所有资源，避免内存泄漏。</p>
</li>
<li><p><strong>线程模型</strong>：</p>
<ul>
<li>Handle 子类会启动内部 IO 线程（默认 1 个，可通过 io_threads 配置），处理网络通信、消息发送 &#x2F; 接收；</li>
<li>业务线程调用 poll()&#x2F;produce() 等 API 时，仅触发逻辑调度，核心 IO 由内部线程处理。</li>
</ul>
</li>
</ul>
<h2 id="6-Producer类（生产者类）"><a href="#6-Producer类（生产者类）" class="headerlink" title="6.Producer类（生产者类）"></a>6.Producer类（生产者类）</h2><h3 id="（1）概述-3"><a href="#（1）概述-3" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Producer 是 librdkafka 中实现 Kafka <strong>“消息生产逻辑”的核心类</strong>，继承自 RdKafka::Handle 抽象基类</li>
<li>封装了消息异步发送、分区路由、回调通知、资源管理等全量生产能力，是<strong>客户端向 Kafka 集群发送消息的唯一入口</strong>。</li>
</ul>
<h4 id="核心定位-3"><a href="#核心定位-3" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>异步发送</strong>：<ul>
<li>默认采用 “<strong>异步非阻塞</strong>” 模式，<strong>produce()</strong> 仅将消息放入<strong>本地队列</strong>，由内部 IO 线程发送至 Broker</li>
<li>仅 flush()&#x2F; 同步发送会阻塞</li>
</ul>
</li>
<li><strong>回调驱动</strong>：<ul>
<li>通过 <strong>DeliveryReportCb</strong> “<strong>异步通知</strong>”消息发送结果（成功 &#x2F; 失败）</li>
</ul>
</li>
<li><strong>分区路由</strong>：<ul>
<li>支持<strong>内置分区器</strong>（按 Key 哈希 &#x2F; 随机）或<strong>自定义分区器</strong>（PartitionerCb）</li>
</ul>
</li>
<li><strong>资源管理</strong>：<ul>
<li>继承 Handle 基类的生命周期管理能力，通过 <strong>delete</strong> 或 <strong>flush() + delete</strong> 安全释放连接、线程、队列等资源</li>
</ul>
</li>
<li><strong>高可用设计</strong>：<ul>
<li>支持<strong>消息重试</strong>、<strong>批量发送</strong>、<strong>压缩</strong>（gzip&#x2F;snappy&#x2F;lz4），提升吞吐量和可靠性</li>
</ul>
</li>
<li><strong>可靠性</strong>：<ul>
<li>支持消息重试（retries）、ACK 确认（acks）、幂等 &#x2F; 事务（需配置）；</li>
</ul>
</li>
<li><strong>高性能</strong>：<ul>
<li>支持批量发送（batch.size）、异步 IO，减少网络请求次数；</li>
</ul>
</li>
</ul>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="&lt;3&gt;继承关系"></a>&lt;3&gt;继承关系</h4><ul>
<li>Producer 继承自 Handle 抽象基类，因此具备以下 Handle 通用能力：<ul>
<li><strong>poll()</strong>：轮询事件，触发回调（<strong>生产者必须定期调用</strong>）</li>
<li><strong>name()</strong>：获取客户端名称</li>
<li><strong>outq_len()</strong>：获取待发送消息队列长度</li>
<li>元数据查询、流控等其他 Handle 方法</li>
</ul>
</li>
</ul>
<h3 id="（2）Producer类的定义"><a href="#（2）Producer类的定义" class="headerlink" title="（2）Producer类的定义"></a>（2）Producer类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Producer : <span class="keyword">public</span> <span class="keyword">virtual</span> Handle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第一梯队】几乎每个生产者应用都会用到</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建 Kafka 生产者实例</span></span><br><span class="line"><span class="comment">     * @param conf 配置对象（可选），不传则使用默认配置；配置对象可复用</span></span><br><span class="line"><span class="comment">     * @param errstr [out] 错误描述字符串</span></span><br><span class="line"><span class="comment">     * @returns 成功返回生产者实例，失败返回 NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Producer *<span class="title">create</span><span class="params">(<span class="type">const</span> Conf *conf, std::string &amp;errstr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Producer</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 消息标志位（用于 produce() 的 msgflags 参数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        <span class="comment">// ⚠️ 详情见类定义末尾</span></span><br><span class="line">        RK_MSG_FREE  = <span class="number">0x1</span>,  <span class="comment">/**&lt; librdkafka 使用完 payload 后会自动 free()</span></span><br><span class="line"><span class="comment">                              *   与 RK_MSG_COPY 互斥 */</span></span><br><span class="line">        RK_MSG_COPY  = <span class="number">0x2</span>,  <span class="comment">/**&lt; librdkafka 会复制 payload 数据，</span></span><br><span class="line"><span class="comment">                              *   调用返回后不再使用原指针</span></span><br><span class="line"><span class="comment">                              *   与 RK_MSG_FREE 互斥 */</span></span><br><span class="line">        RK_MSG_BLOCK = <span class="number">0x4</span>   <span class="comment">/**&lt; 当消息队列满时阻塞 produce() 调用</span></span><br><span class="line"><span class="comment">                              *   警告：使用时必须在另一个线程调用 poll()</span></span><br><span class="line"><span class="comment">                              *   否则会导致无限阻塞 */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 生产并发送单条消息到 Broker（异步非阻塞）</span></span><br><span class="line"><span class="comment">     * @param topic      Topic 对象</span></span><br><span class="line"><span class="comment">     * @param partition  目标分区：PARTITION_UA 自动分区(不手动指定分区，让 librdkafka 根据 key 自动决定)，</span></span><br><span class="line"><span class="comment">         或 0..N 手动指定分区</span></span><br><span class="line"><span class="comment">     * @param msgflags   消息标志：RK_MSG_FREE / RK_MSG_COPY / RK_MSG_BLOCK (⚠️ 详情见类定义末尾)</span></span><br><span class="line"><span class="comment">     * @param payload    消息内容指针</span></span><br><span class="line"><span class="comment">     * @param len        消息长度（字节）</span></span><br><span class="line"><span class="comment">     * @param key        消息 Key（可选），用于分区选择和传递给消费者</span></span><br><span class="line"><span class="comment">     * @param msg_opaque 用户自定义指针，会在投递回调中返回</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功入队</span></span><br><span class="line"><span class="comment">     *          ERR__QUEUE_FULL 队列满</span></span><br><span class="line"><span class="comment">     *          ERR_MSG_SIZE_TOO_LARGE 消息过大</span></span><br><span class="line"><span class="comment">     *          ERR__UNKNOWN_PARTITION / ERR__UNKNOWN_TOPIC 未知分区/Topic</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 若返回错误且使用了 RK_MSG_FREE，调用方仍需负责释放 payload</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(Topic *topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> msgflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> std::string *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief produce() 重载：Key 使用指针+长度形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(Topic *topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> msgflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">void</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief produce() 重载：Topic 使用字符串，支持指定时间戳（推荐）</span></span><br><span class="line"><span class="comment">     * @param topic_name Topic 名称（无需创建 Topic 对象）</span></span><br><span class="line"><span class="comment">     * @param timestamp  消息时间戳（毫秒级 Unix 时间戳，UTC）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(<span class="type">const</span> std::string topic_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> msgflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">void</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int64_t</span> timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief produce() 重载：支持消息头（Headers）</span></span><br><span class="line"><span class="comment">     * @param headers 消息头对象，成功时会被释放，失败时保持不变</span></span><br><span class="line"><span class="comment">     * @warning 成功调用后 headers 会被自动释放，失败时需调用方处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(<span class="type">const</span> std::string topic_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> msgflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">void</span> *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int64_t</span> timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RdKafka::Headers *headers,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief produce() 重载：使用 vector 传递 key 和 payload（自动复制）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">produce</span><span class="params">(Topic *topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int32_t</span> partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt; *payload,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt; *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *msg_opaque)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 等待所有待发送消息完成（刷新）</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间（毫秒）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 全部完成，ERR__TIMED_OUT 超时</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 销毁生产者前应调用此方法，确保所有消息发送完成</span></span><br><span class="line"><span class="comment">     * @remark 会忽略 linger.ms 配置，立即发送队列中的消息</span></span><br><span class="line"><span class="comment">     * @remark 内部会调用 poll()，因此会触发回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">flush</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第二梯队】特殊场景使用</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 清除生产者当前处理的消息</span></span><br><span class="line"><span class="comment">     * @param purge_flags 清除标志</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 清除后需调用 poll() 或 flush() 处理投递报告回调</span></span><br><span class="line"><span class="comment">     * @remark 队列中的消息会收到 ERR__PURGE_QUEUE 错误</span></span><br><span class="line"><span class="comment">     * @remark 传输中的消息会收到 ERR__PURGE_INFLIGHT 错误</span></span><br><span class="line"><span class="comment">     * @warning 清除传输中消息会导致无法确认消息是否成功，可能产生重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">purge</span><span class="params">(<span class="type">int</span> purge_flags)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 清除标志位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        PURGE_QUEUE        = <span class="number">0x1</span>,  <span class="comment">/**&lt; 清除内部队列中的消息 */</span></span><br><span class="line">        PURGE_INFLIGHT     = <span class="number">0x2</span>,  <span class="comment">/**&lt; 清除传输中的消息（可能导致重复） */</span></span><br><span class="line">        PURGE_NON_BLOCKING = <span class="number">0x4</span>   <span class="comment">/**&lt; 不等待后台队列清除完成 */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第三梯队】事务 API（需要 Broker &gt;= 0.11.0）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 初始化事务</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 最大阻塞时间，超时后可在后台继续，允许重试</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 使用事务前必须先调用此方法（仅需一次）</span></span><br><span class="line"><span class="comment">     * @remark 通过 Error::is_retriable() 判断是否可重试</span></span><br><span class="line"><span class="comment">     * @remark 通过 Error::is_fatal() 判断是否为致命错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">init_transactions</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 开始新事务</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须先调用 init_transactions() 成功后才能使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">begin_transaction</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 提交当前事务</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 最大阻塞时间，-1 表示使用剩余事务超时时间（推荐）</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 强烈建议 timeout_ms 传 -1</span></span><br><span class="line"><span class="comment">     * @remark 提交前会自动 flush 所有待发送消息</span></span><br><span class="line"><span class="comment">     * @remark 通过 Error::txn_requires_abort() 判断是否需要中止事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">commit_transaction</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 中止当前事务</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 最大阻塞时间，-1 表示使用剩余事务超时时间（推荐）</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 用于从可中止的事务错误中恢复</span></span><br><span class="line"><span class="comment">     * @remark 会清除所有待发送消息，触发 ERR__PURGE_INFLIGHT/QUEUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">abort_transaction</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 发送消费偏移量到事务（Consume-Transform-Produce 模式）</span></span><br><span class="line"><span class="comment">     * @param offsets        要提交的偏移量列表（应为下一条要消费的偏移量）</span></span><br><span class="line"><span class="comment">     * @param group_metadata 消费者组元数据（从 KafkaConsumer::groupMetadata() 获取）</span></span><br><span class="line"><span class="comment">     * @param timeout_ms     最大阻塞时间</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须在生产者实例上调用，不是消费者</span></span><br><span class="line"><span class="comment">     * @remark 消费者必须禁用自动提交（enable.auto.commit=false）</span></span><br><span class="line"><span class="comment">     * @remark 在 commit_transaction() 之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">send_offsets_to_transaction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;offsets,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ConsumerGroupMetadata *group_metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│  RK_MSG_COPY（推荐）                                            │</span><br><span class="line">│  ─────────────────                                              │</span><br><span class="line">│  • librdkafka 立即复制你的数据到内部缓冲区                       │</span><br><span class="line">│  • <span class="built_in">produce</span>() 返回后，你的 payload 可以立即释放/修改              │</span><br><span class="line">│  • 代价：多一次内存拷贝                                          │</span><br><span class="line">│                                                                  │</span><br><span class="line">│  你的代码               librdkafka                              │</span><br><span class="line">│  ┌────────┐   复制    ┌────────────┐                            │</span><br><span class="line">│  │payload │ ───────► │ 内部缓冲区 │ ────► Kafka                 │</span><br><span class="line">│  └────────┘          └────────────┘                             │</span><br><span class="line">│      ↓                                                          │</span><br><span class="line">│  <span class="built_in">produce</span>()返回后                                                 │</span><br><span class="line">│  你可以 <span class="keyword">delete</span> payload                                          │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│  RK_MSG_FREE（零拷贝，但危险）                                   │</span><br><span class="line">│  ──────────────────────────                                      │</span><br><span class="line">│  • librdkafka 不复制，直接使用你的指针                           │</span><br><span class="line">│  • 发送完成后，librdkafka 会调用 <span class="built_in">free</span>(payload)                   │</span><br><span class="line">│  • 你必须用 <span class="built_in">malloc</span>() 分配，不能用 <span class="keyword">new</span>/栈/string                  │</span><br><span class="line">│  • <span class="built_in">produce</span>() 返回后，你不能再访问 payload！                      │</span><br><span class="line">│                                                                  │</span><br><span class="line">│  你的代码               librdkafka                              │</span><br><span class="line">│  ┌────────┐   直接使用  ┌────────────┐                          │</span><br><span class="line">│  │payload │ ──────────►│   待发送   │ ────► Kafka              │</span><br><span class="line">│  └────────┘            └────────────┘                           │</span><br><span class="line">│      ↑                       ↓                                  │</span><br><span class="line">│  不能再访问！            发送完成后                              │</span><br><span class="line">│                         <span class="built_in">free</span>(payload) ← librdkafka 自动调用     │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│  RK_MSG_BLOCK（阻塞模式）                                        │</span><br><span class="line">│  ──────────────────────                                          │</span><br><span class="line">│  • 与上面两个正交，可组合使用                                     │</span><br><span class="line">│  • 当内部队列满时：                                              │</span><br><span class="line">│    - 不加此标志：<span class="built_in">produce</span>() 立即返回错误 ERR__QUEUE_FULL         │</span><br><span class="line">│    - 加此标志：<span class="built_in">produce</span>() 阻塞等待队列有空间                      │</span><br><span class="line">│  • ⚠️ 必须有另一个线程调用 <span class="built_in">poll</span>()，否则死锁！                    │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（3）核心配置"><a href="#（3）核心配置" class="headerlink" title="（3）核心配置"></a>（3）核心配置</h3><p><a href="#config">全局配置</a><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116154712623.png"></p>
<h3 id="（4）使用示例"><a href="#（4）使用示例" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><h4 id="异步发送示例（生产环境首选）"><a href="#异步发送示例（生产环境首选）" class="headerlink" title="&lt;1&gt;异步发送示例（生产环境首选）"></a>&lt;1&gt;异步发送示例（生产环境首选）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 全局标志：控制生产者退出</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> run = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义投递结果回调（继承 DeliveryReportCb）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeliveryReportCb</span> : <span class="keyword">public</span> RdKafka::DeliveryReportCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dr_cb</span><span class="params">(RdKafka::Message &amp;msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理消息发送结果</span></span><br><span class="line">        <span class="keyword">if</span> (msg.<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 发送失败</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[发送失败] Topic：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 错误：&quot;</span> &lt;&lt; msg.<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 可选：获取失败消息的 Key/内容（需设置 RK_MSG_COPY）</span></span><br><span class="line">            std::string key_str = msg.<span class="built_in">key</span>() ? *msg.<span class="built_in">key</span>() : <span class="string">&quot;无Key&quot;</span>;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;  Key：&quot;</span> &lt;&lt; key_str &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送成功</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[发送成功] Topic：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 偏移量：&quot;</span> &lt;&lt; msg.<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理：优雅退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigterm</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    run = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ========== 1. 初始化配置 ==========</span></span><br><span class="line">    std::string errstr;</span><br><span class="line">    <span class="comment">// 创建全局配置（CONF_GLOBAL）</span></span><br><span class="line">    RdKafka::Conf *global_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    <span class="comment">// 创建主题配置（CONF_TOPIC，可选）</span></span><br><span class="line">    RdKafka::Conf *topic_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_TOPIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置核心参数</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr); <span class="comment">// 必填</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;order-producer-01&quot;</span>, errstr);      <span class="comment">// 生产者标识</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>, errstr);                           <span class="comment">// ACK级别：Leader确认</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;3&quot;</span>, errstr);                        <span class="comment">// 重试3次</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;batch.size&quot;</span>, <span class="string">&quot;16384&quot;</span>, errstr);                 <span class="comment">// 批量大小16KB</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;linger.ms&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr);                      <span class="comment">// 延迟5ms发送（批量）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定投递回调（核心：异步获取发送结果）</span></span><br><span class="line">    MyDeliveryReportCb dr_cb;</span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;dr_cb&quot;</span>, &amp;dr_cb, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 创建生产者实例 ==========</span></span><br><span class="line">    RdKafka::Producer *producer = RdKafka::Producer::<span class="built_in">create</span>(global_conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!producer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建生产者失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> global_conf;</span><br><span class="line">        <span class="keyword">delete</span> topic_conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放配置对象（生产者创建后，配置已拷贝，可释放）</span></span><br><span class="line">    <span class="keyword">delete</span> global_conf;</span><br><span class="line">    <span class="keyword">delete</span> topic_conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 注册信号处理（优雅退出） ==========</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 循环发送消息 ==========</span></span><br><span class="line">    <span class="type">int</span> msg_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (run &amp;&amp; msg_count &lt; <span class="number">10</span>) &#123; <span class="comment">// 发送10条测试消息</span></span><br><span class="line">        std::string msg_payload = <span class="string">&quot;order_&quot;</span> + std::<span class="built_in">to_string</span>(msg_count); <span class="comment">// 消息内容</span></span><br><span class="line">        std::string msg_key = <span class="string">&quot;user_1001&quot;</span>;                              <span class="comment">// 消息Key（用于分区路由）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消息头（可选，附加元数据）</span></span><br><span class="line">        RdKafka::Headers *headers = RdKafka::Headers::<span class="built_in">create</span>();</span><br><span class="line">        std::string trace_id = <span class="string">&quot;trace_789012&quot;</span>;</span><br><span class="line">        std::string msg_type = <span class="string">&quot;order_create&quot;</span>;</span><br><span class="line">        headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;trace-id&quot;</span>, trace_id.<span class="built_in">c_str</span>(), trace_id.<span class="built_in">size</span>());</span><br><span class="line">        headers-&gt;<span class="built_in">add</span>(<span class="string">&quot;msg-type&quot;</span>, msg_type.<span class="built_in">c_str</span>(), msg_type.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步发送消息</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// - &quot;order_topic&quot;：目标Topic</span></span><br><span class="line">        <span class="comment">// - RdKafka::Topic::PARTITION_UA（-1）：自动分配分区（由分区器决定）</span></span><br><span class="line">        <span class="comment">// - RK_MSG_COPY：拷贝消息内容（避免本地内存释放导致问题）</span></span><br><span class="line">        <span class="comment">// - payload/len：消息内容及长度</span></span><br><span class="line">        <span class="comment">// - key/key_len：消息Key及长度</span></span><br><span class="line">        <span class="comment">// - 0：自定义时间戳（0=使用Broker时间）</span></span><br><span class="line">        <span class="comment">// - headers：消息头</span></span><br><span class="line">        <span class="comment">// - nullptr：透传上下文（msg_opaque）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步发送消息</span></span><br><span class="line">        RdKafka::ErrorCode err = producer-&gt;<span class="built_in">produce</span>(</span><br><span class="line">            <span class="string">&quot;order_topic&quot;</span>,</span><br><span class="line">            RdKafka::Topic::PARTITION_UA,</span><br><span class="line">            RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">            (<span class="type">void</span>*)msg_payload.<span class="built_in">data</span>(), msg_payload.<span class="built_in">size</span>(),</span><br><span class="line">            msg_key.<span class="built_in">data</span>(), msg_key.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="number">0</span>,       <span class="comment">// 时间戳</span></span><br><span class="line">            headers, <span class="comment">// 消息头</span></span><br><span class="line">            <span class="literal">nullptr</span>  <span class="comment">// msg_opaque</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚠️ produce成功调用后 headers 会被自动释放，失败时需手动释放</span></span><br><span class="line">        <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;发送消息失败（即时）：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">delete</span> headers;  <span class="comment">// produce 失败时需手动释放 headers</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 队列满时，等待并重试</span></span><br><span class="line">            <span class="keyword">if</span> (err == RdKafka::ERR__QUEUE_FULL) &#123;</span><br><span class="line">                producer-&gt;<span class="built_in">poll</span>(<span class="number">100</span>); <span class="comment">// 处理内部事件，腾出队列空间</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// produce() 成功：headers 已被 librdkafka 接管，禁止再 delete</span></span><br><span class="line">        <span class="comment">// ⚠️ 此时 headers 指针已失效，不要再使用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定期调用poll：驱动回调执行、处理重试（核心！异步发送必须调用）</span></span><br><span class="line">        producer-&gt;<span class="built_in">poll</span>(<span class="number">0</span>); <span class="comment">// 0ms超时：非阻塞处理</span></span><br><span class="line"></span><br><span class="line">        msg_count++;</span><br><span class="line">        <span class="comment">// 模拟业务延迟</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. 优雅关闭生产者 ==========</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;等待所有消息发送完成...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// flush：阻塞等待所有未发送的消息完成（超时5秒）</span></span><br><span class="line">    producer-&gt;<span class="built_in">flush</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有未发送完成的消息</span></span><br><span class="line">    <span class="keyword">if</span> (producer-&gt;<span class="built_in">outq_len</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;仍有 &quot;</span> &lt;&lt; producer-&gt;<span class="built_in">outq_len</span>() &lt;&lt; <span class="string">&quot; 条消息未发送完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 6. 释放资源 ==========</span></span><br><span class="line">    <span class="keyword">delete</span> producer; <span class="comment">// 释放生产者资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步发送示例（特殊场景使用）"><a href="#同步发送示例（特殊场景使用）" class="headerlink" title="&lt;2&gt;同步发送示例（特殊场景使用）"></a>&lt;2&gt;同步发送示例（特殊场景使用）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步发送：通过 msg_opaque 阻塞等待结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync_produce</span><span class="params">(RdKafka::Producer *producer, <span class="type">const</span> std::string &amp;topic, <span class="type">const</span> std::string &amp;payload)</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::ErrorCode err;</span><br><span class="line">    <span class="comment">// 用于阻塞的信号量</span></span><br><span class="line">    <span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息（msg_opaque 传递上下文）</span></span><br><span class="line">    err = producer-&gt;<span class="built_in">produce</span>(</span><br><span class="line">        topic,</span><br><span class="line">        RdKafka::Topic::PARTITION_UA,</span><br><span class="line">        RdKafka::Producer::RK_MSG_COPY,</span><br><span class="line">        (<span class="type">void</span>*)payload.<span class="built_in">data</span>(), payload.<span class="built_in">size</span>(),</span><br><span class="line">        <span class="literal">nullptr</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,        <span class="comment">// timestamp</span></span><br><span class="line">        <span class="literal">nullptr</span>,  <span class="comment">// headers</span></span><br><span class="line">        &amp;done     <span class="comment">// msg_opaque</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;同步发送失败：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待发送结果（轮询+sleep）</span></span><br><span class="line">    <span class="type">int</span> timeout = <span class="number">5000</span>; <span class="comment">// 5秒超时</span></span><br><span class="line">    <span class="type">int</span> poll_interval = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done &amp;&amp; timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        producer-&gt;<span class="built_in">poll</span>(poll_interval);</span><br><span class="line">        timeout -= poll_interval;</span><br><span class="line">        <span class="built_in">usleep</span>(poll_interval * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;同步发送超时&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需修改投递回调，设置 done 标志：</span></span><br><span class="line"><span class="comment">// void dr_cb(RdKafka::Message &amp;msg) override &#123;</span></span><br><span class="line"><span class="comment">//     bool *done = static_cast&lt;bool*&gt;(msg.opaque());</span></span><br><span class="line"><span class="comment">//     *done = true;</span></span><br><span class="line"><span class="comment">//     // ... 原有逻辑</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）关键注意事项"><a href="#（5）关键注意事项" class="headerlink" title="（5）关键注意事项"></a>（5）关键注意事项</h3><ul>
<li><p><strong>异步发送</strong>：</p>
<ul>
<li>produce() <strong>仅</strong>将消息写入<strong>本地环形队列</strong>，内部 IO 线程异步发送</li>
<li>返回 ERR_NO_ERROR <strong>仅代表 “入队成功”</strong>，<strong>不代表 “发送成功”</strong></li>
</ul>
</li>
<li><p><strong>poll () 必须调用</strong>：</p>
<ul>
<li>异步发送时，poll() 是<strong>驱动回调执行、处理重试、清理队列</strong>的核心，需定期调用（建议每次 produce() 后或定时调用）；</li>
<li>若不调用 poll()，<strong>回调不会执行，消息重试也会停滞</strong>，最终导致发送队列满（ERR__QUEUE_FULL）</li>
</ul>
</li>
<li><p><strong>消息可靠性</strong>：</p>
<ul>
<li>关闭生产者前必须调用 flush()，否则队列中的消息会丢失；</li>
<li>acks&#x3D;all + retries&#x3D;N 是最高可靠性配置，但会降低吞吐量；</li>
<li>启用 enable.idempotence&#x3D;true 可避免重复发送（幂等性）；</li>
</ul>
</li>
<li><p><strong>分区策略</strong>：</p>
<ul>
<li>指定 partition 数值：直接发送到该分区；</li>
<li>PARTITION_UA（-1）：按 key 哈希分区（无 key 则随机）；</li>
<li>自定义 PartitionerCb：按业务规则路由（如用户 ID 取模）；</li>
</ul>
</li>
<li><p><strong>消息重试</strong>：</p>
<ul>
<li>配置 retries（重试次数）、retry.backoff.ms（重试间隔），处理网络抖动导致的发送失败；</li>
</ul>
</li>
<li><p><strong>压缩配置</strong>：</p>
<ul>
<li>通过 compression.type 配置（gzip&#x2F;snappy&#x2F;lz4），降低网络传输量。</li>
</ul>
</li>
</ul>
<h2 id="7-KafkaConsumer类（消费者类）"><a href="#7-KafkaConsumer类（消费者类）" class="headerlink" title="7.KafkaConsumer类（消费者类）"></a>7.KafkaConsumer类（消费者类）</h2><h3 id="（1）概述-4"><a href="#（1）概述-4" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::KafkaConsumer 是 librdkafka 中最常用的消费者实现类，继承自 RdKafka::Handle</li>
<li>封装了 Kafka <strong>消费者组模式</strong>下的消息消费能力，包括：<ul>
<li><strong>subscribe()</strong> 自动分区模式（依赖消费者组协调器自动分配分区）</li>
<li><strong>assign()</strong> 手动分区模式（精准指定要消费的分区列表）</li>
<li><strong>offset 管理</strong>（自动&#x2F;手动提交）</li>
<li><strong>Rebalance 处理</strong>（分区重分配）</li>
</ul>
</li>
<li>是客户端从 Kafka 集群消费消息的核心入口</li>
</ul>
<h4 id="核心定位-4"><a href="#核心定位-4" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>消费者组支持</strong>：<ul>
<li>实现 Kafka 消费者组协议，支持自动&#x2F;手动分区分配</li>
<li>依赖 Broker 协调器（Coordinator）实现分区重平衡</li>
</ul>
</li>
<li><strong>消费模式</strong>：<ul>
<li><strong>subscribe()</strong> 自动分区模式：由消费者组自动分配，支持 Rebalance</li>
<li><strong>assign()</strong> 手动分区模式：精准控制分区，无自动 Rebalance</li>
</ul>
</li>
<li><strong>偏移量管理</strong>：<ul>
<li>支持自动提交（enable.auto.commit&#x3D;true）</li>
<li>支持手动提交（commitSync&#x2F;commitAsync）</li>
</ul>
</li>
<li><strong>事件驱动</strong>：<ul>
<li><strong>consume()</strong> 是核心消费方法，同时触发 Rebalance、心跳、回调等事件</li>
<li><strong>禁止使用 poll()</strong>，KafkaConsumer 的 consume() 方法已整合了 poll() 的功能，因此无需单独调用 poll()</li>
</ul>
</li>
<li><strong>资源管理</strong>：<ul>
<li>继承 Handle 基类，通过 <strong>close() + delete</strong> 安全释放资源</li>
</ul>
</li>
<li><strong>线程安全</strong>：<ul>
<li><strong>非线程安全</strong>，所有 API 需在单线程调用（或加锁）</li>
</ul>
</li>
</ul>
<h3 id="（2）KafkaConsumer类的定义"><a href="#（2）KafkaConsumer类的定义" class="headerlink" title="（2）KafkaConsumer类的定义"></a>（2）KafkaConsumer类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> KafkaConsumer : <span class="keyword">public</span> <span class="keyword">virtual</span> Handle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第一梯队】几乎每个消费者应用都会用到</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 创建 KafkaConsumer 实例</span></span><br><span class="line"><span class="comment">     * @param conf 配置对象，必须设置 group.id（消费者组 ID）</span></span><br><span class="line"><span class="comment">     * @param errstr [out] 错误描述字符串</span></span><br><span class="line"><span class="comment">     * @returns 成功返回消费者实例，失败返回 NULL</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 使用 close() 关闭消费者</span></span><br><span class="line"><span class="comment">     * @sa RebalanceCb, CONFIGURATION.md 中的 group.id, session.timeout.ms 等配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> KafkaConsumer *<span class="title">create</span><span class="params">(<span class="type">const</span> Conf *conf, std::string &amp;errstr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">KafkaConsumer</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 订阅 Topic 列表</span></span><br><span class="line"><span class="comment">     * @param topics 要订阅的 Topic 名称列表</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，否则返回错误码</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 之前的订阅会被自动取消</span></span><br><span class="line"><span class="comment">     * @remark 支持正则表达式（以 &quot;^&quot; 开头，如 &quot;^myPfx[0-9]_.*&quot;）</span></span><br><span class="line"><span class="comment">     * @remark 订阅是异步操作，不可用的 Topic 会通过 consume() 返回错误</span></span><br><span class="line"><span class="comment">     * @remark 不存在的 Topic 返回 ERR_UNKNOWN_TOPIC_OR_PART</span></span><br><span class="line"><span class="comment">     * @remark 无权限的 Topic 返回 ERR_TOPIC_AUTHORIZATION_FAILED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">subscribe</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt; &amp;topics)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 消费消息或获取错误事件（核心消费方法）</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间（毫秒）</span></span><br><span class="line"><span class="comment">     * @returns Message 对象，需用 delete 释放</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 会自动触发已注册的回调（RebalanceCb、EventCb、OffsetCommitCb 等）</span></span><br><span class="line"><span class="comment">     * @remark 即使没有消息，也应定期调用以处理回调（尤其是 RebalanceCb）</span></span><br><span class="line"><span class="comment">     * @remark 返回值判断：</span></span><br><span class="line"><span class="comment">     *         - Message::err() == ERR_NO_ERROR：正常消息</span></span><br><span class="line"><span class="comment">     *         - Message::err() == ERR__TIMED_OUT：超时，无消息</span></span><br><span class="line"><span class="comment">     *         - 其他：错误事件</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @warning KafkaConsumer 禁止调用 poll()，只能用 consume()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Message *<span class="title">consume</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 关闭消费者（同步阻塞）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 会依次执行：触发 Rebalance → 停止消费 → 提交偏移量 → 离开消费者组</span></span><br><span class="line"><span class="comment">     * @remark 最大阻塞时间约为 session.timeout.ms</span></span><br><span class="line"><span class="comment">     * @remark 关闭过程中可能触发回调（RebalanceCb、OffsetCommitCb 等）</span></span><br><span class="line"><span class="comment">     * @remark 关闭后必须用 delete 释放消费者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">close</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交当前分配的所有分区偏移量</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，否则返回错误码</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 阻塞直到提交完成或失败</span></span><br><span class="line"><span class="comment">     * @remark 若注册了 OffsetCommitCb，会在后续 consume() 中回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 异步提交当前分配的所有分区偏移量</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功入队</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 非阻塞，提交结果通过 OffsetCommitCb 回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitAsync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第二梯队】常用但非必需</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交单条消息的偏移量</span></span><br><span class="line"><span class="comment">     * @param message 要提交的消息</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 提交的偏移量 = message.offset() + 1（即下一条待消费位置）</span></span><br><span class="line"><span class="comment">     * @remark 阻塞直到提交完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">(Message *message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 异步提交单条消息的偏移量</span></span><br><span class="line"><span class="comment">     * @param message 要提交的消息</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功入队</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 提交的偏移量 = message.offset() + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitAsync</span><span class="params">(Message *message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交指定分区列表的偏移量</span></span><br><span class="line"><span class="comment">     * @param offsets 分区偏移量列表（offset 应为下一条待消费位置）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;offsets)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 异步提交指定分区列表的偏移量</span></span><br><span class="line"><span class="comment">     * @param offsets 分区偏移量列表</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitAsync</span><span class="params">(<span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;offsets)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交并通过回调获取结果</span></span><br><span class="line"><span class="comment">     * @param offset_commit_cb 提交完成后的回调函数</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 回调会在此函数内部被调用（同步）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">(OffsetCommitCb *offset_commit_cb)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 同步提交指定分区偏移量并通过回调获取结果</span></span><br><span class="line"><span class="comment">     * @param offsets 分区偏移量列表</span></span><br><span class="line"><span class="comment">     * @param offset_commit_cb 提交完成后的回调函数</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">commitSync</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;offsets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 OffsetCommitCb *offset_commit_cb)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 取消当前订阅</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">unsubscribe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前订阅的 Topic 列表</span></span><br><span class="line"><span class="comment">     * @param topics [out] 输出当前订阅的 Topic 名称</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">subscription</span><span class="params">(std::vector&lt;std::string&gt; &amp;topics)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前分配的分区列表</span></span><br><span class="line"><span class="comment">     * @param partitions [out] 输出当前分配的分区</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">assignment</span><span class="params">(std::vector&lt;RdKafka::TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 查询已提交的偏移量（从 Broker 获取）</span></span><br><span class="line"><span class="comment">     * @param partitions [in/out] 输入分区列表，输出时填充 offset 或 err</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">committed</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前消费位置（内存中的偏移量）</span></span><br><span class="line"><span class="comment">     * @param partitions [in/out] 输入分区列表，输出时填充 offset 或 err</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 与 committed() 区别：position() 返回内存中的位置，committed() 查询 Broker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">position</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第三梯队】手动分区管理（不使用消费者组自动分配时）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 手动分配分区（不使用消费者组）</span></span><br><span class="line"><span class="comment">     * @param partitions 要消费的分区列表</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 与 subscribe() 互斥，手动分配时不参与消费者组 Rebalance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">assign</span><span class="params">(<span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 取消当前分区分配并停止消费</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">unassign</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 跳转到指定偏移量位置</span></span><br><span class="line"><span class="comment">     * @param partition 目标分区及偏移量</span></span><br><span class="line"><span class="comment">     * @param timeout_ms 超时时间（0=异步，&gt;0=同步等待）</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功，ERR__TIMED_OUT 超时</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须先通过 assign() 分配分区后才能 seek</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">seek</span><span class="params">(<span class="type">const</span> TopicPartition &amp;partition, <span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 存储偏移量（不立即提交，等待自动提交或手动 commit）</span></span><br><span class="line"><span class="comment">     * @param offsets 分区偏移量列表</span></span><br><span class="line"><span class="comment">     * @returns ERR_NO_ERROR 成功</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark offset 值直接存储，不会 +1</span></span><br><span class="line"><span class="comment">     * @remark 必须设置 enable.auto.offset.store=false 才能使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">offsets_store</span><span class="params">(std::vector&lt;TopicPartition *&gt; &amp;offsets)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第四梯队】协作式 Rebalance（COOPERATIVE 协议）</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 增量添加分区到当前分配（协作式 Rebalance）</span></span><br><span class="line"><span class="comment">     * @param partitions 要添加的分区列表</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 用于 COOPERATIVE 协议的 Rebalance 回调中处理 ERR__ASSIGN_PARTITIONS</span></span><br><span class="line"><span class="comment">     * @remark 也可在 Rebalance 回调外使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">incremental_assign</span><span class="params">(<span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 增量移除分区从当前分配（协作式 Rebalance）</span></span><br><span class="line"><span class="comment">     * @param partitions 要移除的分区列表</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象（需 delete）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 用于 COOPERATIVE 协议的 Rebalance 回调中处理 ERR__REVOKE_PARTITIONS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">incremental_unassign</span><span class="params">(<span class="type">const</span> std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取当前 Rebalance 协议类型</span></span><br><span class="line"><span class="comment">     * @returns &quot;NONE&quot;（未加入组）、&quot;EAGER&quot;（急切式）、&quot;COOPERATIVE&quot;（协作式）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">rebalance_protocol</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检查当前分配是否为非自愿丢失</span></span><br><span class="line"><span class="comment">     * @returns true 表示分区分配已丢失（可能已被其他消费者接管）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 仅在 Rebalance 回调中有意义</span></span><br><span class="line"><span class="comment">     * @remark 分配丢失后提交偏移量可能失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">assignment_lost</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line">    <span class="comment">// 【第五梯队】事务支持 &amp; 高级功能</span></span><br><span class="line">    <span class="comment">//=============================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取消费者组元数据（用于事务）</span></span><br><span class="line"><span class="comment">     * @returns ConsumerGroupMetadata 对象（需 delete），未配置 group.id 时返回 NULL</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 用于 Producer::send_offsets_to_transaction() 的参数</span></span><br><span class="line"><span class="comment">     * @sa Producer::send_offsets_to_transaction()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConsumerGroupMetadata *<span class="title">groupMetadata</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 异步关闭消费者（后台执行）</span></span><br><span class="line"><span class="comment">     * @param queue 用于接收 Rebalance 等事件的队列</span></span><br><span class="line"><span class="comment">     * @returns NULL 成功，否则返回 Error 对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @remark 必须持续 poll 该 queue 直到 closed() 返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">close</span><span class="params">(Queue *queue)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检查消费者是否已关闭</span></span><br><span class="line"><span class="comment">     * @returns true 已关闭，false 未关闭</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @sa close(Queue *queue)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">closed</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）核心配置-1"><a href="#（3）核心配置-1" class="headerlink" title="（3）核心配置"></a>（3）核心配置</h3><p><a href="#config">全局配置</a><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116155332043.png"></p>
<h3 id="（4）使用示例-1"><a href="#（4）使用示例-1" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><h4 id="基础消费示例（消费者组模式，最常用）"><a href="#基础消费示例（消费者组模式，最常用）" class="headerlink" title="&lt;1&gt;基础消费示例（消费者组模式，最常用）"></a>&lt;1&gt;基础消费示例（消费者组模式，最常用）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局标志：控制消费者退出</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> run = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理：优雅退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigterm</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    run = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Rebalance 回调（可选，用于监控分区分配变化）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRebalanceCb</span> : <span class="keyword">public</span> RdKafka::RebalanceCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebalance_cb</span><span class="params">(RdKafka::KafkaConsumer *consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::vector&lt;RdKafka::TopicPartition *&gt; &amp;partitions)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR__ASSIGN_PARTITIONS) &#123;</span><br><span class="line">            <span class="comment">// 分区分配</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 分配分区: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> *tp : partitions) &#123;</span><br><span class="line">                std::cout &lt;&lt; tp-&gt;<span class="built_in">topic</span>() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">partition</span>() &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">            consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == RdKafka::ERR__REVOKE_PARTITIONS) &#123;</span><br><span class="line">            <span class="comment">// 分区撤销</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 撤销分区&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            consumer-&gt;<span class="built_in">unassign</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[Rebalance] 错误: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 1. 创建配置 ==========</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必填配置</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;my-consumer-group&quot;</span>, errstr);  <span class="comment">// 消费者组 ID（必填）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选配置</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);  <span class="comment">// 无偏移量时从头消费</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>, errstr);     <span class="comment">// 自动提交偏移量</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;5000&quot;</span>, errstr); <span class="comment">// 自动提交间隔 5秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 Rebalance 回调（可选）</span></span><br><span class="line">    MyRebalanceCb rebalance_cb;</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;rebalance_cb&quot;</span>, &amp;rebalance_cb, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 创建消费者实例 ==========</span></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败: &quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> conf;  <span class="comment">// 配置已拷贝，可释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 订阅 Topic ==========</span></span><br><span class="line">    std::vector&lt;std::string&gt; topics = &#123;<span class="string">&quot;order_topic&quot;</span>, <span class="string">&quot;user_topic&quot;</span>&#125;;</span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">subscribe</span>(topics);</span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;订阅失败: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;已订阅 Topic: order_topic, user_topic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 注册信号处理 ==========</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. 消费循环 ==========</span></span><br><span class="line">    <span class="keyword">while</span> (run) &#123;</span><br><span class="line">        <span class="comment">// consume() 是核心方法，会触发所有回调</span></span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);  <span class="comment">// 超时 1 秒</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg-&gt;<span class="built_in">err</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR_NO_ERROR:</span><br><span class="line">                <span class="comment">// 正常消息</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[消息] Topic: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">topic_name</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 分区: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; Key: &quot;</span> &lt;&lt; (msg-&gt;<span class="built_in">key</span>() ? msg-&gt;<span class="built_in">key</span>()-&gt;<span class="built_in">c_str</span>() : <span class="string">&quot;null&quot;</span>)</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 内容: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                          &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR__TIMED_OUT:</span><br><span class="line">                <span class="comment">// 超时，无消息（正常情况）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR__PARTITION_EOF:</span><br><span class="line">                <span class="comment">// 到达分区末尾</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[EOF] 分区 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() &lt;&lt; <span class="string">&quot; 已读取完毕&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 错误</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[错误] &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> msg;  <span class="comment">// ⚠️ 必须释放消息对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 6. 优雅关闭 ==========</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在关闭消费者...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();  <span class="comment">// 阻塞等待：Rebalance → 提交偏移量 → 离开组</span></span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;消费者已关闭&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手动提交偏移量示例（精确控制）"><a href="#手动提交偏移量示例（精确控制）" class="headerlink" title="&lt;2&gt;手动提交偏移量示例（精确控制）"></a>&lt;2&gt;手动提交偏移量示例（精确控制）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;manual-commit-group&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>, errstr);  <span class="comment">// ⚠️ 禁用自动提交</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;order_topic&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> msg_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running &amp;&amp; msg_count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;处理消息: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">            msg_count++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式1：每条消息立即同步提交（最安全，但性能差）</span></span><br><span class="line">            <span class="comment">// consumer-&gt;commitSync(msg);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式2：每 10 条消息批量提交</span></span><br><span class="line">            <span class="keyword">if</span> (msg_count % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">commitSync</span>();</span><br><span class="line">                <span class="keyword">if</span> (err == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;已提交偏移量（批次 &quot;</span> &lt;&lt; msg_count / <span class="number">10</span> &lt;&lt; <span class="string">&quot;）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;提交失败: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式3：异步提交（高性能，但可能丢失确认）</span></span><br><span class="line">            <span class="comment">// consumer-&gt;commitAsync(msg);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出前提交剩余偏移量</span></span><br><span class="line">    consumer-&gt;<span class="built_in">commitSync</span>();</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手动分区分配示例（不使用消费者组）"><a href="#手动分区分配示例（不使用消费者组）" class="headerlink" title="&lt;3&gt; 手动分区分配示例（不使用消费者组）"></a>&lt;3&gt; 手动分区分配示例（不使用消费者组）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    <span class="comment">// ⚠️ 手动分配模式下 group.id 可选（不参与消费者组协调）</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;manual-assign-group&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动指定要消费的分区和起始偏移量</span></span><br><span class="line">    std::vector&lt;RdKafka::TopicPartition *&gt; partitions;</span><br><span class="line">    partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">0</span>, <span class="number">0</span>));     <span class="comment">// 分区0，从头开始</span></span><br><span class="line">    partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">1</span>, <span class="number">100</span>));   <span class="comment">// 分区1，从偏移量100开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️ 使用 assign() 而非 subscribe()</span></span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;分配分区失败: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 TopicPartition 对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *tp : partitions) &#123;</span><br><span class="line">        <span class="keyword">delete</span> tp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;分区 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 偏移量 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 内容: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>((<span class="type">char</span>*)msg-&gt;<span class="built_in">payload</span>(), msg-&gt;<span class="built_in">len</span>()) </span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">unassign</span>();  <span class="comment">// 取消分配</span></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Seek-跳转偏移量示例"><a href="#Seek-跳转偏移量示例" class="headerlink" title="&lt;4&gt;Seek 跳转偏移量示例"></a>&lt;4&gt;Seek 跳转偏移量示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seek_to_offset</span><span class="params">(RdKafka::KafkaConsumer *consumer, </span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> std::string &amp;topic, <span class="type">int</span> partition, <span class="type">int64_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 TopicPartition 对象</span></span><br><span class="line">    RdKafka::TopicPartition *tp = RdKafka::TopicPartition::<span class="built_in">create</span>(topic, partition, offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步 seek（等待 5 秒）</span></span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">seek</span>(*tp, <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;已跳转到 &quot;</span> &lt;&lt; topic &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; partition &lt;&lt; <span class="string">&quot;] 偏移量 &quot;</span> &lt;&lt; offset &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;跳转失败: &quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;seek-demo-group&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分配分区</span></span><br><span class="line">    std::vector&lt;RdKafka::TopicPartition *&gt; partitions;</span><br><span class="line">    partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">0</span>));</span><br><span class="line">    consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *tp : partitions) <span class="keyword">delete</span> tp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费几条消息后跳转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转到偏移量 100</span></span><br><span class="line">    <span class="built_in">seek_to_offset</span>(consumer, <span class="string">&quot;order_topic&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续消费</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;跳转后偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协作式-Rebalance-示例（COOPERATIVE-协议）"><a href="#协作式-Rebalance-示例（COOPERATIVE-协议）" class="headerlink" title="&lt;5&gt;协作式 Rebalance 示例（COOPERATIVE 协议）"></a>&lt;5&gt;协作式 Rebalance 示例（COOPERATIVE 协议）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协作式 Rebalance 回调</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CooperativeRebalanceCb</span> : <span class="keyword">public</span> RdKafka::RebalanceCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebalance_cb</span><span class="params">(RdKafka::KafkaConsumer *consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::vector&lt;RdKafka::TopicPartition *&gt; &amp;partitions)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        std::string protocol = consumer-&gt;<span class="built_in">rebalance_protocol</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 协议: &quot;</span> &lt;&lt; protocol &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR__ASSIGN_PARTITIONS) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 增量分配分区: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> *tp : partitions) &#123;</span><br><span class="line">                std::cout &lt;&lt; tp-&gt;<span class="built_in">topic</span>() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">partition</span>() &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (protocol == <span class="string">&quot;COOPERATIVE&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 协作式：增量添加</span></span><br><span class="line">                RdKafka::Error *error = consumer-&gt;<span class="built_in">incremental_assign</span>(partitions);</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;增量分配失败: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">delete</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 急切式：全量替换</span></span><br><span class="line">                consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == RdKafka::ERR__REVOKE_PARTITIONS) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Rebalance] 增量撤销分区&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (protocol == <span class="string">&quot;COOPERATIVE&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 协作式：增量移除</span></span><br><span class="line">                RdKafka::Error *error = consumer-&gt;<span class="built_in">incremental_unassign</span>(partitions);</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;增量撤销失败: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">delete</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 急切式：全量撤销</span></span><br><span class="line">                consumer-&gt;<span class="built_in">unassign</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;cooperative-group&quot;</span>, errstr);</span><br><span class="line">    <span class="comment">// 使用协作式分配策略</span></span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;partition.assignment.strategy&quot;</span>, <span class="string">&quot;cooperative-sticky&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    CooperativeRebalanceCb rebalance_cb;</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;rebalance_cb&quot;</span>, &amp;rebalance_cb, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;order_topic&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费循环...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;消息: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）对比图"><a href="#（5）对比图" class="headerlink" title="（5）对比图"></a>（5）对比图</h3><h4 id="KafkaConsumer-vs-Producer"><a href="#KafkaConsumer-vs-Producer" class="headerlink" title="&lt;1&gt;KafkaConsumer vs Producer"></a>&lt;1&gt;KafkaConsumer vs Producer</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103143018.png"></p>
<h4 id="subscribe-vs-assign"><a href="#subscribe-vs-assign" class="headerlink" title="&lt;2&gt;subscribe vs assign"></a>&lt;2&gt;subscribe vs assign</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103427689.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103455545.png"></p>
<h3 id="（6）关键注意事项"><a href="#（6）关键注意事项" class="headerlink" title="（6）关键注意事项"></a>（6）关键注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117103734641.png"></p>
<h2 id="8-RdKafka-Message类（消息类）"><a href="#8-RdKafka-Message类（消息类）" class="headerlink" title="8.RdKafka::Message类（消息类）"></a>8.RdKafka::Message类（消息类）</h2><h3 id="（1）概述-5"><a href="#（1）概述-5" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Message 是 librdkafka 中<strong>消息的核心载体类</strong>,承载消息的元数据、状态（如错误码）等关键信息，用于：<ul>
<li>生产者端：在 DeliveryReportCb 回调中获取投递结果</li>
<li>消费者端：通过 consume() 获取拉取到的消息</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                      Message 使用场景                            │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│   Producer                              Consumer                │</span><br><span class="line">│      │                                      │                   │</span><br><span class="line">│      │ <span class="built_in">produce</span>()                            │ <span class="built_in">consume</span>()         │</span><br><span class="line">│      ▼                                      ▼                   │</span><br><span class="line">│   ┌──────────┐                        ┌──────────┐             │</span><br><span class="line">│   │ 内部队列 │                        │ Message  │◄── 拉取结果  │</span><br><span class="line">│   └────┬─────┘                        └──────────┘             │</span><br><span class="line">│        │ 发送完成                                               │</span><br><span class="line">│        ▼                                                       │</span><br><span class="line">│   ┌────────────────┐                                           │</span><br><span class="line">│   │DeliveryReportCb│                                           │</span><br><span class="line">│   │   <span class="built_in">dr_cb</span>()      │                                           │</span><br><span class="line">│   │  ┌──────────┐  │                                           │</span><br><span class="line">│   │  │ Message  │◄─┼── 投递结果                                 │</span><br><span class="line">│   │  └──────────┘  │                                           │</span><br><span class="line">│   └────────────────┘                                           │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116203247930.png"></p>
<h4 id="核心定位-5"><a href="#核心定位-5" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>消息数据载体</strong>：<ul>
<li>存储消息的「<strong>内容、Key、分区、偏移量</strong>」等“核心业务数据”，是生产者 &#x2F; 消费者处理消息的直接对象；</li>
</ul>
</li>
<li><strong>元数据容器</strong>：<ul>
<li>附带消息的「<strong>主题名、时间戳、生产 &#x2F; 消费状态、错误码</strong>」等“元数据”，支撑消息溯源、异常排查；</li>
</ul>
</li>
<li><strong>状态标识</strong>：<ul>
<li>不仅封装正常消息，也可表示 “空消息”“错误消息”（如消费超时、分区 EOF），是 API 反馈操作结果的重要形式；</li>
</ul>
</li>
<li><strong>内存管理差异</strong>：<ul>
<li>消费者侧：consume() 返回的 Message 需手动 delete</li>
<li>生产者侧：回调中的 Message 由 librdkafka 管理，无需释放</li>
</ul>
</li>
</ul>
<h3 id="（2）Message类的定义"><a href="#（2）Message类的定义" class="headerlink" title="（2）Message类的定义"></a>（2）Message类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Message &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ================================= 错误相关 =================================</span></span><br><span class="line">    <span class="comment">/** @returns 如果对象表示错误事件则返回错误字符串，否则返回空字符串。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">errstr</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @returns 如果对象表示错误事件则返回错误码，否则返回 ERR_NO_ERROR（0）。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">err</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ================================= 位置信息 =================================</span></span><br><span class="line">    <span class="comment">/** @returns 消息对应的 RdKafka::Topic 对象（如果适用），</span></span><br><span class="line"><span class="comment">    *           如果没有通过 RdKafka::Topic::create() 显式创建对应的</span></span><br><span class="line"><span class="comment">    *           RdKafka::Topic 对象则返回 NULL。</span></span><br><span class="line"><span class="comment">    *           在这种情况下请改用 topic_name()。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Topic *<span class="title">topic</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @returns 主题名称（如果适用，否则返回空字符串） */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">topic_name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @returns 分区号（如果适用） */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">partition</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @returns 消息或错误的偏移量（如果适用） */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================= 消息内容 =================================</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">payload</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;           <span class="comment">// 消息体指针（二进制数据，消息体指针，需转换类型）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">len</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;              <span class="comment">// 消息体长度</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string *<span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 消息 Key（可能为 NULL）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">key_len</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;          <span class="comment">// Key 长度</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">void</span> *<span class="title">key_pointer</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// Key 指针（二进制 Key）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================= 时间戳 =================================</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MessageTimestamp <span class="title">timestamp</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 时间戳（含类型）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">latency</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;         <span class="comment">// 消息延迟（微秒，仅生产者）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ================================= 消息头 =================================</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Headers *<span class="title">headers</span><span class="params">()</span> </span>= <span class="number">0</span>;              <span class="comment">// 获取消息头（可修改）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Headers *<span class="title">headers</span><span class="params">(ErrorCode *err)</span> </span>= <span class="number">0</span>;<span class="comment">// 获取消息头，并返回错误码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ================================= 其他 =================================</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">broker_id</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;       <span class="comment">// 处理该消息的 Broker ID</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 为已消费的消息存储 offset + 1。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 消息的 offset + 1 将根据 \c `auto.commit.interval.ms` 配置</span></span><br><span class="line"><span class="comment">    * 或手动无偏移量的 commit() 调用提交到 broker。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @warning 此方法只能对当前已分配的分区调用。</span></span><br><span class="line"><span class="comment">    *          对未分配的分区调用将失败并返回 ERR__STATE。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @warning 避免在调用 seek() 等方法后存储偏移量，</span></span><br><span class="line"><span class="comment">    *          因为这可能会干扰后续恢复暂停的分区，</span></span><br><span class="line"><span class="comment">    *          应在调用 seek 之前存储偏移量。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @remark 使用此 API 时必须将 \c `enable.auto.offset.store` 设置为 &quot;false&quot;。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @returns 成功时返回 NULL，失败时返回错误对象。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Error *<span class="title">offset_store</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @brief 消息持久化状态，应用程序可以用它来判断生产的消息是否已被持久化到主题日志中。 */</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">        <span class="comment">/** 消息从未发送到 broker，或者发送失败且错误表明消息未写入日志。</span></span><br><span class="line"><span class="comment">        *  应用程序重试可能导致乱序，但不会导致重复。 */</span></span><br><span class="line">        MSG_STATUS_NOT_PERSISTED = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 消息已发送到 broker，但未收到确认。</span></span><br><span class="line"><span class="comment">        *  应用程序重试可能导致乱序和重复。 */</span></span><br><span class="line">        MSG_STATUS_POSSIBLY_PERSISTED = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 消息已写入日志并被完全确认。</span></span><br><span class="line"><span class="comment">        *  应用程序无需重试。</span></span><br><span class="line"><span class="comment">        *  注意：此值仅在 \c acks=all 时才可完全信任。 */</span></span><br><span class="line">        MSG_STATUS_PERSISTED = <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@brief 返回消息在主题日志中的持久化状态。（生产者专用）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Message</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    Message 核心属性                          │</span><br><span class="line">├──────────────┬──────────────────────────────────────────────┤</span><br><span class="line">│   内容       │  <span class="built_in">payload</span>() + <span class="built_in">len</span>()  /  <span class="built_in">key</span>() + <span class="built_in">key_len</span>()     │</span><br><span class="line">├──────────────┼──────────────────────────────────────────────┤</span><br><span class="line">│   位置       │  <span class="built_in">topic_name</span>() + <span class="built_in">partition</span>() + <span class="built_in">offset</span>()       │</span><br><span class="line">├──────────────┼──────────────────────────────────────────────┤</span><br><span class="line">│   状态       │  <span class="built_in">err</span>() + <span class="built_in">errstr</span>() + <span class="built_in">status</span>()                 │</span><br><span class="line">├──────────────┼──────────────────────────────────────────────┤</span><br><span class="line">│   元数据     │  <span class="built_in">timestamp</span>() + <span class="built_in">headers</span>() + <span class="built_in">broker_id</span>()       │</span><br><span class="line">└──────────────┴──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="（3）常见错误码-ErrorCode"><a href="#（3）常见错误码-ErrorCode" class="headerlink" title="（3）常见错误码 ErrorCode"></a>（3）常见错误码 ErrorCode</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116205721363.png"></p>
<h3 id="（4）使用示例-2"><a href="#（4）使用示例-2" class="headerlink" title="（4）使用示例"></a>（4）使用示例</h3><h4 id="消费者接收并处理消息（核心场景）"><a href="#消费者接收并处理消息（核心场景）" class="headerlink" title="&lt;1&gt;消费者接收并处理消息（核心场景）"></a>&lt;1&gt;消费者接收并处理消息（核心场景）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="comment">// consume() 方法返回 Message 对象，超时时间 1000ms</span></span><br><span class="line">    RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过 err() 判断消息状态</span></span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;<span class="built_in">err</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR_NO_ERROR: &#123;</span><br><span class="line">            <span class="comment">// 正常消息</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *payload = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>());</span><br><span class="line">            <span class="type">size_t</span> len = msg-&gt;<span class="built_in">len</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// key() 返回 const std::string*</span></span><br><span class="line">            <span class="type">const</span> std::string *key = msg-&gt;<span class="built_in">key</span>();</span><br><span class="line">            std::string key_str = key ? *key : <span class="string">&quot;无Key&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// timestamp() 返回 MessageTimestamp 结构体</span></span><br><span class="line">            RdKafka::MessageTimestamp ts = msg-&gt;<span class="built_in">timestamp</span>();</span><br><span class="line">            std::string ts_type = (ts.type == RdKafka::MessageTimestamp::MSG_TIMESTAMP_CREATE_TIME) </span><br><span class="line">                                  ? <span class="string">&quot;生产时间&quot;</span> : <span class="string">&quot;写入时间&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息：&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  主题：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">topic_name</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  分区：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  偏移量：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  Key：&quot;</span> &lt;&lt; key_str &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  内容：&quot;</span> &lt;&lt; std::<span class="built_in">string</span>(payload, len) &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  时间戳：&quot;</span> &lt;&lt; ts.timestamp &lt;&lt; <span class="string">&quot;（&quot;</span> &lt;&lt; ts_type &lt;&lt; <span class="string">&quot;）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR__TIMED_OUT:</span><br><span class="line">            <span class="comment">// 超时，无消息，继续</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR__PARTITION_EOF:</span><br><span class="line">            <span class="comment">// 到达分区末尾</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;分区 EOF：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">topic_name</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 其他错误</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;消费错误：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️ 必须释放（关键：避免内存泄漏）</span></span><br><span class="line">    <span class="keyword">delete</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生产者发送消息后处理回调（异步发送）"><a href="#生产者发送消息后处理回调（异步发送）" class="headerlink" title="&lt;2&gt;生产者发送消息后处理回调（异步发送）"></a>&lt;2&gt;生产者发送消息后处理回调（异步发送）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeliveryReportCb</span> : <span class="keyword">public</span> RdKafka::DeliveryReportCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数是引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dr_cb</span><span class="params">(RdKafka::Message &amp;msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 发送失败</span></span><br><span class="line">            <span class="type">const</span> std::string *key = msg.<span class="built_in">key</span>();</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;消息发送失败：&quot;</span> &lt;&lt; msg.<span class="built_in">errstr</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  Key：&quot;</span> &lt;&lt; (key ? *key : <span class="string">&quot;无Key&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送成功</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;消息发送成功：&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  主题：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>() &lt;&lt; std::endl  <span class="comment">// ✅ 用 . 不用 -&gt;</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>() &lt;&lt; std::endl</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;  偏移量：&quot;</span> &lt;&lt; msg.<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ⚠️ 回调中的 msg 由 librdkafka 管理，不要 delete</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（5）核心特性与注意事项"><a href="#（5）核心特性与注意事项" class="headerlink" title="（5）核心特性与注意事项"></a>（5）核心特性与注意事项</h3><h4 id="核心特征"><a href="#核心特征" class="headerlink" title="&lt;1&gt;核心特征"></a>&lt;1&gt;核心特征</h4><ul>
<li><strong>只读性</strong>：<ul>
<li>消费者侧的 Message 对象所有属性均为只读；</li>
<li>生产者侧仅发送回调中的 Message 包含发送结果，无法修改消息内容；</li>
</ul>
</li>
<li><strong>分区号特殊值</strong>：<ul>
<li>RdKafka::Topic::PARTITION_UA（等价于 -1）代表 “让 Kafka 自动分配分区”（生产者发送时使用）；</li>
</ul>
</li>
<li><strong>内存管理</strong>：<ul>
<li><strong>消费者</strong> consume() 返回的 Message 指针<strong>需手动 delete，否则内存泄漏</strong>；</li>
<li><strong>生产者回调中</strong>的 Message 对象由 librdkafka 管理，<strong>无需手动释放</strong>；</li>
</ul>
</li>
<li><strong>错误消息判断</strong>：<ul>
<li>consume() 始终返回 Message 对象（不会返回 nullptr）</li>
<li>通过 <strong>err()</strong> 判断状态：<ul>
<li><strong>ERR_NO_ERROR</strong>：正常消息</li>
<li><strong>ERR__TIMED_OUT</strong>：超时，无可用消息</li>
<li><strong>ERR__PARTITION_EOF</strong>：到达分区末尾</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="易错点与最佳实践"><a href="#易错点与最佳实践" class="headerlink" title="&lt;2&gt;易错点与最佳实践"></a>&lt;2&gt;易错点与最佳实践</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116221010502.png"></p>
<h2 id="9-ErrorCode枚举（错误码枚举）"><a href="#9-ErrorCode枚举（错误码枚举）" class="headerlink" title="9.ErrorCode枚举（错误码枚举）"></a>9.ErrorCode枚举（错误码枚举）</h2><h3 id="（1）概述-6"><a href="#（1）概述-6" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-6"><a href="#作用-6" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>是 librdkafka 中封装所有操作结果状态的<strong>核心枚举类型</strong>（本质是整型枚举）</li>
<li>是客户端与 Kafka 集群交互的“<strong>状态反馈中枢</strong>”——所有核心 API（如 produce()&#x2F;assign()&#x2F;commitSync()&#x2F;poll()）的返回值、回调函数的入参均通过该枚举标识操作成功&#x2F;失败原因</li>
<li>是错误处理、问题排查的核心依据。</li>
</ul>
<h4 id="核心定位-6"><a href="#核心定位-6" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>类型本质</strong>：<ul>
<li>typedef int RdKafka::ErrorCode，底层是<strong>整型枚举</strong>（librdkafka 定义了数百个错误码常量）；</li>
</ul>
</li>
<li><strong>分层设计</strong>：<ul>
<li><strong>0</strong>：<ul>
<li><strong>正常状态</strong>（ERR_NO_ERROR）；</li>
</ul>
</li>
<li><strong>负数</strong>：<ul>
<li><strong>客户端内部错误&#x2F;事件</strong>（librdkafka 本地产生，如队列满、超时、重平衡事件）</li>
</ul>
</li>
<li><strong>正数</strong>：<ul>
<li><strong>真正的错误</strong>（如 ERR_UNKNOWN_TOPIC_OR_PART&#x2F;ERR_LEADER_NOT_AVAILABLE）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）核心分类（按业务场景）"><a href="#（2）核心分类（按业务场景）" class="headerlink" title="（2）核心分类（按业务场景）"></a>（2）核心分类（按业务场景）</h3><p>ErrorCode 可按“场景+严重程度”分为 6 大类，覆盖客户端全生命周期：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117113059844.png"></p>
<h3 id="（3）核心错误码详解"><a href="#（3）核心错误码详解" class="headerlink" title="（3）核心错误码详解"></a>（3）核心错误码详解</h3><h4 id="基础通用错误码（所有场景必知）"><a href="#基础通用错误码（所有场景必知）" class="headerlink" title="&lt;1&gt;基础通用错误码（所有场景必知）"></a>&lt;1&gt;基础通用错误码（所有场景必知）</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112530324.png"></p>
<h4 id="生产者核心错误码"><a href="#生产者核心错误码" class="headerlink" title="&lt;2&gt;生产者核心错误码"></a>&lt;2&gt;生产者核心错误码</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112653492.png"></p>
<h4 id="消费者核心错误码"><a href="#消费者核心错误码" class="headerlink" title="&lt;3&gt;消费者核心错误码"></a>&lt;3&gt;消费者核心错误码</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112755227.png"></p>
<h4 id="权限-集群核心错误码"><a href="#权限-集群核心错误码" class="headerlink" title="&lt;4&gt; 权限&#x2F;集群核心错误码"></a>&lt;4&gt; 权限&#x2F;集群核心错误码</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117112844123.png"></p>
<h3 id="（4）核心注意事项-1"><a href="#（4）核心注意事项-1" class="headerlink" title="（4）核心注意事项"></a>（4）核心注意事项</h3><ul>
<li><strong>负数不一定是错误</strong>：<ul>
<li>如 ERR__ASSIGN_PARTITIONS（-175）、ERR__REVOKE_PARTITIONS（-174）、ERR__TIMED_OUT（-185）是”事件标识”，仅用于业务逻辑分支，无需告警；</li>
</ul>
</li>
<li><strong>0 一定是成功</strong>：<ul>
<li>所有 API 返回 ERR_NO_ERROR（0）均代表操作成功；</li>
</ul>
</li>
<li><strong>正数一定是错误</strong>：<ul>
<li>如 ERR_UNKNOWN_TOPIC_OR_PART（3）、ERR_MSG_SIZE_TOO_LARGE（10）是真正的错误，需处理&#x2F;告警。</li>
</ul>
</li>
</ul>
<h2 id="10-Error类（错误类）"><a href="#10-Error类（错误类）" class="headerlink" title="10.Error类（错误类）"></a>10.Error类（错误类）</h2><h3 id="（1）概述-7"><a href="#（1）概述-7" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-7"><a href="#作用-7" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::Error 是 librdkafka 中<strong>封装错误详情的核心类</strong>（区别于 RdKafka::ErrorCode 枚举）</li>
<li>它不仅包含错误码（ErrorCode），还提供了错误描述、错误来源、额外上下文等维度的信息，是对“原始错误码”的增强版封装</li>
<li>在复杂场景（如消息发送失败、重平衡异常）中，Error 类能提供比单纯错误码更丰富的排查依据，是精细化错误处理的关键。</li>
<li>该类主要出现在 Message 对象、回调函数、高级 API 返回值中，与 ErrorCode 枚举是“配套使用”的关系<ul>
<li>ErrorCode 是“错误类型标识”，Error 是“错误详情载体”。</li>
</ul>
</li>
</ul>
<h4 id="核心定位-7"><a href="#核心定位-7" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><p><strong>类的定位</strong>：</p>
<ul>
<li>是<strong>对 ErrorCode 的“包装器”</strong>，补充错误的可读描述、来源、额外信息；</li>
</ul>
</li>
<li><p><strong>核心价值</strong>：</p>
<ul>
<li>统一错误信息的获取方式（无需手动调用 err2str()）；</li>
<li>提供错误的“上下文维度”（如错误来源的 Broker 节点、错误发生的 Topic&#x2F;分区）；</li>
<li>支持错误链（嵌套错误），便于排查多层级异常；</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>Message::error()：返回消费&#x2F;生产消息的 Error 对象；</li>
<li>高级 API（如事务、AdminClient）的返回值；</li>
<li>部分回调函数的入参（如事务回调）。</li>
</ul>
</li>
</ul>
<h4 id="与-ErrorCode-的核心区别"><a href="#与-ErrorCode-的核心区别" class="headerlink" title="&lt;3&gt;与 ErrorCode 的核心区别"></a>&lt;3&gt;与 ErrorCode 的核心区别</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117114455324.png"></p>
<h3 id="（2）Error类的定义"><a href="#（2）Error类的定义" class="headerlink" title="（2）Error类的定义"></a>（2）Error类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Error &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 创建错误对象（静态工厂方法）</span></span><br><span class="line"><span class="comment">   * @param code 错误码枚举值</span></span><br><span class="line"><span class="comment">   * @param errstr 错误描述字符串指针（可为空）</span></span><br><span class="line"><span class="comment">   * @returns 错误对象指针，需调用方负责释放内存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Error *<span class="title">create</span><span class="params">(ErrorCode code, <span class="type">const</span> std::string *errstr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 虚析构函数（支持多态释放）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Error</span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * ========================================</span></span><br><span class="line"><span class="comment">   *        错误访问器方法（按使用频率排序）</span></span><br><span class="line"><span class="comment">   * ========================================</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★★★★ 最高】</span></span><br><span class="line"><span class="comment">   * @brief 获取错误码枚举值</span></span><br><span class="line"><span class="comment">   * @returns 错误码，如 RdKafka::ERR_UNKNOWN_MEMBER_ID</span></span><br><span class="line"><span class="comment">   * @note 最常用——用于 switch/if 分支判断错误类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">code</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★★★☆ 高】</span></span><br><span class="line"><span class="comment">   * @brief 获取人类可读的错误描述字符串</span></span><br><span class="line"><span class="comment">   * @returns 错误描述，如 &quot;Broker: Unknown member&quot;</span></span><br><span class="line"><span class="comment">   * @note 常用——用于日志记录、错误提示</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">str</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★★☆☆ 中】</span></span><br><span class="line"><span class="comment">   * @brief 判断是否为致命错误</span></span><br><span class="line"><span class="comment">   * @returns true 表示客户端实例不可用，需重建；false 表示可恢复</span></span><br><span class="line"><span class="comment">   * @note 用于决定是否需要重启客户端</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">is_fatal</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★★☆☆ 中】</span></span><br><span class="line"><span class="comment">   * @brief 判断操作是否可重试</span></span><br><span class="line"><span class="comment">   * @returns true 表示可重试；false 表示不可重试</span></span><br><span class="line"><span class="comment">   * @note 用于实现重试逻辑</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">is_retriable</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★★☆☆☆ 较低】</span></span><br><span class="line"><span class="comment">   * @brief 获取错误码名称字符串</span></span><br><span class="line"><span class="comment">   * @returns 错误码常量名，如 &quot;ERR_UNKNOWN_MEMBER_ID&quot;</span></span><br><span class="line"><span class="comment">   * @note 主要用于调试日志、监控指标上报</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【使用频率：★☆☆☆☆ 低】</span></span><br><span class="line"><span class="comment">   * @brief 判断是否为需要中止的事务错误</span></span><br><span class="line"><span class="comment">   * @returns true 表示必须调用 abort_transaction() 中止事务；false 表示无需中止</span></span><br><span class="line"><span class="comment">   * @note 仅在使用事务 API 时有意义，普通生产/消费场景无需关注</span></span><br><span class="line"><span class="comment">   * @remark 返回值仅对事务 API 返回的错误有效</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">txn_requires_abort</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）使用示例-1"><a href="#（3）使用示例-1" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="comment">// 示例1：生产者事务场景中的错误处理</span></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleProducerError</span><span class="params">(RdKafka::Producer* producer)</span> </span>&#123;</span><br><span class="line">    RdKafka::Error* error = producer-&gt;<span class="built_in">begin_transaction</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 【最常用】获取错误码进行分支判断</span></span><br><span class="line">        RdKafka::ErrorCode code = error-&gt;<span class="built_in">code</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【常用】记录错误日志</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;事务开始失败: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误码名称: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【中频】判断是否为致命错误</span></span><br><span class="line">        <span class="keyword">if</span> (error-&gt;<span class="built_in">is_fatal</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;致命错误！需要重建生产者实例&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 重建生产者逻辑...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【中频】判断是否可重试</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (error-&gt;<span class="built_in">is_retriable</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;可重试错误，稍后重试...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 重试逻辑...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【低频】事务场景：判断是否需要中止事务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (error-&gt;<span class="built_in">txn_requires_abort</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;需要中止事务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            producer-&gt;<span class="built_in">abort_transaction</span>(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放错误对象（重要！避免内存泄漏）</span></span><br><span class="line">        <span class="keyword">delete</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="comment">// 示例2：提交事务的完整错误处理</span></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">commitTransaction</span><span class="params">(RdKafka::Producer* producer, <span class="type">int</span> timeout_ms)</span> </span>&#123;</span><br><span class="line">    RdKafka::Error* error = producer-&gt;<span class="built_in">commit_transaction</span>(timeout_ms);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;事务提交成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据错误码进行精细化处理</span></span><br><span class="line">    <span class="keyword">switch</span> (error-&gt;<span class="built_in">code</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR__TIMED_OUT:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;事务提交超时: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">if</span> (error-&gt;<span class="built_in">is_retriable</span>()) &#123;</span><br><span class="line">                <span class="keyword">delete</span> error;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">commitTransaction</span>(producer, timeout_ms);  <span class="comment">// 重试</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> RdKafka::ERR__FENCED:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;生产者被隔离，需要重建实例&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;事务提交失败 [&quot;</span> &lt;&lt; error-&gt;<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;]: &quot;</span> </span><br><span class="line">                      &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (error-&gt;<span class="built_in">txn_requires_abort</span>()) &#123;</span><br><span class="line">                producer-&gt;<span class="built_in">abort_transaction</span>(timeout_ms);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> error;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="comment">// 示例3：封装通用错误处理函数</span></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ErrorAction</span> &#123;</span><br><span class="line">    SUCCESS,      <span class="comment">// 成功，无需处理</span></span><br><span class="line">    RETRY,        <span class="comment">// 可重试</span></span><br><span class="line">    ABORT_TXN,    <span class="comment">// 需中止事务</span></span><br><span class="line">    FATAL,        <span class="comment">// 致命错误，需重建客户端</span></span><br><span class="line">    FAIL          <span class="comment">// 失败，不可恢复</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ErrorAction <span class="title">analyzeError</span><span class="params">(RdKafka::Error* error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorAction::SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录错误信息</span></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;[ERROR] Code: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">code</span>() </span><br><span class="line">              &lt;&lt; <span class="string">&quot; | Name: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">name</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; | Desc: &quot;</span> &lt;&lt; error-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error-&gt;<span class="built_in">is_fatal</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorAction::FATAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error-&gt;<span class="built_in">is_retriable</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorAction::RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error-&gt;<span class="built_in">txn_requires_abort</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorAction::ABORT_TXN;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ErrorAction::FAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleUsage</span><span class="params">(RdKafka::Producer* producer)</span> </span>&#123;</span><br><span class="line">    RdKafka::Error* error = producer-&gt;<span class="built_in">begin_transaction</span>();</span><br><span class="line">    </span><br><span class="line">    ErrorAction action = <span class="built_in">analyzeError</span>(error);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::SUCCESS:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;操作成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::RETRY:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;准备重试...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::ABORT_TXN:</span><br><span class="line">            producer-&gt;<span class="built_in">abort_transaction</span>(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::FATAL:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;致命错误，退出程序&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">case</span> ErrorAction::FAIL:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;操作失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">delete</span> error;  <span class="comment">// 始终记得释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）核心注意事项-2"><a href="#（4）核心注意事项-2" class="headerlink" title="（4）核心注意事项"></a>（4）核心注意事项</h3><ul>
<li><strong>内存管理</strong>：<ul>
<li>Error* 指针由 API 返回（如 begin_transaction()、commit_transaction()），<strong>调用方负责 delete</strong>，否则内存泄漏；</li>
<li><strong>核心原则</strong>：凡是 API 返回 Error* 的，用完必须 delete。</li>
</ul>
</li>
<li><strong>关键使用原则</strong>：<ul>
<li><strong>常规场景优先使用 ErrorCode</strong>：<ul>
<li>高频调用（如消息循环）中，整型比较开销极低；</li>
</ul>
</li>
<li><strong>复杂场景使用 Error 类</strong>：<ul>
<li>事务 API、需要判断 is_fatal()&#x2F;is_retriable() 时，Error 类更合适；</li>
</ul>
</li>
<li><strong>日志记录</strong>：<ul>
<li>简单错误用 err2str(code)，需要上下文时用 Error::str()。</li>
</ul>
</li>
</ul>
</li>
<li><strong>致命错误处理</strong>：<ul>
<li>is_fatal()&#x3D;true 时，客户端无法恢复，需记录核心日志并重启客户端；</li>
</ul>
</li>
</ul>
<h2 id="11-MessageTimestamp类（时间戳类）"><a href="#11-MessageTimestamp类（时间戳类）" class="headerlink" title="11.MessageTimestamp类（时间戳类）"></a>11.MessageTimestamp类（时间戳类）</h2><h3 id="（1）概述-8"><a href="#（1）概述-8" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-8"><a href="#作用-8" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>RdKafka::MessageTimestamp 是 librdkafka 中封装 Kafka <strong>消息时间戳</strong>的专用类，用于统一管理消息的「<strong>时间戳值 + 时间戳类型</strong>」，是消费&#x2F;生产场景中<strong>获取消息时间维度信息的核心入口</strong>。</li>
<li>Kafka 消息的时间戳是其元数据的重要组成部分（如生产时间、日志追加时间），该类通过清晰的 API 封装了时间戳的类型判断、数值获取能力，解决了不同时间戳语义的区分问题。</li>
<li>该类<strong>仅用于读取</strong>（生产者发送消息时可指定时间戳，但最终由 Message 对象承载），<strong>所有方法均为只读，线程安全</strong>，是处理消息时间相关逻辑（如按时间过滤、数据回溯、延时消费）的基础。</li>
</ul>
<h4 id="核心定位-8"><a href="#核心定位-8" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>类的定位</strong>：<ul>
<li>轻量级值对象（Value Object），仅包含「<strong>时间戳类型（枚举）+ 时间戳数值（毫秒级）</strong>」两个核心属性；</li>
</ul>
</li>
<li><strong>核心价值</strong>：<ul>
<li>区分时间戳的语义（生产时间&#x2F;日志追加时间），避免业务误解；<ul>
<li>统一时间戳的单位（毫秒级 Unix 时间戳），简化跨语言&#x2F;跨版本兼容；</li>
<li>提供类型安全的 API，替代原始的“数值+标记位”模式；</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li>消费者 consume() 获取消息后，通过 Message::timestamp() 获取该类实例；</li>
<li>生产者 produce() 时指定自定义时间戳（最终体现在消费端的 MessageTimestamp）；</li>
<li>按时间戳过滤消息（如仅处理近1小时的消息）、定位历史数据。</li>
</ul>
</li>
</ul>
<h3 id="（2）MessageTimestamp类的定义"><a href="#（2）MessageTimestamp类的定义" class="headerlink" title="（2）MessageTimestamp类的定义"></a>（2）MessageTimestamp类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> MessageTimestamp &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 消息时间戳类型枚举</span></span><br><span class="line"><span class="comment">   * @details 标识时间戳的来源/含义</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">MessageTimestampType</span> &#123;</span><br><span class="line">    MSG_TIMESTAMP_NOT_AVAILABLE,  <span class="comment">/**&lt; 时间戳不可用（消息无时间戳信息） */</span></span><br><span class="line">    MSG_TIMESTAMP_CREATE_TIME,    <span class="comment">/**&lt; 消息创建时间（由生产者在发送时设置） */</span></span><br><span class="line">    MSG_TIMESTAMP_LOG_APPEND_TIME <span class="comment">/**&lt; 日志追加时间（由 Broker 在写入日志时设置） */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  MessageTimestampType type; <span class="comment">/**&lt; 时间戳类型 */</span></span><br><span class="line">  <span class="type">int64_t</span> timestamp;         <span class="comment">/**&lt; 时间戳值：自 Unix 纪元（1970-01-01 00:00:00 UTC）以来的毫秒数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）使用示例-2"><a href="#（3）使用示例-2" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1：基本使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processMessage</span><span class="params">(RdKafka::Message* message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取消息时间戳</span></span><br><span class="line">    RdKafka::MessageTimestamp ts = message-&gt;<span class="built_in">timestamp</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (ts.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> RdKafka::MessageTimestamp::MSG_TIMESTAMP_CREATE_TIME:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;消息创建时间: &quot;</span> &lt;&lt; ts.timestamp &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> RdKafka::MessageTimestamp::MSG_TIMESTAMP_LOG_APPEND_TIME:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Broker 追加时间: &quot;</span> &lt;&lt; ts.timestamp &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> RdKafka::MessageTimestamp::MSG_TIMESTAMP_NOT_AVAILABLE:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;时间戳不可用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为可读时间（示例）</span></span><br><span class="line">    <span class="keyword">if</span> (ts.type != RdKafka::MessageTimestamp::MSG_TIMESTAMP_NOT_AVAILABLE) &#123;</span><br><span class="line">        <span class="type">time_t</span> seconds = ts.timestamp / <span class="number">1000</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;可读时间: &quot;</span> &lt;&lt; std::<span class="built_in">ctime</span>(&amp;seconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：时间戳单位与转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将毫秒级时间戳转换为本地时间字符串</span></span><br><span class="line"><span class="comment"> * @param ts_ms 毫秒级 Unix 时间戳</span></span><br><span class="line"><span class="comment"> * @returns 格式化字符串，如 &quot;2025-01-01 08:00:00.123&quot;</span></span><br><span class="line"><span class="comment"> * @note 线程安全版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">timestamp_to_local</span><span class="params">(<span class="type">int64_t</span> ts_ms)</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> ts_sec = ts_ms / <span class="number">1000</span>;</span><br><span class="line">    tm local_tm;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">localtime_s</span>(&amp;local_tm, &amp;ts_sec);  <span class="comment">// Windows</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">localtime_r</span>(&amp;ts_sec, &amp;local_tm);  <span class="comment">// POSIX (Linux/macOS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; std::<span class="built_in">put_time</span>(&amp;local_tm, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) </span><br><span class="line">        &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; (ts_ms % <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）注意事项"><a href="#（4）注意事项" class="headerlink" title="（4）注意事项"></a>（4）注意事项</h3><ul>
<li><strong>时间戳单位</strong>：<ul>
<li>毫秒级 Unix 时间戳，转秒级需 “&#x2F;1000”</li>
</ul>
</li>
<li><strong>时区</strong>：<ul>
<li>存储的是 UTC 时间，显示时需转换本地时区</li>
</ul>
</li>
<li><strong>配置依赖</strong>：<ul>
<li>Topic 级别 <strong>message.timestamp.type</strong> 决定使用 <strong>CreateTime</strong> 还是 LogAppendTime**</li>
</ul>
</li>
</ul>
<p><a id="cb"></a></p>
<h2 id="12-RdKafka-xxxCb回调类"><a href="#12-RdKafka-xxxCb回调类" class="headerlink" title="12.RdKafka::xxxCb回调类"></a>12.RdKafka::xxxCb回调类</h2><ul>
<li>RdKafka::xxxCb 是 librdkafka 中一组<strong>抽象回调基类</strong>的统称，用于实现客户端与 Kafka 集群交互的 “<strong>异步事件通知” 机制</strong><ul>
<li>客户端通过继承这些回调类并实现纯虚函数，<strong>可监听生产 &#x2F; 消费过程中的关键事件</strong></li>
<li>如:消息发送结果、消费错误、重平衡、日志输出等，是实现<strong>异步化、定制化业务</strong>逻辑的核心。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116110908752.png"></p>
<h3 id="（1）DeliveryReportCb（生产者投递结果回调）"><a href="#（1）DeliveryReportCb（生产者投递结果回调）" class="headerlink" title="（1）DeliveryReportCb（生产者投递结果回调）"></a>（1）DeliveryReportCb（生产者投递结果回调）</h3><ul>
<li><strong>作用</strong>：<ul>
<li>生产者<strong>异步发送消息（produce()）<strong>后，通过该回调获取最终发送结果，是</strong>处理消息发送失败</strong>的核心入口；</li>
</ul>
</li>
<li><strong>注意</strong>：<ul>
<li><strong>仅异步发送生效</strong>，同步发送（produce()+flush()）无需该回调；</li>
</ul>
</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="&lt;1&gt;定义"></a>&lt;1&gt;定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> DeliveryReportCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// @brief 消息投递报告回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dr_cb</span><span class="params">(Message &amp;message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DeliveryReportCb</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 自定义投递结果回调类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeliveryReportCb</span> : <span class="keyword">public</span> RdKafka::DeliveryReportCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dr_cb</span><span class="params">(RdKafka::Message &amp;msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[发送失败] 主题：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 错误：&quot;</span> &lt;&lt; msg.<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[发送成功] 主题：&quot;</span> &lt;&lt; msg.<span class="built_in">topic_name</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; msg.<span class="built_in">partition</span>() </span><br><span class="line">                      &lt;&lt; <span class="string">&quot; 偏移量：&quot;</span> &lt;&lt; msg.<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定到生产者配置</span></span><br><span class="line">MyDeliveryReportCb dr_cb;</span><br><span class="line">producer_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;dr_cb&quot;</span>, &amp;dr_cb, errstr);</span><br></pre></td></tr></table></figure>

<h3 id="（2）EventCb（客户端底层事件回调）"><a href="#（2）EventCb（客户端底层事件回调）" class="headerlink" title="（2）EventCb（客户端底层事件回调）"></a>（2）EventCb（客户端底层事件回调）</h3><ul>
<li><strong>作用</strong>：<ul>
<li>监听 librdkafka 底层核心事件（如 Broker 连接 &#x2F; 断开、元数据更新、分区 Leader 切换、限流），是精细化监控客户端状态、调试底层问题的关键；</li>
</ul>
</li>
<li><strong>区别于 ErrorCb</strong>：<ul>
<li>ErrorCb 仅监听 “错误事件”，EventCb 覆盖 “错误 + 正常事件”（如连接成功、元数据更新），粒度更细</li>
</ul>
</li>
<li><strong>事件类型</strong>：<ul>
<li>通过 <strong>Event::type()</strong> 获取，核心类型包括：<ul>
<li><strong>EVENT_ERROR</strong>：错误事件（等价于 ErrorCb）；</li>
<li><strong>EVENT_REBALANCE</strong>：重平衡事件（等价于 RebalanceCb）；</li>
<li><strong>EVENT_LOG</strong>：日志事件（等价于 LogCb）；</li>
<li><strong>EVENT_THROTTLE</strong>：限流事件（等价于 ThrottleCb）；</li>
<li><strong>EVENT_CONNECT</strong>：Broker 连接成功；</li>
<li><strong>EVENT_DISCONNECT</strong>：Broker 连接断开；</li>
<li><strong>EVENT_METADATA_UPDATED</strong>：元数据更新（如 Topic 分区变化）；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="&lt;1&gt;定义"></a>&lt;1&gt;定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> EventCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// @brief 事件回调</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">event_cb</span><span class="params">(Event &amp;event)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventCb</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 自定义底层事件回调类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEventCb</span> : <span class="keyword">public</span> RdKafka::EventCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数实现：event=事件对象（包含事件类型、详情、关联的 Broker/分区）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">event_cb</span><span class="params">(RdKafka::Event &amp;event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据事件类型分类处理</span></span><br><span class="line">        <span class="keyword">switch</span> (event.<span class="built_in">type</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_CONNECT:</span><br><span class="line">                <span class="comment">// Broker 连接成功</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[事件] 连接 Broker 成功：&quot;</span> &lt;&lt; event.<span class="built_in">broker_name</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_DISCONNECT:</span><br><span class="line">                <span class="comment">// Broker 连接断开</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[事件] 断开 Broker 连接：&quot;</span> &lt;&lt; event.<span class="built_in">broker_name</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_METADATA_UPDATED:</span><br><span class="line">                <span class="comment">// 元数据更新（如 Topic 分区数变化、Leader 切换）</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[事件] 元数据更新：&quot;</span> &lt;&lt; event.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_THROTTLE:</span><br><span class="line">                <span class="comment">// 被 Broker 限流（等价于 ThrottleCb）</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[事件] 被 Broker 限流：&quot;</span> &lt;&lt; event.<span class="built_in">broker_name</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 限流时长：&quot;</span> &lt;&lt; event.<span class="built_in">throttle_time_ms</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_ERROR:</span><br><span class="line">                <span class="comment">// 错误事件（等价于 ErrorCb）</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[事件] 错误：&quot;</span> &lt;&lt; event.<span class="built_in">str</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 是否致命：&quot;</span> &lt;&lt; (event.<span class="built_in">fatal</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::Event::EVENT_REBALANCE:</span><br><span class="line">                <span class="comment">// 重平衡事件（等价于 RebalanceCb）</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[事件] 重平衡：&quot;</span> &lt;&lt; event.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其他事件（如日志、统计）</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[事件] 未知类型：&quot;</span> &lt;&lt; event.<span class="built_in">type</span>() &lt;&lt; <span class="string">&quot; 详情：&quot;</span> &lt;&lt; event.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定到全局配置（生产者/消费者均可）</span></span><br><span class="line">MyEventCb event_cb;</span><br><span class="line">RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"><span class="keyword">if</span> (conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;event_cb&quot;</span>, &amp;event_cb, errstr) != RdKafka::CONF_OK) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;绑定底层事件回调失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="（3）RebalanceCb（消费者重平衡回调）"><a href="#（3）RebalanceCb（消费者重平衡回调）" class="headerlink" title="（3）RebalanceCb（消费者重平衡回调）"></a>（3）RebalanceCb（消费者重平衡回调）</h3><ul>
<li><strong>作用</strong>：<ul>
<li>消费者组发生“<strong>重平衡</strong>”时触发，是保证消费不丢数据、清理分区资源的关键；</li>
</ul>
</li>
<li><strong>重平衡场景</strong>：<ul>
<li>消费者加入 &#x2F; 退出组、Topic 分区数调整、Broker 重选举；</li>
</ul>
</li>
</ul>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="&lt;1&gt;定义"></a>&lt;1&gt;定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> RebalanceCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 消费者组重平衡回调，配合 RdKafka::KafkaConsumer 使用</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 注册 rebalance_cb 后，librdkafka 将关闭自动分区分配/撤销机制，</span></span><br><span class="line"><span class="comment">  * 改由应用程序的 rebalance_cb 全权负责。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 重平衡回调需要根据两种事件更新 librdkafka 的分区分配集合：</span></span><br><span class="line"><span class="comment">  * - RdKafka::ERR__ASSIGN_PARTITIONS（分配分区）</span></span><br><span class="line"><span class="comment">  * - RdKafka::ERR__REVOKE_PARTITIONS（撤销分区）</span></span><br><span class="line"><span class="comment">  * 同时也要能处理其他任意的重平衡错误（err 不是上述两种的情况）。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @remark 对于其他错误情况，应用程序必须调用 unassign() 来同步状态。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 【Eager 全量分配策略】（如 range、roundrobin）：</span></span><br><span class="line"><span class="comment">  *   - 分配时调用 assign() 设置全部分区</span></span><br><span class="line"><span class="comment">  *   - 撤销时调用 unassign() 清空全部分区</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 【Cooperative 增量分配策略】（如 cooperative-sticky）：</span></span><br><span class="line"><span class="comment">  *   - 分配时调用 incremental_assign() 增量添加分区</span></span><br><span class="line"><span class="comment">  *   - 撤销时调用 incremental_unassign() 增量移除分区</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 不注册回调时，librdkafka 会自动完成上述操作。</span></span><br><span class="line"><span class="comment">  * 注册回调后，应用程序可以在分配/撤销时执行额外操作，例如：</span></span><br><span class="line"><span class="comment">  *   - 分配时：从外部存储加载自定义 offset</span></span><br><span class="line"><span class="comment">  *   - 撤销时：手动提交 offset（当 auto.commit.enable=false 时）</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::assign()</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::incremental_assign()</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::incremental_unassign()</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::assignment_lost()</span></span><br><span class="line"><span class="comment">  * @sa RdKafka::KafkaConsumer::rebalance_protocol()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">rebalance_cb</span><span class="params">(RdKafka::KafkaConsumer *consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::vector&lt;TopicPartition *&gt; &amp;partitions)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">RebalanceCb</span>() &#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRebalanceCb</span> : <span class="keyword">public</span> RdKafka::RebalanceCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebalance_cb</span><span class="params">(RdKafka::KafkaConsumer *consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::vector&lt;RdKafka::TopicPartition*&gt; &amp;partitions)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err == RdKafka::ERR__ASSIGN_PARTITIONS) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[重平衡] 分配分区数：&quot;</span> &lt;&lt; partitions.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) &#123;</span><br><span class="line">                tp-&gt;<span class="built_in">set_offset</span>(RdKafka::Topic::OFFSET_STORED);</span><br><span class="line">            &#125;</span><br><span class="line">            consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == RdKafka::ERR__REVOKE_PARTITIONS) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[重平衡] 回收分区数：&quot;</span> &lt;&lt; partitions.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">            consumer-&gt;<span class="built_in">commitSync</span>();  <span class="comment">// 提交当前 offset</span></span><br><span class="line">            consumer-&gt;<span class="built_in">unassign</span>();   <span class="comment">//取消分区分配</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[重平衡失败] 错误：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">            consumer-&gt;<span class="built_in">unassign</span>();   <span class="comment">//取消分区分配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定到消费者配置</span></span><br><span class="line">MyRebalanceCb rebalance_cb;</span><br><span class="line">consumer_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;rebalance_cb&quot;</span>, &amp;rebalance_cb, errstr);</span><br></pre></td></tr></table></figure>

<h3 id="（4）OffsetCommitCb（消费者-Offset-提交结果回调）"><a href="#（4）OffsetCommitCb（消费者-Offset-提交结果回调）" class="headerlink" title="（4）OffsetCommitCb（消费者 Offset 提交结果回调）"></a>（4）OffsetCommitCb（消费者 Offset 提交结果回调）</h3><ul>
<li><strong>作用</strong>：<ul>
<li>消费者<strong>异步提交 offset</strong>（commitAsync()）后，通过该回调获取提交结果；</li>
<li>同步提交（commitSync()）无需此回调，可直接通过返回值判断结果；</li>
</ul>
</li>
<li><strong>关键场景</strong>：<ul>
<li>异步提交 offset 是生产环境首选（非阻塞），该回调是监控 offset 提交失败的核心入口，避免因提交失败导致重复消费；</li>
</ul>
</li>
</ul>
<h4 id="定义-3"><a href="#定义-3" class="headerlink" title="&lt;1&gt;定义"></a>&lt;1&gt;定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> OffsetCommitCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 设置 offset 提交回调，用于消费者组</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 自动提交或手动提交 offset 的结果会被调度到此回调，</span></span><br><span class="line"><span class="comment">  * 并通过 RdKafka::KafkaConsumer::consume() 触发执行。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 如果没有分区有有效的 offset 可提交，此回调会以 err == ERR__NO_OFFSET 被调用，</span></span><br><span class="line"><span class="comment">  * 这不应被视为错误。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * offsets 列表包含每个分区的信息：</span></span><br><span class="line"><span class="comment">  *   - topic      提交的 Topic 名称</span></span><br><span class="line"><span class="comment">  *   - partition  提交的分区号</span></span><br><span class="line"><span class="comment">  *   - offset     已提交的 offset（尝试提交的值）</span></span><br><span class="line"><span class="comment">  *   - err        提交错误码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">offset_commit_cb</span><span class="params">(RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                               std::vector&lt;TopicPartition *&gt; &amp;offsets)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">OffsetCommitCb</span>() &#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="&lt;2&gt;使用示例"></a>&lt;2&gt;使用示例</h4><p><strong>自动&#x2F;手动提交 offset 完成后触发</strong></p>
<ul>
<li>提交重试、消费进度监控、lag 告警</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 自定义 Offset 提交结果回调类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOffsetCommitCb</span> : <span class="keyword">public</span> RdKafka::OffsetCommitCb &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数实现：</span></span><br><span class="line">    <span class="comment">// err=整体提交错误码，partitions=提交的分区列表（含每个分区的提交结果）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">offset_commit_cb</span><span class="params">(RdKafka::ErrorCode err,</span></span></span><br><span class="line"><span class="params"><span class="function">                          std::vector&lt;RdKafka::TopicPartition*&gt; &amp;partitions)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 整体提交失败（如网络异常、无权限）</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[Offset 提交失败] 整体错误：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历分区，检查每个分区的提交结果（精细化处理）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tp-&gt;<span class="built_in">err</span>() != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">                <span class="comment">// 单个分区提交失败</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;[Offset 提交失败] 主题：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">topic</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 错误：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(tp-&gt;<span class="built_in">err</span>()) &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 业务逻辑：记录失败的 offset、触发重试、告警</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 单个分区提交成功</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[Offset 提交成功] 主题：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">topic</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 分区：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                          &lt;&lt; <span class="string">&quot; 提交的 offset：&quot;</span> &lt;&lt; tp-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定到消费者配置</span></span><br><span class="line">MyOffsetCommitCb offset_commit_cb;</span><br><span class="line">std::string errstr;</span><br><span class="line">RdKafka::Conf *consumer_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line"><span class="comment">// 关键：将回调对象绑定到 &quot;offset_commit_cb&quot; 配置项</span></span><br><span class="line"><span class="keyword">if</span> (consumer_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;offset_commit_cb&quot;</span>, &amp;offset_commit_cb, errstr) != RdKafka::CONF_OK) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;绑定 Offset 提交回调失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 异步提交 Offset（触发回调）</span></span><br><span class="line">std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;topic1&quot;</span>, <span class="number">0</span>));</span><br><span class="line">partitions[<span class="number">0</span>]-&gt;<span class="built_in">set_offset</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 异步提交：非阻塞，结果通过 OffsetCommitCb 返回</span></span><br><span class="line">consumer-&gt;<span class="built_in">commitAsync</span>(partitions, <span class="literal">nullptr</span>); <span class="comment">// 第二个参数为 opaque（透传上下文）</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）回调类通用规则与注意事项"><a href="#（5）回调类通用规则与注意事项" class="headerlink" title="（5）回调类通用规则与注意事项"></a>（5）回调类通用规则与注意事项</h3><h4 id="核心通用规则"><a href="#核心通用规则" class="headerlink" title="&lt;1&gt;核心通用规则"></a>&lt;1&gt;核心通用规则</h4><ul>
<li><strong>抽象类特性</strong>：<ul>
<li>所有 xxxCb 类均包含纯虚函数，必须实现所有纯虚函数才能实例化（未实现会编译失败）；</li>
</ul>
</li>
<li><strong>线程安全</strong>：<ul>
<li>回调函数由 librdkafka 内部线程调用（<strong>非业务线程</strong>），需保证： <ul>
<li>回调内操作（如写日志、更新变量）需<strong>加锁</strong>（std::mutex）；</li>
<li><strong>避免</strong>在回调内执行<strong>耗时操作</strong>（如网络请求、磁盘 IO），会阻塞客户端核心逻辑；</li>
</ul>
</li>
</ul>
</li>
<li><strong>生命周期管理</strong>：<ul>
<li><strong>回调对象的生命周期必须 ≥ 客户端对象（生产者 &#x2F; 消费者）</strong>，否则会导致野指针崩溃；</li>
<li><strong>禁止</strong>在回调内销毁客户端对象（如 delete consumer）；</li>
</ul>
</li>
<li><strong>配置项命名</strong>：<ul>
<li>绑定回调时的配置项名与回调类名对应（如 DeliveryReportCb → dr_cb，RebalanceCb → rebalance_cb），需严格匹配 librdkafka 规范。</li>
</ul>
</li>
</ul>
<h4 id="高频易错点"><a href="#高频易错点" class="headerlink" title="&lt;2&gt;高频易错点"></a>&lt;2&gt;高频易错点</h4><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116224028039.png"></p>
<h2 id="13-Topic类（主题类）"><a href="#13-Topic类（主题类）" class="headerlink" title="13.Topic类（主题类）"></a>13.Topic类（主题类）</h2><h3 id="（1）概述-9"><a href="#（1）概述-9" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-9"><a href="#作用-9" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>是 librdkafka 中封装 Kafka <strong>Topic（主题）句柄</strong>的类，提供主题名称访问、<br>偏移量常量定义及分区可用性检查等功能，是客户端与<strong>具体 Kafka 主题</strong>交互的 “具象化载体”</li>
<li>它不仅定义了主题的名称、分区数、专属配置等核心属性，还提供了消费偏移量控制的关键常量（如 OFFSET_BEGINNING），是<strong>生产者指定发送目标、消费者控制消费范围</strong>的基础类。</li>
</ul>
<h4 id="核心定位-9"><a href="#核心定位-9" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><strong>类的定位</strong>：<ul>
<li>轻量级封装类，代表一个具体的 Kafka 主题，是 “主题元数据 + 主题级配置 + 核心常量” 的集合体；</li>
</ul>
</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>不可修改</strong>：<ul>
<li>Topic 实例创建后，名称、配置等核心属性只读；</li>
</ul>
</li>
<li><strong>轻量级</strong>：<ul>
<li>无复杂内部状态，拷贝 &#x2F; 销毁成本极低；</li>
</ul>
</li>
<li><strong>工厂模式创建</strong>：<ul>
<li>仅能通过 Topic::create() 静态方法实例化，避免手动构造。</li>
</ul>
</li>
</ul>
</li>
<li><strong>核心价值</strong>：<ul>
<li><strong>分离 “全局配置” 与 “主题级配置”</strong>：<ul>
<li>支持为不同 Topic 设置差异化配置（如 Topic A 用 acks&#x3D;all，Topic B 用 acks&#x3D;1）；</li>
</ul>
</li>
<li><strong>提供消费偏移量的标准化常量</strong>：<ul>
<li>统一消费起始位置的控制逻辑（如从最开始 &#x2F; 最新消息消费）；</li>
</ul>
</li>
<li><strong>封装主题元数据查询</strong>：<ul>
<li>简化分区数、配置等信息的获取；</li>
</ul>
</li>
</ul>
</li>
<li>⚠️<strong>注意</strong>：<ul>
<li>大多数常用配置（如 acks、retries、compression.type），实际是<strong>全局配置</strong>，真正的 Topic 级配置项较少（如 partitioner）。</li>
<li><strong>现代用法中，Topic 配置的使用场景已大幅减少。</strong></li>
</ul>
</li>
</ul>
<h3 id="（2）Topic类的定义"><a href="#（2）Topic类的定义" class="headerlink" title="（2）Topic类的定义"></a>（2）Topic类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Topic &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 静态常量（使用频率：⭐⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 未分配分区标识</span></span><br><span class="line"><span class="comment">   * @details 生产者发送消息时使用此值，表示由分区器自动选择目标分区</span></span><br><span class="line"><span class="comment">   * @note 值为 -1，是 produce() 最常用的分区参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> PARTITION_UA;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 从分区最早的消息开始消费</span></span><br><span class="line"><span class="comment">   * @details 值为 -2，用于数据回溯、全量消费历史数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int64_t</span> OFFSET_BEGINNING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 从分区最新的消息开始消费</span></span><br><span class="line"><span class="comment">   * @details 值为 -1，仅消费后续新增消息，用于实时业务场景</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int64_t</span> OFFSET_END;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 使用已存储的偏移量</span></span><br><span class="line"><span class="comment">   * @details 值为 -1000，从 Broker 中恢复上次消费位置，用于断点续传</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int64_t</span> OFFSET_STORED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 无效偏移量标识</span></span><br><span class="line"><span class="comment">   * @details 值为 -1001，用于标记异常场景或偏移量转换失败</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int64_t</span> OFFSET_INVALID;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 静态工厂方法（使用频率：⭐⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 创建 Topic 句柄</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param base      关联的 Producer 或 Consumer 句柄</span></span><br><span class="line"><span class="comment">   * @param topic_str Topic 名称</span></span><br><span class="line"><span class="comment">   * @param conf      可选的 Topic 配置（可为 nullptr 使用默认配置）</span></span><br><span class="line"><span class="comment">   * @param errstr    [out] 错误信息输出</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns 成功返回 Topic 指针，失败返回 nullptr</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note conf 对象在调用后可复用</span></span><br><span class="line"><span class="comment">   * @note 调用者负责 delete 返回的 Topic 对象</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * std::string errstr;</span></span><br><span class="line"><span class="comment">   * RdKafka::Topic* topic = RdKafka::Topic::create(</span></span><br><span class="line"><span class="comment">   *     producer, &quot;my-topic&quot;, nullptr, errstr);</span></span><br><span class="line"><span class="comment">   * if (!topic) &#123;</span></span><br><span class="line"><span class="comment">   *     std::cerr &lt;&lt; &quot;创建 Topic 失败: &quot; &lt;&lt; errstr &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Topic *<span class="title">create</span><span class="params">(Handle *base,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> std::string &amp;topic_str,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Conf *conf,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::string &amp;errstr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 实例方法（使用频率：⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 获取 Topic 名称</span></span><br><span class="line"><span class="comment">   * @returns Topic 名称字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 实例方法（使用频率：⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 检查指定分区是否可用（有 Leader）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param partition 分区编号</span></span><br><span class="line"><span class="comment">   * @returns true 表示分区可用，false 表示不可用</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @warning 仅能在 PartitionerCb 回调函数内部调用！</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">partition_available</span><span class="params">(<span class="type">int32_t</span> partition)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 已废弃方法（使用频率：⭐ - 不推荐使用）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 存储偏移量（已废弃）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param partition 分区编号</span></span><br><span class="line"><span class="comment">   * @param offset    偏移量（实际存储 offset + 1）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns ERR_NO_ERROR 成功，其他值表示错误</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @deprecated 此 API 不支持分区 Leader Epoch，存在日志截断风险</span></span><br><span class="line"><span class="comment">   *             请使用 KafkaConsumer::offsets_store() 或 Message::offset_store() 替代</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note 使用前必须设置 enable.auto.offset.store = false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">offset_store</span><span class="params">(<span class="type">int32_t</span> partition, <span class="type">int64_t</span> offset)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 底层访问（使用频率：⭐ - 仅特殊场景）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 获取底层 C API 句柄</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns rd_kafka_topic_t* 指针</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @warning 直接调用 C API 无官方支持，仅在 C++ API 无法满足需求时使用</span></span><br><span class="line"><span class="comment">   * @note 返回指针生命周期与 Topic 对象相同</span></span><br><span class="line"><span class="comment">   * @note 使用前需 #include &lt;rdkafka/rdkafka.h&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">struct</span> <span class="title class_">rd_kafka_topic_t</span> *<span class="built_in">c_ptr</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 虚析构函数</span></span><br><span class="line"><span class="comment">   * @note 纯虚函数，Topic 为抽象基类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Topic</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117160922667.png"></p>
<ul>
<li><strong>注意</strong>：OFFSET_STORED 的行为依赖配置项 auto.offset.reset：<ul>
<li>若无已存储 offset，会根据 auto.offset.reset 决定回退到 earliest 或 latest</li>
<li>默认值为 latest</li>
</ul>
</li>
</ul>
<h3 id="（3）使用示例-3"><a href="#（3）使用示例-3" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><h4 id="Producer-创建-Topic-句柄并查询元数据"><a href="#Producer-创建-Topic-句柄并查询元数据" class="headerlink" title="&lt;1&gt;Producer 创建 Topic 句柄并查询元数据"></a>&lt;1&gt;Producer 创建 Topic 句柄并查询元数据</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建全局配置（客户端级）</span></span><br><span class="line">    RdKafka::Conf *global_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;topic-demo-producer&quot;</span>, errstr);</span><br><span class="line">    </span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>, errstr); </span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;5&quot;</span>, errstr); </span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;lz4&quot;</span>, errstr); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 Topic 级配置（仅包含真正的 Topic 级配置项）</span></span><br><span class="line">    RdKafka::Conf *topic_conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_TOPIC);</span><br><span class="line">    <span class="comment">// Topic 级配置示例（实际可用的配置项）：</span></span><br><span class="line">    <span class="comment">// topic_conf-&gt;set(&quot;partitioner&quot;, &quot;consistent_random&quot;, errstr);  // 分区策略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 Topic 配置绑定到全局配置（可选）</span></span><br><span class="line">    global_conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;default_topic_conf&quot;</span>, topic_conf, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建 Producer 实例</span></span><br><span class="line">    RdKafka::Producer *producer = RdKafka::Producer::<span class="built_in">create</span>(global_conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!producer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建 Producer 失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> topic_conf;</span><br><span class="line">        <span class="keyword">delete</span> global_conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> global_conf;  <span class="comment">// Producer 创建后可释放</span></span><br><span class="line">    <span class="keyword">delete</span> topic_conf;   <span class="comment">// 已绑定到 global_conf，可释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 创建 Topic 实例</span></span><br><span class="line">    RdKafka::Topic *topic = RdKafka::Topic::<span class="built_in">create</span>(producer, <span class="string">&quot;order_topic&quot;</span>, <span class="literal">nullptr</span>, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!topic) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建 Topic 实例失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> producer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 验证 Topic 元数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Topic 名称：&quot;</span> &lt;&lt; topic-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取分区数需要通过 Metadata API</span></span><br><span class="line">    RdKafka::Metadata *metadata = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (producer-&gt;<span class="built_in">metadata</span>(<span class="literal">false</span>, topic, &amp;metadata, <span class="number">5000</span>) == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// 遍历 Topic 元数据获取分区数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> RdKafka::TopicMetadata* t : *metadata-&gt;<span class="built_in">topics</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;<span class="built_in">topic</span>() == topic-&gt;<span class="built_in">name</span>()) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Topic 分区数：&quot;</span> &lt;&lt; t-&gt;<span class="built_in">partitions</span>()-&gt;<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> metadata;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;加载 Topic 元数据失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 销毁资源</span></span><br><span class="line">    <span class="keyword">delete</span> topic;</span><br><span class="line">    <span class="keyword">delete</span> producer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 等待后台线程清理（可选但推荐）</span></span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Consumer-使用-Topic-偏移量常量控制消费位置"><a href="#Consumer-使用-Topic-偏移量常量控制消费位置" class="headerlink" title="&lt;2&gt; Consumer 使用 Topic 偏移量常量控制消费位置"></a>&lt;2&gt; Consumer 使用 Topic 偏移量常量控制消费位置</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局运行标志，用于优雅退出</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号处理（支持 Ctrl+C 优雅退出）</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者配置</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    <span class="keyword">if</span> (conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr) != RdKafka::Conf::CONF_OK ||</span><br><span class="line">        conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;offset-demo-group&quot;</span>, errstr) != RdKafka::Conf::CONF_OK ||</span><br><span class="line">        conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>, errstr) != RdKafka::Conf::CONF_OK ||</span><br><span class="line">        conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr) != RdKafka::Conf::CONF_OK) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;配置设置失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建消费者</span></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line">    conf = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 构建分区列表，使用 Topic 常量指定偏移量</span></span><br><span class="line">    std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line"></span><br><span class="line">    partitions.<span class="built_in">push_back</span>(</span><br><span class="line">        RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">0</span>, RdKafka::Topic::OFFSET_BEGINNING));</span><br><span class="line">    partitions.<span class="built_in">push_back</span>(</span><br><span class="line">        RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">1</span>, RdKafka::Topic::OFFSET_END));</span><br><span class="line">    partitions.<span class="built_in">push_back</span>(</span><br><span class="line">        RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, <span class="number">2</span>, RdKafka::Topic::OFFSET_STORED));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 应用分区分配</span></span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;分配分区失败：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) <span class="keyword">delete</span> tp;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始消费，按 Ctrl+C 退出...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 消费循环（添加退出条件）</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!msg) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 防御性检查</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg-&gt;<span class="built_in">err</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR_NO_ERROR:</span><br><span class="line">                <span class="comment">// 安全处理 payload（可能为空或不以 null 结尾）</span></span><br><span class="line">                <span class="keyword">if</span> (msg-&gt;<span class="built_in">payload</span>() &amp;&amp; msg-&gt;<span class="built_in">len</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;分区 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() </span><br><span class="line">                              &lt;&lt; <span class="string">&quot; | 偏移量 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>()</span><br><span class="line">                              &lt;&lt; <span class="string">&quot; | Key: &quot;</span> &lt;&lt; (msg-&gt;<span class="built_in">key</span>() ? *msg-&gt;<span class="built_in">key</span>() : <span class="string">&quot;(null)&quot;</span>)</span><br><span class="line">                              &lt;&lt; <span class="string">&quot; | 内容: &quot;</span> </span><br><span class="line">                              &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                              &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR__TIMED_OUT:</span><br><span class="line">                <span class="comment">// 超时是正常的，静默处理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RdKafka::ERR__PARTITION_EOF:</span><br><span class="line">                <span class="comment">// 到达分区末尾（可选：输出提示）</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;分区 &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>() &lt;&lt; <span class="string">&quot; 已到达末尾&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其他错误</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;消费错误：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n正在关闭消费者...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清理资源（正确顺序）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) &#123;</span><br><span class="line">        <span class="keyword">delete</span> tp;</span><br><span class="line">    &#125;</span><br><span class="line">    partitions.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();  <span class="comment">// 先 close</span></span><br><span class="line">    <span class="keyword">delete</span> consumer;    <span class="comment">// 再 delete</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待后台线程清理</span></span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;消费者已关闭&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>⚠️<strong>注意</strong>：<ul>
<li>OFFSET_STORED 依赖 auto.offset.reset 配置,若 Broker 中<strong>无已存储的 offset</strong>，会根据 auto.offset.reset 回退：</li>
<li><strong>earliest</strong> → 等效于 OFFSET_BEGINNING</li>
<li><strong>latest</strong> → 等效于 OFFSET_END（默认值）</li>
</ul>
</li>
</ul>
<h3 id="（4）注意事项-1"><a href="#（4）注意事项-1" class="headerlink" title="（4）注意事项"></a>（4）注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117161830580.png"></p>
<h2 id="14-Queue类（队列类）"><a href="#14-Queue类（队列类）" class="headerlink" title="14.Queue类（队列类）"></a>14.Queue类（队列类）</h2><h3 id="（1）概述-10"><a href="#（1）概述-10" class="headerlink" title="（1）概述"></a>（1）概述</h3><h4 id="作用-10"><a href="#作用-10" class="headerlink" title="&lt;1&gt;作用"></a>&lt;1&gt;作用</h4><ul>
<li>是 librdkafka 中<strong>封装客户端异步操作队列</strong>的核心类，用于管理生产者 &#x2F; 消费者的消息队列、事件队列（如投递报告、重平衡事件）</li>
<li>是实现异步 IO、回调触发的底层核心 ——&gt; 所有异步操作（如消息发送、事件处理）均通过 Queue 类的队列机制完成，<strong>其行为直接影响客户端的性能、可靠性和资源占用</strong>。</li>
</ul>
<h4 id="核心定位-10"><a href="#核心定位-10" class="headerlink" title="&lt;2&gt;核心定位"></a>&lt;2&gt;核心定位</h4><ul>
<li><p><strong>类的定位</strong>：</p>
<ul>
<li>底层封装 librdkafka 的 rd_kafka_queue_t 结构体，是<strong>消费者端</strong>的 “消息&#x2F;事件缓冲区” 封装类；</li>
</ul>
</li>
<li><p><strong>核心价值</strong>：</p>
<ul>
<li><strong>分区级消费隔离</strong>：<ul>
<li>可为不同分区创建独立队列，实现并行消费，避免相互阻塞；</li>
</ul>
</li>
<li><strong>事件转发与隔离</strong>：<ul>
<li>支持将消费者回调事件（如重平衡）转发到独立队列，便于自定义处理逻辑；</li>
</ul>
</li>
<li><strong>细粒度 poll 控制</strong>：<ul>
<li>支持对单个队列进行阻塞&#x2F;非阻塞轮询（poll() &#x2F; consume()）；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>主要使用场景</strong>：</p>
<ul>
<li><strong>分区队列</strong>：<ul>
<li>通过 Consumer::get_partition_queue() 获取指定分区的消息队列；</li>
</ul>
</li>
<li><strong>事件队列</strong>：<ul>
<li>通过 Handle::get_queue() 或 Queue::create() 获取&#x2F;创建事件队列；</li>
</ul>
</li>
<li><strong>独立轮询</strong>：<ul>
<li>使用 queue-&gt;poll(timeout) 单独处理该队列的消息&#x2F;事件；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）Queue类的定义"><a href="#（2）Queue类的定义" class="headerlink" title="（2）Queue类的定义"></a>（2）Queue类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RD_EXPORT</span> Queue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 静态工厂方法（使用频率：⭐⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 创建独立队列对象</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param handle 关联的 Producer 或 Consumer 句柄</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns 成功返回 Queue 指针，失败返回 nullptr</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note 调用者负责 delete 返回的 Queue 对象</span></span><br><span class="line"><span class="comment">   * @note 主要用于消费者端创建分区级队列或事件队列</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * RdKafka::Queue *queue = RdKafka::Queue::create(consumer);</span></span><br><span class="line"><span class="comment">   * if (!queue) &#123;</span></span><br><span class="line"><span class="comment">   *     std::cerr &lt;&lt; &quot;创建队列失败&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Queue *<span class="title">create</span><span class="params">(Handle *handle)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 核心消费方法（使用频率：⭐⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 从队列中消费消息或获取错误事件</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param timeout_ms 超时时间（毫秒），0 表示非阻塞，-1 表示无限等待</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns 返回以下情况之一：</span></span><br><span class="line"><span class="comment">   *   - 正常消息：Message::err() == ERR_NO_ERROR</span></span><br><span class="line"><span class="comment">   *   - 错误事件：Message::err() != ERR_NO_ERROR</span></span><br><span class="line"><span class="comment">   *   - 超时：Message::err() == ERR__TIMED_OUT</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note 使用 delete 释放返回的 Message 对象</span></span><br><span class="line"><span class="comment">   * @note 此方法用于包含消息的队列（消费者分区队列）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * RdKafka::Message *msg = queue-&gt;consume(1000);</span></span><br><span class="line"><span class="comment">   * if (msg-&gt;err() == RdKafka::ERR_NO_ERROR) &#123;</span></span><br><span class="line"><span class="comment">   *     // 处理消息</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * delete msg;</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Message *<span class="title">consume</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 事件轮询方法（使用频率：⭐⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 轮询队列，处理队列中的回调事件</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param timeout_ms 超时时间（毫秒）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns 处理的事件数量，超时返回 0</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @warning 禁止用于包含消息的队列！仅用于事件队列</span></span><br><span class="line"><span class="comment">   * @note 用于驱动回调事件（如投递报告、统计信息等）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * // 用于事件队列</span></span><br><span class="line"><span class="comment">   * int events = event_queue-&gt;poll(100);</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="type">int</span> timeout_ms)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 队列转发方法（使用频率：⭐⭐⭐）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 将当前队列的内容转发/路由到目标队列</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param dst 目标队列，传入 nullptr 可取消转发</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @returns ERR_NO_ERROR 成功，其他值表示错误</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note 调用后，两个队列的内部引用计数都会增加</span></span><br><span class="line"><span class="comment">   * @note 无论 dst 是否为 nullptr，调用后当前队列都不会再向消费者队列转发消息</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @remark 使用场景：</span></span><br><span class="line"><span class="comment">   *   - 将多个分区队列合并到一个队列统一处理</span></span><br><span class="line"><span class="comment">   *   - 将事件队列转发到自定义队列</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * // 将分区队列转发到统一队列</span></span><br><span class="line"><span class="comment">   * partition_queue-&gt;forward(unified_queue);</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * // 取消转发</span></span><br><span class="line"><span class="comment">   * partition_queue-&gt;forward(nullptr);</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ErrorCode <span class="title">forward</span><span class="params">(Queue *dst)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// IO 事件集成方法（使用频率：⭐⭐ - 高级用法）</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 启用队列的 IO 事件触发机制</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param fd      文件描述符，传入 -1 可禁用事件触发</span></span><br><span class="line"><span class="comment">   * @param payload 当队列有新元素入队时写入 fd 的数据</span></span><br><span class="line"><span class="comment">   * @param size    payload 的字节大小</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @details 用于与基于 IO 的事件循环（如 epoll/select/libevent）集成：</span></span><br><span class="line"><span class="comment">   *   - 当空队列收到新元素时，librdkafka 会向 fd 写入 payload</span></span><br><span class="line"><span class="comment">   *   - 应用程序监听 fd 的可读事件，触发后调用 consume()/poll()</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @note librdkafka 会维护 payload 的副本</span></span><br><span class="line"><span class="comment">   * @warning 使用转发队列时，仅在最终目标队列上启用 IO 事件</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @code</span></span><br><span class="line"><span class="comment">   * // 创建 eventfd 用于通知</span></span><br><span class="line"><span class="comment">   * int efd = eventfd(0, EFD_NONBLOCK);</span></span><br><span class="line"><span class="comment">   * uint64_t notify_val = 1;</span></span><br><span class="line"><span class="comment">   * queue-&gt;io_event_enable(efd, &amp;notify_val, sizeof(notify_val));</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * // 在事件循环中监听 efd</span></span><br><span class="line"><span class="comment">   * // 当 efd 可读时，调用 queue-&gt;consume() 获取消息</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * // 禁用</span></span><br><span class="line"><span class="comment">   * queue-&gt;io_event_enable(-1, nullptr, 0);</span></span><br><span class="line"><span class="comment">   * @endcode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">io_event_enable</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  <span class="comment">//==========================================================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 虚析构函数</span></span><br><span class="line"><span class="comment">   * @note 纯虚函数，Queue 为抽象基类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Queue</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117163118116.png"></p>
<h3 id="（3）使用示例-4"><a href="#（3）使用示例-4" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><h4 id="基础用法-创建队列并消费消息"><a href="#基础用法-创建队列并消费消息" class="headerlink" title="&lt;1&gt;基础用法 - 创建队列并消费消息"></a>&lt;1&gt;基础用法 - 创建队列并消费消息</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者配置</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;queue-demo-group&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建消费者</span></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> conf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 订阅主题</span></span><br><span class="line">    consumer-&gt;<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;order_topic&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建独立队列</span></span><br><span class="line">    RdKafka::Queue *queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line">    <span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建队列失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始消费（使用独立队列）...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 消费循环</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        RdKafka::Message *msg = queue-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!msg) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息 | 分区: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; | 偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; | 内容: &quot;</span> </span><br><span class="line">                      &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() != RdKafka::ERR__TIMED_OUT) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;错误：&quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清理</span></span><br><span class="line">    <span class="keyword">delete</span> queue;</span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分区队列-并行消费不同分区"><a href="#分区队列-并行消费不同分区" class="headerlink" title="&lt;2&gt;分区队列 - 并行消费不同分区"></a>&lt;2&gt;分区队列 - 并行消费不同分区</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区消费线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_partition</span><span class="params">(RdKafka::Queue *queue, <span class="type">int</span> partition_id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[线程-&quot;</span> &lt;&lt; partition_id &lt;&lt; <span class="string">&quot;] 开始消费分区 &quot;</span> &lt;&lt; partition_id &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        RdKafka::Message *msg = queue-&gt;<span class="built_in">consume</span>(<span class="number">500</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!msg) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[线程-&quot;</span> &lt;&lt; partition_id &lt;&lt; <span class="string">&quot;] &quot;</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;分区: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">partition</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; | 偏移量: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; | 内容: &quot;</span> </span><br><span class="line">                      &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() != RdKafka::ERR__TIMED_OUT) &#123;</span><br><span class="line">            <span class="comment">// 非超时错误才输出</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[线程-&quot;</span> &lt;&lt; partition_id &lt;&lt; <span class="string">&quot;] 错误: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">errstr</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[线程-&quot;</span> &lt;&lt; partition_id &lt;&lt; <span class="string">&quot;] 退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者配置</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;parallel-queue-group&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建消费者</span></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败：&quot;</span> &lt;&lt; errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 手动分配分区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> partition_count = <span class="number">3</span>;</span><br><span class="line">    std::vector&lt;RdKafka::TopicPartition*&gt; partitions;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; partition_count; ++i) &#123;</span><br><span class="line">        partitions.<span class="built_in">push_back</span>(RdKafka::TopicPartition::<span class="built_in">create</span>(<span class="string">&quot;order_topic&quot;</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RdKafka::ErrorCode err = consumer-&gt;<span class="built_in">assign</span>(partitions);</span><br><span class="line">    <span class="keyword">if</span> (err != RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;分配分区失败：&quot;</span> &lt;&lt; RdKafka::<span class="built_in">err2str</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) <span class="keyword">delete</span> tp;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 为每个分区获取独立队列（核心：使用 get_partition_queue）</span></span><br><span class="line">    std::vector&lt;RdKafka::Queue*&gt; queues;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; partition_count; ++i) &#123;</span><br><span class="line">        <span class="comment">//通过 get_partition_queue 获取分区专属队列</span></span><br><span class="line">        RdKafka::Queue *queue = consumer-&gt;<span class="built_in">get_partition_queue</span>(partitions[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (queue) &#123;</span><br><span class="line">            queues.<span class="built_in">push_back</span>(queue);</span><br><span class="line">            <span class="comment">// 启动独立线程消费该分区</span></span><br><span class="line">            threads.<span class="built_in">emplace_back</span>(consume_partition, queue, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;获取分区 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 的队列失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;已启动 &quot;</span> &lt;&lt; threads.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; 个消费线程，按 Ctrl+C 退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 主线程等待退出信号</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="comment">// 主线程需要定期 poll 以处理心跳等内部事件</span></span><br><span class="line">        <span class="comment">// 注意：消息已被分区队列接管，这里的 consume 主要用于保持连接</span></span><br><span class="line">        RdKafka::Message *msg = consumer-&gt;<span class="built_in">consume</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg) &#123;</span><br><span class="line">            <span class="comment">// 如果有消息到达主队列（通常不会），也处理掉</span></span><br><span class="line">            <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[主线程] 收到消息: &quot;</span> &lt;&lt; msg-&gt;<span class="built_in">offset</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 等待所有消费线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 清理资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q : queues) <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> tp : partitions) <span class="keyword">delete</span> tp;</span><br><span class="line">    </span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="队列转发-合并多个队列"><a href="#队列转发-合并多个队列" class="headerlink" title="&lt;3&gt;队列转发 - 合并多个队列"></a>&lt;3&gt;队列转发 - 合并多个队列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;forward-demo-group&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建统一目标队列</span></span><br><span class="line">    RdKafka::Queue *unified_queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建多个源队列并转发到统一队列</span></span><br><span class="line">    RdKafka::Queue *queue_a = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line">    RdKafka::Queue *queue_b = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 queue_a 和 queue_b 的内容转发到 unified_queue</span></span><br><span class="line">    RdKafka::ErrorCode err_a = queue_a-&gt;forward(unified_queue);</span><br><span class="line">    RdKafka::ErrorCode err_b = queue_b-&gt;forward(unified_queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err_a == RdKafka::ERR_NO_ERROR &amp;&amp; err_b == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列转发设置成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从统一队列消费（可以收到来自 queue_a 和 queue_b 的消息）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        RdKafka::Message *msg = unified_queue-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;收到消息: &quot;</span> </span><br><span class="line">                      &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 取消转发</span></span><br><span class="line">    queue_a-&gt;forward(<span class="literal">nullptr</span>);</span><br><span class="line">    queue_b-&gt;forward(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清理</span></span><br><span class="line">    <span class="keyword">delete</span> queue_a;</span><br><span class="line">    <span class="keyword">delete</span> queue_b;</span><br><span class="line">    <span class="keyword">delete</span> unified_queue;</span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-事件集成-与-epoll-配合使用"><a href="#IO-事件集成-与-epoll-配合使用" class="headerlink" title="&lt;4&gt;IO 事件集成 - 与 epoll 配合使用"></a>&lt;4&gt;IO 事件集成 - 与 epoll 配合使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;librdkafka/rdkafkacpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string errstr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigterm_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建消费者</span></span><br><span class="line">    RdKafka::Conf *conf = RdKafka::Conf::<span class="built_in">create</span>(RdKafka::Conf::CONF_GLOBAL);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;io-event-demo-group&quot;</span>, errstr);</span><br><span class="line">    conf-&gt;<span class="built_in">set</span>(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;earliest&quot;</span>, errstr);</span><br><span class="line"></span><br><span class="line">    RdKafka::KafkaConsumer *consumer = RdKafka::KafkaConsumer::<span class="built_in">create</span>(conf, errstr);</span><br><span class="line">    <span class="keyword">delete</span> conf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!consumer) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建消费者失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer-&gt;<span class="built_in">subscribe</span>(&#123;<span class="string">&quot;order_topic&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建队列</span></span><br><span class="line">    RdKafka::Queue *queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建 eventfd 用于 IO 事件通知</span></span><br><span class="line">    <span class="type">int</span> efd = <span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (efd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;创建 eventfd 失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> queue;</span><br><span class="line">        <span class="keyword">delete</span> consumer;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 启用 IO 事件触发</span></span><br><span class="line">    <span class="type">uint64_t</span> notify_value = <span class="number">1</span>;</span><br><span class="line">    queue-&gt;<span class="built_in">io_event_enable</span>(efd, &amp;notify_value, <span class="built_in">sizeof</span>(notify_value));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 创建 epoll 实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = efd;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, efd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用 epoll + eventfd 监听队列事件...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 事件循环</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epfd, events, <span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == efd) &#123;</span><br><span class="line">                <span class="comment">// 读取并清除 eventfd</span></span><br><span class="line">                <span class="type">uint64_t</span> val;</span><br><span class="line">                <span class="built_in">read</span>(efd, &amp;val, <span class="built_in">sizeof</span>(val));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理队列中所有消息</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    RdKafka::Message *msg = queue-&gt;<span class="built_in">consume</span>(<span class="number">0</span>);  <span class="comment">// 非阻塞</span></span><br><span class="line">                    <span class="keyword">if</span> (!msg || msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR__TIMED_OUT) &#123;</span><br><span class="line">                        <span class="keyword">delete</span> msg;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (msg-&gt;<span class="built_in">err</span>() == RdKafka::ERR_NO_ERROR) &#123;</span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;[IO Event] 收到消息: &quot;</span></span><br><span class="line">                                  &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(msg-&gt;<span class="built_in">payload</span>()), msg-&gt;<span class="built_in">len</span>())</span><br><span class="line">                                  &lt;&lt; std::endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 清理</span></span><br><span class="line">    queue-&gt;<span class="built_in">io_event_enable</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);  <span class="comment">// 禁用 IO 事件</span></span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="built_in">close</span>(efd);</span><br><span class="line">    <span class="keyword">delete</span> queue;</span><br><span class="line">    consumer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> consumer;</span><br><span class="line">    RdKafka::<span class="built_in">wait_destroyed</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）注意事项-2"><a href="#（4）注意事项-2" class="headerlink" title="（4）注意事项"></a>（4）注意事项</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260117163442568.png"><br><strong>poll() 与 consume() 的区别（关键！）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：对消息队列使用 poll()</span></span><br><span class="line">RdKafka::Queue *msg_queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line">msg_queue-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);  <span class="comment">// 禁止！poll() 不处理消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：消息队列使用 consume()</span></span><br><span class="line">RdKafka::Message *msg = msg_queue-&gt;<span class="built_in">consume</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：事件队列使用 poll()</span></span><br><span class="line">RdKafka::Queue *event_queue = RdKafka::Queue::<span class="built_in">create</span>(consumer);</span><br><span class="line">event_queue-&gt;<span class="built_in">poll</span>(<span class="number">1000</span>);  <span class="comment">// 处理回调事件</span></span><br></pre></td></tr></table></figure>

<p><a id="config"></a></p>
<h1 id="附录1：常用配置项"><a href="#附录1：常用配置项" class="headerlink" title="附录1：常用配置项"></a>附录1：常用配置项</h1><h2 id="1-Global通用配置（生产者-消费者共用）"><a href="#1-Global通用配置（生产者-消费者共用）" class="headerlink" title="1.Global通用配置（生产者&#x2F;消费者共用）"></a>1.Global通用配置（生产者&#x2F;消费者共用）</h2><h3 id="（1）关键配置"><a href="#（1）关键配置" class="headerlink" title="（1）关键配置"></a>（1）关键配置</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116144249346.png"></p>
<h3 id="（2）网络与连接相关（网络优化）"><a href="#（2）网络与连接相关（网络优化）" class="headerlink" title="（2）网络与连接相关（网络优化）"></a>（2）网络与连接相关（网络优化）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116144611415.png"></p>
<h3 id="（3）安全认证相关（生产环境）"><a href="#（3）安全认证相关（生产环境）" class="headerlink" title="（3）安全认证相关（生产环境）"></a>（3）安全认证相关（生产环境）</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116153411714.png"></p>
<h3 id="（4）元数据相关"><a href="#（4）元数据相关" class="headerlink" title="（4）元数据相关"></a>（4）元数据相关</h3><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116151134440.png"><br><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116151233728.png"></p>
<h2 id="2-生产者专用"><a href="#2-生产者专用" class="headerlink" title="2.生产者专用"></a>2.生产者专用</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119095109007.png"><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260119095142663.png"></p>
<h2 id="3-消费者专用"><a href="#3-消费者专用" class="headerlink" title="3.消费者专用"></a>3.消费者专用</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260116155332043.png"></p>
<h2 id="4-Cb回调配置项"><a href="#4-Cb回调配置项" class="headerlink" title="4.Cb回调配置项"></a>4.Cb回调配置项</h2><p><img src="https://cdn.jsdelivr.net/gh/xianyubuxian-TXY/hexo-images/images/20260118103329248.png"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="咸鱼 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="咸鱼 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>咸鱼
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://xianyubuxian-txy.github.io/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" title="kafka使用教程">https://xianyubuxian-txy.github.io/2026/01/15/C++/C++后端开发常用库/kafka使用教程/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/CMakeLists%E7%AC%94%E8%AE%B0/" rel="prev" title="CMakeLists笔记">
                  <i class="fa fa-angle-left"></i> CMakeLists笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/json%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="next" title="json的使用">
                  json的使用 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">咸鱼</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">229k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">12:44</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/xianyubuxian-TXY" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline-beta-black.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2026/01/15/C++/C++%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BA%93/kafka%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
